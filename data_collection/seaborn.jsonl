{"task_id": "seaborn_0", "reponame": "seaborn", "testpath": "tests/test_algorithms.py", "testname": "test_algorithms.py", "classname": null, "funcname": "test_bootstrap_length", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn import algorithms as algo"], "code": "def test_bootstrap_length(random):\n    'Test that we get a bootstrap array of the right shape.'\n    a_norm = np.random.randn(1000)\n    out = algo.bootstrap(a_norm)\n    assert (len(out) == 10000)\n    n_boot = 100\n    out = algo.bootstrap(a_norm, n_boot=n_boot)\n    assert (len(out) == n_boot)", "masked_code": "def test_bootstrap_length(random):\n    'Test that we get a bootstrap array of the right shape.'\n    a_norm = np.random.randn(1000)\n    out = algo.bootstrap(a_norm)\n    assert (len(out) == '???')\n    n_boot = 100\n    out = algo.bootstrap(a_norm, n_boot=n_boot)\n    assert (len(out) == n_boot)", "ground_truth": "10000", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1", "reponame": "seaborn", "testpath": "tests/test_algorithms.py", "testname": "test_algorithms.py", "classname": null, "funcname": "test_bootstrap_length", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn import algorithms as algo"], "code": "def test_bootstrap_length(random):\n    'Test that we get a bootstrap array of the right shape.'\n    a_norm = np.random.randn(1000)\n    out = algo.bootstrap(a_norm)\n    assert (len(out) == 10000)\n    n_boot = 100\n    out = algo.bootstrap(a_norm, n_boot=n_boot)\n    assert (len(out) == n_boot)", "masked_code": "def test_bootstrap_length(random):\n    'Test that we get a bootstrap array of the right shape.'\n    a_norm = np.random.randn(1000)\n    out = algo.bootstrap(a_norm)\n    assert (len(out) == 10000)\n    n_boot = 100\n    out = algo.bootstrap(a_norm, n_boot=n_boot)\n    assert (len(out) == '???')", "ground_truth": "n_boot", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_2", "reponame": "seaborn", "testpath": "tests/test_algorithms.py", "testname": "test_algorithms.py", "classname": null, "funcname": "test_bootstrap_axis", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn import algorithms as algo"], "code": "def test_bootstrap_axis(random):\n    'Test axis kwarg to bootstrap function.'\n    x = np.random.randn(10, 20)\n    n_boot = 100\n    out_default = algo.bootstrap(x, n_boot=n_boot)\n    assert (out_default.shape == (n_boot,))\n    out_axis = algo.bootstrap(x, n_boot=n_boot, axis=0)\n    assert out_axis.shape, (n_boot, x.shape[1])", "masked_code": "def test_bootstrap_axis(random):\n    'Test axis kwarg to bootstrap function.'\n    x = np.random.randn(10, 20)\n    n_boot = 100\n    out_default = algo.bootstrap(x, n_boot=n_boot)\n    assert (out_default.shape == '???')\n    out_axis = algo.bootstrap(x, n_boot=n_boot, axis=0)\n    assert out_axis.shape, (n_boot, x.shape[1])", "ground_truth": "(n_boot,)", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_3", "reponame": "seaborn", "testpath": "tests/test_algorithms.py", "testname": "test_algorithms.py", "classname": null, "funcname": "test_bootstrap_ols", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn import algorithms as algo"], "code": "def test_bootstrap_ols(random):\n    'Test bootstrap of OLS model fit.'\n\n    def ols_fit(X, y):\n        XtXinv = np.linalg.inv(np.dot(X.T, X))\n        return XtXinv.dot(X.T).dot(y)\n    X = np.column_stack((np.random.randn(50, 4), np.ones(50)))\n    w = [2, 4, 0, 3, 5]\n    y_noisy = (np.dot(X, w) + (np.random.randn(50) * 20))\n    y_lownoise = (np.dot(X, w) + np.random.randn(50))\n    n_boot = 500\n    w_boot_noisy = algo.bootstrap(X, y_noisy, n_boot=n_boot, func=ols_fit)\n    w_boot_lownoise = algo.bootstrap(X, y_lownoise, n_boot=n_boot, func=ols_fit)\n    assert (w_boot_noisy.shape == (n_boot, 5))\n    assert (w_boot_lownoise.shape == (n_boot, 5))\n    assert (w_boot_noisy.std() > w_boot_lownoise.std())", "masked_code": "def test_bootstrap_ols(random):\n    'Test bootstrap of OLS model fit.'\n\n    def ols_fit(X, y):\n        XtXinv = np.linalg.inv(np.dot(X.T, X))\n        return XtXinv.dot(X.T).dot(y)\n    X = np.column_stack((np.random.randn(50, 4), np.ones(50)))\n    w = [2, 4, 0, 3, 5]\n    y_noisy = (np.dot(X, w) + (np.random.randn(50) * 20))\n    y_lownoise = (np.dot(X, w) + np.random.randn(50))\n    n_boot = 500\n    w_boot_noisy = algo.bootstrap(X, y_noisy, n_boot=n_boot, func=ols_fit)\n    w_boot_lownoise = algo.bootstrap(X, y_lownoise, n_boot=n_boot, func=ols_fit)\n    assert (w_boot_noisy.shape == '???')\n    assert (w_boot_lownoise.shape == (n_boot, 5))\n    assert (w_boot_noisy.std() > w_boot_lownoise.std())", "ground_truth": "(n_boot, 5)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_4", "reponame": "seaborn", "testpath": "tests/test_algorithms.py", "testname": "test_algorithms.py", "classname": null, "funcname": "test_bootstrap_ols", "imports": ["import numpy as np", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn import algorithms as algo"], "code": "def test_bootstrap_ols(random):\n    'Test bootstrap of OLS model fit.'\n\n    def ols_fit(X, y):\n        XtXinv = np.linalg.inv(np.dot(X.T, X))\n        return XtXinv.dot(X.T).dot(y)\n    X = np.column_stack((np.random.randn(50, 4), np.ones(50)))\n    w = [2, 4, 0, 3, 5]\n    y_noisy = (np.dot(X, w) + (np.random.randn(50) * 20))\n    y_lownoise = (np.dot(X, w) + np.random.randn(50))\n    n_boot = 500\n    w_boot_noisy = algo.bootstrap(X, y_noisy, n_boot=n_boot, func=ols_fit)\n    w_boot_lownoise = algo.bootstrap(X, y_lownoise, n_boot=n_boot, func=ols_fit)\n    assert (w_boot_noisy.shape == (n_boot, 5))\n    assert (w_boot_lownoise.shape == (n_boot, 5))\n    assert (w_boot_noisy.std() > w_boot_lownoise.std())", "masked_code": "def test_bootstrap_ols(random):\n    'Test bootstrap of OLS model fit.'\n\n    def ols_fit(X, y):\n        XtXinv = np.linalg.inv(np.dot(X.T, X))\n        return XtXinv.dot(X.T).dot(y)\n    X = np.column_stack((np.random.randn(50, 4), np.ones(50)))\n    w = [2, 4, 0, 3, 5]\n    y_noisy = (np.dot(X, w) + (np.random.randn(50) * 20))\n    y_lownoise = (np.dot(X, w) + np.random.randn(50))\n    n_boot = 500\n    w_boot_noisy = algo.bootstrap(X, y_noisy, n_boot=n_boot, func=ols_fit)\n    w_boot_lownoise = algo.bootstrap(X, y_lownoise, n_boot=n_boot, func=ols_fit)\n    assert (w_boot_noisy.shape == (n_boot, 5))\n    assert (w_boot_lownoise.shape == '???')\n    assert (w_boot_noisy.std() > w_boot_lownoise.std())", "ground_truth": "(n_boot, 5)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_5", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_axes_array_size", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axes_array_size(self):\n    g = ag.FacetGrid(self.df)\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a')\n    assert (g.axes.shape == (3, 1))\n    g = ag.FacetGrid(self.df, col='b')\n    assert (g.axes.shape == (1, 2))\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.axes.shape == (3, 2))\n    for ax in g.axes.flat:\n        assert isinstance(ax, plt.Axes)", "masked_code": "def test_axes_array_size(self):\n    g = ag.FacetGrid(self.df)\n    assert (g.axes.shape == '???')\n    g = ag.FacetGrid(self.df, row='a')\n    assert (g.axes.shape == (3, 1))\n    g = ag.FacetGrid(self.df, col='b')\n    assert (g.axes.shape == (1, 2))\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.axes.shape == (3, 2))\n    for ax in g.axes.flat:\n        assert isinstance(ax, plt.Axes)", "ground_truth": "(1, 1)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_6", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_axes_array_size", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axes_array_size(self):\n    g = ag.FacetGrid(self.df)\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a')\n    assert (g.axes.shape == (3, 1))\n    g = ag.FacetGrid(self.df, col='b')\n    assert (g.axes.shape == (1, 2))\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.axes.shape == (3, 2))\n    for ax in g.axes.flat:\n        assert isinstance(ax, plt.Axes)", "masked_code": "def test_axes_array_size(self):\n    g = ag.FacetGrid(self.df)\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a')\n    assert (g.axes.shape == '???')\n    g = ag.FacetGrid(self.df, col='b')\n    assert (g.axes.shape == (1, 2))\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.axes.shape == (3, 2))\n    for ax in g.axes.flat:\n        assert isinstance(ax, plt.Axes)", "ground_truth": "(3, 1)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_7", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_axes_array_size", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axes_array_size(self):\n    g = ag.FacetGrid(self.df)\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a')\n    assert (g.axes.shape == (3, 1))\n    g = ag.FacetGrid(self.df, col='b')\n    assert (g.axes.shape == (1, 2))\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.axes.shape == (3, 2))\n    for ax in g.axes.flat:\n        assert isinstance(ax, plt.Axes)", "masked_code": "def test_axes_array_size(self):\n    g = ag.FacetGrid(self.df)\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a')\n    assert (g.axes.shape == (3, 1))\n    g = ag.FacetGrid(self.df, col='b')\n    assert (g.axes.shape == '???')\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.axes.shape == (3, 2))\n    for ax in g.axes.flat:\n        assert isinstance(ax, plt.Axes)", "ground_truth": "(1, 2)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_8", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_axes_array_size", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axes_array_size(self):\n    g = ag.FacetGrid(self.df)\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a')\n    assert (g.axes.shape == (3, 1))\n    g = ag.FacetGrid(self.df, col='b')\n    assert (g.axes.shape == (1, 2))\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.axes.shape == (3, 2))\n    for ax in g.axes.flat:\n        assert isinstance(ax, plt.Axes)", "masked_code": "def test_axes_array_size(self):\n    g = ag.FacetGrid(self.df)\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a')\n    assert (g.axes.shape == (3, 1))\n    g = ag.FacetGrid(self.df, col='b')\n    assert (g.axes.shape == (1, 2))\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g.axes.shape == '???')\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.axes.shape == (3, 2))\n    for ax in g.axes.flat:\n        assert isinstance(ax, plt.Axes)", "ground_truth": "(1, 1)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_9", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_axes_array_size", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axes_array_size(self):\n    g = ag.FacetGrid(self.df)\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a')\n    assert (g.axes.shape == (3, 1))\n    g = ag.FacetGrid(self.df, col='b')\n    assert (g.axes.shape == (1, 2))\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.axes.shape == (3, 2))\n    for ax in g.axes.flat:\n        assert isinstance(ax, plt.Axes)", "masked_code": "def test_axes_array_size(self):\n    g = ag.FacetGrid(self.df)\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a')\n    assert (g.axes.shape == (3, 1))\n    g = ag.FacetGrid(self.df, col='b')\n    assert (g.axes.shape == (1, 2))\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g.axes.shape == (1, 1))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.axes.shape == '???')\n    for ax in g.axes.flat:\n        assert isinstance(ax, plt.Axes)", "ground_truth": "(3, 2)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_10", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_col_wrap", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == (1, n))\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == (n,))\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == 4)\n    assert (g_wrap._nrow == (n / 4))\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == (1, (n - 1)))\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == ((n - 1),))\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == n)", "masked_code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == '???')\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == (n,))\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == 4)\n    assert (g_wrap._nrow == (n / 4))\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == (1, (n - 1)))\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == ((n - 1),))\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == n)", "ground_truth": "(1, n)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_11", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_col_wrap", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == (1, n))\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == (n,))\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == 4)\n    assert (g_wrap._nrow == (n / 4))\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == (1, (n - 1)))\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == ((n - 1),))\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == n)", "masked_code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == (1, n))\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == '???')\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == 4)\n    assert (g_wrap._nrow == (n / 4))\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == (1, (n - 1)))\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == ((n - 1),))\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == n)", "ground_truth": "(n,)", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_12", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_col_wrap", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == (1, n))\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == (n,))\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == 4)\n    assert (g_wrap._nrow == (n / 4))\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == (1, (n - 1)))\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == ((n - 1),))\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == n)", "masked_code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == (1, n))\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == (n,))\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == '???')\n    assert (g_wrap._nrow == (n / 4))\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == (1, (n - 1)))\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == ((n - 1),))\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == n)", "ground_truth": "4", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_13", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_col_wrap", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == (1, n))\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == (n,))\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == 4)\n    assert (g_wrap._nrow == (n / 4))\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == (1, (n - 1)))\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == ((n - 1),))\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == n)", "masked_code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == (1, n))\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == (n,))\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == 4)\n    assert (g_wrap._nrow == '???')\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == (1, (n - 1)))\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == ((n - 1),))\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == n)", "ground_truth": "(n / 4)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_14", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_col_wrap", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == (1, n))\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == (n,))\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == 4)\n    assert (g_wrap._nrow == (n / 4))\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == (1, (n - 1)))\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == ((n - 1),))\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == n)", "masked_code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == (1, n))\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == (n,))\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == 4)\n    assert (g_wrap._nrow == (n / 4))\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == '???')\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == ((n - 1),))\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == n)", "ground_truth": "(1, (n - 1))", "quality_analysis": {"complexity_score": 9, "left_complexity": 2, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_15", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_col_wrap", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == (1, n))\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == (n,))\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == 4)\n    assert (g_wrap._nrow == (n / 4))\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == (1, (n - 1)))\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == ((n - 1),))\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == n)", "masked_code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == (1, n))\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == (n,))\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == 4)\n    assert (g_wrap._nrow == (n / 4))\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == (1, (n - 1)))\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == '???')\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == n)", "ground_truth": "((n - 1),)", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_16", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_col_wrap", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == (1, n))\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == (n,))\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == 4)\n    assert (g_wrap._nrow == (n / 4))\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == (1, (n - 1)))\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == ((n - 1),))\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == n)", "masked_code": "def test_col_wrap(self):\n    n = len(self.df.d.unique())\n    g = ag.FacetGrid(self.df, col='d')\n    assert (g.axes.shape == (1, n))\n    assert (g.facet_axis(0, 8) is g.axes[(0, 8)])\n    g_wrap = ag.FacetGrid(self.df, col='d', col_wrap=4)\n    assert (g_wrap.axes.shape == (n,))\n    assert (g_wrap.facet_axis(0, 8) is g_wrap.axes[8])\n    assert (g_wrap._ncol == 4)\n    assert (g_wrap._nrow == (n / 4))\n    with pytest.raises(ValueError):\n        g = ag.FacetGrid(self.df, row='b', col='d', col_wrap=4)\n    df = self.df.copy()\n    df.loc[(df.d == 'j')] = np.nan\n    g_missing = ag.FacetGrid(df, col='d')\n    assert (g_missing.axes.shape == (1, (n - 1)))\n    g_missing_wrap = ag.FacetGrid(df, col='d', col_wrap=4)\n    assert (g_missing_wrap.axes.shape == ((n - 1),))\n    g = ag.FacetGrid(self.df, col='d', col_wrap=1)\n    assert (len(list(g.facet_data())) == '???')", "ground_truth": "n", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_17", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_axes_dict", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axes_dict(self):\n    g = ag.FacetGrid(self.df)\n    assert isinstance(g.axes_dict, dict)\n    assert (not g.axes_dict)\n    g = ag.FacetGrid(self.df, row='c')\n    assert (list(g.axes_dict.keys()) == g.row_names)\n    for (name, ax) in zip(g.row_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, col='c')\n    assert (list(g.axes_dict.keys()) == g.col_names)\n    for (name, ax) in zip(g.col_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, col='a', col_wrap=2)\n    assert (list(g.axes_dict.keys()) == g.col_names)\n    for (name, ax) in zip(g.col_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, row='a', col='c')\n    for ((row_var, col_var), ax) in g.axes_dict.items():\n        i = g.row_names.index(row_var)\n        j = g.col_names.index(col_var)\n        assert (g.axes[(i, j)] is ax)", "masked_code": "def test_axes_dict(self):\n    g = ag.FacetGrid(self.df)\n    assert isinstance(g.axes_dict, dict)\n    assert (not g.axes_dict)\n    g = ag.FacetGrid(self.df, row='c')\n    assert (list(g.axes_dict.keys()) == '???')\n    for (name, ax) in zip(g.row_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, col='c')\n    assert (list(g.axes_dict.keys()) == g.col_names)\n    for (name, ax) in zip(g.col_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, col='a', col_wrap=2)\n    assert (list(g.axes_dict.keys()) == g.col_names)\n    for (name, ax) in zip(g.col_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, row='a', col='c')\n    for ((row_var, col_var), ax) in g.axes_dict.items():\n        i = g.row_names.index(row_var)\n        j = g.col_names.index(col_var)\n        assert (g.axes[(i, j)] is ax)", "ground_truth": "g.row_names", "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_18", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_axes_dict", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axes_dict(self):\n    g = ag.FacetGrid(self.df)\n    assert isinstance(g.axes_dict, dict)\n    assert (not g.axes_dict)\n    g = ag.FacetGrid(self.df, row='c')\n    assert (list(g.axes_dict.keys()) == g.row_names)\n    for (name, ax) in zip(g.row_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, col='c')\n    assert (list(g.axes_dict.keys()) == g.col_names)\n    for (name, ax) in zip(g.col_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, col='a', col_wrap=2)\n    assert (list(g.axes_dict.keys()) == g.col_names)\n    for (name, ax) in zip(g.col_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, row='a', col='c')\n    for ((row_var, col_var), ax) in g.axes_dict.items():\n        i = g.row_names.index(row_var)\n        j = g.col_names.index(col_var)\n        assert (g.axes[(i, j)] is ax)", "masked_code": "def test_axes_dict(self):\n    g = ag.FacetGrid(self.df)\n    assert isinstance(g.axes_dict, dict)\n    assert (not g.axes_dict)\n    g = ag.FacetGrid(self.df, row='c')\n    assert (list(g.axes_dict.keys()) == g.row_names)\n    for (name, ax) in zip(g.row_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, col='c')\n    assert (list(g.axes_dict.keys()) == '???')\n    for (name, ax) in zip(g.col_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, col='a', col_wrap=2)\n    assert (list(g.axes_dict.keys()) == g.col_names)\n    for (name, ax) in zip(g.col_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, row='a', col='c')\n    for ((row_var, col_var), ax) in g.axes_dict.items():\n        i = g.row_names.index(row_var)\n        j = g.col_names.index(col_var)\n        assert (g.axes[(i, j)] is ax)", "ground_truth": "g.col_names", "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_19", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_axes_dict", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axes_dict(self):\n    g = ag.FacetGrid(self.df)\n    assert isinstance(g.axes_dict, dict)\n    assert (not g.axes_dict)\n    g = ag.FacetGrid(self.df, row='c')\n    assert (list(g.axes_dict.keys()) == g.row_names)\n    for (name, ax) in zip(g.row_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, col='c')\n    assert (list(g.axes_dict.keys()) == g.col_names)\n    for (name, ax) in zip(g.col_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, col='a', col_wrap=2)\n    assert (list(g.axes_dict.keys()) == g.col_names)\n    for (name, ax) in zip(g.col_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, row='a', col='c')\n    for ((row_var, col_var), ax) in g.axes_dict.items():\n        i = g.row_names.index(row_var)\n        j = g.col_names.index(col_var)\n        assert (g.axes[(i, j)] is ax)", "masked_code": "def test_axes_dict(self):\n    g = ag.FacetGrid(self.df)\n    assert isinstance(g.axes_dict, dict)\n    assert (not g.axes_dict)\n    g = ag.FacetGrid(self.df, row='c')\n    assert (list(g.axes_dict.keys()) == g.row_names)\n    for (name, ax) in zip(g.row_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, col='c')\n    assert (list(g.axes_dict.keys()) == g.col_names)\n    for (name, ax) in zip(g.col_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, col='a', col_wrap=2)\n    assert (list(g.axes_dict.keys()) == '???')\n    for (name, ax) in zip(g.col_names, g.axes.flat):\n        assert (g.axes_dict[name] is ax)\n    g = ag.FacetGrid(self.df, row='a', col='c')\n    for ((row_var, col_var), ax) in g.axes_dict.items():\n        i = g.row_names.index(row_var)\n        j = g.col_names.index(col_var)\n        assert (g.axes[(i, j)] is ax)", "ground_truth": "g.col_names", "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_20", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_legend_data", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_legend_data(self):\n    g = ag.FacetGrid(self.df, hue='a')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=3)\n    assert (g._legend.get_title().get_text() == 'a')\n    a_levels = sorted(self.df.a.unique())\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(a_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == len(a_levels))\n    for (label, level) in zip(labels, a_levels):\n        assert (label.get_text() == level)", "masked_code": "def test_legend_data(self):\n    g = ag.FacetGrid(self.df, hue='a')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=3)\n    assert (g._legend.get_title().get_text() == 'a')\n    a_levels = sorted(self.df.a.unique())\n    lines = g._legend.get_lines()\n    assert (len(lines) == '???')\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == len(a_levels))\n    for (label, level) in zip(labels, a_levels):\n        assert (label.get_text() == level)", "ground_truth": "len(a_levels)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_21", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_legend_data", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_legend_data(self):\n    g = ag.FacetGrid(self.df, hue='a')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=3)\n    assert (g._legend.get_title().get_text() == 'a')\n    a_levels = sorted(self.df.a.unique())\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(a_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == len(a_levels))\n    for (label, level) in zip(labels, a_levels):\n        assert (label.get_text() == level)", "masked_code": "def test_legend_data(self):\n    g = ag.FacetGrid(self.df, hue='a')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=3)\n    assert (g._legend.get_title().get_text() == 'a')\n    a_levels = sorted(self.df.a.unique())\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(a_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == '???')\n    for (label, level) in zip(labels, a_levels):\n        assert (label.get_text() == level)", "ground_truth": "len(a_levels)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_22", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_legend_data", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_legend_data(self):\n    g = ag.FacetGrid(self.df, hue='a')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=3)\n    assert (g._legend.get_title().get_text() == 'a')\n    a_levels = sorted(self.df.a.unique())\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(a_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == len(a_levels))\n    for (label, level) in zip(labels, a_levels):\n        assert (label.get_text() == level)", "masked_code": "def test_legend_data(self):\n    g = ag.FacetGrid(self.df, hue='a')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=3)\n    assert (g._legend.get_title().get_text() == 'a')\n    a_levels = sorted(self.df.a.unique())\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(a_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == len(a_levels))\n    for (label, level) in zip(labels, a_levels):\n        assert (label.get_text() == '???')", "ground_truth": "level", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_23", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_legend_data_missing_level", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_legend_data_missing_level(self):\n    g = ag.FacetGrid(self.df, hue='a', hue_order=list('azbc'))\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    (c1, c2, c3, c4) = color_palette(n_colors=4)\n    palette = [c1, c3, c4]\n    assert (g._legend.get_title().get_text() == 'a')\n    a_levels = sorted(self.df.a.unique())\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(a_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == 4)\n    for (label, level) in zip(labels, list('azbc')):\n        assert (label.get_text() == level)", "masked_code": "def test_legend_data_missing_level(self):\n    g = ag.FacetGrid(self.df, hue='a', hue_order=list('azbc'))\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    (c1, c2, c3, c4) = color_palette(n_colors=4)\n    palette = [c1, c3, c4]\n    assert (g._legend.get_title().get_text() == 'a')\n    a_levels = sorted(self.df.a.unique())\n    lines = g._legend.get_lines()\n    assert (len(lines) == '???')\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == 4)\n    for (label, level) in zip(labels, list('azbc')):\n        assert (label.get_text() == level)", "ground_truth": "len(a_levels)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_24", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_legend_data_missing_level", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_legend_data_missing_level(self):\n    g = ag.FacetGrid(self.df, hue='a', hue_order=list('azbc'))\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    (c1, c2, c3, c4) = color_palette(n_colors=4)\n    palette = [c1, c3, c4]\n    assert (g._legend.get_title().get_text() == 'a')\n    a_levels = sorted(self.df.a.unique())\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(a_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == 4)\n    for (label, level) in zip(labels, list('azbc')):\n        assert (label.get_text() == level)", "masked_code": "def test_legend_data_missing_level(self):\n    g = ag.FacetGrid(self.df, hue='a', hue_order=list('azbc'))\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    (c1, c2, c3, c4) = color_palette(n_colors=4)\n    palette = [c1, c3, c4]\n    assert (g._legend.get_title().get_text() == 'a')\n    a_levels = sorted(self.df.a.unique())\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(a_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == '???')\n    for (label, level) in zip(labels, list('azbc')):\n        assert (label.get_text() == level)", "ground_truth": "4", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_25", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_legend_data_missing_level", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_legend_data_missing_level(self):\n    g = ag.FacetGrid(self.df, hue='a', hue_order=list('azbc'))\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    (c1, c2, c3, c4) = color_palette(n_colors=4)\n    palette = [c1, c3, c4]\n    assert (g._legend.get_title().get_text() == 'a')\n    a_levels = sorted(self.df.a.unique())\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(a_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == 4)\n    for (label, level) in zip(labels, list('azbc')):\n        assert (label.get_text() == level)", "masked_code": "def test_legend_data_missing_level(self):\n    g = ag.FacetGrid(self.df, hue='a', hue_order=list('azbc'))\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    (c1, c2, c3, c4) = color_palette(n_colors=4)\n    palette = [c1, c3, c4]\n    assert (g._legend.get_title().get_text() == 'a')\n    a_levels = sorted(self.df.a.unique())\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(a_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == 4)\n    for (label, level) in zip(labels, list('azbc')):\n        assert (label.get_text() == '???')", "ground_truth": "level", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_26", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_get_boolean_legend_data", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_get_boolean_legend_data(self):\n    self.df['b_bool'] = (self.df.b == 'm')\n    g = ag.FacetGrid(self.df, hue='b_bool')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=2)\n    assert (g._legend.get_title().get_text() == 'b_bool')\n    b_levels = list(map(str, categorical_order(self.df.b_bool)))\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(b_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == len(b_levels))\n    for (label, level) in zip(labels, b_levels):\n        assert (label.get_text() == level)", "masked_code": "def test_get_boolean_legend_data(self):\n    self.df['b_bool'] = (self.df.b == 'm')\n    g = ag.FacetGrid(self.df, hue='b_bool')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=2)\n    assert (g._legend.get_title().get_text() == '???')\n    b_levels = list(map(str, categorical_order(self.df.b_bool)))\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(b_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == len(b_levels))\n    for (label, level) in zip(labels, b_levels):\n        assert (label.get_text() == level)", "ground_truth": "'b_bool'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_27", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_get_boolean_legend_data", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_get_boolean_legend_data(self):\n    self.df['b_bool'] = (self.df.b == 'm')\n    g = ag.FacetGrid(self.df, hue='b_bool')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=2)\n    assert (g._legend.get_title().get_text() == 'b_bool')\n    b_levels = list(map(str, categorical_order(self.df.b_bool)))\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(b_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == len(b_levels))\n    for (label, level) in zip(labels, b_levels):\n        assert (label.get_text() == level)", "masked_code": "def test_get_boolean_legend_data(self):\n    self.df['b_bool'] = (self.df.b == 'm')\n    g = ag.FacetGrid(self.df, hue='b_bool')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=2)\n    assert (g._legend.get_title().get_text() == 'b_bool')\n    b_levels = list(map(str, categorical_order(self.df.b_bool)))\n    lines = g._legend.get_lines()\n    assert (len(lines) == '???')\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == len(b_levels))\n    for (label, level) in zip(labels, b_levels):\n        assert (label.get_text() == level)", "ground_truth": "len(b_levels)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_28", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_get_boolean_legend_data", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_get_boolean_legend_data(self):\n    self.df['b_bool'] = (self.df.b == 'm')\n    g = ag.FacetGrid(self.df, hue='b_bool')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=2)\n    assert (g._legend.get_title().get_text() == 'b_bool')\n    b_levels = list(map(str, categorical_order(self.df.b_bool)))\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(b_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == len(b_levels))\n    for (label, level) in zip(labels, b_levels):\n        assert (label.get_text() == level)", "masked_code": "def test_get_boolean_legend_data(self):\n    self.df['b_bool'] = (self.df.b == 'm')\n    g = ag.FacetGrid(self.df, hue='b_bool')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=2)\n    assert (g._legend.get_title().get_text() == 'b_bool')\n    b_levels = list(map(str, categorical_order(self.df.b_bool)))\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(b_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == '???')\n    for (label, level) in zip(labels, b_levels):\n        assert (label.get_text() == level)", "ground_truth": "len(b_levels)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_29", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_get_boolean_legend_data", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_get_boolean_legend_data(self):\n    self.df['b_bool'] = (self.df.b == 'm')\n    g = ag.FacetGrid(self.df, hue='b_bool')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=2)\n    assert (g._legend.get_title().get_text() == 'b_bool')\n    b_levels = list(map(str, categorical_order(self.df.b_bool)))\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(b_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == len(b_levels))\n    for (label, level) in zip(labels, b_levels):\n        assert (label.get_text() == level)", "masked_code": "def test_get_boolean_legend_data(self):\n    self.df['b_bool'] = (self.df.b == 'm')\n    g = ag.FacetGrid(self.df, hue='b_bool')\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    palette = color_palette(n_colors=2)\n    assert (g._legend.get_title().get_text() == 'b_bool')\n    b_levels = list(map(str, categorical_order(self.df.b_bool)))\n    lines = g._legend.get_lines()\n    assert (len(lines) == len(b_levels))\n    for (line, hue) in zip(lines, palette):\n        assert_colors_equal(line.get_color(), hue)\n    labels = g._legend.get_texts()\n    assert (len(labels) == len(b_levels))\n    for (label, level) in zip(labels, b_levels):\n        assert (label.get_text() == '???')", "ground_truth": "level", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_30", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_legend_tuples", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_legend_tuples(self):\n    g = ag.FacetGrid(self.df, hue='a')\n    g.map(plt.plot, 'x', 'y')\n    (handles, labels) = g.ax.get_legend_handles_labels()\n    label_tuples = [('', l) for l in labels]\n    legend_data = dict(zip(label_tuples, handles))\n    g.add_legend(legend_data, label_tuples)\n    for (entry, label) in zip(g._legend.get_texts(), labels):\n        assert (entry.get_text() == label)", "masked_code": "def test_legend_tuples(self):\n    g = ag.FacetGrid(self.df, hue='a')\n    g.map(plt.plot, 'x', 'y')\n    (handles, labels) = g.ax.get_legend_handles_labels()\n    label_tuples = [('', l) for l in labels]\n    legend_data = dict(zip(label_tuples, handles))\n    g.add_legend(legend_data, label_tuples)\n    for (entry, label) in zip(g._legend.get_texts(), labels):\n        assert (entry.get_text() == '???')", "ground_truth": "label", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_31", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_generator", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_generator(self):\n    g = ag.FacetGrid(self.df, row='a')\n    d = list(g.facet_data())\n    assert (len(d) == 3)\n    (tup, data) = d[0]\n    assert (tup == (0, 0, 0))\n    assert (data['a'] == 'a').all()\n    (tup, data) = d[1]\n    assert (tup == (1, 0, 0))\n    assert (data['a'] == 'b').all()\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    d = list(g.facet_data())\n    assert (len(d) == 6)\n    (tup, data) = d[0]\n    assert (tup == (0, 0, 0))\n    assert (data['a'] == 'a').all()\n    assert (data['b'] == 'm').all()\n    (tup, data) = d[1]\n    assert (tup == (0, 1, 0))\n    assert (data['a'] == 'a').all()\n    assert (data['b'] == 'n').all()\n    (tup, data) = d[2]\n    assert (tup == (1, 0, 0))\n    assert (data['a'] == 'b').all()\n    assert (data['b'] == 'm').all()\n    g = ag.FacetGrid(self.df, hue='c')\n    d = list(g.facet_data())\n    assert (len(d) == 3)\n    (tup, data) = d[1]\n    assert (tup == (0, 0, 1))\n    assert (data['c'] == 'u').all()", "masked_code": "def test_data_generator(self):\n    g = ag.FacetGrid(self.df, row='a')\n    d = list(g.facet_data())\n    assert (len(d) == '???')\n    (tup, data) = d[0]\n    assert (tup == (0, 0, 0))\n    assert (data['a'] == 'a').all()\n    (tup, data) = d[1]\n    assert (tup == (1, 0, 0))\n    assert (data['a'] == 'b').all()\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    d = list(g.facet_data())\n    assert (len(d) == 6)\n    (tup, data) = d[0]\n    assert (tup == (0, 0, 0))\n    assert (data['a'] == 'a').all()\n    assert (data['b'] == 'm').all()\n    (tup, data) = d[1]\n    assert (tup == (0, 1, 0))\n    assert (data['a'] == 'a').all()\n    assert (data['b'] == 'n').all()\n    (tup, data) = d[2]\n    assert (tup == (1, 0, 0))\n    assert (data['a'] == 'b').all()\n    assert (data['b'] == 'm').all()\n    g = ag.FacetGrid(self.df, hue='c')\n    d = list(g.facet_data())\n    assert (len(d) == 3)\n    (tup, data) = d[1]\n    assert (tup == (0, 0, 1))\n    assert (data['c'] == 'u').all()", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_32", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_generator", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_generator(self):\n    g = ag.FacetGrid(self.df, row='a')\n    d = list(g.facet_data())\n    assert (len(d) == 3)\n    (tup, data) = d[0]\n    assert (tup == (0, 0, 0))\n    assert (data['a'] == 'a').all()\n    (tup, data) = d[1]\n    assert (tup == (1, 0, 0))\n    assert (data['a'] == 'b').all()\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    d = list(g.facet_data())\n    assert (len(d) == 6)\n    (tup, data) = d[0]\n    assert (tup == (0, 0, 0))\n    assert (data['a'] == 'a').all()\n    assert (data['b'] == 'm').all()\n    (tup, data) = d[1]\n    assert (tup == (0, 1, 0))\n    assert (data['a'] == 'a').all()\n    assert (data['b'] == 'n').all()\n    (tup, data) = d[2]\n    assert (tup == (1, 0, 0))\n    assert (data['a'] == 'b').all()\n    assert (data['b'] == 'm').all()\n    g = ag.FacetGrid(self.df, hue='c')\n    d = list(g.facet_data())\n    assert (len(d) == 3)\n    (tup, data) = d[1]\n    assert (tup == (0, 0, 1))\n    assert (data['c'] == 'u').all()", "masked_code": "def test_data_generator(self):\n    g = ag.FacetGrid(self.df, row='a')\n    d = list(g.facet_data())\n    assert (len(d) == 3)\n    (tup, data) = d[0]\n    assert (tup == (0, 0, 0))\n    assert (data['a'] == 'a').all()\n    (tup, data) = d[1]\n    assert (tup == (1, 0, 0))\n    assert (data['a'] == 'b').all()\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    d = list(g.facet_data())\n    assert (len(d) == '???')\n    (tup, data) = d[0]\n    assert (tup == (0, 0, 0))\n    assert (data['a'] == 'a').all()\n    assert (data['b'] == 'm').all()\n    (tup, data) = d[1]\n    assert (tup == (0, 1, 0))\n    assert (data['a'] == 'a').all()\n    assert (data['b'] == 'n').all()\n    (tup, data) = d[2]\n    assert (tup == (1, 0, 0))\n    assert (data['a'] == 'b').all()\n    assert (data['b'] == 'm').all()\n    g = ag.FacetGrid(self.df, hue='c')\n    d = list(g.facet_data())\n    assert (len(d) == 3)\n    (tup, data) = d[1]\n    assert (tup == (0, 0, 1))\n    assert (data['c'] == 'u').all()", "ground_truth": "6", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_33", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_generator", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_generator(self):\n    g = ag.FacetGrid(self.df, row='a')\n    d = list(g.facet_data())\n    assert (len(d) == 3)\n    (tup, data) = d[0]\n    assert (tup == (0, 0, 0))\n    assert (data['a'] == 'a').all()\n    (tup, data) = d[1]\n    assert (tup == (1, 0, 0))\n    assert (data['a'] == 'b').all()\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    d = list(g.facet_data())\n    assert (len(d) == 6)\n    (tup, data) = d[0]\n    assert (tup == (0, 0, 0))\n    assert (data['a'] == 'a').all()\n    assert (data['b'] == 'm').all()\n    (tup, data) = d[1]\n    assert (tup == (0, 1, 0))\n    assert (data['a'] == 'a').all()\n    assert (data['b'] == 'n').all()\n    (tup, data) = d[2]\n    assert (tup == (1, 0, 0))\n    assert (data['a'] == 'b').all()\n    assert (data['b'] == 'm').all()\n    g = ag.FacetGrid(self.df, hue='c')\n    d = list(g.facet_data())\n    assert (len(d) == 3)\n    (tup, data) = d[1]\n    assert (tup == (0, 0, 1))\n    assert (data['c'] == 'u').all()", "masked_code": "def test_data_generator(self):\n    g = ag.FacetGrid(self.df, row='a')\n    d = list(g.facet_data())\n    assert (len(d) == 3)\n    (tup, data) = d[0]\n    assert (tup == (0, 0, 0))\n    assert (data['a'] == 'a').all()\n    (tup, data) = d[1]\n    assert (tup == (1, 0, 0))\n    assert (data['a'] == 'b').all()\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    d = list(g.facet_data())\n    assert (len(d) == 6)\n    (tup, data) = d[0]\n    assert (tup == (0, 0, 0))\n    assert (data['a'] == 'a').all()\n    assert (data['b'] == 'm').all()\n    (tup, data) = d[1]\n    assert (tup == (0, 1, 0))\n    assert (data['a'] == 'a').all()\n    assert (data['b'] == 'n').all()\n    (tup, data) = d[2]\n    assert (tup == (1, 0, 0))\n    assert (data['a'] == 'b').all()\n    assert (data['b'] == 'm').all()\n    g = ag.FacetGrid(self.df, hue='c')\n    d = list(g.facet_data())\n    assert (len(d) == '???')\n    (tup, data) = d[1]\n    assert (tup == (0, 0, 1))\n    assert (data['c'] == 'u').all()", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_34", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_map", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    g.map(plt.plot, 'x', 'y', linewidth=3)\n    lines = g.axes[(0, 0)].lines\n    assert (len(lines) == 3)\n    (line1, _, _) = lines\n    assert (line1.get_linewidth() == 3)\n    (x, y) = line1.get_data()\n    mask = (((self.df.a == 'a') & (self.df.b == 'm')) & (self.df.c == 't'))\n    npt.assert_array_equal(x, self.df.x[mask])\n    npt.assert_array_equal(y, self.df.y[mask])", "masked_code": "def test_map(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    g.map(plt.plot, 'x', 'y', linewidth=3)\n    lines = g.axes[(0, 0)].lines\n    assert (len(lines) == '???')\n    (line1, _, _) = lines\n    assert (line1.get_linewidth() == 3)\n    (x, y) = line1.get_data()\n    mask = (((self.df.a == 'a') & (self.df.b == 'm')) & (self.df.c == 't'))\n    npt.assert_array_equal(x, self.df.x[mask])\n    npt.assert_array_equal(y, self.df.y[mask])", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_35", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_map", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    g.map(plt.plot, 'x', 'y', linewidth=3)\n    lines = g.axes[(0, 0)].lines\n    assert (len(lines) == 3)\n    (line1, _, _) = lines\n    assert (line1.get_linewidth() == 3)\n    (x, y) = line1.get_data()\n    mask = (((self.df.a == 'a') & (self.df.b == 'm')) & (self.df.c == 't'))\n    npt.assert_array_equal(x, self.df.x[mask])\n    npt.assert_array_equal(y, self.df.y[mask])", "masked_code": "def test_map(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    g.map(plt.plot, 'x', 'y', linewidth=3)\n    lines = g.axes[(0, 0)].lines\n    assert (len(lines) == 3)\n    (line1, _, _) = lines\n    assert (line1.get_linewidth() == '???')\n    (x, y) = line1.get_data()\n    mask = (((self.df.a == 'a') & (self.df.b == 'm')) & (self.df.c == 't'))\n    npt.assert_array_equal(x, self.df.x[mask])\n    npt.assert_array_equal(y, self.df.y[mask])", "ground_truth": "3", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_36", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_map_dataframe", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_dataframe(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n\n    def plot(x, y, data=None, **kws):\n        plt.plot(data[x], data[y], **kws)\n    plot.__module__ = 'test'\n    g.map_dataframe(plot, 'x', 'y', linestyle='--')\n    lines = g.axes[(0, 0)].lines\n    assert (len(g.axes[(0, 0)].lines) == 3)\n    (line1, _, _) = lines\n    assert (line1.get_linestyle() == '--')\n    (x, y) = line1.get_data()\n    mask = (((self.df.a == 'a') & (self.df.b == 'm')) & (self.df.c == 't'))\n    npt.assert_array_equal(x, self.df.x[mask])\n    npt.assert_array_equal(y, self.df.y[mask])", "masked_code": "def test_map_dataframe(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n\n    def plot(x, y, data=None, **kws):\n        plt.plot(data[x], data[y], **kws)\n    plot.__module__ = 'test'\n    g.map_dataframe(plot, 'x', 'y', linestyle='--')\n    lines = g.axes[(0, 0)].lines\n    assert (len(g.axes[(0, 0)].lines) == '???')\n    (line1, _, _) = lines\n    assert (line1.get_linestyle() == '--')\n    (x, y) = line1.get_data()\n    mask = (((self.df.a == 'a') & (self.df.b == 'm')) & (self.df.c == 't'))\n    npt.assert_array_equal(x, self.df.x[mask])\n    npt.assert_array_equal(y, self.df.y[mask])", "ground_truth": "3", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_37", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_map_dataframe", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_dataframe(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n\n    def plot(x, y, data=None, **kws):\n        plt.plot(data[x], data[y], **kws)\n    plot.__module__ = 'test'\n    g.map_dataframe(plot, 'x', 'y', linestyle='--')\n    lines = g.axes[(0, 0)].lines\n    assert (len(g.axes[(0, 0)].lines) == 3)\n    (line1, _, _) = lines\n    assert (line1.get_linestyle() == '--')\n    (x, y) = line1.get_data()\n    mask = (((self.df.a == 'a') & (self.df.b == 'm')) & (self.df.c == 't'))\n    npt.assert_array_equal(x, self.df.x[mask])\n    npt.assert_array_equal(y, self.df.y[mask])", "masked_code": "def test_map_dataframe(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n\n    def plot(x, y, data=None, **kws):\n        plt.plot(data[x], data[y], **kws)\n    plot.__module__ = 'test'\n    g.map_dataframe(plot, 'x', 'y', linestyle='--')\n    lines = g.axes[(0, 0)].lines\n    assert (len(g.axes[(0, 0)].lines) == 3)\n    (line1, _, _) = lines\n    assert (line1.get_linestyle() == '???')\n    (x, y) = line1.get_data()\n    mask = (((self.df.a == 'a') & (self.df.b == 'm')) & (self.df.c == 't'))\n    npt.assert_array_equal(x, self.df.x[mask])\n    npt.assert_array_equal(y, self.df.y[mask])", "ground_truth": "'--'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_38", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_titles", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "masked_code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == '???')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "ground_truth": "'a = a | b = m'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_39", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_titles", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "masked_code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == '???')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "ground_truth": "'a = a | b = n'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_40", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_titles", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "masked_code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == '???')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "ground_truth": "'a = b | b = m'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_41", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_titles", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "masked_code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == '???')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "ground_truth": "'a == a \\\\/ b == m'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_42", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_titles", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "masked_code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == '???')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "ground_truth": "'a == a \\\\/ b == n'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_43", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_titles", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "masked_code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == '???')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "ground_truth": "'a == b \\\\/ b == m'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_44", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_titles", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "masked_code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == '???')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "ground_truth": "'b = m'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_45", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_titles", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "masked_code": "def test_set_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'a = a | b = m')\n    assert (g.axes[(0, 1)].get_title() == 'a = a | b = n')\n    assert (g.axes[(1, 0)].get_title() == 'a = b | b = m')\n    g.set_titles('{row_var} == {row_name} \\\\/ {col_var} == {col_name}')\n    assert (g.axes[(0, 0)].get_title() == 'a == a \\\\/ b == m')\n    assert (g.axes[(0, 1)].get_title() == 'a == a \\\\/ b == n')\n    assert (g.axes[(1, 0)].get_title() == 'a == b \\\\/ b == m')\n    g = ag.FacetGrid(self.df, col='b')\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == '???')\n    g = ag.FacetGrid(self.df, col='b', hue='b', dropna=False)\n    g.map(plt.plot, 'x', 'y')", "ground_truth": "'b = n'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_46", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_titles_margin_titles", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_titles_margin_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', margin_titles=True)\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (g.axes[(0, 1)].texts[0].get_text() == 'a = a')\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'a = b')\n    assert (g.axes[(0, 1)].texts[0] is g._margin_titles_texts[0])\n    g.set_titles(col_template='{col_name}', row_template='{row_name}')\n    assert (g.axes[(0, 0)].get_title() == 'm')\n    assert (g.axes[(0, 1)].get_title() == 'n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (len(g.axes[(1, 1)].texts) == 1)\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'b')", "masked_code": "def test_set_titles_margin_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', margin_titles=True)\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == '???')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (g.axes[(0, 1)].texts[0].get_text() == 'a = a')\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'a = b')\n    assert (g.axes[(0, 1)].texts[0] is g._margin_titles_texts[0])\n    g.set_titles(col_template='{col_name}', row_template='{row_name}')\n    assert (g.axes[(0, 0)].get_title() == 'm')\n    assert (g.axes[(0, 1)].get_title() == 'n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (len(g.axes[(1, 1)].texts) == 1)\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'b')", "ground_truth": "'b = m'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_47", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_titles_margin_titles", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_titles_margin_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', margin_titles=True)\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (g.axes[(0, 1)].texts[0].get_text() == 'a = a')\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'a = b')\n    assert (g.axes[(0, 1)].texts[0] is g._margin_titles_texts[0])\n    g.set_titles(col_template='{col_name}', row_template='{row_name}')\n    assert (g.axes[(0, 0)].get_title() == 'm')\n    assert (g.axes[(0, 1)].get_title() == 'n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (len(g.axes[(1, 1)].texts) == 1)\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'b')", "masked_code": "def test_set_titles_margin_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', margin_titles=True)\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == '???')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (g.axes[(0, 1)].texts[0].get_text() == 'a = a')\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'a = b')\n    assert (g.axes[(0, 1)].texts[0] is g._margin_titles_texts[0])\n    g.set_titles(col_template='{col_name}', row_template='{row_name}')\n    assert (g.axes[(0, 0)].get_title() == 'm')\n    assert (g.axes[(0, 1)].get_title() == 'n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (len(g.axes[(1, 1)].texts) == 1)\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'b')", "ground_truth": "'b = n'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_48", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_titles_margin_titles", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_titles_margin_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', margin_titles=True)\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (g.axes[(0, 1)].texts[0].get_text() == 'a = a')\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'a = b')\n    assert (g.axes[(0, 1)].texts[0] is g._margin_titles_texts[0])\n    g.set_titles(col_template='{col_name}', row_template='{row_name}')\n    assert (g.axes[(0, 0)].get_title() == 'm')\n    assert (g.axes[(0, 1)].get_title() == 'n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (len(g.axes[(1, 1)].texts) == 1)\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'b')", "masked_code": "def test_set_titles_margin_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', margin_titles=True)\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (g.axes[(0, 1)].texts[0].get_text() == '???')\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'a = b')\n    assert (g.axes[(0, 1)].texts[0] is g._margin_titles_texts[0])\n    g.set_titles(col_template='{col_name}', row_template='{row_name}')\n    assert (g.axes[(0, 0)].get_title() == 'm')\n    assert (g.axes[(0, 1)].get_title() == 'n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (len(g.axes[(1, 1)].texts) == 1)\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'b')", "ground_truth": "'a = a'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_49", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_titles_margin_titles", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_titles_margin_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', margin_titles=True)\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (g.axes[(0, 1)].texts[0].get_text() == 'a = a')\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'a = b')\n    assert (g.axes[(0, 1)].texts[0] is g._margin_titles_texts[0])\n    g.set_titles(col_template='{col_name}', row_template='{row_name}')\n    assert (g.axes[(0, 0)].get_title() == 'm')\n    assert (g.axes[(0, 1)].get_title() == 'n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (len(g.axes[(1, 1)].texts) == 1)\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'b')", "masked_code": "def test_set_titles_margin_titles(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', margin_titles=True)\n    g.map(plt.plot, 'x', 'y')\n    assert (g.axes[(0, 0)].get_title() == 'b = m')\n    assert (g.axes[(0, 1)].get_title() == 'b = n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (g.axes[(0, 1)].texts[0].get_text() == 'a = a')\n    assert (g.axes[(1, 1)].texts[0].get_text() == '???')\n    assert (g.axes[(0, 1)].texts[0] is g._margin_titles_texts[0])\n    g.set_titles(col_template='{col_name}', row_template='{row_name}')\n    assert (g.axes[(0, 0)].get_title() == 'm')\n    assert (g.axes[(0, 1)].get_title() == 'n')\n    assert (g.axes[(1, 0)].get_title() == '')\n    assert (len(g.axes[(1, 1)].texts) == 1)\n    assert (g.axes[(1, 1)].texts[0].get_text() == 'b')", "ground_truth": "'a = b'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_50", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_ticklabels", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_ticklabels(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    ax = g.axes[((- 1), 0)]\n    xlab = [(l.get_text() + 'h') for l in ax.get_xticklabels()]\n    ylab = [(l.get_text() + 'i') for l in ax.get_yticklabels()]\n    g.set_xticklabels(xlab)\n    g.set_yticklabels(ylab)\n    got_x = [l.get_text() for l in g.axes[((- 1), 1)].get_xticklabels()]\n    got_y = [l.get_text() for l in g.axes[(0, 0)].get_yticklabels()]\n    npt.assert_array_equal(got_x, xlab)\n    npt.assert_array_equal(got_y, ylab)\n    (x, y) = (np.arange(10), np.arange(10))\n    df = pd.DataFrame(np.c_[(x, y)], columns=['x', 'y'])\n    g = ag.FacetGrid(df).map_dataframe(pointplot, x='x', y='y', order=x)\n    g.set_xticklabels(step=2)\n    got_x = [int(l.get_text()) for l in g.axes[(0, 0)].get_xticklabels()]\n    npt.assert_array_equal(x[::2], got_x)\n    g = ag.FacetGrid(self.df, col='d', col_wrap=5)\n    g.map(plt.plot, 'x', 'y')\n    g.set_xticklabels(rotation=45)\n    g.set_yticklabels(rotation=75)\n    for ax in g._bottom_axes:\n        for l in ax.get_xticklabels():\n            assert (l.get_rotation() == 45)\n    for ax in g._left_axes:\n        for l in ax.get_yticklabels():\n            assert (l.get_rotation() == 75)", "masked_code": "def test_set_ticklabels(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    ax = g.axes[((- 1), 0)]\n    xlab = [(l.get_text() + 'h') for l in ax.get_xticklabels()]\n    ylab = [(l.get_text() + 'i') for l in ax.get_yticklabels()]\n    g.set_xticklabels(xlab)\n    g.set_yticklabels(ylab)\n    got_x = [l.get_text() for l in g.axes[((- 1), 1)].get_xticklabels()]\n    got_y = [l.get_text() for l in g.axes[(0, 0)].get_yticklabels()]\n    npt.assert_array_equal(got_x, xlab)\n    npt.assert_array_equal(got_y, ylab)\n    (x, y) = (np.arange(10), np.arange(10))\n    df = pd.DataFrame(np.c_[(x, y)], columns=['x', 'y'])\n    g = ag.FacetGrid(df).map_dataframe(pointplot, x='x', y='y', order=x)\n    g.set_xticklabels(step=2)\n    got_x = [int(l.get_text()) for l in g.axes[(0, 0)].get_xticklabels()]\n    npt.assert_array_equal(x[::2], got_x)\n    g = ag.FacetGrid(self.df, col='d', col_wrap=5)\n    g.map(plt.plot, 'x', 'y')\n    g.set_xticklabels(rotation=45)\n    g.set_yticklabels(rotation=75)\n    for ax in g._bottom_axes:\n        for l in ax.get_xticklabels():\n            assert (l.get_rotation() == '???')\n    for ax in g._left_axes:\n        for l in ax.get_yticklabels():\n            assert (l.get_rotation() == 75)", "ground_truth": "45", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_51", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_set_ticklabels", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_set_ticklabels(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    ax = g.axes[((- 1), 0)]\n    xlab = [(l.get_text() + 'h') for l in ax.get_xticklabels()]\n    ylab = [(l.get_text() + 'i') for l in ax.get_yticklabels()]\n    g.set_xticklabels(xlab)\n    g.set_yticklabels(ylab)\n    got_x = [l.get_text() for l in g.axes[((- 1), 1)].get_xticklabels()]\n    got_y = [l.get_text() for l in g.axes[(0, 0)].get_yticklabels()]\n    npt.assert_array_equal(got_x, xlab)\n    npt.assert_array_equal(got_y, ylab)\n    (x, y) = (np.arange(10), np.arange(10))\n    df = pd.DataFrame(np.c_[(x, y)], columns=['x', 'y'])\n    g = ag.FacetGrid(df).map_dataframe(pointplot, x='x', y='y', order=x)\n    g.set_xticklabels(step=2)\n    got_x = [int(l.get_text()) for l in g.axes[(0, 0)].get_xticklabels()]\n    npt.assert_array_equal(x[::2], got_x)\n    g = ag.FacetGrid(self.df, col='d', col_wrap=5)\n    g.map(plt.plot, 'x', 'y')\n    g.set_xticklabels(rotation=45)\n    g.set_yticklabels(rotation=75)\n    for ax in g._bottom_axes:\n        for l in ax.get_xticklabels():\n            assert (l.get_rotation() == 45)\n    for ax in g._left_axes:\n        for l in ax.get_yticklabels():\n            assert (l.get_rotation() == 75)", "masked_code": "def test_set_ticklabels(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.map(plt.plot, 'x', 'y')\n    ax = g.axes[((- 1), 0)]\n    xlab = [(l.get_text() + 'h') for l in ax.get_xticklabels()]\n    ylab = [(l.get_text() + 'i') for l in ax.get_yticklabels()]\n    g.set_xticklabels(xlab)\n    g.set_yticklabels(ylab)\n    got_x = [l.get_text() for l in g.axes[((- 1), 1)].get_xticklabels()]\n    got_y = [l.get_text() for l in g.axes[(0, 0)].get_yticklabels()]\n    npt.assert_array_equal(got_x, xlab)\n    npt.assert_array_equal(got_y, ylab)\n    (x, y) = (np.arange(10), np.arange(10))\n    df = pd.DataFrame(np.c_[(x, y)], columns=['x', 'y'])\n    g = ag.FacetGrid(df).map_dataframe(pointplot, x='x', y='y', order=x)\n    g.set_xticklabels(step=2)\n    got_x = [int(l.get_text()) for l in g.axes[(0, 0)].get_xticklabels()]\n    npt.assert_array_equal(x[::2], got_x)\n    g = ag.FacetGrid(self.df, col='d', col_wrap=5)\n    g.map(plt.plot, 'x', 'y')\n    g.set_xticklabels(rotation=45)\n    g.set_yticklabels(rotation=75)\n    for ax in g._bottom_axes:\n        for l in ax.get_xticklabels():\n            assert (l.get_rotation() == 45)\n    for ax in g._left_axes:\n        for l in ax.get_yticklabels():\n            assert (l.get_rotation() == '???')", "ground_truth": "75", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_52", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_axis_lims", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axis_lims(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', xlim=(0, 4), ylim=((- 2), 3))\n    assert (g.axes[(0, 0)].get_xlim() == (0, 4))\n    assert (g.axes[(0, 0)].get_ylim() == ((- 2), 3))", "masked_code": "def test_axis_lims(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', xlim=(0, 4), ylim=((- 2), 3))\n    assert (g.axes[(0, 0)].get_xlim() == '???')\n    assert (g.axes[(0, 0)].get_ylim() == ((- 2), 3))", "ground_truth": "(0, 4)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_53", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_axis_lims", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axis_lims(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', xlim=(0, 4), ylim=((- 2), 3))\n    assert (g.axes[(0, 0)].get_xlim() == (0, 4))\n    assert (g.axes[(0, 0)].get_ylim() == ((- 2), 3))", "masked_code": "def test_axis_lims(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', xlim=(0, 4), ylim=((- 2), 3))\n    assert (g.axes[(0, 0)].get_xlim() == (0, 4))\n    assert (g.axes[(0, 0)].get_ylim() == '???')", "ground_truth": "((- 2), 3)", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_54", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_orders", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "masked_code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == '???')\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "ground_truth": "list('abc')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_55", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_orders", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "masked_code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == '???')\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "ground_truth": "list('mn')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_56", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_orders", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "masked_code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == '???')\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "ground_truth": "list('tuv')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_57", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_orders", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "masked_code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == '???')\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "ground_truth": "(3, 2)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_58", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_orders", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "masked_code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == '???')\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "ground_truth": "list('bca')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_59", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_orders", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "masked_code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == '???')\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "ground_truth": "list('nm')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_60", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_orders", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "masked_code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == '???')\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "ground_truth": "list('vtu')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_61", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_orders", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "masked_code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == '???')\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "ground_truth": "(3, 2)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_62", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_orders", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "masked_code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == '???')\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "ground_truth": "list('bcda')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_63", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_orders", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "masked_code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == '???')\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "ground_truth": "list('nom')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_64", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_orders", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "masked_code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == '???')\n    assert (g.axes.shape == (4, 3))", "ground_truth": "list('qvtu')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_65", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_orders", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == (4, 3))", "masked_code": "def test_data_orders(self):\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c')\n    assert (g.row_names == list('abc'))\n    assert (g.col_names == list('mn'))\n    assert (g.hue_names == list('tuv'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bca'), col_order=list('nm'), hue_order=list('vtu'))\n    assert (g.row_names == list('bca'))\n    assert (g.col_names == list('nm'))\n    assert (g.hue_names == list('vtu'))\n    assert (g.axes.shape == (3, 2))\n    g = ag.FacetGrid(self.df, row='a', col='b', hue='c', row_order=list('bcda'), col_order=list('nom'), hue_order=list('qvtu'))\n    assert (g.row_names == list('bcda'))\n    assert (g.col_names == list('nom'))\n    assert (g.hue_names == list('qvtu'))\n    assert (g.axes.shape == '???')", "ground_truth": "(4, 3)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_66", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_palette", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_palette(self):\n    rcmod.set()\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g._colors == color_palette(n_colors=len(self.df.c.unique())))\n    g = ag.FacetGrid(self.df, hue='d')\n    assert (g._colors == color_palette('husl', len(self.df.d.unique())))\n    g = ag.FacetGrid(self.df, hue='c', palette='Set2')\n    assert (g._colors == color_palette('Set2', len(self.df.c.unique())))\n    dict_pal = dict(t='red', u='green', v='blue')\n    list_pal = color_palette(['red', 'green', 'blue'], 3)\n    g = ag.FacetGrid(self.df, hue='c', palette=dict_pal)\n    assert (g._colors == list_pal)\n    list_pal = color_palette(['green', 'blue', 'red'], 3)\n    g = ag.FacetGrid(self.df, hue='c', hue_order=list('uvt'), palette=dict_pal)\n    assert (g._colors == list_pal)", "masked_code": "def test_palette(self):\n    rcmod.set()\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g._colors == '???')\n    g = ag.FacetGrid(self.df, hue='d')\n    assert (g._colors == color_palette('husl', len(self.df.d.unique())))\n    g = ag.FacetGrid(self.df, hue='c', palette='Set2')\n    assert (g._colors == color_palette('Set2', len(self.df.c.unique())))\n    dict_pal = dict(t='red', u='green', v='blue')\n    list_pal = color_palette(['red', 'green', 'blue'], 3)\n    g = ag.FacetGrid(self.df, hue='c', palette=dict_pal)\n    assert (g._colors == list_pal)\n    list_pal = color_palette(['green', 'blue', 'red'], 3)\n    g = ag.FacetGrid(self.df, hue='c', hue_order=list('uvt'), palette=dict_pal)\n    assert (g._colors == list_pal)", "ground_truth": "color_palette(n_colors=len(self.df.c.unique()))", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_67", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_palette", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_palette(self):\n    rcmod.set()\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g._colors == color_palette(n_colors=len(self.df.c.unique())))\n    g = ag.FacetGrid(self.df, hue='d')\n    assert (g._colors == color_palette('husl', len(self.df.d.unique())))\n    g = ag.FacetGrid(self.df, hue='c', palette='Set2')\n    assert (g._colors == color_palette('Set2', len(self.df.c.unique())))\n    dict_pal = dict(t='red', u='green', v='blue')\n    list_pal = color_palette(['red', 'green', 'blue'], 3)\n    g = ag.FacetGrid(self.df, hue='c', palette=dict_pal)\n    assert (g._colors == list_pal)\n    list_pal = color_palette(['green', 'blue', 'red'], 3)\n    g = ag.FacetGrid(self.df, hue='c', hue_order=list('uvt'), palette=dict_pal)\n    assert (g._colors == list_pal)", "masked_code": "def test_palette(self):\n    rcmod.set()\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g._colors == color_palette(n_colors=len(self.df.c.unique())))\n    g = ag.FacetGrid(self.df, hue='d')\n    assert (g._colors == '???')\n    g = ag.FacetGrid(self.df, hue='c', palette='Set2')\n    assert (g._colors == color_palette('Set2', len(self.df.c.unique())))\n    dict_pal = dict(t='red', u='green', v='blue')\n    list_pal = color_palette(['red', 'green', 'blue'], 3)\n    g = ag.FacetGrid(self.df, hue='c', palette=dict_pal)\n    assert (g._colors == list_pal)\n    list_pal = color_palette(['green', 'blue', 'red'], 3)\n    g = ag.FacetGrid(self.df, hue='c', hue_order=list('uvt'), palette=dict_pal)\n    assert (g._colors == list_pal)", "ground_truth": "color_palette('husl', len(self.df.d.unique()))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_68", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_palette", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_palette(self):\n    rcmod.set()\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g._colors == color_palette(n_colors=len(self.df.c.unique())))\n    g = ag.FacetGrid(self.df, hue='d')\n    assert (g._colors == color_palette('husl', len(self.df.d.unique())))\n    g = ag.FacetGrid(self.df, hue='c', palette='Set2')\n    assert (g._colors == color_palette('Set2', len(self.df.c.unique())))\n    dict_pal = dict(t='red', u='green', v='blue')\n    list_pal = color_palette(['red', 'green', 'blue'], 3)\n    g = ag.FacetGrid(self.df, hue='c', palette=dict_pal)\n    assert (g._colors == list_pal)\n    list_pal = color_palette(['green', 'blue', 'red'], 3)\n    g = ag.FacetGrid(self.df, hue='c', hue_order=list('uvt'), palette=dict_pal)\n    assert (g._colors == list_pal)", "masked_code": "def test_palette(self):\n    rcmod.set()\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g._colors == color_palette(n_colors=len(self.df.c.unique())))\n    g = ag.FacetGrid(self.df, hue='d')\n    assert (g._colors == color_palette('husl', len(self.df.d.unique())))\n    g = ag.FacetGrid(self.df, hue='c', palette='Set2')\n    assert (g._colors == '???')\n    dict_pal = dict(t='red', u='green', v='blue')\n    list_pal = color_palette(['red', 'green', 'blue'], 3)\n    g = ag.FacetGrid(self.df, hue='c', palette=dict_pal)\n    assert (g._colors == list_pal)\n    list_pal = color_palette(['green', 'blue', 'red'], 3)\n    g = ag.FacetGrid(self.df, hue='c', hue_order=list('uvt'), palette=dict_pal)\n    assert (g._colors == list_pal)", "ground_truth": "color_palette('Set2', len(self.df.c.unique()))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_69", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_palette", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_palette(self):\n    rcmod.set()\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g._colors == color_palette(n_colors=len(self.df.c.unique())))\n    g = ag.FacetGrid(self.df, hue='d')\n    assert (g._colors == color_palette('husl', len(self.df.d.unique())))\n    g = ag.FacetGrid(self.df, hue='c', palette='Set2')\n    assert (g._colors == color_palette('Set2', len(self.df.c.unique())))\n    dict_pal = dict(t='red', u='green', v='blue')\n    list_pal = color_palette(['red', 'green', 'blue'], 3)\n    g = ag.FacetGrid(self.df, hue='c', palette=dict_pal)\n    assert (g._colors == list_pal)\n    list_pal = color_palette(['green', 'blue', 'red'], 3)\n    g = ag.FacetGrid(self.df, hue='c', hue_order=list('uvt'), palette=dict_pal)\n    assert (g._colors == list_pal)", "masked_code": "def test_palette(self):\n    rcmod.set()\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g._colors == color_palette(n_colors=len(self.df.c.unique())))\n    g = ag.FacetGrid(self.df, hue='d')\n    assert (g._colors == color_palette('husl', len(self.df.d.unique())))\n    g = ag.FacetGrid(self.df, hue='c', palette='Set2')\n    assert (g._colors == color_palette('Set2', len(self.df.c.unique())))\n    dict_pal = dict(t='red', u='green', v='blue')\n    list_pal = color_palette(['red', 'green', 'blue'], 3)\n    g = ag.FacetGrid(self.df, hue='c', palette=dict_pal)\n    assert (g._colors == '???')\n    list_pal = color_palette(['green', 'blue', 'red'], 3)\n    g = ag.FacetGrid(self.df, hue='c', hue_order=list('uvt'), palette=dict_pal)\n    assert (g._colors == list_pal)", "ground_truth": "list_pal", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_70", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_palette", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_palette(self):\n    rcmod.set()\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g._colors == color_palette(n_colors=len(self.df.c.unique())))\n    g = ag.FacetGrid(self.df, hue='d')\n    assert (g._colors == color_palette('husl', len(self.df.d.unique())))\n    g = ag.FacetGrid(self.df, hue='c', palette='Set2')\n    assert (g._colors == color_palette('Set2', len(self.df.c.unique())))\n    dict_pal = dict(t='red', u='green', v='blue')\n    list_pal = color_palette(['red', 'green', 'blue'], 3)\n    g = ag.FacetGrid(self.df, hue='c', palette=dict_pal)\n    assert (g._colors == list_pal)\n    list_pal = color_palette(['green', 'blue', 'red'], 3)\n    g = ag.FacetGrid(self.df, hue='c', hue_order=list('uvt'), palette=dict_pal)\n    assert (g._colors == list_pal)", "masked_code": "def test_palette(self):\n    rcmod.set()\n    g = ag.FacetGrid(self.df, hue='c')\n    assert (g._colors == color_palette(n_colors=len(self.df.c.unique())))\n    g = ag.FacetGrid(self.df, hue='d')\n    assert (g._colors == color_palette('husl', len(self.df.d.unique())))\n    g = ag.FacetGrid(self.df, hue='c', palette='Set2')\n    assert (g._colors == color_palette('Set2', len(self.df.c.unique())))\n    dict_pal = dict(t='red', u='green', v='blue')\n    list_pal = color_palette(['red', 'green', 'blue'], 3)\n    g = ag.FacetGrid(self.df, hue='c', palette=dict_pal)\n    assert (g._colors == list_pal)\n    list_pal = color_palette(['green', 'blue', 'red'], 3)\n    g = ag.FacetGrid(self.df, hue='c', hue_order=list('uvt'), palette=dict_pal)\n    assert (g._colors == '???')", "ground_truth": "list_pal", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_71", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_hue_kws", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_hue_kws(self):\n    kws = dict(marker=['o', 's', 'D'])\n    g = ag.FacetGrid(self.df, hue='c', hue_kws=kws)\n    g.map(plt.plot, 'x', 'y')\n    for (line, marker) in zip(g.axes[(0, 0)].lines, kws['marker']):\n        assert (line.get_marker() == marker)", "masked_code": "def test_hue_kws(self):\n    kws = dict(marker=['o', 's', 'D'])\n    g = ag.FacetGrid(self.df, hue='c', hue_kws=kws)\n    g.map(plt.plot, 'x', 'y')\n    for (line, marker) in zip(g.axes[(0, 0)].lines, kws['marker']):\n        assert (line.get_marker() == '???')", "ground_truth": "marker", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_72", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_dropna", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_dropna(self):\n    df = self.df.copy()\n    hasna = pd.Series(np.tile(np.arange(6), 10), dtype=float)\n    hasna[(hasna == 5)] = np.nan\n    df['hasna'] = hasna\n    g = ag.FacetGrid(df, dropna=False, row='hasna')\n    assert (g._not_na.sum() == 60)\n    g = ag.FacetGrid(df, dropna=True, row='hasna')\n    assert (g._not_na.sum() == 50)", "masked_code": "def test_dropna(self):\n    df = self.df.copy()\n    hasna = pd.Series(np.tile(np.arange(6), 10), dtype=float)\n    hasna[(hasna == 5)] = np.nan\n    df['hasna'] = hasna\n    g = ag.FacetGrid(df, dropna=False, row='hasna')\n    assert (g._not_na.sum() == '???')\n    g = ag.FacetGrid(df, dropna=True, row='hasna')\n    assert (g._not_na.sum() == 50)", "ground_truth": "60", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_73", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_dropna", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_dropna(self):\n    df = self.df.copy()\n    hasna = pd.Series(np.tile(np.arange(6), 10), dtype=float)\n    hasna[(hasna == 5)] = np.nan\n    df['hasna'] = hasna\n    g = ag.FacetGrid(df, dropna=False, row='hasna')\n    assert (g._not_na.sum() == 60)\n    g = ag.FacetGrid(df, dropna=True, row='hasna')\n    assert (g._not_na.sum() == 50)", "masked_code": "def test_dropna(self):\n    df = self.df.copy()\n    hasna = pd.Series(np.tile(np.arange(6), 10), dtype=float)\n    hasna[(hasna == 5)] = np.nan\n    df['hasna'] = hasna\n    g = ag.FacetGrid(df, dropna=False, row='hasna')\n    assert (g._not_na.sum() == 60)\n    g = ag.FacetGrid(df, dropna=True, row='hasna')\n    assert (g._not_na.sum() == '???')", "ground_truth": "50", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_74", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_categorical_column_missing_categories", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_categorical_column_missing_categories(self):\n    df = self.df.copy()\n    df['a'] = df['a'].astype('category')\n    g = ag.FacetGrid(df[(df['a'] == 'a')], col='a', col_wrap=1)\n    assert (g.axes.shape == (len(df['a'].cat.categories),))", "masked_code": "def test_categorical_column_missing_categories(self):\n    df = self.df.copy()\n    df['a'] = df['a'].astype('category')\n    g = ag.FacetGrid(df[(df['a'] == 'a')], col='a', col_wrap=1)\n    assert (g.axes.shape == '???')", "ground_truth": "(len(df['a'].cat.categories),)", "quality_analysis": {"complexity_score": 9, "left_complexity": 2, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_75", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_refline", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_refline(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.refline()\n    for ax in g.axes.flat:\n        assert (not ax.lines)\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy)\n    for ax in g.axes.flat:\n        assert (ax.lines[0].get_color() == '.5')\n        assert (ax.lines[0].get_linestyle() == '--')\n        assert (len(ax.lines) == 2)\n        npt.assert_array_equal(ax.lines[0].get_xydata(), vline)\n        npt.assert_array_equal(ax.lines[1].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.axes[(0, 0)].lines[(- 1)].get_xydata(), vline)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_color() == color)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_linestyle() == linestyle)", "masked_code": "def test_refline(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.refline()\n    for ax in g.axes.flat:\n        assert (not ax.lines)\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy)\n    for ax in g.axes.flat:\n        assert (ax.lines[0].get_color() == '.5')\n        assert (ax.lines[0].get_linestyle() == '--')\n        assert (len(ax.lines) == 2)\n        npt.assert_array_equal(ax.lines[0].get_xydata(), vline)\n        npt.assert_array_equal(ax.lines[1].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.axes[(0, 0)].lines[(- 1)].get_xydata(), vline)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_color() == '???')\n    assert (g.axes[(0, 0)].lines[(- 1)].get_linestyle() == linestyle)", "ground_truth": "color", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_76", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_refline", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_refline(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.refline()\n    for ax in g.axes.flat:\n        assert (not ax.lines)\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy)\n    for ax in g.axes.flat:\n        assert (ax.lines[0].get_color() == '.5')\n        assert (ax.lines[0].get_linestyle() == '--')\n        assert (len(ax.lines) == 2)\n        npt.assert_array_equal(ax.lines[0].get_xydata(), vline)\n        npt.assert_array_equal(ax.lines[1].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.axes[(0, 0)].lines[(- 1)].get_xydata(), vline)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_color() == color)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_linestyle() == linestyle)", "masked_code": "def test_refline(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.refline()\n    for ax in g.axes.flat:\n        assert (not ax.lines)\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy)\n    for ax in g.axes.flat:\n        assert (ax.lines[0].get_color() == '.5')\n        assert (ax.lines[0].get_linestyle() == '--')\n        assert (len(ax.lines) == 2)\n        npt.assert_array_equal(ax.lines[0].get_xydata(), vline)\n        npt.assert_array_equal(ax.lines[1].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.axes[(0, 0)].lines[(- 1)].get_xydata(), vline)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_color() == color)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_linestyle() == '???')", "ground_truth": "linestyle", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_77", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_refline", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_refline(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.refline()\n    for ax in g.axes.flat:\n        assert (not ax.lines)\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy)\n    for ax in g.axes.flat:\n        assert (ax.lines[0].get_color() == '.5')\n        assert (ax.lines[0].get_linestyle() == '--')\n        assert (len(ax.lines) == 2)\n        npt.assert_array_equal(ax.lines[0].get_xydata(), vline)\n        npt.assert_array_equal(ax.lines[1].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.axes[(0, 0)].lines[(- 1)].get_xydata(), vline)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_color() == color)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_linestyle() == linestyle)", "masked_code": "def test_refline(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.refline()\n    for ax in g.axes.flat:\n        assert (not ax.lines)\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy)\n    for ax in g.axes.flat:\n        assert (ax.lines[0].get_color() == '???')\n        assert (ax.lines[0].get_linestyle() == '--')\n        assert (len(ax.lines) == 2)\n        npt.assert_array_equal(ax.lines[0].get_xydata(), vline)\n        npt.assert_array_equal(ax.lines[1].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.axes[(0, 0)].lines[(- 1)].get_xydata(), vline)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_color() == color)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_linestyle() == linestyle)", "ground_truth": "'.5'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_78", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_refline", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_refline(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.refline()\n    for ax in g.axes.flat:\n        assert (not ax.lines)\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy)\n    for ax in g.axes.flat:\n        assert (ax.lines[0].get_color() == '.5')\n        assert (ax.lines[0].get_linestyle() == '--')\n        assert (len(ax.lines) == 2)\n        npt.assert_array_equal(ax.lines[0].get_xydata(), vline)\n        npt.assert_array_equal(ax.lines[1].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.axes[(0, 0)].lines[(- 1)].get_xydata(), vline)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_color() == color)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_linestyle() == linestyle)", "masked_code": "def test_refline(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    g.refline()\n    for ax in g.axes.flat:\n        assert (not ax.lines)\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy)\n    for ax in g.axes.flat:\n        assert (ax.lines[0].get_color() == '.5')\n        assert (ax.lines[0].get_linestyle() == '???')\n        assert (len(ax.lines) == 2)\n        npt.assert_array_equal(ax.lines[0].get_xydata(), vline)\n        npt.assert_array_equal(ax.lines[1].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.axes[(0, 0)].lines[(- 1)].get_xydata(), vline)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_color() == color)\n    assert (g.axes[(0, 0)].lines[(- 1)].get_linestyle() == linestyle)", "ground_truth": "'--'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_79", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_apply", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_apply(self, long_df):\n\n    def f(grid, color):\n        grid.figure.set_facecolor(color)\n    color = (0.1, 0.6, 0.3, 0.9)\n    g = ag.FacetGrid(long_df)\n    res = g.apply(f, color)\n    assert (res is g)\n    assert (g.figure.get_facecolor() == color)", "masked_code": "def test_apply(self, long_df):\n\n    def f(grid, color):\n        grid.figure.set_facecolor(color)\n    color = (0.1, 0.6, 0.3, 0.9)\n    g = ag.FacetGrid(long_df)\n    res = g.apply(f, color)\n    assert (res is g)\n    assert (g.figure.get_facecolor() == '???')", "ground_truth": "color", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_80", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_pipe", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_pipe(self, long_df):\n\n    def f(grid, color):\n        grid.figure.set_facecolor(color)\n        return color\n    color = (0.1, 0.6, 0.3, 0.9)\n    g = ag.FacetGrid(long_df)\n    res = g.pipe(f, color)\n    assert (res == color)\n    assert (g.figure.get_facecolor() == color)", "masked_code": "def test_pipe(self, long_df):\n\n    def f(grid, color):\n        grid.figure.set_facecolor(color)\n        return color\n    color = (0.1, 0.6, 0.3, 0.9)\n    g = ag.FacetGrid(long_df)\n    res = g.pipe(f, color)\n    assert (res == color)\n    assert (g.figure.get_facecolor() == '???')", "ground_truth": "color", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_81", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_tick_params", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_tick_params(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    color = 'blue'\n    pad = 3\n    g.tick_params(pad=pad, color=color)\n    for ax in g.axes.flat:\n        for axis in ['xaxis', 'yaxis']:\n            for tick in getattr(ax, axis).get_major_ticks():\n                assert mpl.colors.same_color(tick.tick1line.get_color(), color)\n                assert mpl.colors.same_color(tick.tick2line.get_color(), color)\n                assert (tick.get_pad() == pad)", "masked_code": "def test_tick_params(self):\n    g = ag.FacetGrid(self.df, row='a', col='b')\n    color = 'blue'\n    pad = 3\n    g.tick_params(pad=pad, color=color)\n    for ax in g.axes.flat:\n        for axis in ['xaxis', 'yaxis']:\n            for tick in getattr(ax, axis).get_major_ticks():\n                assert mpl.colors.same_color(tick.tick1line.get_color(), color)\n                assert mpl.colors.same_color(tick.tick2line.get_color(), color)\n                assert (tick.get_pad() == '???')", "ground_truth": "pad", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_82", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestFacetGrid", "funcname": "test_data_interchange", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "@pytest.mark.skipif(condition=(not hasattr(pd.api, 'interchange')), reason='Tests behavior assuming support for dataframe interchange')\ndef test_data_interchange(self, mock_long_df, long_df):\n    g = ag.FacetGrid(mock_long_df, col='a', row='b')\n    g.map(scatterplot, 'x', 'y')\n    assert (g.axes.shape == (long_df['b'].nunique(), long_df['a'].nunique()))\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == 1)", "masked_code": "@pytest.mark.skipif(condition=(not hasattr(pd.api, 'interchange')), reason='Tests behavior assuming support for dataframe interchange')\ndef test_data_interchange(self, mock_long_df, long_df):\n    g = ag.FacetGrid(mock_long_df, col='a', row='b')\n    g.map(scatterplot, 'x', 'y')\n    assert (g.axes.shape == '???')\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == 1)", "ground_truth": "(long_df['b'].nunique(), long_df['a'].nunique())", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_83", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_default_axes", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_default_axes(self):\n    g = ag.PairGrid(self.df)\n    assert (g.axes.shape == (3, 3))\n    assert (g.x_vars == ['x', 'y', 'z'])\n    assert (g.y_vars == ['x', 'y', 'z'])\n    assert g.square_grid", "masked_code": "def test_default_axes(self):\n    g = ag.PairGrid(self.df)\n    assert (g.axes.shape == '???')\n    assert (g.x_vars == ['x', 'y', 'z'])\n    assert (g.y_vars == ['x', 'y', 'z'])\n    assert g.square_grid", "ground_truth": "(3, 3)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_84", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_default_axes", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_default_axes(self):\n    g = ag.PairGrid(self.df)\n    assert (g.axes.shape == (3, 3))\n    assert (g.x_vars == ['x', 'y', 'z'])\n    assert (g.y_vars == ['x', 'y', 'z'])\n    assert g.square_grid", "masked_code": "def test_default_axes(self):\n    g = ag.PairGrid(self.df)\n    assert (g.axes.shape == (3, 3))\n    assert (g.x_vars == '???')\n    assert (g.y_vars == ['x', 'y', 'z'])\n    assert g.square_grid", "ground_truth": "['x', 'y', 'z']", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_85", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_default_axes", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_default_axes(self):\n    g = ag.PairGrid(self.df)\n    assert (g.axes.shape == (3, 3))\n    assert (g.x_vars == ['x', 'y', 'z'])\n    assert (g.y_vars == ['x', 'y', 'z'])\n    assert g.square_grid", "masked_code": "def test_default_axes(self):\n    g = ag.PairGrid(self.df)\n    assert (g.axes.shape == (3, 3))\n    assert (g.x_vars == ['x', 'y', 'z'])\n    assert (g.y_vars == '???')\n    assert g.square_grid", "ground_truth": "['x', 'y', 'z']", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_86", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_specific_square_axes", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "@pytest.mark.parametrize('vars', [['z', 'x'], np.array(['z', 'x'])])\ndef test_specific_square_axes(self, vars):\n    g = ag.PairGrid(self.df, vars=vars)\n    assert (g.axes.shape == (len(vars), len(vars)))\n    assert (g.x_vars == list(vars))\n    assert (g.y_vars == list(vars))\n    assert g.square_grid", "masked_code": "@pytest.mark.parametrize('vars', [['z', 'x'], np.array(['z', 'x'])])\ndef test_specific_square_axes(self, vars):\n    g = ag.PairGrid(self.df, vars=vars)\n    assert (g.axes.shape == '???')\n    assert (g.x_vars == list(vars))\n    assert (g.y_vars == list(vars))\n    assert g.square_grid", "ground_truth": "(len(vars), len(vars))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_87", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_specific_square_axes", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "@pytest.mark.parametrize('vars', [['z', 'x'], np.array(['z', 'x'])])\ndef test_specific_square_axes(self, vars):\n    g = ag.PairGrid(self.df, vars=vars)\n    assert (g.axes.shape == (len(vars), len(vars)))\n    assert (g.x_vars == list(vars))\n    assert (g.y_vars == list(vars))\n    assert g.square_grid", "masked_code": "@pytest.mark.parametrize('vars', [['z', 'x'], np.array(['z', 'x'])])\ndef test_specific_square_axes(self, vars):\n    g = ag.PairGrid(self.df, vars=vars)\n    assert (g.axes.shape == (len(vars), len(vars)))\n    assert (g.x_vars == '???')\n    assert (g.y_vars == list(vars))\n    assert g.square_grid", "ground_truth": "list(vars)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_88", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_specific_square_axes", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "@pytest.mark.parametrize('vars', [['z', 'x'], np.array(['z', 'x'])])\ndef test_specific_square_axes(self, vars):\n    g = ag.PairGrid(self.df, vars=vars)\n    assert (g.axes.shape == (len(vars), len(vars)))\n    assert (g.x_vars == list(vars))\n    assert (g.y_vars == list(vars))\n    assert g.square_grid", "masked_code": "@pytest.mark.parametrize('vars', [['z', 'x'], np.array(['z', 'x'])])\ndef test_specific_square_axes(self, vars):\n    g = ag.PairGrid(self.df, vars=vars)\n    assert (g.axes.shape == (len(vars), len(vars)))\n    assert (g.x_vars == list(vars))\n    assert (g.y_vars == '???')\n    assert g.square_grid", "ground_truth": "list(vars)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_89", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_specific_nonsquare_axes", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "@pytest.mark.parametrize('x_vars, y_vars', [(['x', 'y'], ['z', 'y', 'x']), (['x', 'y'], 'z'), (np.array(['x', 'y']), np.array(['z', 'y', 'x']))])\ndef test_specific_nonsquare_axes(self, x_vars, y_vars):\n    g = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    assert (g.axes.shape == (len(y_vars), len(x_vars)))\n    assert (g.x_vars == list(x_vars))\n    assert (g.y_vars == list(y_vars))\n    assert (not g.square_grid)", "masked_code": "@pytest.mark.parametrize('x_vars, y_vars', [(['x', 'y'], ['z', 'y', 'x']), (['x', 'y'], 'z'), (np.array(['x', 'y']), np.array(['z', 'y', 'x']))])\ndef test_specific_nonsquare_axes(self, x_vars, y_vars):\n    g = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    assert (g.axes.shape == '???')\n    assert (g.x_vars == list(x_vars))\n    assert (g.y_vars == list(y_vars))\n    assert (not g.square_grid)", "ground_truth": "(len(y_vars), len(x_vars))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_90", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_specific_nonsquare_axes", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "@pytest.mark.parametrize('x_vars, y_vars', [(['x', 'y'], ['z', 'y', 'x']), (['x', 'y'], 'z'), (np.array(['x', 'y']), np.array(['z', 'y', 'x']))])\ndef test_specific_nonsquare_axes(self, x_vars, y_vars):\n    g = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    assert (g.axes.shape == (len(y_vars), len(x_vars)))\n    assert (g.x_vars == list(x_vars))\n    assert (g.y_vars == list(y_vars))\n    assert (not g.square_grid)", "masked_code": "@pytest.mark.parametrize('x_vars, y_vars', [(['x', 'y'], ['z', 'y', 'x']), (['x', 'y'], 'z'), (np.array(['x', 'y']), np.array(['z', 'y', 'x']))])\ndef test_specific_nonsquare_axes(self, x_vars, y_vars):\n    g = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    assert (g.axes.shape == (len(y_vars), len(x_vars)))\n    assert (g.x_vars == '???')\n    assert (g.y_vars == list(y_vars))\n    assert (not g.square_grid)", "ground_truth": "list(x_vars)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_91", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_specific_nonsquare_axes", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "@pytest.mark.parametrize('x_vars, y_vars', [(['x', 'y'], ['z', 'y', 'x']), (['x', 'y'], 'z'), (np.array(['x', 'y']), np.array(['z', 'y', 'x']))])\ndef test_specific_nonsquare_axes(self, x_vars, y_vars):\n    g = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    assert (g.axes.shape == (len(y_vars), len(x_vars)))\n    assert (g.x_vars == list(x_vars))\n    assert (g.y_vars == list(y_vars))\n    assert (not g.square_grid)", "masked_code": "@pytest.mark.parametrize('x_vars, y_vars', [(['x', 'y'], ['z', 'y', 'x']), (['x', 'y'], 'z'), (np.array(['x', 'y']), np.array(['z', 'y', 'x']))])\ndef test_specific_nonsquare_axes(self, x_vars, y_vars):\n    g = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    assert (g.axes.shape == (len(y_vars), len(x_vars)))\n    assert (g.x_vars == list(x_vars))\n    assert (g.y_vars == '???')\n    assert (not g.square_grid)", "ground_truth": "list(y_vars)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_92", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_corner", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_corner(self):\n    plot_vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n    corner_size = sum(((i + 1) for i in range(len(plot_vars))))\n    assert (len(g.figure.axes) == corner_size)\n    g.map_diag(plt.hist)\n    assert (len(g.figure.axes) == (corner_size + len(plot_vars)))\n    for ax in np.diag(g.axes):\n        assert (not ax.yaxis.get_visible())\n    plot_vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n    g.map(scatterplot)\n    assert (len(g.figure.axes) == corner_size)\n    assert (g.axes[(0, 0)].get_ylabel() == 'x')", "masked_code": "def test_corner(self):\n    plot_vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n    corner_size = sum(((i + 1) for i in range(len(plot_vars))))\n    assert (len(g.figure.axes) == '???')\n    g.map_diag(plt.hist)\n    assert (len(g.figure.axes) == (corner_size + len(plot_vars)))\n    for ax in np.diag(g.axes):\n        assert (not ax.yaxis.get_visible())\n    plot_vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n    g.map(scatterplot)\n    assert (len(g.figure.axes) == corner_size)\n    assert (g.axes[(0, 0)].get_ylabel() == 'x')", "ground_truth": "corner_size", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_93", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_corner", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_corner(self):\n    plot_vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n    corner_size = sum(((i + 1) for i in range(len(plot_vars))))\n    assert (len(g.figure.axes) == corner_size)\n    g.map_diag(plt.hist)\n    assert (len(g.figure.axes) == (corner_size + len(plot_vars)))\n    for ax in np.diag(g.axes):\n        assert (not ax.yaxis.get_visible())\n    plot_vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n    g.map(scatterplot)\n    assert (len(g.figure.axes) == corner_size)\n    assert (g.axes[(0, 0)].get_ylabel() == 'x')", "masked_code": "def test_corner(self):\n    plot_vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n    corner_size = sum(((i + 1) for i in range(len(plot_vars))))\n    assert (len(g.figure.axes) == corner_size)\n    g.map_diag(plt.hist)\n    assert (len(g.figure.axes) == '???')\n    for ax in np.diag(g.axes):\n        assert (not ax.yaxis.get_visible())\n    plot_vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n    g.map(scatterplot)\n    assert (len(g.figure.axes) == corner_size)\n    assert (g.axes[(0, 0)].get_ylabel() == 'x')", "ground_truth": "(corner_size + len(plot_vars))", "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_94", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_corner", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_corner(self):\n    plot_vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n    corner_size = sum(((i + 1) for i in range(len(plot_vars))))\n    assert (len(g.figure.axes) == corner_size)\n    g.map_diag(plt.hist)\n    assert (len(g.figure.axes) == (corner_size + len(plot_vars)))\n    for ax in np.diag(g.axes):\n        assert (not ax.yaxis.get_visible())\n    plot_vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n    g.map(scatterplot)\n    assert (len(g.figure.axes) == corner_size)\n    assert (g.axes[(0, 0)].get_ylabel() == 'x')", "masked_code": "def test_corner(self):\n    plot_vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n    corner_size = sum(((i + 1) for i in range(len(plot_vars))))\n    assert (len(g.figure.axes) == corner_size)\n    g.map_diag(plt.hist)\n    assert (len(g.figure.axes) == (corner_size + len(plot_vars)))\n    for ax in np.diag(g.axes):\n        assert (not ax.yaxis.get_visible())\n    plot_vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df, vars=plot_vars, corner=True)\n    g.map(scatterplot)\n    assert (len(g.figure.axes) == '???')\n    assert (g.axes[(0, 0)].get_ylabel() == 'x')", "ground_truth": "corner_size", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_95", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag(self):\n    g = ag.PairGrid(self.df)\n    g.map_diag(plt.hist)\n    for (var, ax) in zip(g.diag_vars, g.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == 30)\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist, histtype='step')\n    for ax in g.diag_axes:\n        for ptch in ax.patches:\n            assert (not ptch.fill)", "masked_code": "def test_map_diag(self):\n    g = ag.PairGrid(self.df)\n    g.map_diag(plt.hist)\n    for (var, ax) in zip(g.diag_vars, g.diag_axes):\n        assert (len(ax.patches) == '???')\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == 30)\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist, histtype='step')\n    for ax in g.diag_axes:\n        for ptch in ax.patches:\n            assert (not ptch.fill)", "ground_truth": "10", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_96", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag(self):\n    g = ag.PairGrid(self.df)\n    g.map_diag(plt.hist)\n    for (var, ax) in zip(g.diag_vars, g.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == 30)\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist, histtype='step')\n    for ax in g.diag_axes:\n        for ptch in ax.patches:\n            assert (not ptch.fill)", "masked_code": "def test_map_diag(self):\n    g = ag.PairGrid(self.df)\n    g.map_diag(plt.hist)\n    for (var, ax) in zip(g.diag_vars, g.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == '???')\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == 30)\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist, histtype='step')\n    for ax in g.diag_axes:\n        for ptch in ax.patches:\n            assert (not ptch.fill)", "ground_truth": "self.df[var].min()", "quality_analysis": {"complexity_score": 9, "left_complexity": 6, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_97", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag(self):\n    g = ag.PairGrid(self.df)\n    g.map_diag(plt.hist)\n    for (var, ax) in zip(g.diag_vars, g.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == 30)\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist, histtype='step')\n    for ax in g.diag_axes:\n        for ptch in ax.patches:\n            assert (not ptch.fill)", "masked_code": "def test_map_diag(self):\n    g = ag.PairGrid(self.df)\n    g.map_diag(plt.hist)\n    for (var, ax) in zip(g.diag_vars, g.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == '???')\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist, histtype='step')\n    for ax in g.diag_axes:\n        for ptch in ax.patches:\n            assert (not ptch.fill)", "ground_truth": "30", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_98", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag_rectangular", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "masked_code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == '???')\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "ground_truth": "(set(x_vars) & set(y_vars))", "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_99", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag_rectangular", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "masked_code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == '???')\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "ground_truth": "(set(x_vars) & set(y_vars))", "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_100", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag_rectangular", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "masked_code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == '???')\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "ground_truth": "(set(x_vars) & set(y_vars))", "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_101", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag_rectangular", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "masked_code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == '???')\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "ground_truth": "10", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_102", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag_rectangular", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "masked_code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == '???')\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "ground_truth": "self.df[var].min()", "quality_analysis": {"complexity_score": 9, "left_complexity": 6, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_103", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag_rectangular", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "masked_code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == '???')\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "ground_truth": "30", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_104", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag_rectangular", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "masked_code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == '???')\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "ground_truth": "10", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_105", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag_rectangular", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "masked_code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == '???')\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "ground_truth": "self.df[var].min()", "quality_analysis": {"complexity_score": 9, "left_complexity": 6, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_106", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag_rectangular", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "masked_code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == '???')\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "ground_truth": "diag_ax.bbox.bounds", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_107", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag_rectangular", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "masked_code": "def test_map_diag_rectangular(self):\n    x_vars = ['x', 'y']\n    y_vars = ['x', 'z', 'y']\n    g1 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g1.map_diag(plt.hist)\n    g1.map_offdiag(plt.scatter)\n    assert (set(g1.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g1.diag_vars, g1.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g1.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g1.diag_axes[j]\n                assert (ax.bbox.bounds == diag_ax.bbox.bounds)\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])\n    g2 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars, hue='a')\n    g2.map_diag(plt.hist)\n    g2.map_offdiag(plt.scatter)\n    assert (set(g2.diag_vars) == (set(x_vars) & set(y_vars)))\n    for ax in g2.diag_axes:\n        assert (len(ax.patches) == 30)\n    x_vars = ['x', 'y', 'z']\n    y_vars = ['x', 'z']\n    g3 = ag.PairGrid(self.df, x_vars=x_vars, y_vars=y_vars)\n    g3.map_diag(plt.hist)\n    g3.map_offdiag(plt.scatter)\n    assert (set(g3.diag_vars) == (set(x_vars) & set(y_vars)))\n    for (var, ax) in zip(g3.diag_vars, g3.diag_axes):\n        assert (len(ax.patches) == 10)\n        assert (pytest.approx(ax.patches[0].get_x()) == self.df[var].min())\n    for (j, x_var) in enumerate(x_vars):\n        for (i, y_var) in enumerate(y_vars):\n            ax = g3.axes[(i, j)]\n            if (x_var == y_var):\n                diag_ax = g3.diag_axes[i]\n                assert (ax.bbox.bounds == '???')\n            else:\n                (x, y) = ax.collections[0].get_offsets().T\n                assert_array_equal(x, self.df[x_var])\n                assert_array_equal(y, self.df[y_var])", "ground_truth": "diag_ax.bbox.bounds", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_108", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag_and_offdiag", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag_and_offdiag(self):\n    vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df)\n    g.map_offdiag(plt.scatter)\n    g.map_diag(plt.hist)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == 10)\n    for (i, j) in zip(*np.triu_indices_from(g.axes, 1)):\n        ax = g.axes[(i, j)]\n        x_in = self.df[vars[j]]\n        y_in = self.df[vars[i]]\n        (x_out, y_out) = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x_in, x_out)\n        npt.assert_array_equal(y_in, y_out)\n    for (i, j) in zip(*np.tril_indices_from(g.axes, (- 1))):\n        ax = g.axes[(i, j)]\n        x_in = self.df[vars[j]]\n        y_in = self.df[vars[i]]\n        (x_out, y_out) = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x_in, x_out)\n        npt.assert_array_equal(y_in, y_out)\n    for (i, j) in zip(*np.diag_indices_from(g.axes)):\n        ax = g.axes[(i, j)]\n        assert (len(ax.collections) == 0)", "masked_code": "def test_map_diag_and_offdiag(self):\n    vars = ['x', 'y', 'z']\n    g = ag.PairGrid(self.df)\n    g.map_offdiag(plt.scatter)\n    g.map_diag(plt.hist)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == '???')\n    for (i, j) in zip(*np.triu_indices_from(g.axes, 1)):\n        ax = g.axes[(i, j)]\n        x_in = self.df[vars[j]]\n        y_in = self.df[vars[i]]\n        (x_out, y_out) = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x_in, x_out)\n        npt.assert_array_equal(y_in, y_out)\n    for (i, j) in zip(*np.tril_indices_from(g.axes, (- 1))):\n        ax = g.axes[(i, j)]\n        x_in = self.df[vars[j]]\n        y_in = self.df[vars[i]]\n        (x_out, y_out) = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x_in, x_out)\n        npt.assert_array_equal(y_in, y_out)\n    for (i, j) in zip(*np.diag_indices_from(g.axes)):\n        ax = g.axes[(i, j)]\n        assert (len(ax.collections) == 0)", "ground_truth": "10", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_109", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_diag_sharey", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_diag_sharey(self):\n    g = ag.PairGrid(self.df, diag_sharey=True)\n    g.map_diag(kdeplot)\n    for ax in g.diag_axes[1:]:\n        assert (ax.get_ylim() == g.diag_axes[0].get_ylim())", "masked_code": "def test_diag_sharey(self):\n    g = ag.PairGrid(self.df, diag_sharey=True)\n    g.map_diag(kdeplot)\n    for ax in g.diag_axes[1:]:\n        assert (ax.get_ylim() == '???')", "ground_truth": "g.diag_axes[0].get_ylim()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_110", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag_matplotlib", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag_matplotlib(self):\n    bins = 10\n    g = ag.PairGrid(self.df)\n    g.map_diag(plt.hist, bins=bins)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == bins)\n    levels = len(self.df['a'].unique())\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist, bins=bins)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == (bins * levels))", "masked_code": "def test_map_diag_matplotlib(self):\n    bins = 10\n    g = ag.PairGrid(self.df)\n    g.map_diag(plt.hist, bins=bins)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == '???')\n    levels = len(self.df['a'].unique())\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist, bins=bins)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == (bins * levels))", "ground_truth": "bins", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_111", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_map_diag_matplotlib", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_map_diag_matplotlib(self):\n    bins = 10\n    g = ag.PairGrid(self.df)\n    g.map_diag(plt.hist, bins=bins)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == bins)\n    levels = len(self.df['a'].unique())\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist, bins=bins)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == (bins * levels))", "masked_code": "def test_map_diag_matplotlib(self):\n    bins = 10\n    g = ag.PairGrid(self.df)\n    g.map_diag(plt.hist, bins=bins)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == bins)\n    levels = len(self.df['a'].unique())\n    g = ag.PairGrid(self.df, hue='a')\n    g.map_diag(plt.hist, bins=bins)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) == '???')", "ground_truth": "(bins * levels)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_112", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_palette", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_palette(self):\n    rcmod.set()\n    g = ag.PairGrid(self.df, hue='a')\n    assert (g.palette == color_palette(n_colors=len(self.df.a.unique())))\n    g = ag.PairGrid(self.df, hue='b')\n    assert (g.palette == color_palette('husl', len(self.df.b.unique())))\n    g = ag.PairGrid(self.df, hue='a', palette='Set2')\n    assert (g.palette == color_palette('Set2', len(self.df.a.unique())))\n    dict_pal = dict(a='red', b='green', c='blue')\n    list_pal = color_palette(['red', 'green', 'blue'])\n    g = ag.PairGrid(self.df, hue='a', palette=dict_pal)\n    assert (g.palette == list_pal)\n    list_pal = color_palette(['blue', 'red', 'green'])\n    g = ag.PairGrid(self.df, hue='a', hue_order=list('cab'), palette=dict_pal)\n    assert (g.palette == list_pal)", "masked_code": "def test_palette(self):\n    rcmod.set()\n    g = ag.PairGrid(self.df, hue='a')\n    assert (g.palette == '???')\n    g = ag.PairGrid(self.df, hue='b')\n    assert (g.palette == color_palette('husl', len(self.df.b.unique())))\n    g = ag.PairGrid(self.df, hue='a', palette='Set2')\n    assert (g.palette == color_palette('Set2', len(self.df.a.unique())))\n    dict_pal = dict(a='red', b='green', c='blue')\n    list_pal = color_palette(['red', 'green', 'blue'])\n    g = ag.PairGrid(self.df, hue='a', palette=dict_pal)\n    assert (g.palette == list_pal)\n    list_pal = color_palette(['blue', 'red', 'green'])\n    g = ag.PairGrid(self.df, hue='a', hue_order=list('cab'), palette=dict_pal)\n    assert (g.palette == list_pal)", "ground_truth": "color_palette(n_colors=len(self.df.a.unique()))", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_113", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_palette", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_palette(self):\n    rcmod.set()\n    g = ag.PairGrid(self.df, hue='a')\n    assert (g.palette == color_palette(n_colors=len(self.df.a.unique())))\n    g = ag.PairGrid(self.df, hue='b')\n    assert (g.palette == color_palette('husl', len(self.df.b.unique())))\n    g = ag.PairGrid(self.df, hue='a', palette='Set2')\n    assert (g.palette == color_palette('Set2', len(self.df.a.unique())))\n    dict_pal = dict(a='red', b='green', c='blue')\n    list_pal = color_palette(['red', 'green', 'blue'])\n    g = ag.PairGrid(self.df, hue='a', palette=dict_pal)\n    assert (g.palette == list_pal)\n    list_pal = color_palette(['blue', 'red', 'green'])\n    g = ag.PairGrid(self.df, hue='a', hue_order=list('cab'), palette=dict_pal)\n    assert (g.palette == list_pal)", "masked_code": "def test_palette(self):\n    rcmod.set()\n    g = ag.PairGrid(self.df, hue='a')\n    assert (g.palette == color_palette(n_colors=len(self.df.a.unique())))\n    g = ag.PairGrid(self.df, hue='b')\n    assert (g.palette == '???')\n    g = ag.PairGrid(self.df, hue='a', palette='Set2')\n    assert (g.palette == color_palette('Set2', len(self.df.a.unique())))\n    dict_pal = dict(a='red', b='green', c='blue')\n    list_pal = color_palette(['red', 'green', 'blue'])\n    g = ag.PairGrid(self.df, hue='a', palette=dict_pal)\n    assert (g.palette == list_pal)\n    list_pal = color_palette(['blue', 'red', 'green'])\n    g = ag.PairGrid(self.df, hue='a', hue_order=list('cab'), palette=dict_pal)\n    assert (g.palette == list_pal)", "ground_truth": "color_palette('husl', len(self.df.b.unique()))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_114", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_palette", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_palette(self):\n    rcmod.set()\n    g = ag.PairGrid(self.df, hue='a')\n    assert (g.palette == color_palette(n_colors=len(self.df.a.unique())))\n    g = ag.PairGrid(self.df, hue='b')\n    assert (g.palette == color_palette('husl', len(self.df.b.unique())))\n    g = ag.PairGrid(self.df, hue='a', palette='Set2')\n    assert (g.palette == color_palette('Set2', len(self.df.a.unique())))\n    dict_pal = dict(a='red', b='green', c='blue')\n    list_pal = color_palette(['red', 'green', 'blue'])\n    g = ag.PairGrid(self.df, hue='a', palette=dict_pal)\n    assert (g.palette == list_pal)\n    list_pal = color_palette(['blue', 'red', 'green'])\n    g = ag.PairGrid(self.df, hue='a', hue_order=list('cab'), palette=dict_pal)\n    assert (g.palette == list_pal)", "masked_code": "def test_palette(self):\n    rcmod.set()\n    g = ag.PairGrid(self.df, hue='a')\n    assert (g.palette == color_palette(n_colors=len(self.df.a.unique())))\n    g = ag.PairGrid(self.df, hue='b')\n    assert (g.palette == color_palette('husl', len(self.df.b.unique())))\n    g = ag.PairGrid(self.df, hue='a', palette='Set2')\n    assert (g.palette == '???')\n    dict_pal = dict(a='red', b='green', c='blue')\n    list_pal = color_palette(['red', 'green', 'blue'])\n    g = ag.PairGrid(self.df, hue='a', palette=dict_pal)\n    assert (g.palette == list_pal)\n    list_pal = color_palette(['blue', 'red', 'green'])\n    g = ag.PairGrid(self.df, hue='a', hue_order=list('cab'), palette=dict_pal)\n    assert (g.palette == list_pal)", "ground_truth": "color_palette('Set2', len(self.df.a.unique()))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_115", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_palette", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_palette(self):\n    rcmod.set()\n    g = ag.PairGrid(self.df, hue='a')\n    assert (g.palette == color_palette(n_colors=len(self.df.a.unique())))\n    g = ag.PairGrid(self.df, hue='b')\n    assert (g.palette == color_palette('husl', len(self.df.b.unique())))\n    g = ag.PairGrid(self.df, hue='a', palette='Set2')\n    assert (g.palette == color_palette('Set2', len(self.df.a.unique())))\n    dict_pal = dict(a='red', b='green', c='blue')\n    list_pal = color_palette(['red', 'green', 'blue'])\n    g = ag.PairGrid(self.df, hue='a', palette=dict_pal)\n    assert (g.palette == list_pal)\n    list_pal = color_palette(['blue', 'red', 'green'])\n    g = ag.PairGrid(self.df, hue='a', hue_order=list('cab'), palette=dict_pal)\n    assert (g.palette == list_pal)", "masked_code": "def test_palette(self):\n    rcmod.set()\n    g = ag.PairGrid(self.df, hue='a')\n    assert (g.palette == color_palette(n_colors=len(self.df.a.unique())))\n    g = ag.PairGrid(self.df, hue='b')\n    assert (g.palette == color_palette('husl', len(self.df.b.unique())))\n    g = ag.PairGrid(self.df, hue='a', palette='Set2')\n    assert (g.palette == color_palette('Set2', len(self.df.a.unique())))\n    dict_pal = dict(a='red', b='green', c='blue')\n    list_pal = color_palette(['red', 'green', 'blue'])\n    g = ag.PairGrid(self.df, hue='a', palette=dict_pal)\n    assert (g.palette == '???')\n    list_pal = color_palette(['blue', 'red', 'green'])\n    g = ag.PairGrid(self.df, hue='a', hue_order=list('cab'), palette=dict_pal)\n    assert (g.palette == list_pal)", "ground_truth": "list_pal", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_116", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_palette", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_palette(self):\n    rcmod.set()\n    g = ag.PairGrid(self.df, hue='a')\n    assert (g.palette == color_palette(n_colors=len(self.df.a.unique())))\n    g = ag.PairGrid(self.df, hue='b')\n    assert (g.palette == color_palette('husl', len(self.df.b.unique())))\n    g = ag.PairGrid(self.df, hue='a', palette='Set2')\n    assert (g.palette == color_palette('Set2', len(self.df.a.unique())))\n    dict_pal = dict(a='red', b='green', c='blue')\n    list_pal = color_palette(['red', 'green', 'blue'])\n    g = ag.PairGrid(self.df, hue='a', palette=dict_pal)\n    assert (g.palette == list_pal)\n    list_pal = color_palette(['blue', 'red', 'green'])\n    g = ag.PairGrid(self.df, hue='a', hue_order=list('cab'), palette=dict_pal)\n    assert (g.palette == list_pal)", "masked_code": "def test_palette(self):\n    rcmod.set()\n    g = ag.PairGrid(self.df, hue='a')\n    assert (g.palette == color_palette(n_colors=len(self.df.a.unique())))\n    g = ag.PairGrid(self.df, hue='b')\n    assert (g.palette == color_palette('husl', len(self.df.b.unique())))\n    g = ag.PairGrid(self.df, hue='a', palette='Set2')\n    assert (g.palette == color_palette('Set2', len(self.df.a.unique())))\n    dict_pal = dict(a='red', b='green', c='blue')\n    list_pal = color_palette(['red', 'green', 'blue'])\n    g = ag.PairGrid(self.df, hue='a', palette=dict_pal)\n    assert (g.palette == list_pal)\n    list_pal = color_palette(['blue', 'red', 'green'])\n    g = ag.PairGrid(self.df, hue='a', hue_order=list('cab'), palette=dict_pal)\n    assert (g.palette == '???')", "ground_truth": "list_pal", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_117", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_hue_kws", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_hue_kws(self):\n    kws = dict(marker=['o', 's', 'd', '+'])\n    g = ag.PairGrid(self.df, hue='a', hue_kws=kws)\n    g.map(plt.plot)\n    for (line, marker) in zip(g.axes[(0, 0)].lines, kws['marker']):\n        assert (line.get_marker() == marker)\n    g = ag.PairGrid(self.df, hue='a', hue_kws=kws, hue_order=list('dcab'))\n    g.map(plt.plot)\n    for (line, marker) in zip(g.axes[(0, 0)].lines, kws['marker']):\n        assert (line.get_marker() == marker)", "masked_code": "def test_hue_kws(self):\n    kws = dict(marker=['o', 's', 'd', '+'])\n    g = ag.PairGrid(self.df, hue='a', hue_kws=kws)\n    g.map(plt.plot)\n    for (line, marker) in zip(g.axes[(0, 0)].lines, kws['marker']):\n        assert (line.get_marker() == '???')\n    g = ag.PairGrid(self.df, hue='a', hue_kws=kws, hue_order=list('dcab'))\n    g.map(plt.plot)\n    for (line, marker) in zip(g.axes[(0, 0)].lines, kws['marker']):\n        assert (line.get_marker() == marker)", "ground_truth": "marker", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_118", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_hue_kws", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_hue_kws(self):\n    kws = dict(marker=['o', 's', 'd', '+'])\n    g = ag.PairGrid(self.df, hue='a', hue_kws=kws)\n    g.map(plt.plot)\n    for (line, marker) in zip(g.axes[(0, 0)].lines, kws['marker']):\n        assert (line.get_marker() == marker)\n    g = ag.PairGrid(self.df, hue='a', hue_kws=kws, hue_order=list('dcab'))\n    g.map(plt.plot)\n    for (line, marker) in zip(g.axes[(0, 0)].lines, kws['marker']):\n        assert (line.get_marker() == marker)", "masked_code": "def test_hue_kws(self):\n    kws = dict(marker=['o', 's', 'd', '+'])\n    g = ag.PairGrid(self.df, hue='a', hue_kws=kws)\n    g.map(plt.plot)\n    for (line, marker) in zip(g.axes[(0, 0)].lines, kws['marker']):\n        assert (line.get_marker() == marker)\n    g = ag.PairGrid(self.df, hue='a', hue_kws=kws, hue_order=list('dcab'))\n    g.map(plt.plot)\n    for (line, marker) in zip(g.axes[(0, 0)].lines, kws['marker']):\n        assert (line.get_marker() == '???')", "ground_truth": "marker", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_119", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_hue_in_map", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_hue_in_map(self, long_df):\n    g = ag.PairGrid(long_df, vars=['x', 'y'])\n    g.map(scatterplot, hue=long_df['a'])\n    ax = g.axes.flat[0]\n    points = ax.collections[0]\n    assert (len(set(map(tuple, points.get_facecolors()))) == 3)", "masked_code": "def test_hue_in_map(self, long_df):\n    g = ag.PairGrid(long_df, vars=['x', 'y'])\n    g.map(scatterplot, hue=long_df['a'])\n    ax = g.axes.flat[0]\n    points = ax.collections[0]\n    assert (len(set(map(tuple, points.get_facecolors()))) == '???')", "ground_truth": "3", "quality_analysis": {"complexity_score": 14, "left_complexity": 13, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_120", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_histplot_legend", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_histplot_legend(self):\n    g = ag.PairGrid(self.df, vars=['x', 'y'], hue='a')\n    g.map_offdiag(histplot)\n    g.add_legend()\n    assert (len(get_legend_handles(g._legend)) == len(self.df['a'].unique()))", "masked_code": "def test_histplot_legend(self):\n    g = ag.PairGrid(self.df, vars=['x', 'y'], hue='a')\n    g.map_offdiag(histplot)\n    g.add_legend()\n    assert (len(get_legend_handles(g._legend)) == '???')", "ground_truth": "len(self.df['a'].unique())", "quality_analysis": {"complexity_score": 14, "left_complexity": 8, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_121", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_pairplot", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_pairplot(self):\n    vars = ['x', 'y', 'z']\n    g = ag.pairplot(self.df)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) > 1)\n    for (i, j) in zip(*np.triu_indices_from(g.axes, 1)):\n        ax = g.axes[(i, j)]\n        x_in = self.df[vars[j]]\n        y_in = self.df[vars[i]]\n        (x_out, y_out) = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x_in, x_out)\n        npt.assert_array_equal(y_in, y_out)\n    for (i, j) in zip(*np.tril_indices_from(g.axes, (- 1))):\n        ax = g.axes[(i, j)]\n        x_in = self.df[vars[j]]\n        y_in = self.df[vars[i]]\n        (x_out, y_out) = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x_in, x_out)\n        npt.assert_array_equal(y_in, y_out)\n    for (i, j) in zip(*np.diag_indices_from(g.axes)):\n        ax = g.axes[(i, j)]\n        assert (len(ax.collections) == 0)\n    g = ag.pairplot(self.df, hue='a')\n    n = len(self.df.a.unique())\n    for ax in g.diag_axes:\n        assert (len(ax.collections) == n)", "masked_code": "def test_pairplot(self):\n    vars = ['x', 'y', 'z']\n    g = ag.pairplot(self.df)\n    for ax in g.diag_axes:\n        assert (len(ax.patches) > 1)\n    for (i, j) in zip(*np.triu_indices_from(g.axes, 1)):\n        ax = g.axes[(i, j)]\n        x_in = self.df[vars[j]]\n        y_in = self.df[vars[i]]\n        (x_out, y_out) = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x_in, x_out)\n        npt.assert_array_equal(y_in, y_out)\n    for (i, j) in zip(*np.tril_indices_from(g.axes, (- 1))):\n        ax = g.axes[(i, j)]\n        x_in = self.df[vars[j]]\n        y_in = self.df[vars[i]]\n        (x_out, y_out) = ax.collections[0].get_offsets().T\n        npt.assert_array_equal(x_in, x_out)\n        npt.assert_array_equal(y_in, y_out)\n    for (i, j) in zip(*np.diag_indices_from(g.axes)):\n        ax = g.axes[(i, j)]\n        assert (len(ax.collections) == 0)\n    g = ag.pairplot(self.df, hue='a')\n    n = len(self.df.a.unique())\n    for ax in g.diag_axes:\n        assert (len(ax.collections) == '???')", "ground_truth": "n", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_122", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_pairplot_column_multiindex", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_pairplot_column_multiindex(self):\n    cols = pd.MultiIndex.from_arrays([['x', 'y'], [1, 2]])\n    df = self.df[['x', 'y']].set_axis(cols, axis=1)\n    g = ag.pairplot(df)\n    assert (g.diag_vars == list(cols))", "masked_code": "def test_pairplot_column_multiindex(self):\n    cols = pd.MultiIndex.from_arrays([['x', 'y'], [1, 2]])\n    df = self.df[['x', 'y']].set_axis(cols, axis=1)\n    g = ag.pairplot(df)\n    assert (g.diag_vars == '???')", "ground_truth": "list(cols)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_123", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_corner_set", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_corner_set(self):\n    g = ag.PairGrid(self.df, corner=True, despine=False)\n    g.set(xlim=(0, 10))\n    assert (g.axes[((- 1), 0)].get_xlim() == (0, 10))", "masked_code": "def test_corner_set(self):\n    g = ag.PairGrid(self.df, corner=True, despine=False)\n    g.set(xlim=(0, 10))\n    assert (g.axes[((- 1), 0)].get_xlim() == '???')", "ground_truth": "(0, 10)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_124", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_tick_params", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_tick_params(self):\n    g = ag.PairGrid(self.df)\n    color = 'red'\n    pad = 3\n    g.tick_params(pad=pad, color=color)\n    for ax in g.axes.flat:\n        for axis in ['xaxis', 'yaxis']:\n            for tick in getattr(ax, axis).get_major_ticks():\n                assert mpl.colors.same_color(tick.tick1line.get_color(), color)\n                assert mpl.colors.same_color(tick.tick2line.get_color(), color)\n                assert (tick.get_pad() == pad)", "masked_code": "def test_tick_params(self):\n    g = ag.PairGrid(self.df)\n    color = 'red'\n    pad = 3\n    g.tick_params(pad=pad, color=color)\n    for ax in g.axes.flat:\n        for axis in ['xaxis', 'yaxis']:\n            for tick in getattr(ax, axis).get_major_ticks():\n                assert mpl.colors.same_color(tick.tick1line.get_color(), color)\n                assert mpl.colors.same_color(tick.tick2line.get_color(), color)\n                assert (tick.get_pad() == '???')", "ground_truth": "pad", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_125", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_data_interchange", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "@pytest.mark.skipif(condition=(not hasattr(pd.api, 'interchange')), reason='Tests behavior assuming support for dataframe interchange')\ndef test_data_interchange(self, mock_long_df, long_df):\n    g = ag.PairGrid(mock_long_df, vars=['x', 'y', 'z'], hue='a')\n    g.map(scatterplot)\n    assert (g.axes.shape == (3, 3))\n    for ax in g.axes.flat:\n        pts = ax.collections[0].get_offsets()\n        assert (len(pts) == len(long_df))", "masked_code": "@pytest.mark.skipif(condition=(not hasattr(pd.api, 'interchange')), reason='Tests behavior assuming support for dataframe interchange')\ndef test_data_interchange(self, mock_long_df, long_df):\n    g = ag.PairGrid(mock_long_df, vars=['x', 'y', 'z'], hue='a')\n    g.map(scatterplot)\n    assert (g.axes.shape == '???')\n    for ax in g.axes.flat:\n        pts = ax.collections[0].get_offsets()\n        assert (len(pts) == len(long_df))", "ground_truth": "(3, 3)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_126", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestPairGrid", "funcname": "test_data_interchange", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "@pytest.mark.skipif(condition=(not hasattr(pd.api, 'interchange')), reason='Tests behavior assuming support for dataframe interchange')\ndef test_data_interchange(self, mock_long_df, long_df):\n    g = ag.PairGrid(mock_long_df, vars=['x', 'y', 'z'], hue='a')\n    g.map(scatterplot)\n    assert (g.axes.shape == (3, 3))\n    for ax in g.axes.flat:\n        pts = ax.collections[0].get_offsets()\n        assert (len(pts) == len(long_df))", "masked_code": "@pytest.mark.skipif(condition=(not hasattr(pd.api, 'interchange')), reason='Tests behavior assuming support for dataframe interchange')\ndef test_data_interchange(self, mock_long_df, long_df):\n    g = ag.PairGrid(mock_long_df, vars=['x', 'y', 'z'], hue='a')\n    g.map(scatterplot)\n    assert (g.axes.shape == (3, 3))\n    for ax in g.axes.flat:\n        pts = ax.collections[0].get_offsets()\n        assert (len(pts) == '???')", "ground_truth": "len(long_df)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_127", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_dropna", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_dropna(self):\n    g = ag.JointGrid(x='x_na', y='y', data=self.data, dropna=False)\n    assert (len(g.x) == len(self.x_na))\n    g = ag.JointGrid(x='x_na', y='y', data=self.data, dropna=True)\n    assert (len(g.x) == pd.notnull(self.x_na).sum())", "masked_code": "def test_dropna(self):\n    g = ag.JointGrid(x='x_na', y='y', data=self.data, dropna=False)\n    assert (len(g.x) == '???')\n    g = ag.JointGrid(x='x_na', y='y', data=self.data, dropna=True)\n    assert (len(g.x) == pd.notnull(self.x_na).sum())", "ground_truth": "len(self.x_na)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_128", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_dropna", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_dropna(self):\n    g = ag.JointGrid(x='x_na', y='y', data=self.data, dropna=False)\n    assert (len(g.x) == len(self.x_na))\n    g = ag.JointGrid(x='x_na', y='y', data=self.data, dropna=True)\n    assert (len(g.x) == pd.notnull(self.x_na).sum())", "masked_code": "def test_dropna(self):\n    g = ag.JointGrid(x='x_na', y='y', data=self.data, dropna=False)\n    assert (len(g.x) == len(self.x_na))\n    g = ag.JointGrid(x='x_na', y='y', data=self.data, dropna=True)\n    assert (len(g.x) == '???')", "ground_truth": "pd.notnull(self.x_na).sum()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_129", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_axlims", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axlims(self):\n    lim = ((- 3), 3)\n    g = ag.JointGrid(x='x', y='y', data=self.data, xlim=lim, ylim=lim)\n    assert (g.ax_joint.get_xlim() == lim)\n    assert (g.ax_joint.get_ylim() == lim)\n    assert (g.ax_marg_x.get_xlim() == lim)\n    assert (g.ax_marg_y.get_ylim() == lim)", "masked_code": "def test_axlims(self):\n    lim = ((- 3), 3)\n    g = ag.JointGrid(x='x', y='y', data=self.data, xlim=lim, ylim=lim)\n    assert (g.ax_joint.get_xlim() == '???')\n    assert (g.ax_joint.get_ylim() == lim)\n    assert (g.ax_marg_x.get_xlim() == lim)\n    assert (g.ax_marg_y.get_ylim() == lim)", "ground_truth": "lim", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_130", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_axlims", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axlims(self):\n    lim = ((- 3), 3)\n    g = ag.JointGrid(x='x', y='y', data=self.data, xlim=lim, ylim=lim)\n    assert (g.ax_joint.get_xlim() == lim)\n    assert (g.ax_joint.get_ylim() == lim)\n    assert (g.ax_marg_x.get_xlim() == lim)\n    assert (g.ax_marg_y.get_ylim() == lim)", "masked_code": "def test_axlims(self):\n    lim = ((- 3), 3)\n    g = ag.JointGrid(x='x', y='y', data=self.data, xlim=lim, ylim=lim)\n    assert (g.ax_joint.get_xlim() == lim)\n    assert (g.ax_joint.get_ylim() == '???')\n    assert (g.ax_marg_x.get_xlim() == lim)\n    assert (g.ax_marg_y.get_ylim() == lim)", "ground_truth": "lim", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_131", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_axlims", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axlims(self):\n    lim = ((- 3), 3)\n    g = ag.JointGrid(x='x', y='y', data=self.data, xlim=lim, ylim=lim)\n    assert (g.ax_joint.get_xlim() == lim)\n    assert (g.ax_joint.get_ylim() == lim)\n    assert (g.ax_marg_x.get_xlim() == lim)\n    assert (g.ax_marg_y.get_ylim() == lim)", "masked_code": "def test_axlims(self):\n    lim = ((- 3), 3)\n    g = ag.JointGrid(x='x', y='y', data=self.data, xlim=lim, ylim=lim)\n    assert (g.ax_joint.get_xlim() == lim)\n    assert (g.ax_joint.get_ylim() == lim)\n    assert (g.ax_marg_x.get_xlim() == '???')\n    assert (g.ax_marg_y.get_ylim() == lim)", "ground_truth": "lim", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_132", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_axlims", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_axlims(self):\n    lim = ((- 3), 3)\n    g = ag.JointGrid(x='x', y='y', data=self.data, xlim=lim, ylim=lim)\n    assert (g.ax_joint.get_xlim() == lim)\n    assert (g.ax_joint.get_ylim() == lim)\n    assert (g.ax_marg_x.get_xlim() == lim)\n    assert (g.ax_marg_y.get_ylim() == lim)", "masked_code": "def test_axlims(self):\n    lim = ((- 3), 3)\n    g = ag.JointGrid(x='x', y='y', data=self.data, xlim=lim, ylim=lim)\n    assert (g.ax_joint.get_xlim() == lim)\n    assert (g.ax_joint.get_ylim() == lim)\n    assert (g.ax_marg_x.get_xlim() == lim)\n    assert (g.ax_marg_y.get_ylim() == '???')", "ground_truth": "lim", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_133", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_univariate_plot_distplot", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_univariate_plot_distplot(self):\n    bins = 10\n    g = ag.JointGrid(x='x', y='x', data=self.data)\n    with pytest.warns(UserWarning):\n        g.plot_marginals(distplot, bins=bins)\n    assert (len(g.ax_marg_x.patches) == bins)\n    assert (len(g.ax_marg_y.patches) == bins)\n    for (x, y) in zip(g.ax_marg_x.patches, g.ax_marg_y.patches):\n        assert (x.get_height() == y.get_width())", "masked_code": "def test_univariate_plot_distplot(self):\n    bins = 10\n    g = ag.JointGrid(x='x', y='x', data=self.data)\n    with pytest.warns(UserWarning):\n        g.plot_marginals(distplot, bins=bins)\n    assert (len(g.ax_marg_x.patches) == '???')\n    assert (len(g.ax_marg_y.patches) == bins)\n    for (x, y) in zip(g.ax_marg_x.patches, g.ax_marg_y.patches):\n        assert (x.get_height() == y.get_width())", "ground_truth": "bins", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_134", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_univariate_plot_distplot", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_univariate_plot_distplot(self):\n    bins = 10\n    g = ag.JointGrid(x='x', y='x', data=self.data)\n    with pytest.warns(UserWarning):\n        g.plot_marginals(distplot, bins=bins)\n    assert (len(g.ax_marg_x.patches) == bins)\n    assert (len(g.ax_marg_y.patches) == bins)\n    for (x, y) in zip(g.ax_marg_x.patches, g.ax_marg_y.patches):\n        assert (x.get_height() == y.get_width())", "masked_code": "def test_univariate_plot_distplot(self):\n    bins = 10\n    g = ag.JointGrid(x='x', y='x', data=self.data)\n    with pytest.warns(UserWarning):\n        g.plot_marginals(distplot, bins=bins)\n    assert (len(g.ax_marg_x.patches) == bins)\n    assert (len(g.ax_marg_y.patches) == '???')\n    for (x, y) in zip(g.ax_marg_x.patches, g.ax_marg_y.patches):\n        assert (x.get_height() == y.get_width())", "ground_truth": "bins", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_135", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_univariate_plot_distplot", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_univariate_plot_distplot(self):\n    bins = 10\n    g = ag.JointGrid(x='x', y='x', data=self.data)\n    with pytest.warns(UserWarning):\n        g.plot_marginals(distplot, bins=bins)\n    assert (len(g.ax_marg_x.patches) == bins)\n    assert (len(g.ax_marg_y.patches) == bins)\n    for (x, y) in zip(g.ax_marg_x.patches, g.ax_marg_y.patches):\n        assert (x.get_height() == y.get_width())", "masked_code": "def test_univariate_plot_distplot(self):\n    bins = 10\n    g = ag.JointGrid(x='x', y='x', data=self.data)\n    with pytest.warns(UserWarning):\n        g.plot_marginals(distplot, bins=bins)\n    assert (len(g.ax_marg_x.patches) == bins)\n    assert (len(g.ax_marg_y.patches) == bins)\n    for (x, y) in zip(g.ax_marg_x.patches, g.ax_marg_y.patches):\n        assert (x.get_height() == '???')", "ground_truth": "y.get_width()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_136", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_univariate_plot_matplotlib", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_univariate_plot_matplotlib(self):\n    bins = 10\n    g = ag.JointGrid(x='x', y='x', data=self.data)\n    g.plot_marginals(plt.hist, bins=bins)\n    assert (len(g.ax_marg_x.patches) == bins)\n    assert (len(g.ax_marg_y.patches) == bins)", "masked_code": "def test_univariate_plot_matplotlib(self):\n    bins = 10\n    g = ag.JointGrid(x='x', y='x', data=self.data)\n    g.plot_marginals(plt.hist, bins=bins)\n    assert (len(g.ax_marg_x.patches) == '???')\n    assert (len(g.ax_marg_y.patches) == bins)", "ground_truth": "bins", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_137", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_univariate_plot_matplotlib", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_univariate_plot_matplotlib(self):\n    bins = 10\n    g = ag.JointGrid(x='x', y='x', data=self.data)\n    g.plot_marginals(plt.hist, bins=bins)\n    assert (len(g.ax_marg_x.patches) == bins)\n    assert (len(g.ax_marg_y.patches) == bins)", "masked_code": "def test_univariate_plot_matplotlib(self):\n    bins = 10\n    g = ag.JointGrid(x='x', y='x', data=self.data)\n    g.plot_marginals(plt.hist, bins=bins)\n    assert (len(g.ax_marg_x.patches) == bins)\n    assert (len(g.ax_marg_y.patches) == '???')", "ground_truth": "bins", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_138", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_space", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_space(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data, space=0)\n    joint_bounds = g.ax_joint.bbox.bounds\n    marg_x_bounds = g.ax_marg_x.bbox.bounds\n    marg_y_bounds = g.ax_marg_y.bbox.bounds\n    assert (joint_bounds[2] == marg_x_bounds[2])\n    assert (joint_bounds[3] == marg_y_bounds[3])", "masked_code": "def test_space(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data, space=0)\n    joint_bounds = g.ax_joint.bbox.bounds\n    marg_x_bounds = g.ax_marg_x.bbox.bounds\n    marg_y_bounds = g.ax_marg_y.bbox.bounds\n    assert (joint_bounds[2] == '???')\n    assert (joint_bounds[3] == marg_y_bounds[3])", "ground_truth": "marg_x_bounds[2]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_139", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_space", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_space(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data, space=0)\n    joint_bounds = g.ax_joint.bbox.bounds\n    marg_x_bounds = g.ax_marg_x.bbox.bounds\n    marg_y_bounds = g.ax_marg_y.bbox.bounds\n    assert (joint_bounds[2] == marg_x_bounds[2])\n    assert (joint_bounds[3] == marg_y_bounds[3])", "masked_code": "def test_space(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data, space=0)\n    joint_bounds = g.ax_joint.bbox.bounds\n    marg_x_bounds = g.ax_marg_x.bbox.bounds\n    marg_y_bounds = g.ax_marg_y.bbox.bounds\n    assert (joint_bounds[2] == marg_x_bounds[2])\n    assert (joint_bounds[3] == '???')", "ground_truth": "marg_y_bounds[3]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_140", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_refline", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "masked_code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '???')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "ground_truth": "'.5'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_141", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_refline", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "masked_code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '???')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "ground_truth": "'--'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_142", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_refline", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "masked_code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == '???')\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "ground_truth": "color", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_143", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_refline", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "masked_code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == '???')\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "ground_truth": "linestyle", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_144", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_refline", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "masked_code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == '???')\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "ground_truth": "len(g.ax_marg_y.lines)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_145", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_refline", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "masked_code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == '???')\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "ground_truth": "(len(g.ax_marg_y.lines) + 1)", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_146", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_refline", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "masked_code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == '???')\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "ground_truth": "len(g.ax_marg_y.lines)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_147", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointGrid", "funcname": "test_refline", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))", "masked_code": "def test_refline(self):\n    g = ag.JointGrid(x='x', y='y', data=self.data)\n    g.plot(scatterplot, histplot)\n    g.refline()\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    refx = refy = 0.5\n    hline = np.array([[0, refy], [1, refy]])\n    vline = np.array([[refx, 0], [refx, 1]])\n    g.refline(x=refx, y=refy, joint=False, marginal=False)\n    assert ((not g.ax_joint.lines) and (not g.ax_marg_x.lines) and (not g.ax_marg_y.lines))\n    g.refline(x=refx, y=refy)\n    assert (g.ax_joint.lines[0].get_color() == '.5')\n    assert (g.ax_joint.lines[0].get_linestyle() == '--')\n    assert (len(g.ax_joint.lines) == 2)\n    assert (len(g.ax_marg_x.lines) == 1)\n    assert (len(g.ax_marg_y.lines) == 1)\n    npt.assert_array_equal(g.ax_joint.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_joint.lines[1].get_xydata(), hline)\n    npt.assert_array_equal(g.ax_marg_x.lines[0].get_xydata(), vline)\n    npt.assert_array_equal(g.ax_marg_y.lines[0].get_xydata(), hline)\n    (color, linestyle) = ('red', '-')\n    g.refline(x=refx, marginal=False, color=color, linestyle=linestyle)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), vline)\n    assert (g.ax_joint.lines[(- 1)].get_color() == color)\n    assert (g.ax_joint.lines[(- 1)].get_linestyle() == linestyle)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(x=refx, joint=False)\n    npt.assert_array_equal(g.ax_marg_x.lines[(- 1)].get_xydata(), vline)\n    assert (len(g.ax_marg_x.lines) == (len(g.ax_marg_y.lines) + 1))\n    g.refline(y=refy, joint=False)\n    npt.assert_array_equal(g.ax_marg_y.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == len(g.ax_marg_y.lines))\n    g.refline(y=refy, marginal=False)\n    npt.assert_array_equal(g.ax_joint.lines[(- 1)].get_xydata(), hline)\n    assert (len(g.ax_marg_x.lines) == '???')", "ground_truth": "len(g.ax_marg_y.lines)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_148", "reponame": "seaborn", "testpath": "tests/test_axisgrid.py", "testname": "test_axisgrid.py", "classname": "TestJointPlot", "funcname": "test_hex_customise", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "import numpy.testing as npt", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "import pandas.testing as tm", "from seaborn._base import categorical_order", "from seaborn import rcmod", "from seaborn.palettes import color_palette", "from seaborn.relational import scatterplot", "from seaborn.distributions import histplot, kdeplot, distplot", "from seaborn.categorical import pointplot", "from seaborn.utils import _version_predates", "from seaborn import axisgrid as ag", "from seaborn._testing import assert_plots_equal, assert_colors_equal", "from seaborn._compat import get_legend_handles"], "code": "def test_hex_customise(self):\n    g = ag.jointplot(x='x', y='y', data=self.data, kind='hex', joint_kws=dict(gridsize=5))\n    assert (len(g.ax_joint.collections) == 1)\n    a = g.ax_joint.collections[0].get_array()\n    assert (a.shape[0] == 28)", "masked_code": "def test_hex_customise(self):\n    g = ag.jointplot(x='x', y='y', data=self.data, kind='hex', joint_kws=dict(gridsize=5))\n    assert (len(g.ax_joint.collections) == 1)\n    a = g.ax_joint.collections[0].get_array()\n    assert (a.shape[0] == '???')", "ground_truth": "28", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_149", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestSemanticMapping", "funcname": "test_call_lookup", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_call_lookup(self):\n    m = SemanticMapping(VectorPlotter())\n    lookup_table = dict(zip('abc', (1, 2, 3)))\n    m.lookup_table = lookup_table\n    for (key, val) in lookup_table.items():\n        assert (m(key) == val)", "masked_code": "def test_call_lookup(self):\n    m = SemanticMapping(VectorPlotter())\n    lookup_table = dict(zip('abc', (1, 2, 3)))\n    m.lookup_table = lookup_table\n    for (key, val) in lookup_table.items():\n        assert (m(key) == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_150", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_plotter_default_init", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_plotter_default_init(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    assert (not hasattr(p, '_hue_map'))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    assert isinstance(p._hue_map, HueMapping)\n    assert (p._hue_map.map_type == p.var_types['hue'])", "masked_code": "def test_plotter_default_init(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    assert (not hasattr(p, '_hue_map'))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    assert isinstance(p._hue_map, HueMapping)\n    assert (p._hue_map.map_type == '???')", "ground_truth": "p.var_types['hue']", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_151", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_plotter_customization", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_plotter_customization(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    palette = 'muted'\n    hue_order = ['b', 'a', 'c']\n    p.map_hue(palette=palette, order=hue_order)\n    assert (p._hue_map.palette == palette)\n    assert (p._hue_map.levels == hue_order)", "masked_code": "def test_plotter_customization(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    palette = 'muted'\n    hue_order = ['b', 'a', 'c']\n    p.map_hue(palette=palette, order=hue_order)\n    assert (p._hue_map.palette == '???')\n    assert (p._hue_map.levels == hue_order)", "ground_truth": "palette", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_152", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_plotter_customization", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_plotter_customization(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    palette = 'muted'\n    hue_order = ['b', 'a', 'c']\n    p.map_hue(palette=palette, order=hue_order)\n    assert (p._hue_map.palette == palette)\n    assert (p._hue_map.levels == hue_order)", "masked_code": "def test_plotter_customization(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    palette = 'muted'\n    hue_order = ['b', 'a', 'c']\n    p.map_hue(palette=palette, order=hue_order)\n    assert (p._hue_map.palette == palette)\n    assert (p._hue_map.levels == '???')", "ground_truth": "hue_order", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_153", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == '???')\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "wide_df.columns.to_list()", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_154", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == '???')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_155", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == '???')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "'Blues'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_156", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == '???')\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "expected_lookup_table", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_157", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == '???')\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "palette", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_158", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == '???')\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "expected_lookup_table", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_159", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == '???')\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "palette", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_160", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == '???')\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "palette", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_161", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == '???')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "hue_order", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_162", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == '???')\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "categorical_order(long_df['a'])", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_163", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == '???')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_164", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == '???')\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "expected_lookup_table", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_165", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == '???')\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "(0, 0, 0, 0)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_166", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == '???')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "expected_lookup_table", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_167", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == '???')\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "[0, 1]", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_168", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == '???')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_169", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == '???')\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "[pd.Timestamp(t) for t in long_df['t'].unique()]", "quality_analysis": {"complexity_score": 2, "left_complexity": 2, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_170", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == '???')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "'datetime'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_171", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == '???')\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "long_df['a_cat'].cat.categories.to_list()", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_172", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == '???')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_173", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == '???')\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "categorical_order(long_df['s_cat'])", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_174", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == '???')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_175", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == '???')\n    assert (m.map_type == 'categorical')", "ground_truth": "expected_lookup_table", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_176", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == '???')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_177", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == '???')\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "[val]", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_178", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "masked_code": "def test_hue_map_categorical(self, wide_df, long_df):\n    p = VectorPlotter(data=wide_df)\n    m = HueMapping(p)\n    assert (m.levels == wide_df.columns.to_list())\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    palette = 'Blues'\n    expected_colors = color_palette(palette, wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == 'Blues')\n    assert (m.lookup_table == expected_lookup_table)\n    palette = color_palette('Reds', wide_df.shape[1])\n    expected_lookup_table = dict(zip(wide_df.columns, palette))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == expected_lookup_table)\n    colors = color_palette('Set1', 8)\n    palette = dict(zip(wide_df.columns, colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.palette == palette)\n    assert (m.lookup_table == palette)\n    palette = dict(zip(wide_df.columns[:(- 1)], colors))\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    palette = colors[:(- 1)]\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    hue_order = ['a', 'c', 'd']\n    m = HueMapping(p, order=hue_order)\n    assert (m.levels == hue_order)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['a']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    m = HueMapping(p)\n    hue_levels = categorical_order(long_df['a'])\n    expected_colors = color_palette(n_colors=len(hue_levels))\n    expected_lookup_table = dict(zip(hue_levels, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    m = HueMapping(p)\n    assert (m(np.nan) == (0, 0, 0, 0))\n    x = y = np.arange(26)\n    hue = pd.Series(list('abcdefghijklmnopqrstuvwxyz'))\n    p = VectorPlotter(variables=dict(x=x, y=y, hue=hue))\n    m = HueMapping(p)\n    expected_colors = color_palette('husl', n_colors=len(hue))\n    expected_lookup_table = dict(zip(hue, expected_colors))\n    assert (m.lookup_table == expected_lookup_table)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='c'))\n    m = HueMapping(p)\n    assert (m.levels == [0, 1])\n    assert (m.map_type == 'categorical')\n    for val in [0, 1]:\n        p = VectorPlotter(data=long_df[(long_df['c'] == val)], variables=dict(x='x', y='y', hue='c'))\n        m = HueMapping(p)\n        assert (m.levels == [val])\n        assert (m.map_type == '???')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='t'))\n    m = HueMapping(p)\n    assert (m.levels == [pd.Timestamp(t) for t in long_df['t'].unique()])\n    assert (m.map_type == 'datetime')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', hue='a_cat'))\n    m = HueMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s_cat'))\n    m = HueMapping(p)\n    assert (m.levels == categorical_order(long_df['s_cat']))\n    assert (m.map_type == 'categorical')\n    assert (m.cmap is None)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    palette = 'deep'\n    levels = categorical_order(long_df['s'])\n    expected_colors = color_palette(palette, n_colors=len(levels))\n    expected_lookup_table = dict(zip(levels, expected_colors))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == expected_lookup_table)\n    assert (m.map_type == 'categorical')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_179", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_numeric", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "masked_code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == '???')\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "ground_truth": "hue_levels", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_180", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_numeric", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "masked_code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == '???')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_181", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_numeric", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "masked_code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == '???')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "ground_truth": "'seaborn_cubehelix'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_182", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_numeric", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "masked_code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == '???')\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "ground_truth": "hue_norm[0]", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_183", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_numeric", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "masked_code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == '???')\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "ground_truth": "hue_norm[1]", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_184", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_numeric", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "masked_code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == '???')\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "ground_truth": "pytest.approx(m.cmap(0.0))", "quality_analysis": {"complexity_score": 13, "left_complexity": 6, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_185", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_numeric", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "masked_code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == '???')\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "ground_truth": "pytest.approx(m.cmap(1.0))", "quality_analysis": {"complexity_score": 13, "left_complexity": 6, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_186", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_numeric", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "masked_code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == '???')\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "ground_truth": "pytest.approx(m.cmap(norm_min))", "quality_analysis": {"complexity_score": 13, "left_complexity": 6, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_187", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_numeric", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "masked_code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == '???')\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "ground_truth": "pytest.approx(m.cmap(1.0))", "quality_analysis": {"complexity_score": 13, "left_complexity": 6, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_188", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_numeric", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "masked_code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == '???')\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "ground_truth": "dict(zip(hue_levels, palette))", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_189", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestHueMapping", "funcname": "test_hue_map_numeric", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == palette)\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "masked_code": "def test_hue_map_numeric(self, long_df):\n    vals = np.concatenate([np.linspace(0, 1, 256), [(- 0.1), 1.1, np.nan]])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='s'))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    m = HueMapping(p)\n    assert (m.levels == hue_levels)\n    assert (m.map_type == 'numeric')\n    assert (m.cmap.name == 'seaborn_cubehelix')\n    palette = 'Purples'\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), get_colormap(palette)(vals))\n    palette = get_colormap('Greens')\n    m = HueMapping(p, palette=palette)\n    assert_array_equal(m.cmap(vals), palette(vals))\n    palette = 'ch:2,0,light=.2'\n    m = HueMapping(p, palette=palette)\n    assert isinstance(m.cmap, mpl.colors.ListedColormap)\n    hue_norm = (1, 4)\n    m = HueMapping(p, norm=hue_norm)\n    assert isinstance(m.norm, mpl.colors.Normalize)\n    assert (m.norm.vmin == hue_norm[0])\n    assert (m.norm.vmax == hue_norm[1])\n    hue_norm = mpl.colors.PowerNorm(2, vmin=1, vmax=10)\n    m = HueMapping(p, norm=hue_norm)\n    assert (m.norm is hue_norm)\n    (hmin, hmax) = (p.plot_data['hue'].min(), p.plot_data['hue'].max())\n    m = HueMapping(p)\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(0.0)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_norm = ((hmin - 1), (hmax - 1))\n    m = HueMapping(p, norm=hue_norm)\n    norm_min = ((hmin - hue_norm[0]) / (hue_norm[1] - hue_norm[0]))\n    assert (m.lookup_table[hmin] == pytest.approx(m.cmap(norm_min)))\n    assert (m.lookup_table[hmax] == pytest.approx(m.cmap(1.0)))\n    hue_levels = list(np.sort(long_df['s'].unique()))\n    palette = color_palette('Blues', len(hue_levels))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == dict(zip(hue_levels, palette)))\n    palette = color_palette('Blues', (len(hue_levels) + 1))\n    with pytest.warns(UserWarning):\n        HueMapping(p, palette=palette)\n    palette = dict(zip(hue_levels, color_palette('Reds')))\n    m = HueMapping(p, palette=palette)\n    assert (m.lookup_table == '???')\n    palette.pop(hue_levels[0])\n    with pytest.raises(ValueError):\n        HueMapping(p, palette=palette)\n    with pytest.raises(ValueError):\n        HueMapping(p, palette='not a valid palette')\n    with pytest.raises(ValueError):\n        HueMapping(p, norm='not a norm')", "ground_truth": "palette", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_190", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestSizeMapping", "funcname": "test_plotter_default_init", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_plotter_default_init(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    assert (not hasattr(p, '_size_map'))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    assert isinstance(p._size_map, SizeMapping)\n    assert (p._size_map.map_type == p.var_types['size'])", "masked_code": "def test_plotter_default_init(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    assert (not hasattr(p, '_size_map'))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    assert isinstance(p._size_map, SizeMapping)\n    assert (p._size_map.map_type == '???')", "ground_truth": "p.var_types['size']", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_191", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestSizeMapping", "funcname": "test_plotter_customization", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_plotter_customization(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    sizes = [1, 4, 2]\n    size_order = ['b', 'a', 'c']\n    p.map_size(sizes=sizes, order=size_order)\n    assert (p._size_map.lookup_table == dict(zip(size_order, sizes)))\n    assert (p._size_map.levels == size_order)", "masked_code": "def test_plotter_customization(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    sizes = [1, 4, 2]\n    size_order = ['b', 'a', 'c']\n    p.map_size(sizes=sizes, order=size_order)\n    assert (p._size_map.lookup_table == '???')\n    assert (p._size_map.levels == size_order)", "ground_truth": "dict(zip(size_order, sizes))", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_192", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestSizeMapping", "funcname": "test_plotter_customization", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_plotter_customization(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    sizes = [1, 4, 2]\n    size_order = ['b', 'a', 'c']\n    p.map_size(sizes=sizes, order=size_order)\n    assert (p._size_map.lookup_table == dict(zip(size_order, sizes)))\n    assert (p._size_map.levels == size_order)", "masked_code": "def test_plotter_customization(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    sizes = [1, 4, 2]\n    size_order = ['b', 'a', 'c']\n    p.map_size(sizes=sizes, order=size_order)\n    assert (p._size_map.lookup_table == dict(zip(size_order, sizes)))\n    assert (p._size_map.levels == '???')", "ground_truth": "size_order", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_193", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestSizeMapping", "funcname": "test_map_size_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_size_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    levels = p.plot_data['size'].unique()\n    sizes = [1, 4, 6]\n    order = [levels[1], levels[2], levels[0]]\n    m = SizeMapping(p, sizes=sizes, order=order)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    order = categorical_order(p.plot_data['size'])\n    sizes = list(np.random.rand(len(levels)))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    sizes = dict(zip(levels, np.random.rand(len(levels))))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == sizes)\n    sizes = (2, 5)\n    m = SizeMapping(p, sizes=sizes)\n    values = np.linspace(*sizes, len(m.levels))[::(- 1)]\n    assert (m.lookup_table == dict(zip(m.levels, values)))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', size='a_cat'))\n    m = SizeMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    sizes = list(np.random.rand((len(levels) + 1)))\n    with pytest.warns(UserWarning):\n        SizeMapping(p, sizes=sizes)\n    sizes = dict(zip(levels, np.random.rand((len(levels) - 1))))\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes=sizes)\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes='bad_size')", "masked_code": "def test_map_size_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    levels = p.plot_data['size'].unique()\n    sizes = [1, 4, 6]\n    order = [levels[1], levels[2], levels[0]]\n    m = SizeMapping(p, sizes=sizes, order=order)\n    assert (m.lookup_table == '???')\n    order = categorical_order(p.plot_data['size'])\n    sizes = list(np.random.rand(len(levels)))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    sizes = dict(zip(levels, np.random.rand(len(levels))))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == sizes)\n    sizes = (2, 5)\n    m = SizeMapping(p, sizes=sizes)\n    values = np.linspace(*sizes, len(m.levels))[::(- 1)]\n    assert (m.lookup_table == dict(zip(m.levels, values)))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', size='a_cat'))\n    m = SizeMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    sizes = list(np.random.rand((len(levels) + 1)))\n    with pytest.warns(UserWarning):\n        SizeMapping(p, sizes=sizes)\n    sizes = dict(zip(levels, np.random.rand((len(levels) - 1))))\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes=sizes)\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes='bad_size')", "ground_truth": "dict(zip(order, sizes))", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_194", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestSizeMapping", "funcname": "test_map_size_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_size_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    levels = p.plot_data['size'].unique()\n    sizes = [1, 4, 6]\n    order = [levels[1], levels[2], levels[0]]\n    m = SizeMapping(p, sizes=sizes, order=order)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    order = categorical_order(p.plot_data['size'])\n    sizes = list(np.random.rand(len(levels)))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    sizes = dict(zip(levels, np.random.rand(len(levels))))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == sizes)\n    sizes = (2, 5)\n    m = SizeMapping(p, sizes=sizes)\n    values = np.linspace(*sizes, len(m.levels))[::(- 1)]\n    assert (m.lookup_table == dict(zip(m.levels, values)))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', size='a_cat'))\n    m = SizeMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    sizes = list(np.random.rand((len(levels) + 1)))\n    with pytest.warns(UserWarning):\n        SizeMapping(p, sizes=sizes)\n    sizes = dict(zip(levels, np.random.rand((len(levels) - 1))))\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes=sizes)\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes='bad_size')", "masked_code": "def test_map_size_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    levels = p.plot_data['size'].unique()\n    sizes = [1, 4, 6]\n    order = [levels[1], levels[2], levels[0]]\n    m = SizeMapping(p, sizes=sizes, order=order)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    order = categorical_order(p.plot_data['size'])\n    sizes = list(np.random.rand(len(levels)))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == '???')\n    sizes = dict(zip(levels, np.random.rand(len(levels))))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == sizes)\n    sizes = (2, 5)\n    m = SizeMapping(p, sizes=sizes)\n    values = np.linspace(*sizes, len(m.levels))[::(- 1)]\n    assert (m.lookup_table == dict(zip(m.levels, values)))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', size='a_cat'))\n    m = SizeMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    sizes = list(np.random.rand((len(levels) + 1)))\n    with pytest.warns(UserWarning):\n        SizeMapping(p, sizes=sizes)\n    sizes = dict(zip(levels, np.random.rand((len(levels) - 1))))\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes=sizes)\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes='bad_size')", "ground_truth": "dict(zip(order, sizes))", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_195", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestSizeMapping", "funcname": "test_map_size_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_size_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    levels = p.plot_data['size'].unique()\n    sizes = [1, 4, 6]\n    order = [levels[1], levels[2], levels[0]]\n    m = SizeMapping(p, sizes=sizes, order=order)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    order = categorical_order(p.plot_data['size'])\n    sizes = list(np.random.rand(len(levels)))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    sizes = dict(zip(levels, np.random.rand(len(levels))))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == sizes)\n    sizes = (2, 5)\n    m = SizeMapping(p, sizes=sizes)\n    values = np.linspace(*sizes, len(m.levels))[::(- 1)]\n    assert (m.lookup_table == dict(zip(m.levels, values)))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', size='a_cat'))\n    m = SizeMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    sizes = list(np.random.rand((len(levels) + 1)))\n    with pytest.warns(UserWarning):\n        SizeMapping(p, sizes=sizes)\n    sizes = dict(zip(levels, np.random.rand((len(levels) - 1))))\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes=sizes)\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes='bad_size')", "masked_code": "def test_map_size_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    levels = p.plot_data['size'].unique()\n    sizes = [1, 4, 6]\n    order = [levels[1], levels[2], levels[0]]\n    m = SizeMapping(p, sizes=sizes, order=order)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    order = categorical_order(p.plot_data['size'])\n    sizes = list(np.random.rand(len(levels)))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    sizes = dict(zip(levels, np.random.rand(len(levels))))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == '???')\n    sizes = (2, 5)\n    m = SizeMapping(p, sizes=sizes)\n    values = np.linspace(*sizes, len(m.levels))[::(- 1)]\n    assert (m.lookup_table == dict(zip(m.levels, values)))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', size='a_cat'))\n    m = SizeMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    sizes = list(np.random.rand((len(levels) + 1)))\n    with pytest.warns(UserWarning):\n        SizeMapping(p, sizes=sizes)\n    sizes = dict(zip(levels, np.random.rand((len(levels) - 1))))\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes=sizes)\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes='bad_size')", "ground_truth": "sizes", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_196", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestSizeMapping", "funcname": "test_map_size_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_size_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    levels = p.plot_data['size'].unique()\n    sizes = [1, 4, 6]\n    order = [levels[1], levels[2], levels[0]]\n    m = SizeMapping(p, sizes=sizes, order=order)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    order = categorical_order(p.plot_data['size'])\n    sizes = list(np.random.rand(len(levels)))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    sizes = dict(zip(levels, np.random.rand(len(levels))))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == sizes)\n    sizes = (2, 5)\n    m = SizeMapping(p, sizes=sizes)\n    values = np.linspace(*sizes, len(m.levels))[::(- 1)]\n    assert (m.lookup_table == dict(zip(m.levels, values)))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', size='a_cat'))\n    m = SizeMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    sizes = list(np.random.rand((len(levels) + 1)))\n    with pytest.warns(UserWarning):\n        SizeMapping(p, sizes=sizes)\n    sizes = dict(zip(levels, np.random.rand((len(levels) - 1))))\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes=sizes)\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes='bad_size')", "masked_code": "def test_map_size_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    levels = p.plot_data['size'].unique()\n    sizes = [1, 4, 6]\n    order = [levels[1], levels[2], levels[0]]\n    m = SizeMapping(p, sizes=sizes, order=order)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    order = categorical_order(p.plot_data['size'])\n    sizes = list(np.random.rand(len(levels)))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    sizes = dict(zip(levels, np.random.rand(len(levels))))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == sizes)\n    sizes = (2, 5)\n    m = SizeMapping(p, sizes=sizes)\n    values = np.linspace(*sizes, len(m.levels))[::(- 1)]\n    assert (m.lookup_table == '???')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', size='a_cat'))\n    m = SizeMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    sizes = list(np.random.rand((len(levels) + 1)))\n    with pytest.warns(UserWarning):\n        SizeMapping(p, sizes=sizes)\n    sizes = dict(zip(levels, np.random.rand((len(levels) - 1))))\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes=sizes)\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes='bad_size')", "ground_truth": "dict(zip(m.levels, values))", "quality_analysis": {"complexity_score": 11, "left_complexity": 2, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_197", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestSizeMapping", "funcname": "test_map_size_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_size_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    levels = p.plot_data['size'].unique()\n    sizes = [1, 4, 6]\n    order = [levels[1], levels[2], levels[0]]\n    m = SizeMapping(p, sizes=sizes, order=order)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    order = categorical_order(p.plot_data['size'])\n    sizes = list(np.random.rand(len(levels)))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    sizes = dict(zip(levels, np.random.rand(len(levels))))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == sizes)\n    sizes = (2, 5)\n    m = SizeMapping(p, sizes=sizes)\n    values = np.linspace(*sizes, len(m.levels))[::(- 1)]\n    assert (m.lookup_table == dict(zip(m.levels, values)))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', size='a_cat'))\n    m = SizeMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    sizes = list(np.random.rand((len(levels) + 1)))\n    with pytest.warns(UserWarning):\n        SizeMapping(p, sizes=sizes)\n    sizes = dict(zip(levels, np.random.rand((len(levels) - 1))))\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes=sizes)\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes='bad_size')", "masked_code": "def test_map_size_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    levels = p.plot_data['size'].unique()\n    sizes = [1, 4, 6]\n    order = [levels[1], levels[2], levels[0]]\n    m = SizeMapping(p, sizes=sizes, order=order)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    order = categorical_order(p.plot_data['size'])\n    sizes = list(np.random.rand(len(levels)))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    sizes = dict(zip(levels, np.random.rand(len(levels))))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == sizes)\n    sizes = (2, 5)\n    m = SizeMapping(p, sizes=sizes)\n    values = np.linspace(*sizes, len(m.levels))[::(- 1)]\n    assert (m.lookup_table == dict(zip(m.levels, values)))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', size='a_cat'))\n    m = SizeMapping(p)\n    assert (m.levels == '???')\n    assert (m.map_type == 'categorical')\n    sizes = list(np.random.rand((len(levels) + 1)))\n    with pytest.warns(UserWarning):\n        SizeMapping(p, sizes=sizes)\n    sizes = dict(zip(levels, np.random.rand((len(levels) - 1))))\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes=sizes)\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes='bad_size')", "ground_truth": "long_df['a_cat'].cat.categories.to_list()", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_198", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestSizeMapping", "funcname": "test_map_size_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_size_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    levels = p.plot_data['size'].unique()\n    sizes = [1, 4, 6]\n    order = [levels[1], levels[2], levels[0]]\n    m = SizeMapping(p, sizes=sizes, order=order)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    order = categorical_order(p.plot_data['size'])\n    sizes = list(np.random.rand(len(levels)))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    sizes = dict(zip(levels, np.random.rand(len(levels))))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == sizes)\n    sizes = (2, 5)\n    m = SizeMapping(p, sizes=sizes)\n    values = np.linspace(*sizes, len(m.levels))[::(- 1)]\n    assert (m.lookup_table == dict(zip(m.levels, values)))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', size='a_cat'))\n    m = SizeMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == 'categorical')\n    sizes = list(np.random.rand((len(levels) + 1)))\n    with pytest.warns(UserWarning):\n        SizeMapping(p, sizes=sizes)\n    sizes = dict(zip(levels, np.random.rand((len(levels) - 1))))\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes=sizes)\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes='bad_size')", "masked_code": "def test_map_size_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    levels = p.plot_data['size'].unique()\n    sizes = [1, 4, 6]\n    order = [levels[1], levels[2], levels[0]]\n    m = SizeMapping(p, sizes=sizes, order=order)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    order = categorical_order(p.plot_data['size'])\n    sizes = list(np.random.rand(len(levels)))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == dict(zip(order, sizes)))\n    sizes = dict(zip(levels, np.random.rand(len(levels))))\n    m = SizeMapping(p, sizes=sizes)\n    assert (m.lookup_table == sizes)\n    sizes = (2, 5)\n    m = SizeMapping(p, sizes=sizes)\n    values = np.linspace(*sizes, len(m.levels))[::(- 1)]\n    assert (m.lookup_table == dict(zip(m.levels, values)))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', size='a_cat'))\n    m = SizeMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    assert (m.map_type == '???')\n    sizes = list(np.random.rand((len(levels) + 1)))\n    with pytest.warns(UserWarning):\n        SizeMapping(p, sizes=sizes)\n    sizes = dict(zip(levels, np.random.rand((len(levels) - 1))))\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes=sizes)\n    with pytest.raises(ValueError):\n        SizeMapping(p, sizes='bad_size')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_199", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestSizeMapping", "funcname": "test_array_palette_deprecation", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_array_palette_deprecation(self, long_df):\n    p = VectorPlotter(long_df, {'y': 'y', 'hue': 's'})\n    pal = mpl.cm.Blues([0.3, 0.5, 0.8])[(:, :3)]\n    with pytest.warns(UserWarning, match='Numpy array is not a supported type'):\n        m = HueMapping(p, pal)\n    assert (m.palette == pal.tolist())", "masked_code": "def test_array_palette_deprecation(self, long_df):\n    p = VectorPlotter(long_df, {'y': 'y', 'hue': 's'})\n    pal = mpl.cm.Blues([0.3, 0.5, 0.8])[(:, :3)]\n    with pytest.warns(UserWarning, match='Numpy array is not a supported type'):\n        m = HueMapping(p, pal)\n    assert (m.palette == '???')", "ground_truth": "pal.tolist()", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_200", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestStyleMapping", "funcname": "test_plotter_customization", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_plotter_customization(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    markers = ['s', 'p', 'h']\n    style_order = ['b', 'a', 'c']\n    p.map_style(markers=markers, order=style_order)\n    assert (p._style_map.levels == style_order)\n    assert (p._style_map(style_order, 'marker') == markers)", "masked_code": "def test_plotter_customization(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    markers = ['s', 'p', 'h']\n    style_order = ['b', 'a', 'c']\n    p.map_style(markers=markers, order=style_order)\n    assert (p._style_map.levels == '???')\n    assert (p._style_map(style_order, 'marker') == markers)", "ground_truth": "style_order", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_201", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestStyleMapping", "funcname": "test_plotter_customization", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_plotter_customization(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    markers = ['s', 'p', 'h']\n    style_order = ['b', 'a', 'c']\n    p.map_style(markers=markers, order=style_order)\n    assert (p._style_map.levels == style_order)\n    assert (p._style_map(style_order, 'marker') == markers)", "masked_code": "def test_plotter_customization(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    markers = ['s', 'p', 'h']\n    style_order = ['b', 'a', 'c']\n    p.map_style(markers=markers, order=style_order)\n    assert (p._style_map.levels == style_order)\n    assert (p._style_map(style_order, 'marker') == '???')", "ground_truth": "markers", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_202", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestStyleMapping", "funcname": "test_map_style", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "masked_code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == '???')\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "ground_truth": "long_df['a_cat'].cat.categories.to_list()", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_203", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestStyleMapping", "funcname": "test_map_style", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "masked_code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == '???')\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "ground_truth": "dashes", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_204", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestStyleMapping", "funcname": "test_map_style", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "masked_code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == '???')\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "ground_truth": "mark", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_205", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestStyleMapping", "funcname": "test_map_style", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "masked_code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == '???')\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "ground_truth": "dash", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_206", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestStyleMapping", "funcname": "test_map_style", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "masked_code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == '???')\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "ground_truth": "markers[key]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_207", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestStyleMapping", "funcname": "test_map_style", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "masked_code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == '???')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "ground_truth": "dashes[key]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_208", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestStyleMapping", "funcname": "test_map_style", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "masked_code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == '???')\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "ground_truth": "dash", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_209", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestStyleMapping", "funcname": "test_map_style", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == mark)\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "masked_code": "def test_map_style(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', style='a'))\n    m = StyleMapping(p, markers=True, dashes=True)\n    n = len(m.levels)\n    for (key, dashes) in zip(m.levels, unique_dashes(n)):\n        assert (m(key, 'dashes') == dashes)\n    actual_marker_paths = {k: mpl.markers.MarkerStyle(m(k, 'marker')).get_path() for k in m.levels}\n    expected_marker_paths = {k: mpl.markers.MarkerStyle(m).get_path() for (k, m) in zip(m.levels, unique_markers(n))}\n    assert (actual_marker_paths == expected_marker_paths)\n    (markers, dashes) = (['o', 's', 'd'], [(1, 0), (1, 1), (2, 1, 3, 1)])\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for (key, mark, dash) in zip(m.levels, markers, dashes):\n        assert (m(key, 'marker') == mark)\n        assert (m(key, 'dashes') == dash)\n    markers = dict(zip(p.plot_data['style'].unique(), markers))\n    dashes = dict(zip(p.plot_data['style'].unique(), dashes))\n    m = StyleMapping(p, markers=markers, dashes=dashes)\n    for key in m.levels:\n        assert (m(key, 'marker') == markers[key])\n        assert (m(key, 'dashes') == dashes[key])\n    p = VectorPlotter(data=long_df, variables=dict(x='x', style='a_cat'))\n    m = StyleMapping(p)\n    assert (m.levels == long_df['a_cat'].cat.categories.to_list())\n    order = p.plot_data['style'].unique()[[1, 2, 0]]\n    m = StyleMapping(p, markers=True, dashes=True, order=order)\n    n = len(order)\n    for (key, mark, dash) in zip(order, unique_markers(n), unique_dashes(n)):\n        assert (m(key, 'dashes') == dash)\n        assert (m(key, 'marker') == '???')\n        obj = mpl.markers.MarkerStyle(mark)\n        path = obj.get_path().transformed(obj.get_transform())\n        assert_array_equal(m(key, 'path').vertices, path.vertices)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=['o', 's'], dashes=False)\n    with pytest.warns(UserWarning):\n        StyleMapping(p, markers=False, dashes=[(2, 1)])\n    (markers, dashes) = ({'a': 'o', 'b': 's'}, False)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (False, {'a': (1, 0), 'b': (2, 1)})\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)\n    (markers, dashes) = (['o', 'x', 's'], None)\n    with pytest.raises(ValueError):\n        StyleMapping(p, markers=markers, dashes=dashes)", "ground_truth": "mark", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_210", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_flat_variables", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_flat_variables(self, flat_data):\n    p = VectorPlotter()\n    p.assign_variables(data=flat_data)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_data))\n    try:\n        expected_x = flat_data.index\n        expected_x_name = flat_data.index.name\n    except AttributeError:\n        expected_x = np.arange(len(flat_data))\n        expected_x_name = None\n    x = p.plot_data['x']\n    assert_array_equal(x, expected_x)\n    expected_y = flat_data\n    expected_y_name = getattr(flat_data, 'name', None)\n    y = p.plot_data['y']\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] == expected_x_name)\n    assert (p.variables['y'] == expected_y_name)", "masked_code": "def test_flat_variables(self, flat_data):\n    p = VectorPlotter()\n    p.assign_variables(data=flat_data)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_data))\n    try:\n        expected_x = flat_data.index\n        expected_x_name = flat_data.index.name\n    except AttributeError:\n        expected_x = np.arange(len(flat_data))\n        expected_x_name = None\n    x = p.plot_data['x']\n    assert_array_equal(x, expected_x)\n    expected_y = flat_data\n    expected_y_name = getattr(flat_data, 'name', None)\n    y = p.plot_data['y']\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] == expected_x_name)\n    assert (p.variables['y'] == expected_y_name)", "ground_truth": "'wide'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_211", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_flat_variables", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_flat_variables(self, flat_data):\n    p = VectorPlotter()\n    p.assign_variables(data=flat_data)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_data))\n    try:\n        expected_x = flat_data.index\n        expected_x_name = flat_data.index.name\n    except AttributeError:\n        expected_x = np.arange(len(flat_data))\n        expected_x_name = None\n    x = p.plot_data['x']\n    assert_array_equal(x, expected_x)\n    expected_y = flat_data\n    expected_y_name = getattr(flat_data, 'name', None)\n    y = p.plot_data['y']\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] == expected_x_name)\n    assert (p.variables['y'] == expected_y_name)", "masked_code": "def test_flat_variables(self, flat_data):\n    p = VectorPlotter()\n    p.assign_variables(data=flat_data)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == '???')\n    assert (len(p.plot_data) == len(flat_data))\n    try:\n        expected_x = flat_data.index\n        expected_x_name = flat_data.index.name\n    except AttributeError:\n        expected_x = np.arange(len(flat_data))\n        expected_x_name = None\n    x = p.plot_data['x']\n    assert_array_equal(x, expected_x)\n    expected_y = flat_data\n    expected_y_name = getattr(flat_data, 'name', None)\n    y = p.plot_data['y']\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] == expected_x_name)\n    assert (p.variables['y'] == expected_y_name)", "ground_truth": "['x', 'y']", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_212", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_flat_variables", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_flat_variables(self, flat_data):\n    p = VectorPlotter()\n    p.assign_variables(data=flat_data)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_data))\n    try:\n        expected_x = flat_data.index\n        expected_x_name = flat_data.index.name\n    except AttributeError:\n        expected_x = np.arange(len(flat_data))\n        expected_x_name = None\n    x = p.plot_data['x']\n    assert_array_equal(x, expected_x)\n    expected_y = flat_data\n    expected_y_name = getattr(flat_data, 'name', None)\n    y = p.plot_data['y']\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] == expected_x_name)\n    assert (p.variables['y'] == expected_y_name)", "masked_code": "def test_flat_variables(self, flat_data):\n    p = VectorPlotter()\n    p.assign_variables(data=flat_data)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == '???')\n    try:\n        expected_x = flat_data.index\n        expected_x_name = flat_data.index.name\n    except AttributeError:\n        expected_x = np.arange(len(flat_data))\n        expected_x_name = None\n    x = p.plot_data['x']\n    assert_array_equal(x, expected_x)\n    expected_y = flat_data\n    expected_y_name = getattr(flat_data, 'name', None)\n    y = p.plot_data['y']\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] == expected_x_name)\n    assert (p.variables['y'] == expected_y_name)", "ground_truth": "len(flat_data)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_213", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_flat_variables", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_flat_variables(self, flat_data):\n    p = VectorPlotter()\n    p.assign_variables(data=flat_data)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_data))\n    try:\n        expected_x = flat_data.index\n        expected_x_name = flat_data.index.name\n    except AttributeError:\n        expected_x = np.arange(len(flat_data))\n        expected_x_name = None\n    x = p.plot_data['x']\n    assert_array_equal(x, expected_x)\n    expected_y = flat_data\n    expected_y_name = getattr(flat_data, 'name', None)\n    y = p.plot_data['y']\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] == expected_x_name)\n    assert (p.variables['y'] == expected_y_name)", "masked_code": "def test_flat_variables(self, flat_data):\n    p = VectorPlotter()\n    p.assign_variables(data=flat_data)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_data))\n    try:\n        expected_x = flat_data.index\n        expected_x_name = flat_data.index.name\n    except AttributeError:\n        expected_x = np.arange(len(flat_data))\n        expected_x_name = None\n    x = p.plot_data['x']\n    assert_array_equal(x, expected_x)\n    expected_y = flat_data\n    expected_y_name = getattr(flat_data, 'name', None)\n    y = p.plot_data['y']\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] == '???')\n    assert (p.variables['y'] == expected_y_name)", "ground_truth": "expected_x_name", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_214", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_flat_variables", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_flat_variables(self, flat_data):\n    p = VectorPlotter()\n    p.assign_variables(data=flat_data)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_data))\n    try:\n        expected_x = flat_data.index\n        expected_x_name = flat_data.index.name\n    except AttributeError:\n        expected_x = np.arange(len(flat_data))\n        expected_x_name = None\n    x = p.plot_data['x']\n    assert_array_equal(x, expected_x)\n    expected_y = flat_data\n    expected_y_name = getattr(flat_data, 'name', None)\n    y = p.plot_data['y']\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] == expected_x_name)\n    assert (p.variables['y'] == expected_y_name)", "masked_code": "def test_flat_variables(self, flat_data):\n    p = VectorPlotter()\n    p.assign_variables(data=flat_data)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_data))\n    try:\n        expected_x = flat_data.index\n        expected_x_name = flat_data.index.name\n    except AttributeError:\n        expected_x = np.arange(len(flat_data))\n        expected_x_name = None\n    x = p.plot_data['x']\n    assert_array_equal(x, expected_x)\n    expected_y = flat_data\n    expected_y_name = getattr(flat_data, 'name', None)\n    y = p.plot_data['y']\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] == expected_x_name)\n    assert (p.variables['y'] == '???')", "ground_truth": "expected_y_name", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_215", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_long_df", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_long_df(self, long_df, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_df, variables=long_variables)\n    assert (p.input_format == 'long')\n    assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "masked_code": "def test_long_df(self, long_df, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_df, variables=long_variables)\n    assert (p.input_format == '???')\n    assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "ground_truth": "'long'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_216", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_long_df", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_long_df(self, long_df, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_df, variables=long_variables)\n    assert (p.input_format == 'long')\n    assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "masked_code": "def test_long_df(self, long_df, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_df, variables=long_variables)\n    assert (p.input_format == 'long')\n    assert (p.variables == '???')\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "ground_truth": "long_variables", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_217", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_long_df_with_index", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_long_df_with_index(self, long_df, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_df.set_index('a'), variables=long_variables)\n    assert (p.input_format == 'long')\n    assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "masked_code": "def test_long_df_with_index(self, long_df, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_df.set_index('a'), variables=long_variables)\n    assert (p.input_format == '???')\n    assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "ground_truth": "'long'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_218", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_long_df_with_index", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_long_df_with_index(self, long_df, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_df.set_index('a'), variables=long_variables)\n    assert (p.input_format == 'long')\n    assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "masked_code": "def test_long_df_with_index(self, long_df, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_df.set_index('a'), variables=long_variables)\n    assert (p.input_format == 'long')\n    assert (p.variables == '???')\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "ground_truth": "long_variables", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_219", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_long_df_with_multiindex", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_long_df_with_multiindex(self, long_df, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_df.set_index(['a', 'x']), variables=long_variables)\n    assert (p.input_format == 'long')\n    assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "masked_code": "def test_long_df_with_multiindex(self, long_df, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_df.set_index(['a', 'x']), variables=long_variables)\n    assert (p.input_format == '???')\n    assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "ground_truth": "'long'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_220", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_long_df_with_multiindex", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_long_df_with_multiindex(self, long_df, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_df.set_index(['a', 'x']), variables=long_variables)\n    assert (p.input_format == 'long')\n    assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "masked_code": "def test_long_df_with_multiindex(self, long_df, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_df.set_index(['a', 'x']), variables=long_variables)\n    assert (p.input_format == 'long')\n    assert (p.variables == '???')\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "ground_truth": "long_variables", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_221", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_long_dict", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_long_dict(self, long_dict, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_dict, variables=long_variables)\n    assert (p.input_format == 'long')\n    assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], pd.Series(long_dict[val]))", "masked_code": "def test_long_dict(self, long_dict, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_dict, variables=long_variables)\n    assert (p.input_format == '???')\n    assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], pd.Series(long_dict[val]))", "ground_truth": "'long'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_222", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_long_dict", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_long_dict(self, long_dict, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_dict, variables=long_variables)\n    assert (p.input_format == 'long')\n    assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], pd.Series(long_dict[val]))", "masked_code": "def test_long_dict(self, long_dict, long_variables):\n    p = VectorPlotter()\n    p.assign_variables(data=long_dict, variables=long_variables)\n    assert (p.input_format == 'long')\n    assert (p.variables == '???')\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], pd.Series(long_dict[val]))", "ground_truth": "long_variables", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_223", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_long_vectors", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_long_vectors(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = VectorPlotter()\n    p.assign_variables(variables=variables)\n    assert (p.input_format == 'long')\n    assert (list(p.variables) == list(long_variables))\n    if (vector_type == 'series'):\n        assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "masked_code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_long_vectors(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = VectorPlotter()\n    p.assign_variables(variables=variables)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == list(long_variables))\n    if (vector_type == 'series'):\n        assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "ground_truth": "'long'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_224", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_long_vectors", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_long_vectors(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = VectorPlotter()\n    p.assign_variables(variables=variables)\n    assert (p.input_format == 'long')\n    assert (list(p.variables) == list(long_variables))\n    if (vector_type == 'series'):\n        assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "masked_code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_long_vectors(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = VectorPlotter()\n    p.assign_variables(variables=variables)\n    assert (p.input_format == 'long')\n    assert (list(p.variables) == '???')\n    if (vector_type == 'series'):\n        assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "ground_truth": "list(long_variables)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_225", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_long_vectors", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_long_vectors(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = VectorPlotter()\n    p.assign_variables(variables=variables)\n    assert (p.input_format == 'long')\n    assert (list(p.variables) == list(long_variables))\n    if (vector_type == 'series'):\n        assert (p.variables == long_variables)\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "masked_code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_long_vectors(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = VectorPlotter()\n    p.assign_variables(variables=variables)\n    assert (p.input_format == 'long')\n    assert (list(p.variables) == list(long_variables))\n    if (vector_type == 'series'):\n        assert (p.variables == '???')\n    for (key, val) in long_variables.items():\n        assert_array_equal(p.plot_data[key], long_df[val])", "ground_truth": "long_variables", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_226", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_long_numeric_name", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "@pytest.mark.parametrize('name', [3, 4.5])\ndef test_long_numeric_name(self, long_df, name):\n    long_df[name] = long_df['x']\n    p = VectorPlotter()\n    p.assign_variables(data=long_df, variables={'x': name})\n    assert_array_equal(p.plot_data['x'], long_df[name])\n    assert (p.variables['x'] == str(name))", "masked_code": "@pytest.mark.parametrize('name', [3, 4.5])\ndef test_long_numeric_name(self, long_df, name):\n    long_df[name] = long_df['x']\n    p = VectorPlotter()\n    p.assign_variables(data=long_df, variables={'x': name})\n    assert_array_equal(p.plot_data['x'], long_df[name])\n    assert (p.variables['x'] == '???')", "ground_truth": "str(name)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_227", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_long_hierarchical_index", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_long_hierarchical_index(self, rng):\n    cols = pd.MultiIndex.from_product([['a'], ['x', 'y']])\n    data = rng.uniform(size=(50, 2))\n    df = pd.DataFrame(data, columns=cols)\n    name = ('a', 'y')\n    var = 'y'\n    p = VectorPlotter()\n    p.assign_variables(data=df, variables={var: name})\n    assert_array_equal(p.plot_data[var], df[name])\n    assert (p.variables[var] == str(name))", "masked_code": "def test_long_hierarchical_index(self, rng):\n    cols = pd.MultiIndex.from_product([['a'], ['x', 'y']])\n    data = rng.uniform(size=(50, 2))\n    df = pd.DataFrame(data, columns=cols)\n    name = ('a', 'y')\n    var = 'y'\n    p = VectorPlotter()\n    p.assign_variables(data=df, variables={var: name})\n    assert_array_equal(p.plot_data[var], df[name])\n    assert (p.variables[var] == '???')", "ground_truth": "str(name)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_228", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_quantitites", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == n_subsets)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == n_subsets)\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)", "masked_code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == n_subsets)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == '???')\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == n_subsets)\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)", "ground_truth": "n_subsets", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_229", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_quantitites", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == n_subsets)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == n_subsets)\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)", "masked_code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == n_subsets)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == '???')\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == n_subsets)\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)", "ground_truth": "n_subsets", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_230", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_quantitites", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == n_subsets)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == n_subsets)\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)", "masked_code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == n_subsets)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == '???')\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)", "ground_truth": "n_subsets", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_231", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_quantitites", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == n_subsets)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == n_subsets)\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)", "masked_code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == n_subsets)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == n_subsets)\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == '???')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)", "ground_truth": "n_subsets", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_232", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_quantitites", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == n_subsets)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == n_subsets)\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)", "masked_code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == n_subsets)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == n_subsets)\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == '???')\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)", "ground_truth": "n_subsets", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_233", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_quantitites", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == n_subsets)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == n_subsets)\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)", "masked_code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == n_subsets)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == n_subsets)\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == '???')", "ground_truth": "n_subsets", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_234", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_quantitites", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == n_subsets)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == n_subsets)\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)", "masked_code": "def test_iter_data_quantitites(self, long_df):\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    out = p.iter_data('hue')\n    assert (len(list(out)) == 1)\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    semantics = ['hue', 'size', 'style']\n    for semantic in semantics:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', semantic: var})\n        getattr(p, f'map_{semantic}')()\n        out = p.iter_data(semantics)\n        assert (len(list(out)) == '???')\n    var = 'a'\n    n_subsets = len(long_df[var].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    out = p.iter_data(semantics, reverse=True)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2) = ('a', 's')\n    n_subsets = len(long_df[var1].unique())\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(['hue'])\n    assert (len(list(out)) == n_subsets)\n    n_subsets = len(set(list(map(tuple, long_df[[var1, var2]].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, style=var2))\n    p.map_hue()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var1))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)\n    (var1, var2, var3) = ('a', 's', 'b')\n    cols = [var1, var2, var3]\n    n_subsets = len(set(list(map(tuple, long_df[cols].values))))\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2, style=var3))\n    p.map_hue()\n    p.map_size()\n    p.map_style()\n    out = p.iter_data(semantics)\n    assert (len(list(out)) == n_subsets)", "ground_truth": "n_subsets", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_235", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_keys", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_keys(self, long_df):\n    semantics = ['hue', 'size', 'style']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (sub_vars == {})\n    var = 'a'\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue'])\n        assert (sub_vars['hue'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size=var))\n    for (sub_vars, _) in p.iter_data('size'):\n        assert (list(sub_vars) == ['size'])\n        assert (sub_vars['size'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'style'])\n        assert (sub_vars['hue'] in long_df[var].values)\n        assert (sub_vars['style'] in long_df[var].values)\n        assert (sub_vars['hue'] == sub_vars['style'])\n    (var1, var2) = ('a', 's')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'size'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['size'] in long_df[var2].values)\n    semantics = ['hue', 'col', 'row']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, col=var2))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue', 'col'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['col'] in long_df[var2].values)", "masked_code": "def test_iter_data_keys(self, long_df):\n    semantics = ['hue', 'size', 'style']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (sub_vars == {})\n    var = 'a'\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == '???')\n        assert (sub_vars['hue'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size=var))\n    for (sub_vars, _) in p.iter_data('size'):\n        assert (list(sub_vars) == ['size'])\n        assert (sub_vars['size'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'style'])\n        assert (sub_vars['hue'] in long_df[var].values)\n        assert (sub_vars['style'] in long_df[var].values)\n        assert (sub_vars['hue'] == sub_vars['style'])\n    (var1, var2) = ('a', 's')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'size'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['size'] in long_df[var2].values)\n    semantics = ['hue', 'col', 'row']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, col=var2))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue', 'col'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['col'] in long_df[var2].values)", "ground_truth": "['hue']", "quality_analysis": {"complexity_score": 7, "left_complexity": 4, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_236", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_keys", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_keys(self, long_df):\n    semantics = ['hue', 'size', 'style']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (sub_vars == {})\n    var = 'a'\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue'])\n        assert (sub_vars['hue'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size=var))\n    for (sub_vars, _) in p.iter_data('size'):\n        assert (list(sub_vars) == ['size'])\n        assert (sub_vars['size'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'style'])\n        assert (sub_vars['hue'] in long_df[var].values)\n        assert (sub_vars['style'] in long_df[var].values)\n        assert (sub_vars['hue'] == sub_vars['style'])\n    (var1, var2) = ('a', 's')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'size'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['size'] in long_df[var2].values)\n    semantics = ['hue', 'col', 'row']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, col=var2))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue', 'col'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['col'] in long_df[var2].values)", "masked_code": "def test_iter_data_keys(self, long_df):\n    semantics = ['hue', 'size', 'style']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (sub_vars == {})\n    var = 'a'\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue'])\n        assert (sub_vars['hue'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size=var))\n    for (sub_vars, _) in p.iter_data('size'):\n        assert (list(sub_vars) == '???')\n        assert (sub_vars['size'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'style'])\n        assert (sub_vars['hue'] in long_df[var].values)\n        assert (sub_vars['style'] in long_df[var].values)\n        assert (sub_vars['hue'] == sub_vars['style'])\n    (var1, var2) = ('a', 's')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'size'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['size'] in long_df[var2].values)\n    semantics = ['hue', 'col', 'row']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, col=var2))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue', 'col'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['col'] in long_df[var2].values)", "ground_truth": "['size']", "quality_analysis": {"complexity_score": 7, "left_complexity": 4, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_237", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_keys", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_keys(self, long_df):\n    semantics = ['hue', 'size', 'style']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (sub_vars == {})\n    var = 'a'\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue'])\n        assert (sub_vars['hue'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size=var))\n    for (sub_vars, _) in p.iter_data('size'):\n        assert (list(sub_vars) == ['size'])\n        assert (sub_vars['size'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'style'])\n        assert (sub_vars['hue'] in long_df[var].values)\n        assert (sub_vars['style'] in long_df[var].values)\n        assert (sub_vars['hue'] == sub_vars['style'])\n    (var1, var2) = ('a', 's')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'size'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['size'] in long_df[var2].values)\n    semantics = ['hue', 'col', 'row']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, col=var2))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue', 'col'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['col'] in long_df[var2].values)", "masked_code": "def test_iter_data_keys(self, long_df):\n    semantics = ['hue', 'size', 'style']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (sub_vars == {})\n    var = 'a'\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue'])\n        assert (sub_vars['hue'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size=var))\n    for (sub_vars, _) in p.iter_data('size'):\n        assert (list(sub_vars) == ['size'])\n        assert (sub_vars['size'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == '???')\n        assert (sub_vars['hue'] in long_df[var].values)\n        assert (sub_vars['style'] in long_df[var].values)\n        assert (sub_vars['hue'] == sub_vars['style'])\n    (var1, var2) = ('a', 's')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'size'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['size'] in long_df[var2].values)\n    semantics = ['hue', 'col', 'row']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, col=var2))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue', 'col'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['col'] in long_df[var2].values)", "ground_truth": "['hue', 'style']", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_238", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_keys", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_keys(self, long_df):\n    semantics = ['hue', 'size', 'style']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (sub_vars == {})\n    var = 'a'\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue'])\n        assert (sub_vars['hue'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size=var))\n    for (sub_vars, _) in p.iter_data('size'):\n        assert (list(sub_vars) == ['size'])\n        assert (sub_vars['size'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'style'])\n        assert (sub_vars['hue'] in long_df[var].values)\n        assert (sub_vars['style'] in long_df[var].values)\n        assert (sub_vars['hue'] == sub_vars['style'])\n    (var1, var2) = ('a', 's')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'size'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['size'] in long_df[var2].values)\n    semantics = ['hue', 'col', 'row']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, col=var2))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue', 'col'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['col'] in long_df[var2].values)", "masked_code": "def test_iter_data_keys(self, long_df):\n    semantics = ['hue', 'size', 'style']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (sub_vars == {})\n    var = 'a'\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue'])\n        assert (sub_vars['hue'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size=var))\n    for (sub_vars, _) in p.iter_data('size'):\n        assert (list(sub_vars) == ['size'])\n        assert (sub_vars['size'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'style'])\n        assert (sub_vars['hue'] in long_df[var].values)\n        assert (sub_vars['style'] in long_df[var].values)\n        assert (sub_vars['hue'] == '???')\n    (var1, var2) = ('a', 's')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'size'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['size'] in long_df[var2].values)\n    semantics = ['hue', 'col', 'row']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, col=var2))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue', 'col'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['col'] in long_df[var2].values)", "ground_truth": "sub_vars['style']", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_239", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_keys", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_keys(self, long_df):\n    semantics = ['hue', 'size', 'style']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (sub_vars == {})\n    var = 'a'\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue'])\n        assert (sub_vars['hue'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size=var))\n    for (sub_vars, _) in p.iter_data('size'):\n        assert (list(sub_vars) == ['size'])\n        assert (sub_vars['size'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'style'])\n        assert (sub_vars['hue'] in long_df[var].values)\n        assert (sub_vars['style'] in long_df[var].values)\n        assert (sub_vars['hue'] == sub_vars['style'])\n    (var1, var2) = ('a', 's')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'size'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['size'] in long_df[var2].values)\n    semantics = ['hue', 'col', 'row']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, col=var2))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue', 'col'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['col'] in long_df[var2].values)", "masked_code": "def test_iter_data_keys(self, long_df):\n    semantics = ['hue', 'size', 'style']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (sub_vars == {})\n    var = 'a'\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue'])\n        assert (sub_vars['hue'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size=var))\n    for (sub_vars, _) in p.iter_data('size'):\n        assert (list(sub_vars) == ['size'])\n        assert (sub_vars['size'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'style'])\n        assert (sub_vars['hue'] in long_df[var].values)\n        assert (sub_vars['style'] in long_df[var].values)\n        assert (sub_vars['hue'] == sub_vars['style'])\n    (var1, var2) = ('a', 's')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == '???')\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['size'] in long_df[var2].values)\n    semantics = ['hue', 'col', 'row']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, col=var2))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue', 'col'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['col'] in long_df[var2].values)", "ground_truth": "['hue', 'size']", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_240", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_keys", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_keys(self, long_df):\n    semantics = ['hue', 'size', 'style']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (sub_vars == {})\n    var = 'a'\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue'])\n        assert (sub_vars['hue'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size=var))\n    for (sub_vars, _) in p.iter_data('size'):\n        assert (list(sub_vars) == ['size'])\n        assert (sub_vars['size'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'style'])\n        assert (sub_vars['hue'] in long_df[var].values)\n        assert (sub_vars['style'] in long_df[var].values)\n        assert (sub_vars['hue'] == sub_vars['style'])\n    (var1, var2) = ('a', 's')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'size'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['size'] in long_df[var2].values)\n    semantics = ['hue', 'col', 'row']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, col=var2))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue', 'col'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['col'] in long_df[var2].values)", "masked_code": "def test_iter_data_keys(self, long_df):\n    semantics = ['hue', 'size', 'style']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (sub_vars == {})\n    var = 'a'\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == ['hue'])\n        assert (sub_vars['hue'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', size=var))\n    for (sub_vars, _) in p.iter_data('size'):\n        assert (list(sub_vars) == ['size'])\n        assert (sub_vars['size'] in long_df[var].values)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var, style=var))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'style'])\n        assert (sub_vars['hue'] in long_df[var].values)\n        assert (sub_vars['style'] in long_df[var].values)\n        assert (sub_vars['hue'] == sub_vars['style'])\n    (var1, var2) = ('a', 's')\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, size=var2))\n    for (sub_vars, _) in p.iter_data(semantics):\n        assert (list(sub_vars) == ['hue', 'size'])\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['size'] in long_df[var2].values)\n    semantics = ['hue', 'col', 'row']\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue=var1, col=var2))\n    for (sub_vars, _) in p.iter_data('hue'):\n        assert (list(sub_vars) == '???')\n        assert (sub_vars['hue'] in long_df[var1].values)\n        assert (sub_vars['col'] in long_df[var2].values)", "ground_truth": "['hue', 'col']", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_241", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_iter_data_reverse", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_iter_data_reverse(self, long_df):\n    reversed_order = categorical_order(long_df['a'])[::(- 1)]\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    iterator = p.iter_data('hue', reverse=True)\n    for (i, (sub_vars, _)) in enumerate(iterator):\n        assert (sub_vars['hue'] == reversed_order[i])", "masked_code": "def test_iter_data_reverse(self, long_df):\n    reversed_order = categorical_order(long_df['a'])[::(- 1)]\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    iterator = p.iter_data('hue', reverse=True)\n    for (i, (sub_vars, _)) in enumerate(iterator):\n        assert (sub_vars['hue'] == '???')", "ground_truth": "reversed_order[i]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_242", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_axis_labels", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_axis_labels(self, long_df):\n    (f, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == '')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax, default_y='default')\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == 'default')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax, default_x='default', default_y='default')\n    assert (ax.get_xlabel() == 'default')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='a'))\n    ax.set(xlabel='existing', ylabel='also existing')\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'existing')\n    assert (ax.get_ylabel() == 'also existing')\n    (f, (ax1, ax2)) = plt.subplots(1, 2, sharey=True)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    p._add_axis_labels(ax1)\n    p._add_axis_labels(ax2)\n    assert (ax1.get_xlabel() == 'x')\n    assert (ax1.get_ylabel() == 'y')\n    assert ax1.yaxis.label.get_visible()\n    assert (ax2.get_xlabel() == 'x')\n    assert (ax2.get_ylabel() == 'y')\n    assert (not ax2.yaxis.label.get_visible())", "masked_code": "def test_axis_labels(self, long_df):\n    (f, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == '')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax, default_y='default')\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == '???')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax, default_x='default', default_y='default')\n    assert (ax.get_xlabel() == 'default')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='a'))\n    ax.set(xlabel='existing', ylabel='also existing')\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'existing')\n    assert (ax.get_ylabel() == 'also existing')\n    (f, (ax1, ax2)) = plt.subplots(1, 2, sharey=True)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    p._add_axis_labels(ax1)\n    p._add_axis_labels(ax2)\n    assert (ax1.get_xlabel() == 'x')\n    assert (ax1.get_ylabel() == 'y')\n    assert ax1.yaxis.label.get_visible()\n    assert (ax2.get_xlabel() == 'x')\n    assert (ax2.get_ylabel() == 'y')\n    assert (not ax2.yaxis.label.get_visible())", "ground_truth": "'default'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_243", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_axis_labels", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_axis_labels(self, long_df):\n    (f, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == '')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax, default_y='default')\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == 'default')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax, default_x='default', default_y='default')\n    assert (ax.get_xlabel() == 'default')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='a'))\n    ax.set(xlabel='existing', ylabel='also existing')\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'existing')\n    assert (ax.get_ylabel() == 'also existing')\n    (f, (ax1, ax2)) = plt.subplots(1, 2, sharey=True)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    p._add_axis_labels(ax1)\n    p._add_axis_labels(ax2)\n    assert (ax1.get_xlabel() == 'x')\n    assert (ax1.get_ylabel() == 'y')\n    assert ax1.yaxis.label.get_visible()\n    assert (ax2.get_xlabel() == 'x')\n    assert (ax2.get_ylabel() == 'y')\n    assert (not ax2.yaxis.label.get_visible())", "masked_code": "def test_axis_labels(self, long_df):\n    (f, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == '')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax, default_y='default')\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == 'default')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax, default_x='default', default_y='default')\n    assert (ax.get_xlabel() == '???')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='a'))\n    ax.set(xlabel='existing', ylabel='also existing')\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'existing')\n    assert (ax.get_ylabel() == 'also existing')\n    (f, (ax1, ax2)) = plt.subplots(1, 2, sharey=True)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    p._add_axis_labels(ax1)\n    p._add_axis_labels(ax2)\n    assert (ax1.get_xlabel() == 'x')\n    assert (ax1.get_ylabel() == 'y')\n    assert ax1.yaxis.label.get_visible()\n    assert (ax2.get_xlabel() == 'x')\n    assert (ax2.get_ylabel() == 'y')\n    assert (not ax2.yaxis.label.get_visible())", "ground_truth": "'default'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_244", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_axis_labels", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_axis_labels(self, long_df):\n    (f, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == '')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax, default_y='default')\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == 'default')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax, default_x='default', default_y='default')\n    assert (ax.get_xlabel() == 'default')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='a'))\n    ax.set(xlabel='existing', ylabel='also existing')\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'existing')\n    assert (ax.get_ylabel() == 'also existing')\n    (f, (ax1, ax2)) = plt.subplots(1, 2, sharey=True)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    p._add_axis_labels(ax1)\n    p._add_axis_labels(ax2)\n    assert (ax1.get_xlabel() == 'x')\n    assert (ax1.get_ylabel() == 'y')\n    assert ax1.yaxis.label.get_visible()\n    assert (ax2.get_xlabel() == 'x')\n    assert (ax2.get_ylabel() == 'y')\n    assert (not ax2.yaxis.label.get_visible())", "masked_code": "def test_axis_labels(self, long_df):\n    (f, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == '')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax, default_y='default')\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == 'default')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax, default_x='default', default_y='default')\n    assert (ax.get_xlabel() == 'default')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='a'))\n    ax.set(xlabel='existing', ylabel='also existing')\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == '???')\n    assert (ax.get_ylabel() == 'also existing')\n    (f, (ax1, ax2)) = plt.subplots(1, 2, sharey=True)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    p._add_axis_labels(ax1)\n    p._add_axis_labels(ax2)\n    assert (ax1.get_xlabel() == 'x')\n    assert (ax1.get_ylabel() == 'y')\n    assert ax1.yaxis.label.get_visible()\n    assert (ax2.get_xlabel() == 'x')\n    assert (ax2.get_ylabel() == 'y')\n    assert (not ax2.yaxis.label.get_visible())", "ground_truth": "'existing'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_245", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_axis_labels", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_axis_labels(self, long_df):\n    (f, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == '')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax, default_y='default')\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == 'default')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax, default_x='default', default_y='default')\n    assert (ax.get_xlabel() == 'default')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='a'))\n    ax.set(xlabel='existing', ylabel='also existing')\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'existing')\n    assert (ax.get_ylabel() == 'also existing')\n    (f, (ax1, ax2)) = plt.subplots(1, 2, sharey=True)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    p._add_axis_labels(ax1)\n    p._add_axis_labels(ax2)\n    assert (ax1.get_xlabel() == 'x')\n    assert (ax1.get_ylabel() == 'y')\n    assert ax1.yaxis.label.get_visible()\n    assert (ax2.get_xlabel() == 'x')\n    assert (ax2.get_ylabel() == 'y')\n    assert (not ax2.yaxis.label.get_visible())", "masked_code": "def test_axis_labels(self, long_df):\n    (f, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == '')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='a'))\n    p._add_axis_labels(ax, default_y='default')\n    assert (ax.get_xlabel() == 'a')\n    assert (ax.get_ylabel() == 'default')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(y='a'))\n    p._add_axis_labels(ax, default_x='default', default_y='default')\n    assert (ax.get_xlabel() == 'default')\n    assert (ax.get_ylabel() == 'a')\n    ax.clear()\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='a'))\n    ax.set(xlabel='existing', ylabel='also existing')\n    p._add_axis_labels(ax)\n    assert (ax.get_xlabel() == 'existing')\n    assert (ax.get_ylabel() == '???')\n    (f, (ax1, ax2)) = plt.subplots(1, 2, sharey=True)\n    p = VectorPlotter(data=long_df, variables=dict(x='x', y='y'))\n    p._add_axis_labels(ax1)\n    p._add_axis_labels(ax2)\n    assert (ax1.get_xlabel() == 'x')\n    assert (ax1.get_ylabel() == 'y')\n    assert ax1.yaxis.label.get_visible()\n    assert (ax2.get_xlabel() == 'x')\n    assert (ax2.get_ylabel() == 'y')\n    assert (not ax2.yaxis.label.get_visible())", "ground_truth": "'also existing'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_246", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == '???')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_247", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == '???')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'linear'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_248", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == '???')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_249", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == '???')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'linear'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_250", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == '???')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'linear'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_251", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == '???')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_252", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == '???')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_253", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == '???')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_254", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == '???')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_255", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == '???')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'linear'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_256", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == '???')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'linear'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_257", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == '???')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_258", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == '???')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'linear'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_259", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == '???')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_260", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == '???')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_261", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == '???')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'linear'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_262", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == '???')\n    assert (ax.yaxis.get_scale() == 'linear')", "ground_truth": "'linear'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_263", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_log_scale", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'linear')", "masked_code": "def test_attach_log_scale(self, long_df):\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p._attach(ax, log_scale=2)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(True, False))\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(ax, log_scale=(False, 2))\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'y'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == 'log')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 't'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'log')\n    assert (ax.yaxis.get_scale() == 'linear')\n    (_, ax) = plt.subplots()\n    p = VectorPlotter(data=long_df, variables={'x': 'a', 'y': 'b'})\n    p._attach(ax, log_scale=True)\n    assert (ax.xaxis.get_scale() == 'linear')\n    assert (ax.yaxis.get_scale() == '???')", "ground_truth": "'linear'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_264", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_facets", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_facets(self, long_df):\n    g = FacetGrid(long_df, col='a')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'col': 'a'})\n    p._attach(g)\n    assert (p.ax is None)\n    assert (p.facets == g)", "masked_code": "def test_attach_facets(self, long_df):\n    g = FacetGrid(long_df, col='a')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'col': 'a'})\n    p._attach(g)\n    assert (p.ax is None)\n    assert (p.facets == '???')", "ground_truth": "g", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_265", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_shared_axes", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_shared_axes(self, long_df):\n    g = FacetGrid(long_df)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    g = FacetGrid(long_df, col='a')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False, col_wrap=2)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == len(g.axes.flat))\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex='col')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharey='row')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == p.plot_data['row'].nunique())\n    assert (p.converters['y'].groupby(p.plot_data['row']).nunique().max() == 1)", "masked_code": "def test_attach_shared_axes(self, long_df):\n    g = FacetGrid(long_df)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    g = FacetGrid(long_df, col='a')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == '???')\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False, col_wrap=2)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == len(g.axes.flat))\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex='col')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharey='row')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == p.plot_data['row'].nunique())\n    assert (p.converters['y'].groupby(p.plot_data['row']).nunique().max() == 1)", "ground_truth": "p.plot_data['col'].nunique()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_266", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_shared_axes", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_shared_axes(self, long_df):\n    g = FacetGrid(long_df)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    g = FacetGrid(long_df, col='a')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False, col_wrap=2)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == len(g.axes.flat))\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex='col')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharey='row')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == p.plot_data['row'].nunique())\n    assert (p.converters['y'].groupby(p.plot_data['row']).nunique().max() == 1)", "masked_code": "def test_attach_shared_axes(self, long_df):\n    g = FacetGrid(long_df)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    g = FacetGrid(long_df, col='a')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False, col_wrap=2)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == '???')\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == len(g.axes.flat))\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex='col')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharey='row')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == p.plot_data['row'].nunique())\n    assert (p.converters['y'].groupby(p.plot_data['row']).nunique().max() == 1)", "ground_truth": "p.plot_data['col'].nunique()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_267", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_shared_axes", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_shared_axes(self, long_df):\n    g = FacetGrid(long_df)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    g = FacetGrid(long_df, col='a')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False, col_wrap=2)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == len(g.axes.flat))\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex='col')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharey='row')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == p.plot_data['row'].nunique())\n    assert (p.converters['y'].groupby(p.plot_data['row']).nunique().max() == 1)", "masked_code": "def test_attach_shared_axes(self, long_df):\n    g = FacetGrid(long_df)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    g = FacetGrid(long_df, col='a')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False, col_wrap=2)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == '???')\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex='col')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharey='row')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == p.plot_data['row'].nunique())\n    assert (p.converters['y'].groupby(p.plot_data['row']).nunique().max() == 1)", "ground_truth": "len(g.axes.flat)", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_268", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_shared_axes", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_shared_axes(self, long_df):\n    g = FacetGrid(long_df)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    g = FacetGrid(long_df, col='a')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False, col_wrap=2)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == len(g.axes.flat))\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex='col')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharey='row')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == p.plot_data['row'].nunique())\n    assert (p.converters['y'].groupby(p.plot_data['row']).nunique().max() == 1)", "masked_code": "def test_attach_shared_axes(self, long_df):\n    g = FacetGrid(long_df)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    g = FacetGrid(long_df, col='a')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False, col_wrap=2)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == len(g.axes.flat))\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex='col')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == '???')\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharey='row')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == p.plot_data['row'].nunique())\n    assert (p.converters['y'].groupby(p.plot_data['row']).nunique().max() == 1)", "ground_truth": "p.plot_data['col'].nunique()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_269", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_attach_shared_axes", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_attach_shared_axes(self, long_df):\n    g = FacetGrid(long_df)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    g = FacetGrid(long_df, col='a')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False, col_wrap=2)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == len(g.axes.flat))\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex='col')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharey='row')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == p.plot_data['row'].nunique())\n    assert (p.converters['y'].groupby(p.plot_data['row']).nunique().max() == 1)", "masked_code": "def test_attach_shared_axes(self, long_df):\n    g = FacetGrid(long_df)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    g = FacetGrid(long_df, col='a')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', sharex=False, col_wrap=2)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex=False)\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == len(g.axes.flat))\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharex='col')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == p.plot_data['col'].nunique())\n    assert (p.converters['x'].groupby(p.plot_data['col']).nunique().max() == 1)\n    assert (p.converters['y'].nunique() == 1)\n    g = FacetGrid(long_df, col='a', row='b', sharey='row')\n    p = VectorPlotter(data=long_df, variables={'x': 'x', 'y': 'y', 'col': 'a', 'row': 'b'})\n    p._attach(g)\n    assert (p.converters['x'].nunique() == 1)\n    assert (p.converters['y'].nunique() == '???')\n    assert (p.converters['y'].groupby(p.plot_data['row']).nunique().max() == 1)", "ground_truth": "p.plot_data['row'].nunique()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_270", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_comp_data_missing", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_comp_data_missing(self, comp_data_missing_fixture):\n    (orig_data, comp_data) = comp_data_missing_fixture\n    p = VectorPlotter(variables={'x': orig_data})\n    ax = plt.figure().subplots()\n    p._attach(ax)\n    assert_array_equal(p.comp_data['x'], comp_data)\n    assert (p.comp_data['x'].dtype == 'float')", "masked_code": "def test_comp_data_missing(self, comp_data_missing_fixture):\n    (orig_data, comp_data) = comp_data_missing_fixture\n    p = VectorPlotter(variables={'x': orig_data})\n    ax = plt.figure().subplots()\n    p._attach(ax)\n    assert_array_equal(p.comp_data['x'], comp_data)\n    assert (p.comp_data['x'].dtype == '???')", "ground_truth": "'float'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_271", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_comp_data_nullable_dtype", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_comp_data_nullable_dtype(self):\n    x = pd.Series([1, 2, 3, 4], dtype='Int64')\n    p = VectorPlotter(variables={'x': x})\n    ax = plt.figure().subplots()\n    p._attach(ax)\n    assert_array_equal(p.comp_data['x'], x)\n    assert (p.comp_data['x'].dtype == 'float')", "masked_code": "def test_comp_data_nullable_dtype(self):\n    x = pd.Series([1, 2, 3, 4], dtype='Int64')\n    p = VectorPlotter(variables={'x': x})\n    ax = plt.figure().subplots()\n    p._attach(ax)\n    assert_array_equal(p.comp_data['x'], x)\n    assert (p.comp_data['x'].dtype == '???')", "ground_truth": "'float'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_272", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_var_order", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_var_order(self, long_df):\n    order = ['c', 'b', 'a']\n    for var in ['hue', 'size', 'style']:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', var: 'a'})\n        mapper = getattr(p, f'map_{var}')\n        mapper(order=order)\n        assert (p.var_levels[var] == order)", "masked_code": "def test_var_order(self, long_df):\n    order = ['c', 'b', 'a']\n    for var in ['hue', 'size', 'style']:\n        p = VectorPlotter(data=long_df, variables={'x': 'x', var: 'a'})\n        mapper = getattr(p, f'map_{var}')\n        mapper(order=order)\n        assert (p.var_levels[var] == '???')", "ground_truth": "order", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_273", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_scale_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_scale_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p.scale_categorical('y')\n    assert (p.variables['y'] is None)\n    assert (p.var_types['y'] == 'categorical')\n    assert (p.plot_data['y'] == '').all()\n    p = VectorPlotter(data=long_df, variables={'x': 's'})\n    p.scale_categorical('x')\n    assert (p.var_types['x'] == 'categorical')\n    assert hasattr(p.plot_data['x'], 'str')\n    assert (not p._var_ordered['x'])\n    assert p.plot_data['x'].is_monotonic_increasing\n    assert_array_equal(p.var_levels['x'], p.plot_data['x'].unique())\n    p = VectorPlotter(data=long_df, variables={'x': 'a'})\n    p.scale_categorical('x')\n    assert (not p._var_ordered['x'])\n    assert_array_equal(p.var_levels['x'], categorical_order(long_df['a']))\n    p = VectorPlotter(data=long_df, variables={'x': 'a_cat'})\n    p.scale_categorical('x')\n    assert p._var_ordered['x']\n    assert_array_equal(p.var_levels['x'], categorical_order(long_df['a_cat']))\n    p = VectorPlotter(data=long_df, variables={'x': 'a'})\n    order = np.roll(long_df['a'].unique(), 1)\n    p.scale_categorical('x', order=order)\n    assert p._var_ordered['x']\n    assert_array_equal(p.var_levels['x'], order)\n    p = VectorPlotter(data=long_df, variables={'x': 's'})\n    p.scale_categorical('x', formatter=(lambda x: f'{x:%}'))\n    assert p.plot_data['x'].str.endswith('%').all()\n    assert all((s.endswith('%') for s in p.var_levels['x']))", "masked_code": "def test_scale_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p.scale_categorical('y')\n    assert (p.variables['y'] is None)\n    assert (p.var_types['y'] == '???')\n    assert (p.plot_data['y'] == '').all()\n    p = VectorPlotter(data=long_df, variables={'x': 's'})\n    p.scale_categorical('x')\n    assert (p.var_types['x'] == 'categorical')\n    assert hasattr(p.plot_data['x'], 'str')\n    assert (not p._var_ordered['x'])\n    assert p.plot_data['x'].is_monotonic_increasing\n    assert_array_equal(p.var_levels['x'], p.plot_data['x'].unique())\n    p = VectorPlotter(data=long_df, variables={'x': 'a'})\n    p.scale_categorical('x')\n    assert (not p._var_ordered['x'])\n    assert_array_equal(p.var_levels['x'], categorical_order(long_df['a']))\n    p = VectorPlotter(data=long_df, variables={'x': 'a_cat'})\n    p.scale_categorical('x')\n    assert p._var_ordered['x']\n    assert_array_equal(p.var_levels['x'], categorical_order(long_df['a_cat']))\n    p = VectorPlotter(data=long_df, variables={'x': 'a'})\n    order = np.roll(long_df['a'].unique(), 1)\n    p.scale_categorical('x', order=order)\n    assert p._var_ordered['x']\n    assert_array_equal(p.var_levels['x'], order)\n    p = VectorPlotter(data=long_df, variables={'x': 's'})\n    p.scale_categorical('x', formatter=(lambda x: f'{x:%}'))\n    assert p.plot_data['x'].str.endswith('%').all()\n    assert all((s.endswith('%') for s in p.var_levels['x']))", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_274", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestVectorPlotter", "funcname": "test_scale_categorical", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_scale_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p.scale_categorical('y')\n    assert (p.variables['y'] is None)\n    assert (p.var_types['y'] == 'categorical')\n    assert (p.plot_data['y'] == '').all()\n    p = VectorPlotter(data=long_df, variables={'x': 's'})\n    p.scale_categorical('x')\n    assert (p.var_types['x'] == 'categorical')\n    assert hasattr(p.plot_data['x'], 'str')\n    assert (not p._var_ordered['x'])\n    assert p.plot_data['x'].is_monotonic_increasing\n    assert_array_equal(p.var_levels['x'], p.plot_data['x'].unique())\n    p = VectorPlotter(data=long_df, variables={'x': 'a'})\n    p.scale_categorical('x')\n    assert (not p._var_ordered['x'])\n    assert_array_equal(p.var_levels['x'], categorical_order(long_df['a']))\n    p = VectorPlotter(data=long_df, variables={'x': 'a_cat'})\n    p.scale_categorical('x')\n    assert p._var_ordered['x']\n    assert_array_equal(p.var_levels['x'], categorical_order(long_df['a_cat']))\n    p = VectorPlotter(data=long_df, variables={'x': 'a'})\n    order = np.roll(long_df['a'].unique(), 1)\n    p.scale_categorical('x', order=order)\n    assert p._var_ordered['x']\n    assert_array_equal(p.var_levels['x'], order)\n    p = VectorPlotter(data=long_df, variables={'x': 's'})\n    p.scale_categorical('x', formatter=(lambda x: f'{x:%}'))\n    assert p.plot_data['x'].str.endswith('%').all()\n    assert all((s.endswith('%') for s in p.var_levels['x']))", "masked_code": "def test_scale_categorical(self, long_df):\n    p = VectorPlotter(data=long_df, variables={'x': 'x'})\n    p.scale_categorical('y')\n    assert (p.variables['y'] is None)\n    assert (p.var_types['y'] == 'categorical')\n    assert (p.plot_data['y'] == '').all()\n    p = VectorPlotter(data=long_df, variables={'x': 's'})\n    p.scale_categorical('x')\n    assert (p.var_types['x'] == '???')\n    assert hasattr(p.plot_data['x'], 'str')\n    assert (not p._var_ordered['x'])\n    assert p.plot_data['x'].is_monotonic_increasing\n    assert_array_equal(p.var_levels['x'], p.plot_data['x'].unique())\n    p = VectorPlotter(data=long_df, variables={'x': 'a'})\n    p.scale_categorical('x')\n    assert (not p._var_ordered['x'])\n    assert_array_equal(p.var_levels['x'], categorical_order(long_df['a']))\n    p = VectorPlotter(data=long_df, variables={'x': 'a_cat'})\n    p.scale_categorical('x')\n    assert p._var_ordered['x']\n    assert_array_equal(p.var_levels['x'], categorical_order(long_df['a_cat']))\n    p = VectorPlotter(data=long_df, variables={'x': 'a'})\n    order = np.roll(long_df['a'].unique(), 1)\n    p.scale_categorical('x', order=order)\n    assert p._var_ordered['x']\n    assert_array_equal(p.var_levels['x'], order)\n    p = VectorPlotter(data=long_df, variables={'x': 's'})\n    p.scale_categorical('x', formatter=(lambda x: f'{x:%}'))\n    assert p.plot_data['x'].str.endswith('%').all()\n    assert all((s.endswith('%') for s in p.var_levels['x']))", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_275", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_unique_dashes", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_unique_dashes(self):\n    n = 24\n    dashes = unique_dashes(n)\n    assert (len(dashes) == n)\n    assert (len(set(dashes)) == n)\n    assert (dashes[0] == '')\n    for spec in dashes[1:]:\n        assert isinstance(spec, tuple)\n        assert (not (len(spec) % 2))", "masked_code": "def test_unique_dashes(self):\n    n = 24\n    dashes = unique_dashes(n)\n    assert (len(dashes) == '???')\n    assert (len(set(dashes)) == n)\n    assert (dashes[0] == '')\n    for spec in dashes[1:]:\n        assert isinstance(spec, tuple)\n        assert (not (len(spec) % 2))", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_276", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_unique_dashes", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_unique_dashes(self):\n    n = 24\n    dashes = unique_dashes(n)\n    assert (len(dashes) == n)\n    assert (len(set(dashes)) == n)\n    assert (dashes[0] == '')\n    for spec in dashes[1:]:\n        assert isinstance(spec, tuple)\n        assert (not (len(spec) % 2))", "masked_code": "def test_unique_dashes(self):\n    n = 24\n    dashes = unique_dashes(n)\n    assert (len(dashes) == n)\n    assert (len(set(dashes)) == '???')\n    assert (dashes[0] == '')\n    for spec in dashes[1:]:\n        assert isinstance(spec, tuple)\n        assert (not (len(spec) % 2))", "ground_truth": "n", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_277", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_unique_markers", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_unique_markers(self):\n    n = 24\n    markers = unique_markers(n)\n    assert (len(markers) == n)\n    assert (len(set(markers)) == n)\n    for m in markers:\n        assert mpl.markers.MarkerStyle(m).is_filled()", "masked_code": "def test_unique_markers(self):\n    n = 24\n    markers = unique_markers(n)\n    assert (len(markers) == '???')\n    assert (len(set(markers)) == n)\n    for m in markers:\n        assert mpl.markers.MarkerStyle(m).is_filled()", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_278", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_unique_markers", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_unique_markers(self):\n    n = 24\n    markers = unique_markers(n)\n    assert (len(markers) == n)\n    assert (len(set(markers)) == n)\n    for m in markers:\n        assert mpl.markers.MarkerStyle(m).is_filled()", "masked_code": "def test_unique_markers(self):\n    n = 24\n    markers = unique_markers(n)\n    assert (len(markers) == n)\n    assert (len(set(markers)) == '???')\n    for m in markers:\n        assert mpl.markers.MarkerStyle(m).is_filled()", "ground_truth": "n", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_279", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == '???')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_280", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == '???')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_281", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == '???')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_282", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == '???')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_283", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == '???')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_284", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == '???')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_285", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == '???')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_286", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == '???')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_287", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == '???')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_288", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == '???')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_289", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == '???')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_290", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == '???')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_291", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == '???')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_292", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == '???')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_293", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == '???')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_294", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == '???')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_295", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == '???')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_296", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == '???')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'datetime'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_297", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == '???')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'datetime'", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_298", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == '???')\n    assert (variable_type(s.to_list()) == 'datetime')", "ground_truth": "'datetime'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_299", "reponame": "seaborn", "testpath": "tests/test_base.py", "testname": "test_base.py", "classname": "TestCoreFunc", "funcname": "test_variable_type", "imports": ["import itertools", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn.axisgrid import FacetGrid", "from seaborn._compat import get_colormap, get_converter", "from seaborn._base import SemanticMapping, HueMapping, SizeMapping, StyleMapping, VectorPlotter, variable_type, infer_orient, unique_dashes, unique_markers, categorical_order", "from seaborn.utils import desaturate", "from seaborn.palettes import color_palette"], "code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == 'datetime')", "masked_code": "def test_variable_type(self):\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    assert (variable_type(s.to_numpy()) == 'numeric')\n    assert (variable_type(s.to_list()) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    assert (variable_type(s.to_numpy()) == 'categorical')\n    assert (variable_type(s.to_list()) == 'categorical')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')\n    assert (variable_type(s.to_numpy()) == 'datetime')\n    assert (variable_type(s.to_list()) == '???')", "ground_truth": "'datetime'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_300", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCategoricalPlotterNew", "funcname": "test_axis_labels", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('func,kwargs', itertools.product(PLOT_FUNCS, [{'x': 'x', 'y': 'a'}, {'x': 'a', 'y': 'y'}, {'x': 'y'}, {'y': 'x'}]))\ndef test_axis_labels(self, long_df, func, kwargs):\n    func(data=long_df, **kwargs)\n    ax = plt.gca()\n    for axis in 'xy':\n        val = kwargs.get(axis, '')\n        label_func = getattr(ax, f'get_{axis}label')\n        assert (label_func() == val)", "masked_code": "@pytest.mark.parametrize('func,kwargs', itertools.product(PLOT_FUNCS, [{'x': 'x', 'y': 'a'}, {'x': 'a', 'y': 'y'}, {'x': 'y'}, {'y': 'x'}]))\ndef test_axis_labels(self, long_df, func, kwargs):\n    func(data=long_df, **kwargs)\n    ax = plt.gca()\n    for axis in 'xy':\n        val = kwargs.get(axis, '')\n        label_func = getattr(ax, f'get_{axis}label')\n        assert (label_func() == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_301", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedAxesLevelTests", "funcname": "test_labels_long", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_labels_long(self, long_df, orient):\n    depend = {'x': 'y', 'y': 'x'}[orient]\n    kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n    ax = self.func(long_df, **kws)\n    _draw_figure(ax.figure)\n    assert (getattr(ax, f'get_{orient}label')() == kws[orient])\n    assert (getattr(ax, f'get_{depend}label')() == kws[depend])\n    get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n    ori_labels = [t.get_text() for t in get_ori_labels()]\n    ori_levels = categorical_order(long_df[kws[orient]])\n    assert (ori_labels == ori_levels)\n    legend = ax.get_legend()\n    assert (legend.get_title().get_text() == kws['hue'])\n    hue_labels = [t.get_text() for t in legend.texts]\n    hue_levels = categorical_order(long_df[kws['hue']])\n    assert (hue_labels == hue_levels)", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_labels_long(self, long_df, orient):\n    depend = {'x': 'y', 'y': 'x'}[orient]\n    kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n    ax = self.func(long_df, **kws)\n    _draw_figure(ax.figure)\n    assert (getattr(ax, f'get_{orient}label')() == '???')\n    assert (getattr(ax, f'get_{depend}label')() == kws[depend])\n    get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n    ori_labels = [t.get_text() for t in get_ori_labels()]\n    ori_levels = categorical_order(long_df[kws[orient]])\n    assert (ori_labels == ori_levels)\n    legend = ax.get_legend()\n    assert (legend.get_title().get_text() == kws['hue'])\n    hue_labels = [t.get_text() for t in legend.texts]\n    hue_levels = categorical_order(long_df[kws['hue']])\n    assert (hue_labels == hue_levels)", "ground_truth": "kws[orient]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_302", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedAxesLevelTests", "funcname": "test_labels_long", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_labels_long(self, long_df, orient):\n    depend = {'x': 'y', 'y': 'x'}[orient]\n    kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n    ax = self.func(long_df, **kws)\n    _draw_figure(ax.figure)\n    assert (getattr(ax, f'get_{orient}label')() == kws[orient])\n    assert (getattr(ax, f'get_{depend}label')() == kws[depend])\n    get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n    ori_labels = [t.get_text() for t in get_ori_labels()]\n    ori_levels = categorical_order(long_df[kws[orient]])\n    assert (ori_labels == ori_levels)\n    legend = ax.get_legend()\n    assert (legend.get_title().get_text() == kws['hue'])\n    hue_labels = [t.get_text() for t in legend.texts]\n    hue_levels = categorical_order(long_df[kws['hue']])\n    assert (hue_labels == hue_levels)", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_labels_long(self, long_df, orient):\n    depend = {'x': 'y', 'y': 'x'}[orient]\n    kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n    ax = self.func(long_df, **kws)\n    _draw_figure(ax.figure)\n    assert (getattr(ax, f'get_{orient}label')() == kws[orient])\n    assert (getattr(ax, f'get_{depend}label')() == '???')\n    get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n    ori_labels = [t.get_text() for t in get_ori_labels()]\n    ori_levels = categorical_order(long_df[kws[orient]])\n    assert (ori_labels == ori_levels)\n    legend = ax.get_legend()\n    assert (legend.get_title().get_text() == kws['hue'])\n    hue_labels = [t.get_text() for t in legend.texts]\n    hue_levels = categorical_order(long_df[kws['hue']])\n    assert (hue_labels == hue_levels)", "ground_truth": "kws[depend]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_303", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedAxesLevelTests", "funcname": "test_labels_long", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_labels_long(self, long_df, orient):\n    depend = {'x': 'y', 'y': 'x'}[orient]\n    kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n    ax = self.func(long_df, **kws)\n    _draw_figure(ax.figure)\n    assert (getattr(ax, f'get_{orient}label')() == kws[orient])\n    assert (getattr(ax, f'get_{depend}label')() == kws[depend])\n    get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n    ori_labels = [t.get_text() for t in get_ori_labels()]\n    ori_levels = categorical_order(long_df[kws[orient]])\n    assert (ori_labels == ori_levels)\n    legend = ax.get_legend()\n    assert (legend.get_title().get_text() == kws['hue'])\n    hue_labels = [t.get_text() for t in legend.texts]\n    hue_levels = categorical_order(long_df[kws['hue']])\n    assert (hue_labels == hue_levels)", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_labels_long(self, long_df, orient):\n    depend = {'x': 'y', 'y': 'x'}[orient]\n    kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n    ax = self.func(long_df, **kws)\n    _draw_figure(ax.figure)\n    assert (getattr(ax, f'get_{orient}label')() == kws[orient])\n    assert (getattr(ax, f'get_{depend}label')() == kws[depend])\n    get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n    ori_labels = [t.get_text() for t in get_ori_labels()]\n    ori_levels = categorical_order(long_df[kws[orient]])\n    assert (ori_labels == ori_levels)\n    legend = ax.get_legend()\n    assert (legend.get_title().get_text() == '???')\n    hue_labels = [t.get_text() for t in legend.texts]\n    hue_levels = categorical_order(long_df[kws['hue']])\n    assert (hue_labels == hue_levels)", "ground_truth": "kws['hue']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_304", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedAxesLevelTests", "funcname": "test_labels_wide", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_labels_wide(self, wide_df):\n    wide_df = wide_df.rename_axis('cols', axis=1)\n    ax = self.func(wide_df)\n    _draw_figure(ax.figure)\n    assert (ax.get_xlabel() == wide_df.columns.name)\n    labels = [t.get_text() for t in ax.get_xticklabels()]\n    for (label, level) in zip(labels, wide_df.columns):\n        assert (label == level)", "masked_code": "def test_labels_wide(self, wide_df):\n    wide_df = wide_df.rename_axis('cols', axis=1)\n    ax = self.func(wide_df)\n    _draw_figure(ax.figure)\n    assert (ax.get_xlabel() == '???')\n    labels = [t.get_text() for t in ax.get_xticklabels()]\n    for (label, level) in zip(labels, wide_df.columns):\n        assert (label == level)", "ground_truth": "wide_df.columns.name", "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_305", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedAxesLevelTests", "funcname": "test_color", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_color(self, long_df, common_kws):\n    common_kws.update(data=long_df, x='a', y='y')\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(color='C2', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(color='C3', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C3'))", "masked_code": "def test_color(self, long_df, common_kws):\n    common_kws.update(data=long_df, x='a', y='y')\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == '???')\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(color='C2', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(color='C3', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C3'))", "ground_truth": "to_rgba('C0')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_306", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedAxesLevelTests", "funcname": "test_color", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_color(self, long_df, common_kws):\n    common_kws.update(data=long_df, x='a', y='y')\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(color='C2', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(color='C3', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C3'))", "masked_code": "def test_color(self, long_df, common_kws):\n    common_kws.update(data=long_df, x='a', y='y')\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == '???')\n    ax = plt.figure().subplots()\n    self.func(color='C2', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(color='C3', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C3'))", "ground_truth": "to_rgba('C1')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_307", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedAxesLevelTests", "funcname": "test_color", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_color(self, long_df, common_kws):\n    common_kws.update(data=long_df, x='a', y='y')\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(color='C2', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(color='C3', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C3'))", "masked_code": "def test_color(self, long_df, common_kws):\n    common_kws.update(data=long_df, x='a', y='y')\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(color='C2', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == '???')\n    ax = plt.figure().subplots()\n    self.func(color='C3', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C3'))", "ground_truth": "to_rgba('C2')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_308", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedAxesLevelTests", "funcname": "test_color", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_color(self, long_df, common_kws):\n    common_kws.update(data=long_df, x='a', y='y')\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(color='C2', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(color='C3', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C3'))", "masked_code": "def test_color(self, long_df, common_kws):\n    common_kws.update(data=long_df, x='a', y='y')\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(ax=ax, **common_kws)\n    self.func(ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(color='C2', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(color='C3', ax=ax, **common_kws)\n    assert (self.get_last_color(ax) == '???')", "ground_truth": "to_rgba('C3')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_309", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedAxesLevelTests", "funcname": "test_two_calls", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_two_calls(self):\n    ax = plt.figure().subplots()\n    self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n    self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n    assert (ax.get_xlim() == ((- 0.5), 4.5))", "masked_code": "def test_two_calls(self):\n    ax = plt.figure().subplots()\n    self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n    self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n    assert (ax.get_xlim() == '???')", "ground_truth": "((- 0.5), 4.5)", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_310", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedAxesLevelTests", "funcname": "test_log_scale", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_log_scale(self, long_df, orient):\n    depvar = {'x': 'y', 'y': 'x'}[orient]\n    variables = {orient: 'a', depvar: 'z'}\n    ax = self.func(long_df, **variables, log_scale=True)\n    assert (getattr(ax, f'get_{orient}scale')() == 'linear')\n    assert (getattr(ax, f'get_{depvar}scale')() == 'log')", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_log_scale(self, long_df, orient):\n    depvar = {'x': 'y', 'y': 'x'}[orient]\n    variables = {orient: 'a', depvar: 'z'}\n    ax = self.func(long_df, **variables, log_scale=True)\n    assert (getattr(ax, f'get_{orient}scale')() == '???')\n    assert (getattr(ax, f'get_{depvar}scale')() == 'log')", "ground_truth": "'linear'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_311", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedAxesLevelTests", "funcname": "test_log_scale", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_log_scale(self, long_df, orient):\n    depvar = {'x': 'y', 'y': 'x'}[orient]\n    variables = {orient: 'a', depvar: 'z'}\n    ax = self.func(long_df, **variables, log_scale=True)\n    assert (getattr(ax, f'get_{orient}scale')() == 'linear')\n    assert (getattr(ax, f'get_{depvar}scale')() == 'log')", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_log_scale(self, long_df, orient):\n    depvar = {'x': 'y', 'y': 'x'}[orient]\n    variables = {orient: 'a', depvar: 'z'}\n    ax = self.func(long_df, **variables, log_scale=True)\n    assert (getattr(ax, f'get_{orient}scale')() == 'linear')\n    assert (getattr(ax, f'get_{depvar}scale')() == '???')", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_312", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_color", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_color(self, long_df, common_kws):\n    super().test_color(long_df, common_kws)\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='a', y='y', facecolor='C4', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C4'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='a', y='y', fc='C5', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C5'))", "masked_code": "def test_color(self, long_df, common_kws):\n    super().test_color(long_df, common_kws)\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='a', y='y', facecolor='C4', ax=ax)\n    assert (self.get_last_color(ax) == '???')\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='a', y='y', fc='C5', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C5'))", "ground_truth": "to_rgba('C4')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_313", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_color", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_color(self, long_df, common_kws):\n    super().test_color(long_df, common_kws)\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='a', y='y', facecolor='C4', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C4'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='a', y='y', fc='C5', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C5'))", "masked_code": "def test_color(self, long_df, common_kws):\n    super().test_color(long_df, common_kws)\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='a', y='y', facecolor='C4', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C4'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='a', y='y', fc='C5', ax=ax)\n    assert (self.get_last_color(ax) == '???')", "ground_truth": "to_rgba('C5')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_314", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_wide", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient,data_type', [('h', 'dataframe'), ('h', 'dict'), ('v', 'dataframe'), ('v', 'dict'), ('y', 'dataframe'), ('y', 'dict'), ('x', 'dataframe'), ('x', 'dict')])\ndef test_wide(self, wide_df, orient, data_type):\n    if (data_type == 'dict'):\n        wide_df = {k: v.to_numpy() for (k, v) in wide_df.items()}\n    ax = self.func(data=wide_df, orient=orient, color='C0')\n    _draw_figure(ax.figure)\n    cat_idx = (0 if (orient in 'vx') else 1)\n    val_idx = int((not cat_idx))\n    axis_objs = (ax.xaxis, ax.yaxis)\n    cat_axis = axis_objs[cat_idx]\n    for (i, label) in enumerate(cat_axis.get_majorticklabels()):\n        key = label.get_text()\n        points = ax.collections[i]\n        point_pos = points.get_offsets().T\n        val_pos = point_pos[val_idx]\n        cat_pos = point_pos[cat_idx]\n        assert_array_equal(cat_pos.round(), i)\n        assert_array_equal(val_pos, wide_df[key])\n        for point_color in points.get_facecolors():\n            assert (tuple(point_color) == to_rgba('C0'))", "masked_code": "@pytest.mark.parametrize('orient,data_type', [('h', 'dataframe'), ('h', 'dict'), ('v', 'dataframe'), ('v', 'dict'), ('y', 'dataframe'), ('y', 'dict'), ('x', 'dataframe'), ('x', 'dict')])\ndef test_wide(self, wide_df, orient, data_type):\n    if (data_type == 'dict'):\n        wide_df = {k: v.to_numpy() for (k, v) in wide_df.items()}\n    ax = self.func(data=wide_df, orient=orient, color='C0')\n    _draw_figure(ax.figure)\n    cat_idx = (0 if (orient in 'vx') else 1)\n    val_idx = int((not cat_idx))\n    axis_objs = (ax.xaxis, ax.yaxis)\n    cat_axis = axis_objs[cat_idx]\n    for (i, label) in enumerate(cat_axis.get_majorticklabels()):\n        key = label.get_text()\n        points = ax.collections[i]\n        point_pos = points.get_offsets().T\n        val_pos = point_pos[val_idx]\n        cat_pos = point_pos[cat_idx]\n        assert_array_equal(cat_pos.round(), i)\n        assert_array_equal(val_pos, wide_df[key])\n        for point_color in points.get_facecolors():\n            assert (tuple(point_color) == '???')", "ground_truth": "to_rgba('C0')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_315", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_positions", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('variables,orient', [({'cat': 'a', 'val': 'y', 'hue': None}, None), ({'val': 'y', 'cat': 'a', 'hue': None}, None), ({'cat': 'a', 'val': 'y', 'hue': 'a'}, None), ({'val': 'y', 'cat': 'a', 'hue': 'a'}, None), ({'cat': 'a', 'val': 'y', 'hue': 'b'}, None), ({'val': 'y', 'cat': 'a', 'hue': 'x'}, None), ({'cat': 's', 'val': 'y', 'hue': None}, None), ({'val': 'y', 'cat': 's', 'hue': None}, 'h'), ({'cat': 'a', 'val': 'b', 'hue': None}, None), ({'val': 'a', 'cat': 'b', 'hue': None}, 'h'), ({'cat': 'a', 'val': 't', 'hue': None}, None), ({'val': 't', 'cat': 'a', 'hue': None}, None), ({'cat': 'd', 'val': 'y', 'hue': None}, None), ({'val': 'y', 'cat': 'd', 'hue': None}, None), ({'cat': 'a_cat', 'val': 'y', 'hue': None}, None), ({'val': 'y', 'cat': 's_cat', 'hue': None}, None)])\ndef test_positions(self, long_df, variables, orient):\n    cat_var = variables['cat']\n    val_var = variables['val']\n    hue_var = variables['hue']\n    var_names = list(variables.values())\n    (x_var, y_var, *_) = var_names\n    ax = self.func(data=long_df, x=x_var, y=y_var, hue=hue_var, orient=orient)\n    _draw_figure(ax.figure)\n    cat_idx = var_names.index(cat_var)\n    val_idx = var_names.index(val_var)\n    axis_objs = (ax.xaxis, ax.yaxis)\n    cat_axis = axis_objs[cat_idx]\n    val_axis = axis_objs[val_idx]\n    cat_data = long_df[cat_var]\n    cat_levels = categorical_order(cat_data)\n    for (i, label) in enumerate(cat_levels):\n        vals = long_df.loc[((cat_data == label), val_var)]\n        points = ax.collections[i].get_offsets().T\n        cat_pos = points[var_names.index(cat_var)]\n        val_pos = points[var_names.index(val_var)]\n        assert_array_equal(val_pos, val_axis.convert_units(vals))\n        assert_array_equal(cat_pos.round(), i)\n        assert (0 <= np.ptp(cat_pos) <= 0.8)\n        label = pd.Index([label]).astype(str)[0]\n        assert (cat_axis.get_majorticklabels()[i].get_text() == label)", "masked_code": "@pytest.mark.parametrize('variables,orient', [({'cat': 'a', 'val': 'y', 'hue': None}, None), ({'val': 'y', 'cat': 'a', 'hue': None}, None), ({'cat': 'a', 'val': 'y', 'hue': 'a'}, None), ({'val': 'y', 'cat': 'a', 'hue': 'a'}, None), ({'cat': 'a', 'val': 'y', 'hue': 'b'}, None), ({'val': 'y', 'cat': 'a', 'hue': 'x'}, None), ({'cat': 's', 'val': 'y', 'hue': None}, None), ({'val': 'y', 'cat': 's', 'hue': None}, 'h'), ({'cat': 'a', 'val': 'b', 'hue': None}, None), ({'val': 'a', 'cat': 'b', 'hue': None}, 'h'), ({'cat': 'a', 'val': 't', 'hue': None}, None), ({'val': 't', 'cat': 'a', 'hue': None}, None), ({'cat': 'd', 'val': 'y', 'hue': None}, None), ({'val': 'y', 'cat': 'd', 'hue': None}, None), ({'cat': 'a_cat', 'val': 'y', 'hue': None}, None), ({'val': 'y', 'cat': 's_cat', 'hue': None}, None)])\ndef test_positions(self, long_df, variables, orient):\n    cat_var = variables['cat']\n    val_var = variables['val']\n    hue_var = variables['hue']\n    var_names = list(variables.values())\n    (x_var, y_var, *_) = var_names\n    ax = self.func(data=long_df, x=x_var, y=y_var, hue=hue_var, orient=orient)\n    _draw_figure(ax.figure)\n    cat_idx = var_names.index(cat_var)\n    val_idx = var_names.index(val_var)\n    axis_objs = (ax.xaxis, ax.yaxis)\n    cat_axis = axis_objs[cat_idx]\n    val_axis = axis_objs[val_idx]\n    cat_data = long_df[cat_var]\n    cat_levels = categorical_order(cat_data)\n    for (i, label) in enumerate(cat_levels):\n        vals = long_df.loc[((cat_data == label), val_var)]\n        points = ax.collections[i].get_offsets().T\n        cat_pos = points[var_names.index(cat_var)]\n        val_pos = points[var_names.index(val_var)]\n        assert_array_equal(val_pos, val_axis.convert_units(vals))\n        assert_array_equal(cat_pos.round(), i)\n        assert (0 <= np.ptp(cat_pos) <= 0.8)\n        label = pd.Index([label]).astype(str)[0]\n        assert (cat_axis.get_majorticklabels()[i].get_text() == '???')", "ground_truth": "label", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_316", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_order", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('x_type,order', [(str, None), (str, ['a', 'b', 'c']), (str, ['c', 'a']), (str, ['a', 'b', 'c', 'd']), (int, None), (int, [3, 1, 2]), (int, [3, 1]), (int, [1, 2, 3, 4]), (int, ['3', '1', '2'])])\ndef test_order(self, x_type, order):\n    if (x_type is str):\n        x = ['b', 'a', 'c']\n    else:\n        x = [2, 1, 3]\n    y = [1, 2, 3]\n    ax = self.func(x=x, y=y, order=order)\n    _draw_figure(ax.figure)\n    if (order is None):\n        order = x\n        if (x_type is int):\n            order = np.sort(order)\n    assert (len(ax.collections) == len(order))\n    tick_labels = ax.xaxis.get_majorticklabels()\n    assert (ax.get_xlim()[1] == (len(order) - 0.5))\n    for (i, points) in enumerate(ax.collections):\n        cat = order[i]\n        assert (tick_labels[i].get_text() == str(cat))\n        positions = points.get_offsets()\n        if (x_type(cat) in x):\n            val = y[x.index(x_type(cat))]\n            assert (positions[(0, 1)] == val)\n        else:\n            assert (not positions.size)", "masked_code": "@pytest.mark.parametrize('x_type,order', [(str, None), (str, ['a', 'b', 'c']), (str, ['c', 'a']), (str, ['a', 'b', 'c', 'd']), (int, None), (int, [3, 1, 2]), (int, [3, 1]), (int, [1, 2, 3, 4]), (int, ['3', '1', '2'])])\ndef test_order(self, x_type, order):\n    if (x_type is str):\n        x = ['b', 'a', 'c']\n    else:\n        x = [2, 1, 3]\n    y = [1, 2, 3]\n    ax = self.func(x=x, y=y, order=order)\n    _draw_figure(ax.figure)\n    if (order is None):\n        order = x\n        if (x_type is int):\n            order = np.sort(order)\n    assert (len(ax.collections) == '???')\n    tick_labels = ax.xaxis.get_majorticklabels()\n    assert (ax.get_xlim()[1] == (len(order) - 0.5))\n    for (i, points) in enumerate(ax.collections):\n        cat = order[i]\n        assert (tick_labels[i].get_text() == str(cat))\n        positions = points.get_offsets()\n        if (x_type(cat) in x):\n            val = y[x.index(x_type(cat))]\n            assert (positions[(0, 1)] == val)\n        else:\n            assert (not positions.size)", "ground_truth": "len(order)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_317", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_order", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('x_type,order', [(str, None), (str, ['a', 'b', 'c']), (str, ['c', 'a']), (str, ['a', 'b', 'c', 'd']), (int, None), (int, [3, 1, 2]), (int, [3, 1]), (int, [1, 2, 3, 4]), (int, ['3', '1', '2'])])\ndef test_order(self, x_type, order):\n    if (x_type is str):\n        x = ['b', 'a', 'c']\n    else:\n        x = [2, 1, 3]\n    y = [1, 2, 3]\n    ax = self.func(x=x, y=y, order=order)\n    _draw_figure(ax.figure)\n    if (order is None):\n        order = x\n        if (x_type is int):\n            order = np.sort(order)\n    assert (len(ax.collections) == len(order))\n    tick_labels = ax.xaxis.get_majorticklabels()\n    assert (ax.get_xlim()[1] == (len(order) - 0.5))\n    for (i, points) in enumerate(ax.collections):\n        cat = order[i]\n        assert (tick_labels[i].get_text() == str(cat))\n        positions = points.get_offsets()\n        if (x_type(cat) in x):\n            val = y[x.index(x_type(cat))]\n            assert (positions[(0, 1)] == val)\n        else:\n            assert (not positions.size)", "masked_code": "@pytest.mark.parametrize('x_type,order', [(str, None), (str, ['a', 'b', 'c']), (str, ['c', 'a']), (str, ['a', 'b', 'c', 'd']), (int, None), (int, [3, 1, 2]), (int, [3, 1]), (int, [1, 2, 3, 4]), (int, ['3', '1', '2'])])\ndef test_order(self, x_type, order):\n    if (x_type is str):\n        x = ['b', 'a', 'c']\n    else:\n        x = [2, 1, 3]\n    y = [1, 2, 3]\n    ax = self.func(x=x, y=y, order=order)\n    _draw_figure(ax.figure)\n    if (order is None):\n        order = x\n        if (x_type is int):\n            order = np.sort(order)\n    assert (len(ax.collections) == len(order))\n    tick_labels = ax.xaxis.get_majorticklabels()\n    assert (ax.get_xlim()[1] == '???')\n    for (i, points) in enumerate(ax.collections):\n        cat = order[i]\n        assert (tick_labels[i].get_text() == str(cat))\n        positions = points.get_offsets()\n        if (x_type(cat) in x):\n            val = y[x.index(x_type(cat))]\n            assert (positions[(0, 1)] == val)\n        else:\n            assert (not positions.size)", "ground_truth": "(len(order) - 0.5)", "quality_analysis": {"complexity_score": 14, "left_complexity": 7, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_318", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_order", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('x_type,order', [(str, None), (str, ['a', 'b', 'c']), (str, ['c', 'a']), (str, ['a', 'b', 'c', 'd']), (int, None), (int, [3, 1, 2]), (int, [3, 1]), (int, [1, 2, 3, 4]), (int, ['3', '1', '2'])])\ndef test_order(self, x_type, order):\n    if (x_type is str):\n        x = ['b', 'a', 'c']\n    else:\n        x = [2, 1, 3]\n    y = [1, 2, 3]\n    ax = self.func(x=x, y=y, order=order)\n    _draw_figure(ax.figure)\n    if (order is None):\n        order = x\n        if (x_type is int):\n            order = np.sort(order)\n    assert (len(ax.collections) == len(order))\n    tick_labels = ax.xaxis.get_majorticklabels()\n    assert (ax.get_xlim()[1] == (len(order) - 0.5))\n    for (i, points) in enumerate(ax.collections):\n        cat = order[i]\n        assert (tick_labels[i].get_text() == str(cat))\n        positions = points.get_offsets()\n        if (x_type(cat) in x):\n            val = y[x.index(x_type(cat))]\n            assert (positions[(0, 1)] == val)\n        else:\n            assert (not positions.size)", "masked_code": "@pytest.mark.parametrize('x_type,order', [(str, None), (str, ['a', 'b', 'c']), (str, ['c', 'a']), (str, ['a', 'b', 'c', 'd']), (int, None), (int, [3, 1, 2]), (int, [3, 1]), (int, [1, 2, 3, 4]), (int, ['3', '1', '2'])])\ndef test_order(self, x_type, order):\n    if (x_type is str):\n        x = ['b', 'a', 'c']\n    else:\n        x = [2, 1, 3]\n    y = [1, 2, 3]\n    ax = self.func(x=x, y=y, order=order)\n    _draw_figure(ax.figure)\n    if (order is None):\n        order = x\n        if (x_type is int):\n            order = np.sort(order)\n    assert (len(ax.collections) == len(order))\n    tick_labels = ax.xaxis.get_majorticklabels()\n    assert (ax.get_xlim()[1] == (len(order) - 0.5))\n    for (i, points) in enumerate(ax.collections):\n        cat = order[i]\n        assert (tick_labels[i].get_text() == '???')\n        positions = points.get_offsets()\n        if (x_type(cat) in x):\n            val = y[x.index(x_type(cat))]\n            assert (positions[(0, 1)] == val)\n        else:\n            assert (not positions.size)", "ground_truth": "str(cat)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_319", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_order", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('x_type,order', [(str, None), (str, ['a', 'b', 'c']), (str, ['c', 'a']), (str, ['a', 'b', 'c', 'd']), (int, None), (int, [3, 1, 2]), (int, [3, 1]), (int, [1, 2, 3, 4]), (int, ['3', '1', '2'])])\ndef test_order(self, x_type, order):\n    if (x_type is str):\n        x = ['b', 'a', 'c']\n    else:\n        x = [2, 1, 3]\n    y = [1, 2, 3]\n    ax = self.func(x=x, y=y, order=order)\n    _draw_figure(ax.figure)\n    if (order is None):\n        order = x\n        if (x_type is int):\n            order = np.sort(order)\n    assert (len(ax.collections) == len(order))\n    tick_labels = ax.xaxis.get_majorticklabels()\n    assert (ax.get_xlim()[1] == (len(order) - 0.5))\n    for (i, points) in enumerate(ax.collections):\n        cat = order[i]\n        assert (tick_labels[i].get_text() == str(cat))\n        positions = points.get_offsets()\n        if (x_type(cat) in x):\n            val = y[x.index(x_type(cat))]\n            assert (positions[(0, 1)] == val)\n        else:\n            assert (not positions.size)", "masked_code": "@pytest.mark.parametrize('x_type,order', [(str, None), (str, ['a', 'b', 'c']), (str, ['c', 'a']), (str, ['a', 'b', 'c', 'd']), (int, None), (int, [3, 1, 2]), (int, [3, 1]), (int, [1, 2, 3, 4]), (int, ['3', '1', '2'])])\ndef test_order(self, x_type, order):\n    if (x_type is str):\n        x = ['b', 'a', 'c']\n    else:\n        x = [2, 1, 3]\n    y = [1, 2, 3]\n    ax = self.func(x=x, y=y, order=order)\n    _draw_figure(ax.figure)\n    if (order is None):\n        order = x\n        if (x_type is int):\n            order = np.sort(order)\n    assert (len(ax.collections) == len(order))\n    tick_labels = ax.xaxis.get_majorticklabels()\n    assert (ax.get_xlim()[1] == (len(order) - 0.5))\n    for (i, points) in enumerate(ax.collections):\n        cat = order[i]\n        assert (tick_labels[i].get_text() == str(cat))\n        positions = points.get_offsets()\n        if (x_type(cat) in x):\n            val = y[x.index(x_type(cat))]\n            assert (positions[(0, 1)] == '???')\n        else:\n            assert (not positions.size)", "ground_truth": "val", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_320", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_hue_categorical", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('hue_var', ['a', 'b'])\ndef test_hue_categorical(self, long_df, hue_var):\n    cat_var = 'b'\n    hue_levels = categorical_order(long_df[hue_var])\n    cat_levels = categorical_order(long_df[cat_var])\n    pal_name = 'muted'\n    palette = dict(zip(hue_levels, color_palette(pal_name)))\n    ax = self.func(data=long_df, x=cat_var, y='y', hue=hue_var, palette=pal_name)\n    for (i, level) in enumerate(cat_levels):\n        sub_df = long_df[(long_df[cat_var] == level)]\n        point_hues = sub_df[hue_var]\n        points = ax.collections[i]\n        point_colors = points.get_facecolors()\n        assert (len(point_hues) == len(point_colors))\n        for (hue, color) in zip(point_hues, point_colors):\n            assert (tuple(color) == to_rgba(palette[hue]))", "masked_code": "@pytest.mark.parametrize('hue_var', ['a', 'b'])\ndef test_hue_categorical(self, long_df, hue_var):\n    cat_var = 'b'\n    hue_levels = categorical_order(long_df[hue_var])\n    cat_levels = categorical_order(long_df[cat_var])\n    pal_name = 'muted'\n    palette = dict(zip(hue_levels, color_palette(pal_name)))\n    ax = self.func(data=long_df, x=cat_var, y='y', hue=hue_var, palette=pal_name)\n    for (i, level) in enumerate(cat_levels):\n        sub_df = long_df[(long_df[cat_var] == level)]\n        point_hues = sub_df[hue_var]\n        points = ax.collections[i]\n        point_colors = points.get_facecolors()\n        assert (len(point_hues) == '???')\n        for (hue, color) in zip(point_hues, point_colors):\n            assert (tuple(color) == to_rgba(palette[hue]))", "ground_truth": "len(point_colors)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_321", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_hue_categorical", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('hue_var', ['a', 'b'])\ndef test_hue_categorical(self, long_df, hue_var):\n    cat_var = 'b'\n    hue_levels = categorical_order(long_df[hue_var])\n    cat_levels = categorical_order(long_df[cat_var])\n    pal_name = 'muted'\n    palette = dict(zip(hue_levels, color_palette(pal_name)))\n    ax = self.func(data=long_df, x=cat_var, y='y', hue=hue_var, palette=pal_name)\n    for (i, level) in enumerate(cat_levels):\n        sub_df = long_df[(long_df[cat_var] == level)]\n        point_hues = sub_df[hue_var]\n        points = ax.collections[i]\n        point_colors = points.get_facecolors()\n        assert (len(point_hues) == len(point_colors))\n        for (hue, color) in zip(point_hues, point_colors):\n            assert (tuple(color) == to_rgba(palette[hue]))", "masked_code": "@pytest.mark.parametrize('hue_var', ['a', 'b'])\ndef test_hue_categorical(self, long_df, hue_var):\n    cat_var = 'b'\n    hue_levels = categorical_order(long_df[hue_var])\n    cat_levels = categorical_order(long_df[cat_var])\n    pal_name = 'muted'\n    palette = dict(zip(hue_levels, color_palette(pal_name)))\n    ax = self.func(data=long_df, x=cat_var, y='y', hue=hue_var, palette=pal_name)\n    for (i, level) in enumerate(cat_levels):\n        sub_df = long_df[(long_df[cat_var] == level)]\n        point_hues = sub_df[hue_var]\n        points = ax.collections[i]\n        point_colors = points.get_facecolors()\n        assert (len(point_hues) == len(point_colors))\n        for (hue, color) in zip(point_hues, point_colors):\n            assert (tuple(color) == '???')", "ground_truth": "to_rgba(palette[hue])", "quality_analysis": {"complexity_score": 12, "left_complexity": 4, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_322", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_single", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('val_var,val_col,hue_col', list(itertools.product(['x', 'y'], ['b', 'y', 't'], [None, 'a'])))\ndef test_single(self, long_df, val_var, val_col, hue_col):\n    var_kws = {val_var: val_col, 'hue': hue_col}\n    ax = self.func(data=long_df, **var_kws)\n    _draw_figure(ax.figure)\n    axis_vars = ['x', 'y']\n    val_idx = axis_vars.index(val_var)\n    cat_idx = int((not val_idx))\n    cat_var = axis_vars[cat_idx]\n    cat_axis = getattr(ax, f'{cat_var}axis')\n    val_axis = getattr(ax, f'{val_var}axis')\n    points = ax.collections[0]\n    point_pos = points.get_offsets().T\n    cat_pos = point_pos[cat_idx]\n    val_pos = point_pos[val_idx]\n    assert_array_equal(cat_pos.round(), 0)\n    assert (cat_pos.max() <= 0.4)\n    assert (cat_pos.min() >= (- 0.4))\n    num_vals = val_axis.convert_units(long_df[val_col])\n    assert_array_equal(val_pos, num_vals)\n    if (hue_col is not None):\n        palette = dict(zip(categorical_order(long_df[hue_col]), color_palette()))\n    facecolors = points.get_facecolors()\n    for (i, color) in enumerate(facecolors):\n        if (hue_col is None):\n            assert (tuple(color) == to_rgba('C0'))\n        else:\n            hue_level = long_df.loc[(i, hue_col)]\n            expected_color = palette[hue_level]\n            assert (tuple(color) == to_rgba(expected_color))\n    ticklabels = cat_axis.get_majorticklabels()\n    assert (len(ticklabels) == 1)\n    assert (not ticklabels[0].get_text())", "masked_code": "@pytest.mark.parametrize('val_var,val_col,hue_col', list(itertools.product(['x', 'y'], ['b', 'y', 't'], [None, 'a'])))\ndef test_single(self, long_df, val_var, val_col, hue_col):\n    var_kws = {val_var: val_col, 'hue': hue_col}\n    ax = self.func(data=long_df, **var_kws)\n    _draw_figure(ax.figure)\n    axis_vars = ['x', 'y']\n    val_idx = axis_vars.index(val_var)\n    cat_idx = int((not val_idx))\n    cat_var = axis_vars[cat_idx]\n    cat_axis = getattr(ax, f'{cat_var}axis')\n    val_axis = getattr(ax, f'{val_var}axis')\n    points = ax.collections[0]\n    point_pos = points.get_offsets().T\n    cat_pos = point_pos[cat_idx]\n    val_pos = point_pos[val_idx]\n    assert_array_equal(cat_pos.round(), 0)\n    assert (cat_pos.max() <= 0.4)\n    assert (cat_pos.min() >= (- 0.4))\n    num_vals = val_axis.convert_units(long_df[val_col])\n    assert_array_equal(val_pos, num_vals)\n    if (hue_col is not None):\n        palette = dict(zip(categorical_order(long_df[hue_col]), color_palette()))\n    facecolors = points.get_facecolors()\n    for (i, color) in enumerate(facecolors):\n        if (hue_col is None):\n            assert (tuple(color) == '???')\n        else:\n            hue_level = long_df.loc[(i, hue_col)]\n            expected_color = palette[hue_level]\n            assert (tuple(color) == to_rgba(expected_color))\n    ticklabels = cat_axis.get_majorticklabels()\n    assert (len(ticklabels) == 1)\n    assert (not ticklabels[0].get_text())", "ground_truth": "to_rgba('C0')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_323", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_single", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('val_var,val_col,hue_col', list(itertools.product(['x', 'y'], ['b', 'y', 't'], [None, 'a'])))\ndef test_single(self, long_df, val_var, val_col, hue_col):\n    var_kws = {val_var: val_col, 'hue': hue_col}\n    ax = self.func(data=long_df, **var_kws)\n    _draw_figure(ax.figure)\n    axis_vars = ['x', 'y']\n    val_idx = axis_vars.index(val_var)\n    cat_idx = int((not val_idx))\n    cat_var = axis_vars[cat_idx]\n    cat_axis = getattr(ax, f'{cat_var}axis')\n    val_axis = getattr(ax, f'{val_var}axis')\n    points = ax.collections[0]\n    point_pos = points.get_offsets().T\n    cat_pos = point_pos[cat_idx]\n    val_pos = point_pos[val_idx]\n    assert_array_equal(cat_pos.round(), 0)\n    assert (cat_pos.max() <= 0.4)\n    assert (cat_pos.min() >= (- 0.4))\n    num_vals = val_axis.convert_units(long_df[val_col])\n    assert_array_equal(val_pos, num_vals)\n    if (hue_col is not None):\n        palette = dict(zip(categorical_order(long_df[hue_col]), color_palette()))\n    facecolors = points.get_facecolors()\n    for (i, color) in enumerate(facecolors):\n        if (hue_col is None):\n            assert (tuple(color) == to_rgba('C0'))\n        else:\n            hue_level = long_df.loc[(i, hue_col)]\n            expected_color = palette[hue_level]\n            assert (tuple(color) == to_rgba(expected_color))\n    ticklabels = cat_axis.get_majorticklabels()\n    assert (len(ticklabels) == 1)\n    assert (not ticklabels[0].get_text())", "masked_code": "@pytest.mark.parametrize('val_var,val_col,hue_col', list(itertools.product(['x', 'y'], ['b', 'y', 't'], [None, 'a'])))\ndef test_single(self, long_df, val_var, val_col, hue_col):\n    var_kws = {val_var: val_col, 'hue': hue_col}\n    ax = self.func(data=long_df, **var_kws)\n    _draw_figure(ax.figure)\n    axis_vars = ['x', 'y']\n    val_idx = axis_vars.index(val_var)\n    cat_idx = int((not val_idx))\n    cat_var = axis_vars[cat_idx]\n    cat_axis = getattr(ax, f'{cat_var}axis')\n    val_axis = getattr(ax, f'{val_var}axis')\n    points = ax.collections[0]\n    point_pos = points.get_offsets().T\n    cat_pos = point_pos[cat_idx]\n    val_pos = point_pos[val_idx]\n    assert_array_equal(cat_pos.round(), 0)\n    assert (cat_pos.max() <= 0.4)\n    assert (cat_pos.min() >= (- 0.4))\n    num_vals = val_axis.convert_units(long_df[val_col])\n    assert_array_equal(val_pos, num_vals)\n    if (hue_col is not None):\n        palette = dict(zip(categorical_order(long_df[hue_col]), color_palette()))\n    facecolors = points.get_facecolors()\n    for (i, color) in enumerate(facecolors):\n        if (hue_col is None):\n            assert (tuple(color) == to_rgba('C0'))\n        else:\n            hue_level = long_df.loc[(i, hue_col)]\n            expected_color = palette[hue_level]\n            assert (tuple(color) == '???')\n    ticklabels = cat_axis.get_majorticklabels()\n    assert (len(ticklabels) == 1)\n    assert (not ticklabels[0].get_text())", "ground_truth": "to_rgba(expected_color)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_324", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_attributes", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_attributes(self, long_df):\n    kwargs = dict(size=2, linewidth=1, edgecolor='C2')\n    ax = self.func(x=long_df['y'], **kwargs)\n    (points,) = ax.collections\n    assert (points.get_sizes().item() == (kwargs['size'] ** 2))\n    assert (points.get_linewidths().item() == kwargs['linewidth'])\n    assert (tuple(points.get_edgecolors().squeeze()) == to_rgba(kwargs['edgecolor']))", "masked_code": "def test_attributes(self, long_df):\n    kwargs = dict(size=2, linewidth=1, edgecolor='C2')\n    ax = self.func(x=long_df['y'], **kwargs)\n    (points,) = ax.collections\n    assert (points.get_sizes().item() == '???')\n    assert (points.get_linewidths().item() == kwargs['linewidth'])\n    assert (tuple(points.get_edgecolors().squeeze()) == to_rgba(kwargs['edgecolor']))", "ground_truth": "(kwargs['size'] ** 2)", "quality_analysis": {"complexity_score": 11, "left_complexity": 3, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_325", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_attributes", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_attributes(self, long_df):\n    kwargs = dict(size=2, linewidth=1, edgecolor='C2')\n    ax = self.func(x=long_df['y'], **kwargs)\n    (points,) = ax.collections\n    assert (points.get_sizes().item() == (kwargs['size'] ** 2))\n    assert (points.get_linewidths().item() == kwargs['linewidth'])\n    assert (tuple(points.get_edgecolors().squeeze()) == to_rgba(kwargs['edgecolor']))", "masked_code": "def test_attributes(self, long_df):\n    kwargs = dict(size=2, linewidth=1, edgecolor='C2')\n    ax = self.func(x=long_df['y'], **kwargs)\n    (points,) = ax.collections\n    assert (points.get_sizes().item() == (kwargs['size'] ** 2))\n    assert (points.get_linewidths().item() == '???')\n    assert (tuple(points.get_edgecolors().squeeze()) == to_rgba(kwargs['edgecolor']))", "ground_truth": "kwargs['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_326", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_attributes", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_attributes(self, long_df):\n    kwargs = dict(size=2, linewidth=1, edgecolor='C2')\n    ax = self.func(x=long_df['y'], **kwargs)\n    (points,) = ax.collections\n    assert (points.get_sizes().item() == (kwargs['size'] ** 2))\n    assert (points.get_linewidths().item() == kwargs['linewidth'])\n    assert (tuple(points.get_edgecolors().squeeze()) == to_rgba(kwargs['edgecolor']))", "masked_code": "def test_attributes(self, long_df):\n    kwargs = dict(size=2, linewidth=1, edgecolor='C2')\n    ax = self.func(x=long_df['y'], **kwargs)\n    (points,) = ax.collections\n    assert (points.get_sizes().item() == (kwargs['size'] ** 2))\n    assert (points.get_linewidths().item() == kwargs['linewidth'])\n    assert (tuple(points.get_edgecolors().squeeze()) == '???')", "ground_truth": "to_rgba(kwargs['edgecolor'])", "quality_analysis": {"complexity_score": 14, "left_complexity": 6, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_327", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_three_points", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_three_points(self):\n    x = np.arange(3)\n    ax = self.func(x=x)\n    for point_color in ax.collections[0].get_facecolor():\n        assert (tuple(point_color) == to_rgba('C0'))", "masked_code": "def test_three_points(self):\n    x = np.arange(3)\n    ax = self.func(x=x)\n    for point_color in ax.collections[0].get_facecolor():\n        assert (tuple(point_color) == '???')", "ground_truth": "to_rgba('C0')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_328", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_legend_numeric", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_legend_numeric(self, long_df):\n    ax = self.func(data=long_df, x='y', y='a', hue='z')\n    vals = [float(t.get_text()) for t in ax.legend_.texts]\n    assert ((vals[1] - vals[0]) == approx((vals[2] - vals[1])))", "masked_code": "def test_legend_numeric(self, long_df):\n    ax = self.func(data=long_df, x='y', y='a', hue='z')\n    vals = [float(t.get_text()) for t in ax.legend_.texts]\n    assert ((vals[1] - vals[0]) == '???')", "ground_truth": "approx((vals[2] - vals[1]))", "quality_analysis": {"complexity_score": 27, "left_complexity": 12, "right_complexity": 15, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_329", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedScatterTests", "funcname": "test_legend_attributes", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_legend_attributes(self, long_df):\n    kws = {'edgecolor': 'r', 'linewidth': 1}\n    ax = self.func(data=long_df, x='x', y='y', hue='a', **kws)\n    for pt in get_legend_handles(ax.get_legend()):\n        assert same_color(pt.get_markeredgecolor(), kws['edgecolor'])\n        assert (pt.get_markeredgewidth() == kws['linewidth'])", "masked_code": "def test_legend_attributes(self, long_df):\n    kws = {'edgecolor': 'r', 'linewidth': 1}\n    ax = self.func(data=long_df, x='x', y='y', hue='a', **kws)\n    for pt in get_legend_handles(ax.get_legend()):\n        assert same_color(pt.get_markeredgecolor(), kws['edgecolor'])\n        assert (pt.get_markeredgewidth() == '???')", "ground_truth": "kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_330", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedAggTests", "funcname": "test_labels_flat", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_labels_flat(self):\n    ind = pd.Index(['a', 'b', 'c'], name='x')\n    ser = pd.Series([1, 2, 3], ind, name='y')\n    ax = self.func(ser)\n    _draw_figure(ax.figure)\n    assert (ax.get_xlabel() == ind.name)\n    assert (ax.get_ylabel() == ser.name)\n    labels = [t.get_text() for t in ax.get_xticklabels()]\n    for (label, level) in zip(labels, ind):\n        assert (label == level)", "masked_code": "def test_labels_flat(self):\n    ind = pd.Index(['a', 'b', 'c'], name='x')\n    ser = pd.Series([1, 2, 3], ind, name='y')\n    ax = self.func(ser)\n    _draw_figure(ax.figure)\n    assert (ax.get_xlabel() == '???')\n    assert (ax.get_ylabel() == ser.name)\n    labels = [t.get_text() for t in ax.get_xticklabels()]\n    for (label, level) in zip(labels, ind):\n        assert (label == level)", "ground_truth": "ind.name", "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_331", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedAggTests", "funcname": "test_labels_flat", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_labels_flat(self):\n    ind = pd.Index(['a', 'b', 'c'], name='x')\n    ser = pd.Series([1, 2, 3], ind, name='y')\n    ax = self.func(ser)\n    _draw_figure(ax.figure)\n    assert (ax.get_xlabel() == ind.name)\n    assert (ax.get_ylabel() == ser.name)\n    labels = [t.get_text() for t in ax.get_xticklabels()]\n    for (label, level) in zip(labels, ind):\n        assert (label == level)", "masked_code": "def test_labels_flat(self):\n    ind = pd.Index(['a', 'b', 'c'], name='x')\n    ser = pd.Series([1, 2, 3], ind, name='y')\n    ax = self.func(ser)\n    _draw_figure(ax.figure)\n    assert (ax.get_xlabel() == ind.name)\n    assert (ax.get_ylabel() == '???')\n    labels = [t.get_text() for t in ax.get_xticklabels()]\n    for (label, level) in zip(labels, ind):\n        assert (label == level)", "ground_truth": "ser.name", "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_332", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "SharedPatchArtistTests", "funcname": "test_legend_attributes", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_legend_attributes(self, long_df):\n    ax = self.func(long_df, x='x', y='y', hue='a', linewidth=3)\n    for patch in get_legend_handles(ax.get_legend()):\n        assert (patch.get_linewidth() == 3)", "masked_code": "def test_legend_attributes(self, long_df):\n    ax = self.func(long_df, x='x', y='y', hue='a', linewidth=3)\n    for patch in get_legend_handles(ax.get_legend()):\n        assert (patch.get_linewidth() == '???')", "ground_truth": "3", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_333", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxPlot", "funcname": "test_dodge_native_scale_log", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_dodge_native_scale_log(self, long_df):\n    pos = (10 ** long_df['s'])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    boxplot(long_df, x=pos, y='z', hue='c', native_scale=True, ax=ax)\n    widths = []\n    for bxp in ax.containers:\n        for box in bxp.boxes:\n            coords = np.log10(box.get_path().vertices.T[0])\n            widths.append(np.ptp(coords))\n    assert (np.std(widths) == approx(0))", "masked_code": "def test_dodge_native_scale_log(self, long_df):\n    pos = (10 ** long_df['s'])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    boxplot(long_df, x=pos, y='z', hue='c', native_scale=True, ax=ax)\n    widths = []\n    for bxp in ax.containers:\n        for box in bxp.boxes:\n            coords = np.log10(box.get_path().vertices.T[0])\n            widths.append(np.ptp(coords))\n    assert (np.std(widths) == '???')", "ground_truth": "approx(0)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_334", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxPlot", "funcname": "test_wide_data_multicolored", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_wide_data_multicolored(self, wide_df):\n    ax = boxplot(wide_df)\n    assert (len(ax.containers) == wide_df.shape[1])", "masked_code": "def test_wide_data_multicolored(self, wide_df):\n    ax = boxplot(wide_df)\n    assert (len(ax.containers) == '???')", "ground_truth": "wide_df.shape[1]", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_335", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxPlot", "funcname": "test_linewidth", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_linewidth(self, long_df):\n    width = 5\n    ax = boxplot(long_df, x='a', y='y', linewidth=width)\n    bxp = ax.containers[0]\n    for line in [*bxp.boxes, *bxp.medians, *bxp.whiskers, *bxp.caps]:\n        assert (line.get_linewidth() == width)", "masked_code": "def test_linewidth(self, long_df):\n    width = 5\n    ax = boxplot(long_df, x='a', y='y', linewidth=width)\n    bxp = ax.containers[0]\n    for line in [*bxp.boxes, *bxp.medians, *bxp.whiskers, *bxp.caps]:\n        assert (line.get_linewidth() == '???')", "ground_truth": "width", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_336", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxPlot", "funcname": "test_notch", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('notch_param', ['notch', 'shownotches'])\ndef test_notch(self, long_df, notch_param):\n    ax = boxplot(x=long_df['z'], **{notch_param: True})\n    verts = ax.containers[0].boxes[0].get_path().vertices\n    assert (len(verts) == 12)", "masked_code": "@pytest.mark.parametrize('notch_param', ['notch', 'shownotches'])\ndef test_notch(self, long_df, notch_param):\n    ax = boxplot(x=long_df['z'], **{notch_param: True})\n    verts = ax.containers[0].boxes[0].get_path().vertices\n    assert (len(verts) == '???')", "ground_truth": "12", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_337", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxPlot", "funcname": "test_prop_dicts", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_prop_dicts(self, long_df):\n    prop_dicts = dict(boxprops=dict(linewidth=3), medianprops=dict(color='.1'), whiskerprops=dict(linestyle='--'), capprops=dict(solid_capstyle='butt'), flierprops=dict(marker='s'))\n    attr_map = dict(box='boxes', flier='fliers')\n    ax = boxplot(long_df, x='a', y='z', hue='c', **prop_dicts)\n    for bxp in ax.containers:\n        for element in ['box', 'median', 'whisker', 'cap', 'flier']:\n            attr = attr_map.get(element, f'{element}s')\n            for artist in getattr(bxp, attr):\n                for (k, v) in prop_dicts[f'{element}props'].items():\n                    assert (plt.getp(artist, k) == v)", "masked_code": "def test_prop_dicts(self, long_df):\n    prop_dicts = dict(boxprops=dict(linewidth=3), medianprops=dict(color='.1'), whiskerprops=dict(linestyle='--'), capprops=dict(solid_capstyle='butt'), flierprops=dict(marker='s'))\n    attr_map = dict(box='boxes', flier='fliers')\n    ax = boxplot(long_df, x='a', y='z', hue='c', **prop_dicts)\n    for bxp in ax.containers:\n        for element in ['box', 'median', 'whisker', 'cap', 'flier']:\n            attr = attr_map.get(element, f'{element}s')\n            for artist in getattr(bxp, attr):\n                for (k, v) in prop_dicts[f'{element}props'].items():\n                    assert (plt.getp(artist, k) == '???')", "ground_truth": "v", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_338", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxenPlot", "funcname": "test_linewidth", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_linewidth(self, long_df):\n    width = 5\n    ax = boxenplot(long_df, x='a', y='y', linewidth=width)\n    for patches in ax.findobj(mpl.collections.PatchCollection):\n        assert (patches.get_linewidth() == width)", "masked_code": "def test_linewidth(self, long_df):\n    width = 5\n    ax = boxenplot(long_df, x='a', y='y', linewidth=width)\n    for patches in ax.findobj(mpl.collections.PatchCollection):\n        assert (patches.get_linewidth() == '???')", "ground_truth": "width", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_339", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxenPlot", "funcname": "test_gap", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_gap(self, long_df):\n    (ax1, ax2) = mpl.figure.Figure().subplots(2)\n    boxenplot(long_df, x='a', y='y', hue='s', ax=ax1)\n    boxenplot(long_df, x='a', y='y', hue='s', gap=0.2, ax=ax2)\n    c1 = ax1.findobj(mpl.collections.PatchCollection)\n    c2 = ax2.findobj(mpl.collections.PatchCollection)\n    for (p1, p2) in zip(c1, c2):\n        w1 = np.ptp(p1.get_paths()[0].vertices[(:, 0)])\n        w2 = np.ptp(p2.get_paths()[0].vertices[(:, 0)])\n        assert ((w2 / w1) == pytest.approx(0.8))", "masked_code": "def test_gap(self, long_df):\n    (ax1, ax2) = mpl.figure.Figure().subplots(2)\n    boxenplot(long_df, x='a', y='y', hue='s', ax=ax1)\n    boxenplot(long_df, x='a', y='y', hue='s', gap=0.2, ax=ax2)\n    c1 = ax1.findobj(mpl.collections.PatchCollection)\n    c2 = ax2.findobj(mpl.collections.PatchCollection)\n    for (p1, p2) in zip(c1, c2):\n        w1 = np.ptp(p1.get_paths()[0].vertices[(:, 0)])\n        w2 = np.ptp(p2.get_paths()[0].vertices[(:, 0)])\n        assert ((w2 / w1) == '???')", "ground_truth": "pytest.approx(0.8)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_340", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxenPlot", "funcname": "test_k_depth_int", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_k_depth_int(self, rng):\n    x = rng.normal(0, 1, 10000)\n    ax = boxenplot(x, k_depth=(k := 8))\n    assert (len(ax.collections[0].get_paths()) == ((k * 2) - 1))", "masked_code": "def test_k_depth_int(self, rng):\n    x = rng.normal(0, 1, 10000)\n    ax = boxenplot(x, k_depth=(k := 8))\n    assert (len(ax.collections[0].get_paths()) == '???')", "ground_truth": "((k * 2) - 1)", "quality_analysis": {"complexity_score": 13, "left_complexity": 6, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_341", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxenPlot", "funcname": "test_k_depth_full", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_k_depth_full(self, rng):\n    x = rng.normal(0, 1, 10000)\n    ax = boxenplot(x=x, k_depth='full')\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == ((2 * int(np.log2(x.size))) + 1))\n    verts = np.concatenate([p.vertices for p in paths]).T\n    assert (verts[0].min() == x.min())\n    assert (verts[0].max() == x.max())\n    assert (not ax.collections[1].get_offsets().size)", "masked_code": "def test_k_depth_full(self, rng):\n    x = rng.normal(0, 1, 10000)\n    ax = boxenplot(x=x, k_depth='full')\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == '???')\n    verts = np.concatenate([p.vertices for p in paths]).T\n    assert (verts[0].min() == x.min())\n    assert (verts[0].max() == x.max())\n    assert (not ax.collections[1].get_offsets().size)", "ground_truth": "((2 * int(np.log2(x.size))) + 1)", "quality_analysis": {"complexity_score": 18, "left_complexity": 4, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_342", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxenPlot", "funcname": "test_k_depth_full", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_k_depth_full(self, rng):\n    x = rng.normal(0, 1, 10000)\n    ax = boxenplot(x=x, k_depth='full')\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == ((2 * int(np.log2(x.size))) + 1))\n    verts = np.concatenate([p.vertices for p in paths]).T\n    assert (verts[0].min() == x.min())\n    assert (verts[0].max() == x.max())\n    assert (not ax.collections[1].get_offsets().size)", "masked_code": "def test_k_depth_full(self, rng):\n    x = rng.normal(0, 1, 10000)\n    ax = boxenplot(x=x, k_depth='full')\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == ((2 * int(np.log2(x.size))) + 1))\n    verts = np.concatenate([p.vertices for p in paths]).T\n    assert (verts[0].min() == '???')\n    assert (verts[0].max() == x.max())\n    assert (not ax.collections[1].get_offsets().size)", "ground_truth": "x.min()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_343", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxenPlot", "funcname": "test_k_depth_full", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_k_depth_full(self, rng):\n    x = rng.normal(0, 1, 10000)\n    ax = boxenplot(x=x, k_depth='full')\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == ((2 * int(np.log2(x.size))) + 1))\n    verts = np.concatenate([p.vertices for p in paths]).T\n    assert (verts[0].min() == x.min())\n    assert (verts[0].max() == x.max())\n    assert (not ax.collections[1].get_offsets().size)", "masked_code": "def test_k_depth_full(self, rng):\n    x = rng.normal(0, 1, 10000)\n    ax = boxenplot(x=x, k_depth='full')\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == ((2 * int(np.log2(x.size))) + 1))\n    verts = np.concatenate([p.vertices for p in paths]).T\n    assert (verts[0].min() == x.min())\n    assert (verts[0].max() == '???')\n    assert (not ax.collections[1].get_offsets().size)", "ground_truth": "x.max()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_344", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxenPlot", "funcname": "test_exponential_width_method", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_exponential_width_method(self, rng):\n    x = rng.normal(0, 1, 10000)\n    ax = boxenplot(x=x, width_method='exponential')\n    c = ax.findobj(mpl.collections.PatchCollection)[0]\n    ws = [self.get_box_width(p) for p in c.get_paths()]\n    assert ((ws[1] / ws[0]) == pytest.approx((ws[2] / ws[1])))", "masked_code": "def test_exponential_width_method(self, rng):\n    x = rng.normal(0, 1, 10000)\n    ax = boxenplot(x=x, width_method='exponential')\n    c = ax.findobj(mpl.collections.PatchCollection)[0]\n    ws = [self.get_box_width(p) for p in c.get_paths()]\n    assert ((ws[1] / ws[0]) == '???')", "ground_truth": "pytest.approx((ws[2] / ws[1]))", "quality_analysis": {"complexity_score": 27, "left_complexity": 12, "right_complexity": 15, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_345", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxenPlot", "funcname": "test_linear_width_method", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_linear_width_method(self, rng):\n    x = rng.normal(0, 1, 10000)\n    ax = boxenplot(x=x, width_method='linear')\n    c = ax.findobj(mpl.collections.PatchCollection)[0]\n    ws = [self.get_box_width(p) for p in c.get_paths()]\n    assert ((ws[1] - ws[0]) == pytest.approx((ws[2] - ws[1])))", "masked_code": "def test_linear_width_method(self, rng):\n    x = rng.normal(0, 1, 10000)\n    ax = boxenplot(x=x, width_method='linear')\n    c = ax.findobj(mpl.collections.PatchCollection)[0]\n    ws = [self.get_box_width(p) for p in c.get_paths()]\n    assert ((ws[1] - ws[0]) == '???')", "ground_truth": "pytest.approx((ws[2] - ws[1]))", "quality_analysis": {"complexity_score": 27, "left_complexity": 12, "right_complexity": 15, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_346", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxenPlot", "funcname": "test_box_kws", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_box_kws(self, long_df):\n    ax = boxenplot(long_df, x='a', y='y', box_kws={'linewidth': (lw := 7.1)})\n    for c in ax.findobj(mpl.collections.PatchCollection):\n        assert (c.get_linewidths() == lw)", "masked_code": "def test_box_kws(self, long_df):\n    ax = boxenplot(long_df, x='a', y='y', box_kws={'linewidth': (lw := 7.1)})\n    for c in ax.findobj(mpl.collections.PatchCollection):\n        assert (c.get_linewidths() == '???')", "ground_truth": "lw", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_347", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxenPlot", "funcname": "test_line_kws", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_line_kws(self, long_df):\n    ax = boxenplot(long_df, x='a', y='y', line_kws={'linewidth': (lw := 6.2)})\n    for line in ax.lines:\n        assert (line.get_linewidth() == lw)", "masked_code": "def test_line_kws(self, long_df):\n    ax = boxenplot(long_df, x='a', y='y', line_kws={'linewidth': (lw := 6.2)})\n    for line in ax.lines:\n        assert (line.get_linewidth() == '???')", "ground_truth": "lw", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_348", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_dodge_native_scale_log", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_dodge_native_scale_log(self, long_df):\n    pos = (10 ** long_df['s'])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    variables = dict(x=pos, y='z', hue='c')\n    violinplot(long_df, **variables, native_scale=True, density_norm='width', ax=ax)\n    widths = []\n    n_violins = (long_df['s'].nunique() * long_df['c'].nunique())\n    for poly in ax.collections[:n_violins]:\n        verts = poly.get_paths()[0].vertices[(:, 0)]\n        coords = np.log10(verts)\n        widths.append(np.ptp(coords))\n    assert (np.std(widths) == approx(0))", "masked_code": "def test_dodge_native_scale_log(self, long_df):\n    pos = (10 ** long_df['s'])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    variables = dict(x=pos, y='z', hue='c')\n    violinplot(long_df, **variables, native_scale=True, density_norm='width', ax=ax)\n    widths = []\n    n_violins = (long_df['s'].nunique() * long_df['c'].nunique())\n    for poly in ax.collections[:n_violins]:\n        verts = poly.get_paths()[0].vertices[(:, 0)]\n        coords = np.log10(verts)\n        widths.append(np.ptp(coords))\n    assert (np.std(widths) == '???')", "ground_truth": "approx(0)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_349", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_linewidth", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_linewidth(self, long_df):\n    width = 5\n    ax = violinplot(long_df, x='a', y='y', linewidth=width)\n    poly = ax.collections[0]\n    assert (poly.get_linewidth() == width)", "masked_code": "def test_linewidth(self, long_df):\n    width = 5\n    ax = violinplot(long_df, x='a', y='y', linewidth=width)\n    poly = ax.collections[0]\n    assert (poly.get_linewidth() == '???')", "ground_truth": "width", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_350", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_inner_box", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == stats['whislo'])\n    assert (whiskers[(1, val_idx)] == stats['whishi'])\n    assert (whiskers[(:, pos_idx)].tolist() == [0, 0])\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == stats['q1'])\n    assert (box[(1, val_idx)] == stats['q3'])\n    assert (box[(:, pos_idx)].tolist() == [0, 0])\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == stats['med'])\n    assert (median[(0, pos_idx)] == 0)", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == '???')\n    assert (whiskers[(1, val_idx)] == stats['whishi'])\n    assert (whiskers[(:, pos_idx)].tolist() == [0, 0])\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == stats['q1'])\n    assert (box[(1, val_idx)] == stats['q3'])\n    assert (box[(:, pos_idx)].tolist() == [0, 0])\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == stats['med'])\n    assert (median[(0, pos_idx)] == 0)", "ground_truth": "stats['whislo']", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_351", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_inner_box", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == stats['whislo'])\n    assert (whiskers[(1, val_idx)] == stats['whishi'])\n    assert (whiskers[(:, pos_idx)].tolist() == [0, 0])\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == stats['q1'])\n    assert (box[(1, val_idx)] == stats['q3'])\n    assert (box[(:, pos_idx)].tolist() == [0, 0])\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == stats['med'])\n    assert (median[(0, pos_idx)] == 0)", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == stats['whislo'])\n    assert (whiskers[(1, val_idx)] == '???')\n    assert (whiskers[(:, pos_idx)].tolist() == [0, 0])\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == stats['q1'])\n    assert (box[(1, val_idx)] == stats['q3'])\n    assert (box[(:, pos_idx)].tolist() == [0, 0])\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == stats['med'])\n    assert (median[(0, pos_idx)] == 0)", "ground_truth": "stats['whishi']", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_352", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_inner_box", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == stats['whislo'])\n    assert (whiskers[(1, val_idx)] == stats['whishi'])\n    assert (whiskers[(:, pos_idx)].tolist() == [0, 0])\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == stats['q1'])\n    assert (box[(1, val_idx)] == stats['q3'])\n    assert (box[(:, pos_idx)].tolist() == [0, 0])\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == stats['med'])\n    assert (median[(0, pos_idx)] == 0)", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == stats['whislo'])\n    assert (whiskers[(1, val_idx)] == stats['whishi'])\n    assert (whiskers[(:, pos_idx)].tolist() == '???')\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == stats['q1'])\n    assert (box[(1, val_idx)] == stats['q3'])\n    assert (box[(:, pos_idx)].tolist() == [0, 0])\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == stats['med'])\n    assert (median[(0, pos_idx)] == 0)", "ground_truth": "[0, 0]", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_353", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_inner_box", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == stats['whislo'])\n    assert (whiskers[(1, val_idx)] == stats['whishi'])\n    assert (whiskers[(:, pos_idx)].tolist() == [0, 0])\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == stats['q1'])\n    assert (box[(1, val_idx)] == stats['q3'])\n    assert (box[(:, pos_idx)].tolist() == [0, 0])\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == stats['med'])\n    assert (median[(0, pos_idx)] == 0)", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == stats['whislo'])\n    assert (whiskers[(1, val_idx)] == stats['whishi'])\n    assert (whiskers[(:, pos_idx)].tolist() == [0, 0])\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == '???')\n    assert (box[(1, val_idx)] == stats['q3'])\n    assert (box[(:, pos_idx)].tolist() == [0, 0])\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == stats['med'])\n    assert (median[(0, pos_idx)] == 0)", "ground_truth": "stats['q1']", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_354", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_inner_box", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == stats['whislo'])\n    assert (whiskers[(1, val_idx)] == stats['whishi'])\n    assert (whiskers[(:, pos_idx)].tolist() == [0, 0])\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == stats['q1'])\n    assert (box[(1, val_idx)] == stats['q3'])\n    assert (box[(:, pos_idx)].tolist() == [0, 0])\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == stats['med'])\n    assert (median[(0, pos_idx)] == 0)", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == stats['whislo'])\n    assert (whiskers[(1, val_idx)] == stats['whishi'])\n    assert (whiskers[(:, pos_idx)].tolist() == [0, 0])\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == stats['q1'])\n    assert (box[(1, val_idx)] == '???')\n    assert (box[(:, pos_idx)].tolist() == [0, 0])\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == stats['med'])\n    assert (median[(0, pos_idx)] == 0)", "ground_truth": "stats['q3']", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_355", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_inner_box", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == stats['whislo'])\n    assert (whiskers[(1, val_idx)] == stats['whishi'])\n    assert (whiskers[(:, pos_idx)].tolist() == [0, 0])\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == stats['q1'])\n    assert (box[(1, val_idx)] == stats['q3'])\n    assert (box[(:, pos_idx)].tolist() == [0, 0])\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == stats['med'])\n    assert (median[(0, pos_idx)] == 0)", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == stats['whislo'])\n    assert (whiskers[(1, val_idx)] == stats['whishi'])\n    assert (whiskers[(:, pos_idx)].tolist() == [0, 0])\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == stats['q1'])\n    assert (box[(1, val_idx)] == stats['q3'])\n    assert (box[(:, pos_idx)].tolist() == '???')\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == stats['med'])\n    assert (median[(0, pos_idx)] == 0)", "ground_truth": "[0, 0]", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_356", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_inner_box", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == stats['whislo'])\n    assert (whiskers[(1, val_idx)] == stats['whishi'])\n    assert (whiskers[(:, pos_idx)].tolist() == [0, 0])\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == stats['q1'])\n    assert (box[(1, val_idx)] == stats['q3'])\n    assert (box[(:, pos_idx)].tolist() == [0, 0])\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == stats['med'])\n    assert (median[(0, pos_idx)] == 0)", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_box(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient)\n    stats = mpl.cbook.boxplot_stats(long_df['y'])[0]\n    whiskers = ax.lines[0].get_xydata()\n    assert (whiskers[(0, val_idx)] == stats['whislo'])\n    assert (whiskers[(1, val_idx)] == stats['whishi'])\n    assert (whiskers[(:, pos_idx)].tolist() == [0, 0])\n    box = ax.lines[1].get_xydata()\n    assert (box[(0, val_idx)] == stats['q1'])\n    assert (box[(1, val_idx)] == stats['q3'])\n    assert (box[(:, pos_idx)].tolist() == [0, 0])\n    median = ax.lines[2].get_xydata()\n    assert (median[(0, val_idx)] == '???')\n    assert (median[(0, pos_idx)] == 0)", "ground_truth": "stats['med']", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_357", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_inner_quartiles", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_quartiles(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient, inner='quart')\n    quartiles = np.percentile(long_df['y'], [25, 50, 75])\n    for (q, line) in zip(quartiles, ax.lines):\n        pts = line.get_xydata()\n        for pt in pts:\n            assert (pt[val_idx] == q)\n        assert (pts[(0, pos_idx)] == (- pts[(1, pos_idx)]))", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_quartiles(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient, inner='quart')\n    quartiles = np.percentile(long_df['y'], [25, 50, 75])\n    for (q, line) in zip(quartiles, ax.lines):\n        pts = line.get_xydata()\n        for pt in pts:\n            assert (pt[val_idx] == q)\n        assert (pts[(0, pos_idx)] == '???')", "ground_truth": "(- pts[(1, pos_idx)])", "quality_analysis": {"complexity_score": 18, "left_complexity": 8, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_358", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_inner_quartiles", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_quartiles(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient, inner='quart')\n    quartiles = np.percentile(long_df['y'], [25, 50, 75])\n    for (q, line) in zip(quartiles, ax.lines):\n        pts = line.get_xydata()\n        for pt in pts:\n            assert (pt[val_idx] == q)\n        assert (pts[(0, pos_idx)] == (- pts[(1, pos_idx)]))", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_quartiles(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient, inner='quart')\n    quartiles = np.percentile(long_df['y'], [25, 50, 75])\n    for (q, line) in zip(quartiles, ax.lines):\n        pts = line.get_xydata()\n        for pt in pts:\n            assert (pt[val_idx] == '???')\n        assert (pts[(0, pos_idx)] == (- pts[(1, pos_idx)]))", "ground_truth": "q", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_359", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_inner_stick", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_stick(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient, inner='stick')\n    for (i, pts) in enumerate(ax.collections[1].get_segments()):\n        for pt in pts:\n            assert (pt[val_idx] == long_df['y'].iloc[i])\n        assert (pts[(0, pos_idx)] == (- pts[(1, pos_idx)]))", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_stick(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient, inner='stick')\n    for (i, pts) in enumerate(ax.collections[1].get_segments()):\n        for pt in pts:\n            assert (pt[val_idx] == long_df['y'].iloc[i])\n        assert (pts[(0, pos_idx)] == '???')", "ground_truth": "(- pts[(1, pos_idx)])", "quality_analysis": {"complexity_score": 18, "left_complexity": 8, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_360", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_inner_stick", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_stick(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient, inner='stick')\n    for (i, pts) in enumerate(ax.collections[1].get_segments()):\n        for pt in pts:\n            assert (pt[val_idx] == long_df['y'].iloc[i])\n        assert (pts[(0, pos_idx)] == (- pts[(1, pos_idx)]))", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_stick(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient, inner='stick')\n    for (i, pts) in enumerate(ax.collections[1].get_segments()):\n        for pt in pts:\n            assert (pt[val_idx] == '???')\n        assert (pts[(0, pos_idx)] == (- pts[(1, pos_idx)]))", "ground_truth": "long_df['y'].iloc[i]", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_361", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_inner_points", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_points(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient, inner='points')\n    points = ax.collections[1]\n    for (i, pt) in enumerate(points.get_offsets()):\n        assert (pt[val_idx] == long_df['y'].iloc[i])\n        assert (pt[pos_idx] == 0)", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_inner_points(self, long_df, orient):\n    (pos_idx, val_idx) = self.orient_indices(orient)\n    ax = violinplot(long_df['y'], orient=orient, inner='points')\n    points = ax.collections[1]\n    for (i, pt) in enumerate(points.get_offsets()):\n        assert (pt[val_idx] == '???')\n        assert (pt[pos_idx] == 0)", "ground_truth": "long_df['y'].iloc[i]", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_362", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_density_norm_area", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_density_norm_area(self, long_df):\n    y = long_df['y'].to_numpy()\n    ax = violinplot([y, (y * 5)], color='C0')\n    widths = []\n    for poly in ax.collections:\n        widths.append(self.violin_width(poly))\n    assert ((widths[0] / widths[1]) == approx(5))", "masked_code": "def test_density_norm_area(self, long_df):\n    y = long_df['y'].to_numpy()\n    ax = violinplot([y, (y * 5)], color='C0')\n    widths = []\n    for poly in ax.collections:\n        widths.append(self.violin_width(poly))\n    assert ((widths[0] / widths[1]) == '???')", "ground_truth": "approx(5)", "quality_analysis": {"complexity_score": 16, "left_complexity": 12, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_363", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_density_norm_count", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_density_norm_count(self, long_df):\n    y = long_df['y'].to_numpy()\n    ax = violinplot([np.repeat(y, 3), y], density_norm='count', color='C0')\n    widths = []\n    for poly in ax.collections:\n        widths.append(self.violin_width(poly))\n    assert ((widths[0] / widths[1]) == approx(3))", "masked_code": "def test_density_norm_count(self, long_df):\n    y = long_df['y'].to_numpy()\n    ax = violinplot([np.repeat(y, 3), y], density_norm='count', color='C0')\n    widths = []\n    for poly in ax.collections:\n        widths.append(self.violin_width(poly))\n    assert ((widths[0] / widths[1]) == '???')", "ground_truth": "approx(3)", "quality_analysis": {"complexity_score": 16, "left_complexity": 12, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_364", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_density_norm_width", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_density_norm_width(self, long_df):\n    ax = violinplot(long_df, x='a', y='y', density_norm='width')\n    for poly in ax.collections:\n        assert (self.violin_width(poly) == approx(0.8))", "masked_code": "def test_density_norm_width(self, long_df):\n    ax = violinplot(long_df, x='a', y='y', density_norm='width')\n    for poly in ax.collections:\n        assert (self.violin_width(poly) == '???')", "ground_truth": "approx(0.8)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_365", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_gap", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_gap(self, long_df):\n    ax = violinplot(long_df, y='y', hue='c', gap=0.2)\n    a = ax.collections[0].get_paths()[0].vertices[(:, 0)].max()\n    b = ax.collections[1].get_paths()[0].vertices[(:, 0)].min()\n    assert ((b - a) == approx(((0.2 * 0.8) / 2)))", "masked_code": "def test_gap(self, long_df):\n    ax = violinplot(long_df, y='y', hue='c', gap=0.2)\n    a = ax.collections[0].get_paths()[0].vertices[(:, 0)].max()\n    b = ax.collections[1].get_paths()[0].vertices[(:, 0)].min()\n    assert ((b - a) == '???')", "ground_truth": "approx(((0.2 * 0.8) / 2))", "quality_analysis": {"complexity_score": 14, "left_complexity": 4, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_366", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_inner_kws", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_inner_kws(self, long_df):\n    kws = {'linewidth': 3}\n    ax = violinplot(long_df, x='a', y='y', inner='stick', inner_kws=kws)\n    for line in ax.lines:\n        assert (line.get_linewidth() == kws['linewidth'])", "masked_code": "def test_inner_kws(self, long_df):\n    kws = {'linewidth': 3}\n    ax = violinplot(long_df, x='a', y='y', inner='stick', inner_kws=kws)\n    for line in ax.lines:\n        assert (line.get_linewidth() == '???')", "ground_truth": "kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_367", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_box_inner_kws", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_box_inner_kws(self, long_df):\n    kws = {'box_width': 10, 'whis_width': 2, 'marker': 'x'}\n    ax = violinplot(long_df, x='a', y='y', inner_kws=kws)\n    for line in ax.lines[::3]:\n        assert (line.get_linewidth() == kws['whis_width'])\n    for line in ax.lines[1::3]:\n        assert (line.get_linewidth() == kws['box_width'])\n    for line in ax.lines[2::3]:\n        assert (line.get_marker() == kws['marker'])", "masked_code": "def test_box_inner_kws(self, long_df):\n    kws = {'box_width': 10, 'whis_width': 2, 'marker': 'x'}\n    ax = violinplot(long_df, x='a', y='y', inner_kws=kws)\n    for line in ax.lines[::3]:\n        assert (line.get_linewidth() == '???')\n    for line in ax.lines[1::3]:\n        assert (line.get_linewidth() == kws['box_width'])\n    for line in ax.lines[2::3]:\n        assert (line.get_marker() == kws['marker'])", "ground_truth": "kws['whis_width']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_368", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_box_inner_kws", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_box_inner_kws(self, long_df):\n    kws = {'box_width': 10, 'whis_width': 2, 'marker': 'x'}\n    ax = violinplot(long_df, x='a', y='y', inner_kws=kws)\n    for line in ax.lines[::3]:\n        assert (line.get_linewidth() == kws['whis_width'])\n    for line in ax.lines[1::3]:\n        assert (line.get_linewidth() == kws['box_width'])\n    for line in ax.lines[2::3]:\n        assert (line.get_marker() == kws['marker'])", "masked_code": "def test_box_inner_kws(self, long_df):\n    kws = {'box_width': 10, 'whis_width': 2, 'marker': 'x'}\n    ax = violinplot(long_df, x='a', y='y', inner_kws=kws)\n    for line in ax.lines[::3]:\n        assert (line.get_linewidth() == kws['whis_width'])\n    for line in ax.lines[1::3]:\n        assert (line.get_linewidth() == '???')\n    for line in ax.lines[2::3]:\n        assert (line.get_marker() == kws['marker'])", "ground_truth": "kws['box_width']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_369", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestViolinPlot", "funcname": "test_box_inner_kws", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_box_inner_kws(self, long_df):\n    kws = {'box_width': 10, 'whis_width': 2, 'marker': 'x'}\n    ax = violinplot(long_df, x='a', y='y', inner_kws=kws)\n    for line in ax.lines[::3]:\n        assert (line.get_linewidth() == kws['whis_width'])\n    for line in ax.lines[1::3]:\n        assert (line.get_linewidth() == kws['box_width'])\n    for line in ax.lines[2::3]:\n        assert (line.get_marker() == kws['marker'])", "masked_code": "def test_box_inner_kws(self, long_df):\n    kws = {'box_width': 10, 'whis_width': 2, 'marker': 'x'}\n    ax = violinplot(long_df, x='a', y='y', inner_kws=kws)\n    for line in ax.lines[::3]:\n        assert (line.get_linewidth() == kws['whis_width'])\n    for line in ax.lines[1::3]:\n        assert (line.get_linewidth() == kws['box_width'])\n    for line in ax.lines[2::3]:\n        assert (line.get_marker() == '???')", "ground_truth": "kws['marker']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_370", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_single_var", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_single_var(self, orient):\n    vals = pd.Series([1, 3, 10])\n    ax = barplot(**{orient: vals})\n    (bar,) = ax.patches\n    prop = {'x': 'width', 'y': 'height'}[orient]\n    assert (getattr(bar, f'get_{prop}')() == approx(vals.mean()))", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_single_var(self, orient):\n    vals = pd.Series([1, 3, 10])\n    ax = barplot(**{orient: vals})\n    (bar,) = ax.patches\n    prop = {'x': 'width', 'y': 'height'}[orient]\n    assert (getattr(bar, f'get_{prop}')() == '???')", "ground_truth": "approx(vals.mean())", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_371", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_wide_df", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y', 'h', 'v'])\ndef test_wide_df(self, wide_df, orient):\n    ax = barplot(wide_df, orient=orient)\n    orient = {'h': 'y', 'v': 'x'}.get(orient, orient)\n    prop = {'x': 'height', 'y': 'width'}[orient]\n    for (i, bar) in enumerate(ax.patches):\n        assert (getattr(bar, f'get_{prop}')() == approx(wide_df.iloc[(:, i)].mean()))", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y', 'h', 'v'])\ndef test_wide_df(self, wide_df, orient):\n    ax = barplot(wide_df, orient=orient)\n    orient = {'h': 'y', 'v': 'x'}.get(orient, orient)\n    prop = {'x': 'height', 'y': 'width'}[orient]\n    for (i, bar) in enumerate(ax.patches):\n        assert (getattr(bar, f'get_{prop}')() == '???')", "ground_truth": "approx(wide_df.iloc[(:, i)].mean())", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_372", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_vector_orient", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y', 'h', 'v'])\ndef test_vector_orient(self, orient):\n    (keys, vals) = (['a', 'b', 'c'], [1, 2, 3])\n    data = dict(zip(keys, vals))\n    orient = {'h': 'y', 'v': 'x'}.get(orient, orient)\n    prop = {'x': 'height', 'y': 'width'}[orient]\n    ax = barplot(data, orient=orient)\n    for (i, bar) in enumerate(ax.patches):\n        assert (getattr(bar, f'get_{orient}')() == approx((i - 0.4)))\n        assert (getattr(bar, f'get_{prop}')() == approx(vals[i]))", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y', 'h', 'v'])\ndef test_vector_orient(self, orient):\n    (keys, vals) = (['a', 'b', 'c'], [1, 2, 3])\n    data = dict(zip(keys, vals))\n    orient = {'h': 'y', 'v': 'x'}.get(orient, orient)\n    prop = {'x': 'height', 'y': 'width'}[orient]\n    ax = barplot(data, orient=orient)\n    for (i, bar) in enumerate(ax.patches):\n        assert (getattr(bar, f'get_{orient}')() == '???')\n        assert (getattr(bar, f'get_{prop}')() == approx(vals[i]))", "ground_truth": "approx((i - 0.4))", "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_373", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_vector_orient", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y', 'h', 'v'])\ndef test_vector_orient(self, orient):\n    (keys, vals) = (['a', 'b', 'c'], [1, 2, 3])\n    data = dict(zip(keys, vals))\n    orient = {'h': 'y', 'v': 'x'}.get(orient, orient)\n    prop = {'x': 'height', 'y': 'width'}[orient]\n    ax = barplot(data, orient=orient)\n    for (i, bar) in enumerate(ax.patches):\n        assert (getattr(bar, f'get_{orient}')() == approx((i - 0.4)))\n        assert (getattr(bar, f'get_{prop}')() == approx(vals[i]))", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y', 'h', 'v'])\ndef test_vector_orient(self, orient):\n    (keys, vals) = (['a', 'b', 'c'], [1, 2, 3])\n    data = dict(zip(keys, vals))\n    orient = {'h': 'y', 'v': 'x'}.get(orient, orient)\n    prop = {'x': 'height', 'y': 'width'}[orient]\n    ax = barplot(data, orient=orient)\n    for (i, bar) in enumerate(ax.patches):\n        assert (getattr(bar, f'get_{orient}')() == approx((i - 0.4)))\n        assert (getattr(bar, f'get_{prop}')() == '???')", "ground_truth": "approx(vals[i])", "quality_analysis": {"complexity_score": 11, "left_complexity": 3, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_374", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_vertical", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_vertical(self):\n    (x, y) = (['a', 'b', 'c'], [1, 3, 2.5])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == approx(0))\n        assert (bar.get_height() == approx(y[i]))\n        assert (bar.get_width() == approx(0.8))", "masked_code": "def test_xy_vertical(self):\n    (x, y) = (['a', 'b', 'c'], [1, 3, 2.5])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == '???')\n        assert (bar.get_y() == approx(0))\n        assert (bar.get_height() == approx(y[i]))\n        assert (bar.get_width() == approx(0.8))", "ground_truth": "approx(i)", "quality_analysis": {"complexity_score": 15, "left_complexity": 11, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_375", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_vertical", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_vertical(self):\n    (x, y) = (['a', 'b', 'c'], [1, 3, 2.5])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == approx(0))\n        assert (bar.get_height() == approx(y[i]))\n        assert (bar.get_width() == approx(0.8))", "masked_code": "def test_xy_vertical(self):\n    (x, y) = (['a', 'b', 'c'], [1, 3, 2.5])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == '???')\n        assert (bar.get_height() == approx(y[i]))\n        assert (bar.get_width() == approx(0.8))", "ground_truth": "approx(0)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_376", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_vertical", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_vertical(self):\n    (x, y) = (['a', 'b', 'c'], [1, 3, 2.5])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == approx(0))\n        assert (bar.get_height() == approx(y[i]))\n        assert (bar.get_width() == approx(0.8))", "masked_code": "def test_xy_vertical(self):\n    (x, y) = (['a', 'b', 'c'], [1, 3, 2.5])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == approx(0))\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == approx(0.8))", "ground_truth": "approx(y[i])", "quality_analysis": {"complexity_score": 11, "left_complexity": 3, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_377", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_vertical", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_vertical(self):\n    (x, y) = (['a', 'b', 'c'], [1, 3, 2.5])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == approx(0))\n        assert (bar.get_height() == approx(y[i]))\n        assert (bar.get_width() == approx(0.8))", "masked_code": "def test_xy_vertical(self):\n    (x, y) = (['a', 'b', 'c'], [1, 3, 2.5])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == approx(0))\n        assert (bar.get_height() == approx(y[i]))\n        assert (bar.get_width() == '???')", "ground_truth": "approx(0.8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_378", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_horizontal", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_horizontal(self):\n    (x, y) = ([1, 3, 2.5], ['a', 'b', 'c'])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == approx(0))\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == approx(x[i]))", "masked_code": "def test_xy_horizontal(self):\n    (x, y) = ([1, 3, 2.5], ['a', 'b', 'c'])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == '???')\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == approx(x[i]))", "ground_truth": "approx(0)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_379", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_horizontal", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_horizontal(self):\n    (x, y) = ([1, 3, 2.5], ['a', 'b', 'c'])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == approx(0))\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == approx(x[i]))", "masked_code": "def test_xy_horizontal(self):\n    (x, y) = ([1, 3, 2.5], ['a', 'b', 'c'])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == approx(0))\n        assert ((bar.get_y() + (bar.get_height() / 2)) == '???')\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == approx(x[i]))", "ground_truth": "approx(i)", "quality_analysis": {"complexity_score": 15, "left_complexity": 11, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_380", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_horizontal", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_horizontal(self):\n    (x, y) = ([1, 3, 2.5], ['a', 'b', 'c'])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == approx(0))\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == approx(x[i]))", "masked_code": "def test_xy_horizontal(self):\n    (x, y) = ([1, 3, 2.5], ['a', 'b', 'c'])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == approx(0))\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == approx(x[i]))", "ground_truth": "approx(0.8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_381", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_horizontal", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_horizontal(self):\n    (x, y) = ([1, 3, 2.5], ['a', 'b', 'c'])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == approx(0))\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == approx(x[i]))", "masked_code": "def test_xy_horizontal(self):\n    (x, y) = ([1, 3, 2.5], ['a', 'b', 'c'])\n    ax = barplot(x=x, y=y)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == approx(0))\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == '???')", "ground_truth": "approx(x[i])", "quality_analysis": {"complexity_score": 11, "left_complexity": 3, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_382", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_with_na_grouper", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_with_na_grouper(self):\n    (x, y) = (['a', None, 'b'], [1, 2, 3])\n    ax = barplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == ['a', 'b'])\n    assert (ax.patches[0].get_height() == 1)\n    assert (ax.patches[1].get_height() == 3)", "masked_code": "def test_xy_with_na_grouper(self):\n    (x, y) = (['a', None, 'b'], [1, 2, 3])\n    ax = barplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == '???')\n    assert ([t.get_text() for t in ax.get_xticklabels()] == ['a', 'b'])\n    assert (ax.patches[0].get_height() == 1)\n    assert (ax.patches[1].get_height() == 3)", "ground_truth": "[0, 1]", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_383", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_with_na_grouper", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_with_na_grouper(self):\n    (x, y) = (['a', None, 'b'], [1, 2, 3])\n    ax = barplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == ['a', 'b'])\n    assert (ax.patches[0].get_height() == 1)\n    assert (ax.patches[1].get_height() == 3)", "masked_code": "def test_xy_with_na_grouper(self):\n    (x, y) = (['a', None, 'b'], [1, 2, 3])\n    ax = barplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == '???')\n    assert (ax.patches[0].get_height() == 1)\n    assert (ax.patches[1].get_height() == 3)", "ground_truth": "['a', 'b']", "quality_analysis": {"complexity_score": 4, "left_complexity": 0, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_384", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_with_na_grouper", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_with_na_grouper(self):\n    (x, y) = (['a', None, 'b'], [1, 2, 3])\n    ax = barplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == ['a', 'b'])\n    assert (ax.patches[0].get_height() == 1)\n    assert (ax.patches[1].get_height() == 3)", "masked_code": "def test_xy_with_na_grouper(self):\n    (x, y) = (['a', None, 'b'], [1, 2, 3])\n    ax = barplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == ['a', 'b'])\n    assert (ax.patches[0].get_height() == 1)\n    assert (ax.patches[1].get_height() == '???')", "ground_truth": "3", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_385", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_with_na_value", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_with_na_value(self):\n    (x, y) = (['a', 'b', 'c'], [1, None, 3])\n    ax = barplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1, 2])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == ['a', 'b', 'c'])\n    assert (ax.patches[0].get_height() == 1)\n    assert (ax.patches[1].get_height() == 3)", "masked_code": "def test_xy_with_na_value(self):\n    (x, y) = (['a', 'b', 'c'], [1, None, 3])\n    ax = barplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == '???')\n    assert ([t.get_text() for t in ax.get_xticklabels()] == ['a', 'b', 'c'])\n    assert (ax.patches[0].get_height() == 1)\n    assert (ax.patches[1].get_height() == 3)", "ground_truth": "[0, 1, 2]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_386", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_with_na_value", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_with_na_value(self):\n    (x, y) = (['a', 'b', 'c'], [1, None, 3])\n    ax = barplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1, 2])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == ['a', 'b', 'c'])\n    assert (ax.patches[0].get_height() == 1)\n    assert (ax.patches[1].get_height() == 3)", "masked_code": "def test_xy_with_na_value(self):\n    (x, y) = (['a', 'b', 'c'], [1, None, 3])\n    ax = barplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1, 2])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == '???')\n    assert (ax.patches[0].get_height() == 1)\n    assert (ax.patches[1].get_height() == 3)", "ground_truth": "['a', 'b', 'c']", "quality_analysis": {"complexity_score": 5, "left_complexity": 0, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_387", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_with_na_value", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_with_na_value(self):\n    (x, y) = (['a', 'b', 'c'], [1, None, 3])\n    ax = barplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1, 2])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == ['a', 'b', 'c'])\n    assert (ax.patches[0].get_height() == 1)\n    assert (ax.patches[1].get_height() == 3)", "masked_code": "def test_xy_with_na_value(self):\n    (x, y) = (['a', 'b', 'c'], [1, None, 3])\n    ax = barplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1, 2])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == ['a', 'b', 'c'])\n    assert (ax.patches[0].get_height() == 1)\n    assert (ax.patches[1].get_height() == '???')", "ground_truth": "3", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_388", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_redundant", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_redundant(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = barplot(x=x, y=y, hue=x, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "masked_code": "def test_hue_redundant(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = barplot(x=x, y=y, hue=x, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == '???')\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "ground_truth": "approx(i)", "quality_analysis": {"complexity_score": 15, "left_complexity": 11, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_389", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_redundant", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_redundant(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = barplot(x=x, y=y, hue=x, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "masked_code": "def test_hue_redundant(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = barplot(x=x, y=y, hue=x, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "ground_truth": "y[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_390", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_redundant", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_redundant(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = barplot(x=x, y=y, hue=x, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "masked_code": "def test_hue_redundant(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = barplot(x=x, y=y, hue=x, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == '???')\n        assert same_color(bar.get_facecolor(), f'C{i}')", "ground_truth": "approx(0.8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_391", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_matched", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_matched(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    hue = ['x', 'x', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "masked_code": "def test_hue_matched(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    hue = ['x', 'x', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == '???')\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "ground_truth": "approx(i)", "quality_analysis": {"complexity_score": 15, "left_complexity": 11, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_392", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_matched", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_matched(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    hue = ['x', 'x', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "masked_code": "def test_hue_matched(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    hue = ['x', 'x', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "ground_truth": "y[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_393", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_matched", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_matched(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    hue = ['x', 'x', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "masked_code": "def test_hue_matched(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    hue = ['x', 'x', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == '???')\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "ground_truth": "approx(0.8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_394", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_matched_by_name", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_matched_by_name(self):\n    data = {'x': ['a', 'b', 'c'], 'y': [1, 2, 3]}\n    ax = barplot(data, x='x', y='y', hue='x', saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == data['y'][i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "masked_code": "def test_hue_matched_by_name(self):\n    data = {'x': ['a', 'b', 'c'], 'y': [1, 2, 3]}\n    ax = barplot(data, x='x', y='y', hue='x', saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == '???')\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == data['y'][i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "ground_truth": "approx(i)", "quality_analysis": {"complexity_score": 15, "left_complexity": 11, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_395", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_matched_by_name", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_matched_by_name(self):\n    data = {'x': ['a', 'b', 'c'], 'y': [1, 2, 3]}\n    ax = barplot(data, x='x', y='y', hue='x', saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == data['y'][i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "masked_code": "def test_hue_matched_by_name(self):\n    data = {'x': ['a', 'b', 'c'], 'y': [1, 2, 3]}\n    ax = barplot(data, x='x', y='y', hue='x', saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "ground_truth": "data['y'][i]", "quality_analysis": {"complexity_score": 12, "left_complexity": 3, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_396", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_matched_by_name", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_matched_by_name(self):\n    data = {'x': ['a', 'b', 'c'], 'y': [1, 2, 3]}\n    ax = barplot(data, x='x', y='y', hue='x', saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == data['y'][i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "masked_code": "def test_hue_matched_by_name(self):\n    data = {'x': ['a', 'b', 'c'], 'y': [1, 2, 3]}\n    ax = barplot(data, x='x', y='y', hue='x', saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == data['y'][i])\n        assert (bar.get_width() == '???')\n        assert same_color(bar.get_facecolor(), f'C{i}')", "ground_truth": "approx(0.8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_397", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_dodged", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_dodged(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        sign = (1 if (i // 2) else (- 1))\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(((i % 2) + ((sign * 0.8) / 4))))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx((0.8 / 2)))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "masked_code": "def test_hue_dodged(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        sign = (1 if (i // 2) else (- 1))\n        assert ((bar.get_x() + (bar.get_width() / 2)) == '???')\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx((0.8 / 2)))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "ground_truth": "approx(((i % 2) + ((sign * 0.8) / 4)))", "quality_analysis": {"complexity_score": 27, "left_complexity": 11, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_398", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_dodged", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_dodged(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        sign = (1 if (i // 2) else (- 1))\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(((i % 2) + ((sign * 0.8) / 4))))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx((0.8 / 2)))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "masked_code": "def test_hue_dodged(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        sign = (1 if (i // 2) else (- 1))\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(((i % 2) + ((sign * 0.8) / 4))))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == approx((0.8 / 2)))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "ground_truth": "y[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_399", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_dodged", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_dodged(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        sign = (1 if (i // 2) else (- 1))\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(((i % 2) + ((sign * 0.8) / 4))))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx((0.8 / 2)))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "masked_code": "def test_hue_dodged(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        sign = (1 if (i // 2) else (- 1))\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(((i % 2) + ((sign * 0.8) / 4))))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == '???')\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "ground_truth": "approx((0.8 / 2))", "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_400", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_gap", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_gap(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, gap=0.25, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_width() == approx(((0.8 / 2) * 0.75)))", "masked_code": "def test_gap(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, gap=0.25, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_width() == '???')", "ground_truth": "approx(((0.8 / 2) * 0.75))", "quality_analysis": {"complexity_score": 13, "left_complexity": 3, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_401", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_undodged", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_undodged(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, dodge=False, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx((i % 2)))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "masked_code": "def test_hue_undodged(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, dodge=False, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == '???')\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "ground_truth": "approx((i % 2))", "quality_analysis": {"complexity_score": 18, "left_complexity": 11, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_402", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_undodged", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_undodged(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, dodge=False, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx((i % 2)))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "masked_code": "def test_hue_undodged(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, dodge=False, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx((i % 2)))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "ground_truth": "y[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_403", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_undodged", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_undodged(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, dodge=False, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx((i % 2)))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "masked_code": "def test_hue_undodged(self):\n    x = ['a', 'b', 'a', 'b']\n    y = [1, 2, 3, 4]\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, saturation=1, dodge=False, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx((i % 2)))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == '???')\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "ground_truth": "approx(0.8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_404", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_order", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_order(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    hue_order = ['c', 'b', 'a']\n    ax = barplot(x=x, y=y, hue=x, hue_order=hue_order, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert same_color(bar.get_facecolor(), f'C{i}')\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx((2 - i)))", "masked_code": "def test_hue_order(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    hue_order = ['c', 'b', 'a']\n    ax = barplot(x=x, y=y, hue=x, hue_order=hue_order, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert same_color(bar.get_facecolor(), f'C{i}')\n        assert ((bar.get_x() + (bar.get_width() / 2)) == '???')", "ground_truth": "approx((2 - i))", "quality_analysis": {"complexity_score": 18, "left_complexity": 11, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_405", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_norm", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_norm(self):\n    (x, y) = ([1, 2, 3, 4], [1, 2, 3, 4])\n    ax = barplot(x=x, y=y, hue=x, hue_norm=(2, 3))\n    colors = [bar.get_facecolor() for bar in ax.patches]\n    assert (colors[0] == colors[1])\n    assert (colors[1] != colors[2])\n    assert (colors[2] == colors[3])", "masked_code": "def test_hue_norm(self):\n    (x, y) = ([1, 2, 3, 4], [1, 2, 3, 4])\n    ax = barplot(x=x, y=y, hue=x, hue_norm=(2, 3))\n    colors = [bar.get_facecolor() for bar in ax.patches]\n    assert (colors[0] == '???')\n    assert (colors[1] != colors[2])\n    assert (colors[2] == colors[3])", "ground_truth": "colors[1]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_406", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_hue_norm", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_norm(self):\n    (x, y) = ([1, 2, 3, 4], [1, 2, 3, 4])\n    ax = barplot(x=x, y=y, hue=x, hue_norm=(2, 3))\n    colors = [bar.get_facecolor() for bar in ax.patches]\n    assert (colors[0] == colors[1])\n    assert (colors[1] != colors[2])\n    assert (colors[2] == colors[3])", "masked_code": "def test_hue_norm(self):\n    (x, y) = ([1, 2, 3, 4], [1, 2, 3, 4])\n    ax = barplot(x=x, y=y, hue=x, hue_norm=(2, 3))\n    colors = [bar.get_facecolor() for bar in ax.patches]\n    assert (colors[0] == colors[1])\n    assert (colors[1] != colors[2])\n    assert (colors[2] == '???')", "ground_truth": "colors[3]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_407", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_native_scale", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_native_scale(self):\n    (x, y) = ([2, 4, 8], [1, 2, 3])\n    ax = barplot(x=x, y=y, native_scale=True)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(x[i]))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx((0.8 * 2)))", "masked_code": "def test_xy_native_scale(self):\n    (x, y) = ([2, 4, 8], [1, 2, 3])\n    ax = barplot(x=x, y=y, native_scale=True)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == '???')\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx((0.8 * 2)))", "ground_truth": "approx(x[i])", "quality_analysis": {"complexity_score": 19, "left_complexity": 11, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_408", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_native_scale", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_native_scale(self):\n    (x, y) = ([2, 4, 8], [1, 2, 3])\n    ax = barplot(x=x, y=y, native_scale=True)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(x[i]))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx((0.8 * 2)))", "masked_code": "def test_xy_native_scale(self):\n    (x, y) = ([2, 4, 8], [1, 2, 3])\n    ax = barplot(x=x, y=y, native_scale=True)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(x[i]))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == approx((0.8 * 2)))", "ground_truth": "y[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_409", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_native_scale", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_native_scale(self):\n    (x, y) = ([2, 4, 8], [1, 2, 3])\n    ax = barplot(x=x, y=y, native_scale=True)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(x[i]))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == approx((0.8 * 2)))", "masked_code": "def test_xy_native_scale(self):\n    (x, y) = ([2, 4, 8], [1, 2, 3])\n    ax = barplot(x=x, y=y, native_scale=True)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(x[i]))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n        assert (bar.get_width() == '???')", "ground_truth": "approx((0.8 * 2))", "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_410", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_xy_native_scale_log_transform", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_native_scale_log_transform(self):\n    (x, y) = ([1, 10, 100], [1, 2, 3])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, native_scale=True, ax=ax)\n    for (i, bar) in enumerate(ax.patches):\n        (x0, x1) = np.log10([bar.get_x(), (bar.get_x() + bar.get_width())])\n        center = (10 ** (x0 + ((x1 - x0) / 2)))\n        assert (center == approx(x[i]))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == y[i])\n    assert (ax.patches[1].get_width() > ax.patches[0].get_width())", "masked_code": "def test_xy_native_scale_log_transform(self):\n    (x, y) = ([1, 10, 100], [1, 2, 3])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, native_scale=True, ax=ax)\n    for (i, bar) in enumerate(ax.patches):\n        (x0, x1) = np.log10([bar.get_x(), (bar.get_x() + bar.get_width())])\n        center = (10 ** (x0 + ((x1 - x0) / 2)))\n        assert (center == approx(x[i]))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == '???')\n    assert (ax.patches[1].get_width() > ax.patches[0].get_width())", "ground_truth": "y[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_411", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_native_scale_dodged", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_native_scale_dodged(self):\n    (x, y) = ([2, 4, 2, 4], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, native_scale=True)\n    for (x_i, bar) in zip(x[:2], ax.patches[:2]):\n        assert ((bar.get_x() + bar.get_width()) == approx(x_i))\n    for (x_i, bar) in zip(x[2:], ax.patches[2:]):\n        assert (bar.get_x() == approx(x_i))", "masked_code": "def test_native_scale_dodged(self):\n    (x, y) = ([2, 4, 2, 4], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, native_scale=True)\n    for (x_i, bar) in zip(x[:2], ax.patches[:2]):\n        assert ((bar.get_x() + bar.get_width()) == '???')\n    for (x_i, bar) in zip(x[2:], ax.patches[2:]):\n        assert (bar.get_x() == approx(x_i))", "ground_truth": "approx(x_i)", "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_412", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_native_scale_dodged", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_native_scale_dodged(self):\n    (x, y) = ([2, 4, 2, 4], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, native_scale=True)\n    for (x_i, bar) in zip(x[:2], ax.patches[:2]):\n        assert ((bar.get_x() + bar.get_width()) == approx(x_i))\n    for (x_i, bar) in zip(x[2:], ax.patches[2:]):\n        assert (bar.get_x() == approx(x_i))", "masked_code": "def test_native_scale_dodged(self):\n    (x, y) = ([2, 4, 2, 4], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = barplot(x=x, y=y, hue=hue, native_scale=True)\n    for (x_i, bar) in zip(x[:2], ax.patches[:2]):\n        assert ((bar.get_x() + bar.get_width()) == approx(x_i))\n    for (x_i, bar) in zip(x[2:], ax.patches[2:]):\n        assert (bar.get_x() == '???')", "ground_truth": "approx(x_i)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_413", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_native_scale_log_transform_dodged", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_native_scale_log_transform_dodged(self):\n    (x, y) = ([1, 100, 1, 100], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, hue=hue, native_scale=True, ax=ax)\n    for (x_i, bar) in zip(x[:2], ax.patches[:2]):\n        assert ((bar.get_x() + bar.get_width()) == approx(x_i))\n    for (x_i, bar) in zip(x[2:], ax.patches[2:]):\n        assert (bar.get_x() == approx(x_i))", "masked_code": "def test_native_scale_log_transform_dodged(self):\n    (x, y) = ([1, 100, 1, 100], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, hue=hue, native_scale=True, ax=ax)\n    for (x_i, bar) in zip(x[:2], ax.patches[:2]):\n        assert ((bar.get_x() + bar.get_width()) == '???')\n    for (x_i, bar) in zip(x[2:], ax.patches[2:]):\n        assert (bar.get_x() == approx(x_i))", "ground_truth": "approx(x_i)", "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_414", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_native_scale_log_transform_dodged", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_native_scale_log_transform_dodged(self):\n    (x, y) = ([1, 100, 1, 100], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, hue=hue, native_scale=True, ax=ax)\n    for (x_i, bar) in zip(x[:2], ax.patches[:2]):\n        assert ((bar.get_x() + bar.get_width()) == approx(x_i))\n    for (x_i, bar) in zip(x[2:], ax.patches[2:]):\n        assert (bar.get_x() == approx(x_i))", "masked_code": "def test_native_scale_log_transform_dodged(self):\n    (x, y) = ([1, 100, 1, 100], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, hue=hue, native_scale=True, ax=ax)\n    for (x_i, bar) in zip(x[:2], ax.patches[:2]):\n        assert ((bar.get_x() + bar.get_width()) == approx(x_i))\n    for (x_i, bar) in zip(x[2:], ax.patches[2:]):\n        assert (bar.get_x() == '???')", "ground_truth": "approx(x_i)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_415", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_estimate_default", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_estimate_default(self, long_df):\n    (agg_var, val_var) = ('a', 'y')\n    agg_df = long_df.groupby(agg_var)[val_var].mean()\n    ax = barplot(long_df, x=agg_var, y=val_var, errorbar=None)\n    order = categorical_order(long_df[agg_var])\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_height() == approx(agg_df[order[i]]))", "masked_code": "def test_estimate_default(self, long_df):\n    (agg_var, val_var) = ('a', 'y')\n    agg_df = long_df.groupby(agg_var)[val_var].mean()\n    ax = barplot(long_df, x=agg_var, y=val_var, errorbar=None)\n    order = categorical_order(long_df[agg_var])\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_height() == '???')", "ground_truth": "approx(agg_df[order[i]])", "quality_analysis": {"complexity_score": 15, "left_complexity": 3, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_416", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_estimate_string", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_estimate_string(self, long_df):\n    (agg_var, val_var) = ('a', 'y')\n    agg_df = long_df.groupby(agg_var)[val_var].median()\n    ax = barplot(long_df, x=agg_var, y=val_var, estimator='median', errorbar=None)\n    order = categorical_order(long_df[agg_var])\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_height() == approx(agg_df[order[i]]))", "masked_code": "def test_estimate_string(self, long_df):\n    (agg_var, val_var) = ('a', 'y')\n    agg_df = long_df.groupby(agg_var)[val_var].median()\n    ax = barplot(long_df, x=agg_var, y=val_var, estimator='median', errorbar=None)\n    order = categorical_order(long_df[agg_var])\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_height() == '???')", "ground_truth": "approx(agg_df[order[i]])", "quality_analysis": {"complexity_score": 15, "left_complexity": 3, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_417", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_estimate_func", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_estimate_func(self, long_df):\n    (agg_var, val_var) = ('a', 'y')\n    agg_df = long_df.groupby(agg_var)[val_var].median()\n    ax = barplot(long_df, x=agg_var, y=val_var, estimator=np.median, errorbar=None)\n    order = categorical_order(long_df[agg_var])\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_height() == approx(agg_df[order[i]]))", "masked_code": "def test_estimate_func(self, long_df):\n    (agg_var, val_var) = ('a', 'y')\n    agg_df = long_df.groupby(agg_var)[val_var].median()\n    ax = barplot(long_df, x=agg_var, y=val_var, estimator=np.median, errorbar=None)\n    order = categorical_order(long_df[agg_var])\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_height() == '???')", "ground_truth": "approx(agg_df[order[i]])", "quality_analysis": {"complexity_score": 15, "left_complexity": 3, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_418", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_estimate_log_transform", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_estimate_log_transform(self, long_df):\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=long_df['z'], ax=ax)\n    (bar,) = ax.patches\n    assert (bar.get_width() == (10 ** np.log10(long_df['z']).mean()))", "masked_code": "def test_estimate_log_transform(self, long_df):\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=long_df['z'], ax=ax)\n    (bar,) = ax.patches\n    assert (bar.get_width() == '???')", "ground_truth": "(10 ** np.log10(long_df['z']).mean())", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_419", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_width", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_width(self):\n    width = 0.5\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = barplot(x=x, y=y, width=width)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_width() == width)", "masked_code": "def test_width(self):\n    width = 0.5\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = barplot(x=x, y=y, width=width)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == '???')\n        assert (bar.get_width() == width)", "ground_truth": "approx(i)", "quality_analysis": {"complexity_score": 15, "left_complexity": 11, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_420", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_width", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_width(self):\n    width = 0.5\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = barplot(x=x, y=y, width=width)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_width() == width)", "masked_code": "def test_width(self):\n    width = 0.5\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = barplot(x=x, y=y, width=width)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_width() == '???')", "ground_truth": "width", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_421", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_width_native_scale", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_width_native_scale(self):\n    width = 0.5\n    (x, y) = ([4, 6, 10], [1, 2, 3])\n    ax = barplot(x=x, y=y, width=width, native_scale=True)\n    for bar in ax.patches:\n        assert (bar.get_width() == (width * 2))", "masked_code": "def test_width_native_scale(self):\n    width = 0.5\n    (x, y) = ([4, 6, 10], [1, 2, 3])\n    ax = barplot(x=x, y=y, width=width, native_scale=True)\n    for bar in ax.patches:\n        assert (bar.get_width() == '???')", "ground_truth": "(width * 2)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_422", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_width_spaced_categories", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_width_spaced_categories(self):\n    ax = barplot(x=['a', 'b', 'c'], y=[4, 5, 6])\n    barplot(x=['a', 'c'], y=[1, 3], ax=ax)\n    for bar in ax.patches:\n        assert (bar.get_width() == pytest.approx(0.8))", "masked_code": "def test_width_spaced_categories(self):\n    ax = barplot(x=['a', 'b', 'c'], y=[4, 5, 6])\n    barplot(x=['a', 'c'], y=[1, 3], ax=ax)\n    for bar in ax.patches:\n        assert (bar.get_width() == '???')", "ground_truth": "pytest.approx(0.8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_423", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_error_caps", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_error_caps(self):\n    (x, y) = ((['a', 'b', 'c'] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "masked_code": "def test_error_caps(self):\n    (x, y) = ((['a', 'b', 'c'] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, errorbar='pi')\n    assert (len(ax.patches) == '???')\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "ground_truth": "len(ax.lines)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_424", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_error_caps", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_error_caps(self):\n    (x, y) = ((['a', 'b', 'c'] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "masked_code": "def test_error_caps(self):\n    (x, y) = ((['a', 'b', 'c'] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == '???')\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "ground_truth": "8", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_425", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_error_caps", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_error_caps(self):\n    (x, y) = ((['a', 'b', 'c'] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "masked_code": "def test_error_caps(self):\n    (x, y) = ((['a', 'b', 'c'] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == '???')\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "ground_truth": "approx(bar.get_x())", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_426", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_error_caps", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_error_caps(self):\n    (x, y) = ((['a', 'b', 'c'] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "masked_code": "def test_error_caps(self):\n    (x, y) = ((['a', 'b', 'c'] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == '???')", "ground_truth": "approx((bar.get_x() + bar.get_width()))", "quality_analysis": {"complexity_score": 15, "left_complexity": 4, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_427", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_error_caps_native_scale", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_error_caps_native_scale(self):\n    (x, y) = (([2, 4, 20] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "masked_code": "def test_error_caps_native_scale(self):\n    (x, y) = (([2, 4, 20] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi')\n    assert (len(ax.patches) == '???')\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "ground_truth": "len(ax.lines)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_428", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_error_caps_native_scale", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_error_caps_native_scale(self):\n    (x, y) = (([2, 4, 20] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "masked_code": "def test_error_caps_native_scale(self):\n    (x, y) = (([2, 4, 20] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == '???')\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "ground_truth": "8", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_429", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_error_caps_native_scale", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_error_caps_native_scale(self):\n    (x, y) = (([2, 4, 20] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "masked_code": "def test_error_caps_native_scale(self):\n    (x, y) = (([2, 4, 20] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == '???')\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "ground_truth": "approx(bar.get_x())", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_430", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_error_caps_native_scale", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_error_caps_native_scale(self):\n    (x, y) = (([2, 4, 20] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "masked_code": "def test_error_caps_native_scale(self):\n    (x, y) = (([2, 4, 20] * 2), [1, 2, 3, 4, 5, 6])\n    ax = barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi')\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == '???')", "ground_truth": "approx((bar.get_x() + bar.get_width()))", "quality_analysis": {"complexity_score": 15, "left_complexity": 4, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_431", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_error_caps_native_scale_log_transform", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_error_caps_native_scale_log_transform(self):\n    (x, y) = (([1, 10, 1000] * 2), [1, 2, 3, 4, 5, 6])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi', ax=ax)\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "masked_code": "def test_error_caps_native_scale_log_transform(self):\n    (x, y) = (([1, 10, 1000] * 2), [1, 2, 3, 4, 5, 6])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi', ax=ax)\n    assert (len(ax.patches) == '???')\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "ground_truth": "len(ax.lines)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_432", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_error_caps_native_scale_log_transform", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_error_caps_native_scale_log_transform(self):\n    (x, y) = (([1, 10, 1000] * 2), [1, 2, 3, 4, 5, 6])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi', ax=ax)\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "masked_code": "def test_error_caps_native_scale_log_transform(self):\n    (x, y) = (([1, 10, 1000] * 2), [1, 2, 3, 4, 5, 6])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi', ax=ax)\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == '???')\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "ground_truth": "8", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_433", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_error_caps_native_scale_log_transform", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_error_caps_native_scale_log_transform(self):\n    (x, y) = (([1, 10, 1000] * 2), [1, 2, 3, 4, 5, 6])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi', ax=ax)\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "masked_code": "def test_error_caps_native_scale_log_transform(self):\n    (x, y) = (([1, 10, 1000] * 2), [1, 2, 3, 4, 5, 6])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi', ax=ax)\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == '???')\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "ground_truth": "approx(bar.get_x())", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_434", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_error_caps_native_scale_log_transform", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_error_caps_native_scale_log_transform(self):\n    (x, y) = (([1, 10, 1000] * 2), [1, 2, 3, 4, 5, 6])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi', ax=ax)\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == approx((bar.get_x() + bar.get_width())))", "masked_code": "def test_error_caps_native_scale_log_transform(self):\n    (x, y) = (([1, 10, 1000] * 2), [1, 2, 3, 4, 5, 6])\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    barplot(x=x, y=y, capsize=0.8, native_scale=True, errorbar='pi', ax=ax)\n    assert (len(ax.patches) == len(ax.lines))\n    for (bar, error) in zip(ax.patches, ax.lines):\n        pos = error.get_xdata()\n        assert (len(pos) == 8)\n        assert (np.nanmin(pos) == approx(bar.get_x()))\n        assert (np.nanmax(pos) == '???')", "ground_truth": "approx((bar.get_x() + bar.get_width()))", "quality_analysis": {"complexity_score": 15, "left_complexity": 4, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_435", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_bar_kwargs", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_bar_kwargs(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    kwargs = dict(linewidth=3, facecolor=(0.5, 0.4, 0.3, 0.2), rasterized=True)\n    ax = barplot(x=x, y=y, **kwargs)\n    for bar in ax.patches:\n        assert (bar.get_linewidth() == kwargs['linewidth'])\n        assert (bar.get_facecolor() == kwargs['facecolor'])\n        assert (bar.get_rasterized() == kwargs['rasterized'])", "masked_code": "def test_bar_kwargs(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    kwargs = dict(linewidth=3, facecolor=(0.5, 0.4, 0.3, 0.2), rasterized=True)\n    ax = barplot(x=x, y=y, **kwargs)\n    for bar in ax.patches:\n        assert (bar.get_linewidth() == '???')\n        assert (bar.get_facecolor() == kwargs['facecolor'])\n        assert (bar.get_rasterized() == kwargs['rasterized'])", "ground_truth": "kwargs['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_436", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_bar_kwargs", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_bar_kwargs(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    kwargs = dict(linewidth=3, facecolor=(0.5, 0.4, 0.3, 0.2), rasterized=True)\n    ax = barplot(x=x, y=y, **kwargs)\n    for bar in ax.patches:\n        assert (bar.get_linewidth() == kwargs['linewidth'])\n        assert (bar.get_facecolor() == kwargs['facecolor'])\n        assert (bar.get_rasterized() == kwargs['rasterized'])", "masked_code": "def test_bar_kwargs(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    kwargs = dict(linewidth=3, facecolor=(0.5, 0.4, 0.3, 0.2), rasterized=True)\n    ax = barplot(x=x, y=y, **kwargs)\n    for bar in ax.patches:\n        assert (bar.get_linewidth() == kwargs['linewidth'])\n        assert (bar.get_facecolor() == '???')\n        assert (bar.get_rasterized() == kwargs['rasterized'])", "ground_truth": "kwargs['facecolor']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_437", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_bar_kwargs", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_bar_kwargs(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    kwargs = dict(linewidth=3, facecolor=(0.5, 0.4, 0.3, 0.2), rasterized=True)\n    ax = barplot(x=x, y=y, **kwargs)\n    for bar in ax.patches:\n        assert (bar.get_linewidth() == kwargs['linewidth'])\n        assert (bar.get_facecolor() == kwargs['facecolor'])\n        assert (bar.get_rasterized() == kwargs['rasterized'])", "masked_code": "def test_bar_kwargs(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    kwargs = dict(linewidth=3, facecolor=(0.5, 0.4, 0.3, 0.2), rasterized=True)\n    ax = barplot(x=x, y=y, **kwargs)\n    for bar in ax.patches:\n        assert (bar.get_linewidth() == kwargs['linewidth'])\n        assert (bar.get_facecolor() == kwargs['facecolor'])\n        assert (bar.get_rasterized() == '???')", "ground_truth": "kwargs['rasterized']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_438", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_legend_attributes", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_legend_attributes(self, long_df):\n    palette = color_palette()\n    ax = barplot(long_df, x='a', y='y', hue='c', saturation=1, edgecolor='k', linewidth=3)\n    for (i, patch) in enumerate(get_legend_handles(ax.get_legend())):\n        assert same_color(patch.get_facecolor(), palette[i])\n        assert same_color(patch.get_edgecolor(), 'k')\n        assert (patch.get_linewidth() == 3)", "masked_code": "def test_legend_attributes(self, long_df):\n    palette = color_palette()\n    ax = barplot(long_df, x='a', y='y', hue='c', saturation=1, edgecolor='k', linewidth=3)\n    for (i, patch) in enumerate(get_legend_handles(ax.get_legend())):\n        assert same_color(patch.get_facecolor(), palette[i])\n        assert same_color(patch.get_edgecolor(), 'k')\n        assert (patch.get_linewidth() == '???')", "ground_truth": "3", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_439", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_legend_unfilled", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_legend_unfilled(self, long_df):\n    palette = color_palette()\n    ax = barplot(long_df, x='a', y='y', hue='c', fill=False, linewidth=3)\n    for (i, patch) in enumerate(get_legend_handles(ax.get_legend())):\n        assert (patch.get_facecolor() == (0, 0, 0, 0))\n        assert same_color(patch.get_edgecolor(), palette[i])\n        assert (patch.get_linewidth() == 3)", "masked_code": "def test_legend_unfilled(self, long_df):\n    palette = color_palette()\n    ax = barplot(long_df, x='a', y='y', hue='c', fill=False, linewidth=3)\n    for (i, patch) in enumerate(get_legend_handles(ax.get_legend())):\n        assert (patch.get_facecolor() == '???')\n        assert same_color(patch.get_edgecolor(), palette[i])\n        assert (patch.get_linewidth() == 3)", "ground_truth": "(0, 0, 0, 0)", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_440", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_legend_unfilled", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_legend_unfilled(self, long_df):\n    palette = color_palette()\n    ax = barplot(long_df, x='a', y='y', hue='c', fill=False, linewidth=3)\n    for (i, patch) in enumerate(get_legend_handles(ax.get_legend())):\n        assert (patch.get_facecolor() == (0, 0, 0, 0))\n        assert same_color(patch.get_edgecolor(), palette[i])\n        assert (patch.get_linewidth() == 3)", "masked_code": "def test_legend_unfilled(self, long_df):\n    palette = color_palette()\n    ax = barplot(long_df, x='a', y='y', hue='c', fill=False, linewidth=3)\n    for (i, patch) in enumerate(get_legend_handles(ax.get_legend())):\n        assert (patch.get_facecolor() == (0, 0, 0, 0))\n        assert same_color(patch.get_edgecolor(), palette[i])\n        assert (patch.get_linewidth() == '???')", "ground_truth": "3", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_441", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_err_kws", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('fill', [True, False])\ndef test_err_kws(self, fill):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    err_kws = dict(color=(1, 1, 0.5, 0.5), linewidth=5)\n    ax = barplot(x=x, y=y, fill=fill, err_kws=err_kws)\n    for line in ax.lines:\n        assert (line.get_color() == err_kws['color'])\n        assert (line.get_linewidth() == err_kws['linewidth'])", "masked_code": "@pytest.mark.parametrize('fill', [True, False])\ndef test_err_kws(self, fill):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    err_kws = dict(color=(1, 1, 0.5, 0.5), linewidth=5)\n    ax = barplot(x=x, y=y, fill=fill, err_kws=err_kws)\n    for line in ax.lines:\n        assert (line.get_color() == '???')\n        assert (line.get_linewidth() == err_kws['linewidth'])", "ground_truth": "err_kws['color']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_442", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_err_kws", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('fill', [True, False])\ndef test_err_kws(self, fill):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    err_kws = dict(color=(1, 1, 0.5, 0.5), linewidth=5)\n    ax = barplot(x=x, y=y, fill=fill, err_kws=err_kws)\n    for line in ax.lines:\n        assert (line.get_color() == err_kws['color'])\n        assert (line.get_linewidth() == err_kws['linewidth'])", "masked_code": "@pytest.mark.parametrize('fill', [True, False])\ndef test_err_kws(self, fill):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    err_kws = dict(color=(1, 1, 0.5, 0.5), linewidth=5)\n    ax = barplot(x=x, y=y, fill=fill, err_kws=err_kws)\n    for line in ax.lines:\n        assert (line.get_color() == err_kws['color'])\n        assert (line.get_linewidth() == '???')", "ground_truth": "err_kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_443", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_errwidth_deprecation", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_errwidth_deprecation(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    val = 5\n    with pytest.warns(FutureWarning, match='\\n\\nThe `errwidth` parameter'):\n        ax = barplot(x=x, y=y, errwidth=val)\n    for line in ax.lines:\n        assert (line.get_linewidth() == val)", "masked_code": "def test_errwidth_deprecation(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    val = 5\n    with pytest.warns(FutureWarning, match='\\n\\nThe `errwidth` parameter'):\n        ax = barplot(x=x, y=y, errwidth=val)\n    for line in ax.lines:\n        assert (line.get_linewidth() == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_444", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBarPlot", "funcname": "test_errcolor_deprecation", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_errcolor_deprecation(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    val = (1, 0.7, 0.4, 0.8)\n    with pytest.warns(FutureWarning, match='\\n\\nThe `errcolor` parameter'):\n        ax = barplot(x=x, y=y, errcolor=val)\n    for line in ax.lines:\n        assert (line.get_color() == val)", "masked_code": "def test_errcolor_deprecation(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    val = (1, 0.7, 0.4, 0.8)\n    with pytest.warns(FutureWarning, match='\\n\\nThe `errcolor` parameter'):\n        ax = barplot(x=x, y=y, errcolor=val)\n    for line in ax.lines:\n        assert (line.get_color() == '???')", "ground_truth": "val", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_445", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_single_var", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_single_var(self, orient):\n    vals = pd.Series([1, 3, 10])\n    ax = pointplot(**{orient: vals})\n    line = ax.lines[0]\n    assert (getattr(line, f'get_{orient}data')() == approx(vals.mean()))", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_single_var(self, orient):\n    vals = pd.Series([1, 3, 10])\n    ax = pointplot(**{orient: vals})\n    line = ax.lines[0]\n    assert (getattr(line, f'get_{orient}data')() == '???')", "ground_truth": "approx(vals.mean())", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_446", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_xy_vertical", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_vertical(self):\n    (x, y) = (['a', 'b', 'c'], [1, 3, 2.5])\n    ax = pointplot(x=x, y=y)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == (i, y[i]))", "masked_code": "def test_xy_vertical(self):\n    (x, y) = (['a', 'b', 'c'], [1, 3, 2.5])\n    ax = pointplot(x=x, y=y)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == '???')", "ground_truth": "(i, y[i])", "quality_analysis": {"complexity_score": 12, "left_complexity": 4, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_447", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_xy_horizontal", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_horizontal(self):\n    (x, y) = ([1, 3, 2.5], ['a', 'b', 'c'])\n    ax = pointplot(x=x, y=y)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == (x[i], i))", "masked_code": "def test_xy_horizontal(self):\n    (x, y) = ([1, 3, 2.5], ['a', 'b', 'c'])\n    ax = pointplot(x=x, y=y)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == '???')", "ground_truth": "(x[i], i)", "quality_analysis": {"complexity_score": 12, "left_complexity": 4, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_448", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_xy_with_na_grouper", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_with_na_grouper(self):\n    (x, y) = (['a', None, 'b'], [1, 2, 3])\n    ax = pointplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == ['a', 'b'])\n    assert_array_equal(ax.lines[0].get_xdata(), [0, 1])\n    assert_array_equal(ax.lines[0].get_ydata(), [1, 3])", "masked_code": "def test_xy_with_na_grouper(self):\n    (x, y) = (['a', None, 'b'], [1, 2, 3])\n    ax = pointplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == '???')\n    assert ([t.get_text() for t in ax.get_xticklabels()] == ['a', 'b'])\n    assert_array_equal(ax.lines[0].get_xdata(), [0, 1])\n    assert_array_equal(ax.lines[0].get_ydata(), [1, 3])", "ground_truth": "[0, 1]", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_449", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_xy_with_na_grouper", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_with_na_grouper(self):\n    (x, y) = (['a', None, 'b'], [1, 2, 3])\n    ax = pointplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == ['a', 'b'])\n    assert_array_equal(ax.lines[0].get_xdata(), [0, 1])\n    assert_array_equal(ax.lines[0].get_ydata(), [1, 3])", "masked_code": "def test_xy_with_na_grouper(self):\n    (x, y) = (['a', None, 'b'], [1, 2, 3])\n    ax = pointplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == '???')\n    assert_array_equal(ax.lines[0].get_xdata(), [0, 1])\n    assert_array_equal(ax.lines[0].get_ydata(), [1, 3])", "ground_truth": "['a', 'b']", "quality_analysis": {"complexity_score": 4, "left_complexity": 0, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_450", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_xy_with_na_value", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_with_na_value(self):\n    (x, y) = (['a', 'b', 'c'], [1, np.nan, 3])\n    ax = pointplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1, 2])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == x)\n    assert_array_equal(ax.lines[0].get_xdata(), [0, 1, 2])\n    assert_array_equal(ax.lines[0].get_ydata(), y)", "masked_code": "def test_xy_with_na_value(self):\n    (x, y) = (['a', 'b', 'c'], [1, np.nan, 3])\n    ax = pointplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == '???')\n    assert ([t.get_text() for t in ax.get_xticklabels()] == x)\n    assert_array_equal(ax.lines[0].get_xdata(), [0, 1, 2])\n    assert_array_equal(ax.lines[0].get_ydata(), y)", "ground_truth": "[0, 1, 2]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_451", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_xy_with_na_value", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_xy_with_na_value(self):\n    (x, y) = (['a', 'b', 'c'], [1, np.nan, 3])\n    ax = pointplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1, 2])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == x)\n    assert_array_equal(ax.lines[0].get_xdata(), [0, 1, 2])\n    assert_array_equal(ax.lines[0].get_ydata(), y)", "masked_code": "def test_xy_with_na_value(self):\n    (x, y) = (['a', 'b', 'c'], [1, np.nan, 3])\n    ax = pointplot(x=x, y=y)\n    _draw_figure(ax.figure)\n    assert (ax.get_xticks() == [0, 1, 2])\n    assert ([t.get_text() for t in ax.get_xticklabels()] == '???')\n    assert_array_equal(ax.lines[0].get_xdata(), [0, 1, 2])\n    assert_array_equal(ax.lines[0].get_ydata(), y)", "ground_truth": "x", "quality_analysis": {"complexity_score": 1, "left_complexity": 0, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_452", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_estimate", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('estimator', ['mean', (lambda x: np.mean(x))])\ndef test_estimate(self, long_df, estimator):\n    (agg_var, val_var) = ('a', 'y')\n    agg_df = long_df.groupby(agg_var)[val_var].agg(estimator)\n    ax = pointplot(long_df, x=agg_var, y=val_var, errorbar=None)\n    order = categorical_order(long_df[agg_var])\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == approx((i, agg_df[order[i]])))", "masked_code": "@pytest.mark.parametrize('estimator', ['mean', (lambda x: np.mean(x))])\ndef test_estimate(self, long_df, estimator):\n    (agg_var, val_var) = ('a', 'y')\n    agg_df = long_df.groupby(agg_var)[val_var].agg(estimator)\n    ax = pointplot(long_df, x=agg_var, y=val_var, errorbar=None)\n    order = categorical_order(long_df[agg_var])\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == '???')", "ground_truth": "approx((i, agg_df[order[i]]))", "quality_analysis": {"complexity_score": 19, "left_complexity": 4, "right_complexity": 15, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_453", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_marker_linestyle", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_marker_linestyle(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = pointplot(x=x, y=y, marker='s', linestyle='--')\n    line = ax.lines[0]\n    assert (line.get_marker() == 's')\n    assert (line.get_linestyle() == '--')", "masked_code": "def test_marker_linestyle(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = pointplot(x=x, y=y, marker='s', linestyle='--')\n    line = ax.lines[0]\n    assert (line.get_marker() == 's')\n    assert (line.get_linestyle() == '???')", "ground_truth": "'--'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_454", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_markers_linestyles_single", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_markers_linestyles_single(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = pointplot(x=x, y=y, markers='s', linestyles='--')\n    line = ax.lines[0]\n    assert (line.get_marker() == 's')\n    assert (line.get_linestyle() == '--')", "masked_code": "def test_markers_linestyles_single(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = pointplot(x=x, y=y, markers='s', linestyles='--')\n    line = ax.lines[0]\n    assert (line.get_marker() == 's')\n    assert (line.get_linestyle() == '???')", "ground_truth": "'--'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_455", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_markers_linestyles_mapped", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_markers_linestyles_mapped(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    markers = ['d', 's']\n    linestyles = ['--', ':']\n    ax = pointplot(x=x, y=y, hue=hue, markers=markers, linestyles=linestyles, errorbar=None)\n    for (i, line) in enumerate(ax.lines[:2]):\n        assert (line.get_marker() == markers[i])\n        assert (line.get_linestyle() == linestyles[i])", "masked_code": "def test_markers_linestyles_mapped(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    markers = ['d', 's']\n    linestyles = ['--', ':']\n    ax = pointplot(x=x, y=y, hue=hue, markers=markers, linestyles=linestyles, errorbar=None)\n    for (i, line) in enumerate(ax.lines[:2]):\n        assert (line.get_marker() == '???')\n        assert (line.get_linestyle() == linestyles[i])", "ground_truth": "markers[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_456", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_markers_linestyles_mapped", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_markers_linestyles_mapped(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    markers = ['d', 's']\n    linestyles = ['--', ':']\n    ax = pointplot(x=x, y=y, hue=hue, markers=markers, linestyles=linestyles, errorbar=None)\n    for (i, line) in enumerate(ax.lines[:2]):\n        assert (line.get_marker() == markers[i])\n        assert (line.get_linestyle() == linestyles[i])", "masked_code": "def test_markers_linestyles_mapped(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    markers = ['d', 's']\n    linestyles = ['--', ':']\n    ax = pointplot(x=x, y=y, hue=hue, markers=markers, linestyles=linestyles, errorbar=None)\n    for (i, line) in enumerate(ax.lines[:2]):\n        assert (line.get_marker() == markers[i])\n        assert (line.get_linestyle() == '???')", "ground_truth": "linestyles[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_457", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_dodge_boolean", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_dodge_boolean(self):\n    (x, y) = (['a', 'b', 'a', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = pointplot(x=x, y=y, hue=hue, dodge=True, errorbar=None)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == ((i - 0.025), y[i]))\n    for (i, xy) in enumerate(ax.lines[1].get_xydata()):\n        assert (tuple(xy) == ((i + 0.025), y[(2 + i)]))", "masked_code": "def test_dodge_boolean(self):\n    (x, y) = (['a', 'b', 'a', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = pointplot(x=x, y=y, hue=hue, dodge=True, errorbar=None)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == '???')\n    for (i, xy) in enumerate(ax.lines[1].get_xydata()):\n        assert (tuple(xy) == ((i + 0.025), y[(2 + i)]))", "ground_truth": "((i - 0.025), y[i])", "quality_analysis": {"complexity_score": 15, "left_complexity": 4, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_458", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_dodge_boolean", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_dodge_boolean(self):\n    (x, y) = (['a', 'b', 'a', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = pointplot(x=x, y=y, hue=hue, dodge=True, errorbar=None)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == ((i - 0.025), y[i]))\n    for (i, xy) in enumerate(ax.lines[1].get_xydata()):\n        assert (tuple(xy) == ((i + 0.025), y[(2 + i)]))", "masked_code": "def test_dodge_boolean(self):\n    (x, y) = (['a', 'b', 'a', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = pointplot(x=x, y=y, hue=hue, dodge=True, errorbar=None)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == ((i - 0.025), y[i]))\n    for (i, xy) in enumerate(ax.lines[1].get_xydata()):\n        assert (tuple(xy) == '???')", "ground_truth": "((i + 0.025), y[(2 + i)])", "quality_analysis": {"complexity_score": 18, "left_complexity": 4, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_459", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_dodge_float", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_dodge_float(self):\n    (x, y) = (['a', 'b', 'a', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = pointplot(x=x, y=y, hue=hue, dodge=0.2, errorbar=None)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == ((i - 0.1), y[i]))\n    for (i, xy) in enumerate(ax.lines[1].get_xydata()):\n        assert (tuple(xy) == ((i + 0.1), y[(2 + i)]))", "masked_code": "def test_dodge_float(self):\n    (x, y) = (['a', 'b', 'a', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = pointplot(x=x, y=y, hue=hue, dodge=0.2, errorbar=None)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == '???')\n    for (i, xy) in enumerate(ax.lines[1].get_xydata()):\n        assert (tuple(xy) == ((i + 0.1), y[(2 + i)]))", "ground_truth": "((i - 0.1), y[i])", "quality_analysis": {"complexity_score": 15, "left_complexity": 4, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_460", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_dodge_float", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_dodge_float(self):\n    (x, y) = (['a', 'b', 'a', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = pointplot(x=x, y=y, hue=hue, dodge=0.2, errorbar=None)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == ((i - 0.1), y[i]))\n    for (i, xy) in enumerate(ax.lines[1].get_xydata()):\n        assert (tuple(xy) == ((i + 0.1), y[(2 + i)]))", "masked_code": "def test_dodge_float(self):\n    (x, y) = (['a', 'b', 'a', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = pointplot(x=x, y=y, hue=hue, dodge=0.2, errorbar=None)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == ((i - 0.1), y[i]))\n    for (i, xy) in enumerate(ax.lines[1].get_xydata()):\n        assert (tuple(xy) == '???')", "ground_truth": "((i + 0.1), y[(2 + i)])", "quality_analysis": {"complexity_score": 18, "left_complexity": 4, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_461", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_dodge_log_scale", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_dodge_log_scale(self):\n    (x, y) = ([10, 1000, 10, 1000], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    pointplot(x=x, y=y, hue=hue, dodge=0.2, native_scale=True, errorbar=None, ax=ax)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == approx(((10 ** (np.log10(x[i]) - 0.2)), y[i])))\n    for (i, xy) in enumerate(ax.lines[1].get_xydata()):\n        assert (tuple(xy) == approx(((10 ** (np.log10(x[(2 + i)]) + 0.2)), y[(2 + i)])))", "masked_code": "def test_dodge_log_scale(self):\n    (x, y) = ([10, 1000, 10, 1000], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    pointplot(x=x, y=y, hue=hue, dodge=0.2, native_scale=True, errorbar=None, ax=ax)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == '???')\n    for (i, xy) in enumerate(ax.lines[1].get_xydata()):\n        assert (tuple(xy) == approx(((10 ** (np.log10(x[(2 + i)]) + 0.2)), y[(2 + i)])))", "ground_truth": "approx(((10 ** (np.log10(x[i]) - 0.2)), y[i]))", "quality_analysis": {"complexity_score": 28, "left_complexity": 4, "right_complexity": 24, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_462", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_dodge_log_scale", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_dodge_log_scale(self):\n    (x, y) = ([10, 1000, 10, 1000], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    pointplot(x=x, y=y, hue=hue, dodge=0.2, native_scale=True, errorbar=None, ax=ax)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == approx(((10 ** (np.log10(x[i]) - 0.2)), y[i])))\n    for (i, xy) in enumerate(ax.lines[1].get_xydata()):\n        assert (tuple(xy) == approx(((10 ** (np.log10(x[(2 + i)]) + 0.2)), y[(2 + i)])))", "masked_code": "def test_dodge_log_scale(self):\n    (x, y) = ([10, 1000, 10, 1000], [1, 2, 3, 4])\n    hue = ['x', 'x', 'y', 'y']\n    ax = mpl.figure.Figure().subplots()\n    ax.set_xscale('log')\n    pointplot(x=x, y=y, hue=hue, dodge=0.2, native_scale=True, errorbar=None, ax=ax)\n    for (i, xy) in enumerate(ax.lines[0].get_xydata()):\n        assert (tuple(xy) == approx(((10 ** (np.log10(x[i]) - 0.2)), y[i])))\n    for (i, xy) in enumerate(ax.lines[1].get_xydata()):\n        assert (tuple(xy) == '???')", "ground_truth": "approx(((10 ** (np.log10(x[(2 + i)]) + 0.2)), y[(2 + i)]))", "quality_analysis": {"complexity_score": 34, "left_complexity": 4, "right_complexity": 30, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_463", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_err_kws", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_err_kws(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    err_kws = dict(color=(0.2, 0.5, 0.3), linewidth=10)\n    ax = pointplot(x=x, y=y, errorbar=('pi', 100), err_kws=err_kws)\n    for line in ax.lines[1:]:\n        assert same_color(line.get_color(), err_kws['color'])\n        assert (line.get_linewidth() == err_kws['linewidth'])", "masked_code": "def test_err_kws(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    err_kws = dict(color=(0.2, 0.5, 0.3), linewidth=10)\n    ax = pointplot(x=x, y=y, errorbar=('pi', 100), err_kws=err_kws)\n    for line in ax.lines[1:]:\n        assert same_color(line.get_color(), err_kws['color'])\n        assert (line.get_linewidth() == '???')", "ground_truth": "err_kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_464", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_err_kws_inherited", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_err_kws_inherited(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    kws = dict(color=(0.2, 0.5, 0.3), linewidth=10)\n    ax = pointplot(x=x, y=y, errorbar=('pi', 100), **kws)\n    for line in ax.lines[1:]:\n        assert same_color(line.get_color(), kws['color'])\n        assert (line.get_linewidth() == kws['linewidth'])", "masked_code": "def test_err_kws_inherited(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    kws = dict(color=(0.2, 0.5, 0.3), linewidth=10)\n    ax = pointplot(x=x, y=y, errorbar=('pi', 100), **kws)\n    for line in ax.lines[1:]:\n        assert same_color(line.get_color(), kws['color'])\n        assert (line.get_linewidth() == '???')", "ground_truth": "kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_465", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_legend_contents", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Legend handle missing marker property')\ndef test_legend_contents(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    ax = pointplot(x=x, y=y, hue=hue)\n    _draw_figure(ax.figure)\n    legend = ax.get_legend()\n    assert ([t.get_text() for t in legend.texts] == ['x', 'y'])\n    for (i, handle) in enumerate(get_legend_handles(legend)):\n        assert (handle.get_marker() == 'o')\n        assert (handle.get_linestyle() == '-')\n        assert same_color(handle.get_color(), f'C{i}')", "masked_code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Legend handle missing marker property')\ndef test_legend_contents(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    ax = pointplot(x=x, y=y, hue=hue)\n    _draw_figure(ax.figure)\n    legend = ax.get_legend()\n    assert ([t.get_text() for t in legend.texts] == '???')\n    for (i, handle) in enumerate(get_legend_handles(legend)):\n        assert (handle.get_marker() == 'o')\n        assert (handle.get_linestyle() == '-')\n        assert same_color(handle.get_color(), f'C{i}')", "ground_truth": "['x', 'y']", "quality_analysis": {"complexity_score": 4, "left_complexity": 0, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_466", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_legend_set_props", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Legend handle missing marker property')\ndef test_legend_set_props(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    kws = dict(marker='s', linewidth=1)\n    ax = pointplot(x=x, y=y, hue=hue, **kws)\n    legend = ax.get_legend()\n    for (i, handle) in enumerate(get_legend_handles(legend)):\n        assert (handle.get_marker() == kws['marker'])\n        assert (handle.get_linewidth() == kws['linewidth'])", "masked_code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Legend handle missing marker property')\ndef test_legend_set_props(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    kws = dict(marker='s', linewidth=1)\n    ax = pointplot(x=x, y=y, hue=hue, **kws)\n    legend = ax.get_legend()\n    for (i, handle) in enumerate(get_legend_handles(legend)):\n        assert (handle.get_marker() == '???')\n        assert (handle.get_linewidth() == kws['linewidth'])", "ground_truth": "kws['marker']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_467", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_legend_set_props", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Legend handle missing marker property')\ndef test_legend_set_props(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    kws = dict(marker='s', linewidth=1)\n    ax = pointplot(x=x, y=y, hue=hue, **kws)\n    legend = ax.get_legend()\n    for (i, handle) in enumerate(get_legend_handles(legend)):\n        assert (handle.get_marker() == kws['marker'])\n        assert (handle.get_linewidth() == kws['linewidth'])", "masked_code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Legend handle missing marker property')\ndef test_legend_set_props(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    kws = dict(marker='s', linewidth=1)\n    ax = pointplot(x=x, y=y, hue=hue, **kws)\n    legend = ax.get_legend()\n    for (i, handle) in enumerate(get_legend_handles(legend)):\n        assert (handle.get_marker() == kws['marker'])\n        assert (handle.get_linewidth() == '???')", "ground_truth": "kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_468", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_legend_synced_props", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Legend handle missing marker property')\ndef test_legend_synced_props(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    kws = dict(markers=['s', 'd'], linestyles=['--', ':'])\n    ax = pointplot(x=x, y=y, hue=hue, **kws)\n    legend = ax.get_legend()\n    for (i, handle) in enumerate(get_legend_handles(legend)):\n        assert (handle.get_marker() == kws['markers'][i])\n        assert (handle.get_linestyle() == kws['linestyles'][i])", "masked_code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Legend handle missing marker property')\ndef test_legend_synced_props(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    kws = dict(markers=['s', 'd'], linestyles=['--', ':'])\n    ax = pointplot(x=x, y=y, hue=hue, **kws)\n    legend = ax.get_legend()\n    for (i, handle) in enumerate(get_legend_handles(legend)):\n        assert (handle.get_marker() == '???')\n        assert (handle.get_linestyle() == kws['linestyles'][i])", "ground_truth": "kws['markers'][i]", "quality_analysis": {"complexity_score": 12, "left_complexity": 3, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_469", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_legend_synced_props", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Legend handle missing marker property')\ndef test_legend_synced_props(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    kws = dict(markers=['s', 'd'], linestyles=['--', ':'])\n    ax = pointplot(x=x, y=y, hue=hue, **kws)\n    legend = ax.get_legend()\n    for (i, handle) in enumerate(get_legend_handles(legend)):\n        assert (handle.get_marker() == kws['markers'][i])\n        assert (handle.get_linestyle() == kws['linestyles'][i])", "masked_code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Legend handle missing marker property')\ndef test_legend_synced_props(self):\n    (x, y) = (['a', 'a', 'b', 'b'], [1, 2, 3, 4])\n    hue = ['x', 'y', 'x', 'y']\n    kws = dict(markers=['s', 'd'], linestyles=['--', ':'])\n    ax = pointplot(x=x, y=y, hue=hue, **kws)\n    legend = ax.get_legend()\n    for (i, handle) in enumerate(get_legend_handles(legend)):\n        assert (handle.get_marker() == kws['markers'][i])\n        assert (handle.get_linestyle() == '???')", "ground_truth": "kws['linestyles'][i]", "quality_analysis": {"complexity_score": 12, "left_complexity": 3, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_470", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestPointPlot", "funcname": "test_scale_deprecation", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_scale_deprecation(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = pointplot(x=x, y=y, errorbar=None)\n    with pytest.warns(UserWarning, match='The `scale` parameter'):\n        pointplot(x=x, y=y, errorbar=None, scale=2)\n    (l1, l2) = ax.lines\n    assert (l2.get_linewidth() == (2 * l1.get_linewidth()))\n    assert (l2.get_markersize() > l1.get_markersize())", "masked_code": "def test_scale_deprecation(self):\n    (x, y) = (['a', 'b', 'c'], [1, 2, 3])\n    ax = pointplot(x=x, y=y, errorbar=None)\n    with pytest.warns(UserWarning, match='The `scale` parameter'):\n        pointplot(x=x, y=y, errorbar=None, scale=2)\n    (l1, l2) = ax.lines\n    assert (l2.get_linewidth() == '???')\n    assert (l2.get_markersize() > l1.get_markersize())", "ground_truth": "(2 * l1.get_linewidth())", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_471", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_labels_long", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_labels_long(self, long_df):\n    fig = mpl.figure.Figure()\n    axs = fig.subplots(2)\n    countplot(long_df, x='a', ax=axs[0])\n    countplot(long_df, x='b', stat='percent', ax=axs[1])\n    _draw_figure(fig)\n    assert (axs[0].get_xlabel() == 'a')\n    assert (axs[1].get_xlabel() == 'b')\n    assert (axs[0].get_ylabel() == 'count')\n    assert (axs[1].get_ylabel() == 'percent')", "masked_code": "def test_labels_long(self, long_df):\n    fig = mpl.figure.Figure()\n    axs = fig.subplots(2)\n    countplot(long_df, x='a', ax=axs[0])\n    countplot(long_df, x='b', stat='percent', ax=axs[1])\n    _draw_figure(fig)\n    assert (axs[0].get_xlabel() == 'a')\n    assert (axs[1].get_xlabel() == 'b')\n    assert (axs[0].get_ylabel() == '???')\n    assert (axs[1].get_ylabel() == 'percent')", "ground_truth": "'count'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_472", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_labels_long", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_labels_long(self, long_df):\n    fig = mpl.figure.Figure()\n    axs = fig.subplots(2)\n    countplot(long_df, x='a', ax=axs[0])\n    countplot(long_df, x='b', stat='percent', ax=axs[1])\n    _draw_figure(fig)\n    assert (axs[0].get_xlabel() == 'a')\n    assert (axs[1].get_xlabel() == 'b')\n    assert (axs[0].get_ylabel() == 'count')\n    assert (axs[1].get_ylabel() == 'percent')", "masked_code": "def test_labels_long(self, long_df):\n    fig = mpl.figure.Figure()\n    axs = fig.subplots(2)\n    countplot(long_df, x='a', ax=axs[0])\n    countplot(long_df, x='b', stat='percent', ax=axs[1])\n    _draw_figure(fig)\n    assert (axs[0].get_xlabel() == 'a')\n    assert (axs[1].get_xlabel() == 'b')\n    assert (axs[0].get_ylabel() == 'count')\n    assert (axs[1].get_ylabel() == '???')", "ground_truth": "'percent'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_473", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_wide_data", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_wide_data(self, wide_df):\n    ax = countplot(wide_df)\n    assert (len(ax.patches) == len(wide_df.columns))\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == len(wide_df))\n        assert (bar.get_width() == approx(0.8))", "masked_code": "def test_wide_data(self, wide_df):\n    ax = countplot(wide_df)\n    assert (len(ax.patches) == '???')\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == len(wide_df))\n        assert (bar.get_width() == approx(0.8))", "ground_truth": "len(wide_df.columns)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_474", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_wide_data", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_wide_data(self, wide_df):\n    ax = countplot(wide_df)\n    assert (len(ax.patches) == len(wide_df.columns))\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == len(wide_df))\n        assert (bar.get_width() == approx(0.8))", "masked_code": "def test_wide_data(self, wide_df):\n    ax = countplot(wide_df)\n    assert (len(ax.patches) == len(wide_df.columns))\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == '???')\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == len(wide_df))\n        assert (bar.get_width() == approx(0.8))", "ground_truth": "approx(i)", "quality_analysis": {"complexity_score": 15, "left_complexity": 11, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_475", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_wide_data", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_wide_data(self, wide_df):\n    ax = countplot(wide_df)\n    assert (len(ax.patches) == len(wide_df.columns))\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == len(wide_df))\n        assert (bar.get_width() == approx(0.8))", "masked_code": "def test_wide_data(self, wide_df):\n    ax = countplot(wide_df)\n    assert (len(ax.patches) == len(wide_df.columns))\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == approx(0.8))", "ground_truth": "len(wide_df)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_476", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_wide_data", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_wide_data(self, wide_df):\n    ax = countplot(wide_df)\n    assert (len(ax.patches) == len(wide_df.columns))\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == len(wide_df))\n        assert (bar.get_width() == approx(0.8))", "masked_code": "def test_wide_data(self, wide_df):\n    ax = countplot(wide_df)\n    assert (len(ax.patches) == len(wide_df.columns))\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == len(wide_df))\n        assert (bar.get_width() == '???')", "ground_truth": "approx(0.8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_477", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_flat_series", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_flat_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == 0)\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == counts[i])", "masked_code": "def test_flat_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == 0)\n        assert ((bar.get_y() + (bar.get_height() / 2)) == '???')\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == counts[i])", "ground_truth": "approx(i)", "quality_analysis": {"complexity_score": 15, "left_complexity": 11, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_478", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_flat_series", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_flat_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == 0)\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == counts[i])", "masked_code": "def test_flat_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == 0)\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == counts[i])", "ground_truth": "approx(0.8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_479", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_flat_series", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_flat_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == 0)\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == counts[i])", "masked_code": "def test_flat_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == 0)\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == '???')", "ground_truth": "counts[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_480", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_x_series", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_x_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(x=vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == approx(0.8))", "masked_code": "def test_x_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(x=vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == '???')\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == approx(0.8))", "ground_truth": "approx(i)", "quality_analysis": {"complexity_score": 15, "left_complexity": 11, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_481", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_x_series", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_x_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(x=vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == approx(0.8))", "masked_code": "def test_x_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(x=vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == approx(0.8))", "ground_truth": "counts[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_482", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_x_series", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_x_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(x=vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == approx(0.8))", "masked_code": "def test_x_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(x=vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == '???')", "ground_truth": "approx(0.8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_483", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_y_series", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_y_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(y=vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == 0)\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == counts[i])", "masked_code": "def test_y_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(y=vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == 0)\n        assert ((bar.get_y() + (bar.get_height() / 2)) == '???')\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == counts[i])", "ground_truth": "approx(i)", "quality_analysis": {"complexity_score": 15, "left_complexity": 11, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_484", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_y_series", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_y_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(y=vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == 0)\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == counts[i])", "masked_code": "def test_y_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(y=vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == 0)\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == counts[i])", "ground_truth": "approx(0.8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_485", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_y_series", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_y_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(y=vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == 0)\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == counts[i])", "masked_code": "def test_y_series(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(y=vals)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_x() == 0)\n        assert ((bar.get_y() + (bar.get_height() / 2)) == approx(i))\n        assert (bar.get_height() == approx(0.8))\n        assert (bar.get_width() == '???')", "ground_truth": "counts[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_486", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_hue_redundant", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_redundant(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(x=vals, hue=vals, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "masked_code": "def test_hue_redundant(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(x=vals, hue=vals, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == '???')\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "ground_truth": "approx(i)", "quality_analysis": {"complexity_score": 15, "left_complexity": 11, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_487", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_hue_redundant", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_redundant(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(x=vals, hue=vals, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "masked_code": "def test_hue_redundant(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(x=vals, hue=vals, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "ground_truth": "counts[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_488", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_hue_redundant", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_redundant(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(x=vals, hue=vals, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == approx(0.8))\n        assert same_color(bar.get_facecolor(), f'C{i}')", "masked_code": "def test_hue_redundant(self):\n    vals = ['a', 'b', 'c']\n    counts = [2, 1, 4]\n    vals = pd.Series([x for (x, n) in zip(vals, counts) for _ in range(n)])\n    ax = countplot(x=vals, hue=vals, saturation=1)\n    for (i, bar) in enumerate(ax.patches):\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(i))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == '???')\n        assert same_color(bar.get_facecolor(), f'C{i}')", "ground_truth": "approx(0.8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_489", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_hue_dodged", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_dodged(self):\n    vals = ['a', 'a', 'a', 'b', 'b', 'b']\n    hue = ['x', 'y', 'y', 'x', 'x', 'x']\n    counts = [1, 3, 2, 0]\n    ax = countplot(x=vals, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        sign = (1 if (i // 2) else (- 1))\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(((i % 2) + ((sign * 0.8) / 4))))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == approx((0.8 / 2)))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "masked_code": "def test_hue_dodged(self):\n    vals = ['a', 'a', 'a', 'b', 'b', 'b']\n    hue = ['x', 'y', 'y', 'x', 'x', 'x']\n    counts = [1, 3, 2, 0]\n    ax = countplot(x=vals, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        sign = (1 if (i // 2) else (- 1))\n        assert ((bar.get_x() + (bar.get_width() / 2)) == '???')\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == approx((0.8 / 2)))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "ground_truth": "approx(((i % 2) + ((sign * 0.8) / 4)))", "quality_analysis": {"complexity_score": 27, "left_complexity": 11, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_490", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_hue_dodged", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_dodged(self):\n    vals = ['a', 'a', 'a', 'b', 'b', 'b']\n    hue = ['x', 'y', 'y', 'x', 'x', 'x']\n    counts = [1, 3, 2, 0]\n    ax = countplot(x=vals, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        sign = (1 if (i // 2) else (- 1))\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(((i % 2) + ((sign * 0.8) / 4))))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == approx((0.8 / 2)))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "masked_code": "def test_hue_dodged(self):\n    vals = ['a', 'a', 'a', 'b', 'b', 'b']\n    hue = ['x', 'y', 'y', 'x', 'x', 'x']\n    counts = [1, 3, 2, 0]\n    ax = countplot(x=vals, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        sign = (1 if (i // 2) else (- 1))\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(((i % 2) + ((sign * 0.8) / 4))))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == '???')\n        assert (bar.get_width() == approx((0.8 / 2)))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "ground_truth": "counts[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_491", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_hue_dodged", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_hue_dodged(self):\n    vals = ['a', 'a', 'a', 'b', 'b', 'b']\n    hue = ['x', 'y', 'y', 'x', 'x', 'x']\n    counts = [1, 3, 2, 0]\n    ax = countplot(x=vals, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        sign = (1 if (i // 2) else (- 1))\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(((i % 2) + ((sign * 0.8) / 4))))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == approx((0.8 / 2)))\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "masked_code": "def test_hue_dodged(self):\n    vals = ['a', 'a', 'a', 'b', 'b', 'b']\n    hue = ['x', 'y', 'y', 'x', 'x', 'x']\n    counts = [1, 3, 2, 0]\n    ax = countplot(x=vals, hue=hue, saturation=1, legend=False)\n    for (i, bar) in enumerate(ax.patches):\n        sign = (1 if (i // 2) else (- 1))\n        assert ((bar.get_x() + (bar.get_width() / 2)) == approx(((i % 2) + ((sign * 0.8) / 4))))\n        assert (bar.get_y() == 0)\n        assert (bar.get_height() == counts[i])\n        assert (bar.get_width() == '???')\n        assert same_color(bar.get_facecolor(), f'C{(i // 2)}')", "ground_truth": "approx((0.8 / 2))", "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_492", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCountPlot", "funcname": "test_stat", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "@pytest.mark.parametrize('stat', ['percent', 'probability', 'proportion'])\ndef test_stat(self, long_df, stat):\n    col = 'a'\n    order = categorical_order(long_df[col])\n    expected = long_df[col].value_counts(normalize=True)\n    if (stat == 'percent'):\n        expected *= 100\n    ax = countplot(long_df, x=col, stat=stat)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_height() == approx(expected[order[i]]))", "masked_code": "@pytest.mark.parametrize('stat', ['percent', 'probability', 'proportion'])\ndef test_stat(self, long_df, stat):\n    col = 'a'\n    order = categorical_order(long_df[col])\n    expected = long_df[col].value_counts(normalize=True)\n    if (stat == 'percent'):\n        expected *= 100\n    ax = countplot(long_df, x=col, stat=stat)\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_height() == '???')", "ground_truth": "approx(expected[order[i]])", "quality_analysis": {"complexity_score": 15, "left_complexity": 3, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_493", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_facet_organization", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_facet_organization(self):\n    g = cat.catplot(x='g', y='y', data=self.df)\n    assert (g.axes.shape == (1, 1))\n    g = cat.catplot(x='g', y='y', col='h', data=self.df)\n    assert (g.axes.shape == (1, 2))\n    g = cat.catplot(x='g', y='y', row='h', data=self.df)\n    assert (g.axes.shape == (2, 1))\n    g = cat.catplot(x='g', y='y', col='u', row='h', data=self.df)\n    assert (g.axes.shape == (2, 3))", "masked_code": "def test_facet_organization(self):\n    g = cat.catplot(x='g', y='y', data=self.df)\n    assert (g.axes.shape == '???')\n    g = cat.catplot(x='g', y='y', col='h', data=self.df)\n    assert (g.axes.shape == (1, 2))\n    g = cat.catplot(x='g', y='y', row='h', data=self.df)\n    assert (g.axes.shape == (2, 1))\n    g = cat.catplot(x='g', y='y', col='u', row='h', data=self.df)\n    assert (g.axes.shape == (2, 3))", "ground_truth": "(1, 1)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_494", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_facet_organization", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_facet_organization(self):\n    g = cat.catplot(x='g', y='y', data=self.df)\n    assert (g.axes.shape == (1, 1))\n    g = cat.catplot(x='g', y='y', col='h', data=self.df)\n    assert (g.axes.shape == (1, 2))\n    g = cat.catplot(x='g', y='y', row='h', data=self.df)\n    assert (g.axes.shape == (2, 1))\n    g = cat.catplot(x='g', y='y', col='u', row='h', data=self.df)\n    assert (g.axes.shape == (2, 3))", "masked_code": "def test_facet_organization(self):\n    g = cat.catplot(x='g', y='y', data=self.df)\n    assert (g.axes.shape == (1, 1))\n    g = cat.catplot(x='g', y='y', col='h', data=self.df)\n    assert (g.axes.shape == '???')\n    g = cat.catplot(x='g', y='y', row='h', data=self.df)\n    assert (g.axes.shape == (2, 1))\n    g = cat.catplot(x='g', y='y', col='u', row='h', data=self.df)\n    assert (g.axes.shape == (2, 3))", "ground_truth": "(1, 2)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_495", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_facet_organization", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_facet_organization(self):\n    g = cat.catplot(x='g', y='y', data=self.df)\n    assert (g.axes.shape == (1, 1))\n    g = cat.catplot(x='g', y='y', col='h', data=self.df)\n    assert (g.axes.shape == (1, 2))\n    g = cat.catplot(x='g', y='y', row='h', data=self.df)\n    assert (g.axes.shape == (2, 1))\n    g = cat.catplot(x='g', y='y', col='u', row='h', data=self.df)\n    assert (g.axes.shape == (2, 3))", "masked_code": "def test_facet_organization(self):\n    g = cat.catplot(x='g', y='y', data=self.df)\n    assert (g.axes.shape == (1, 1))\n    g = cat.catplot(x='g', y='y', col='h', data=self.df)\n    assert (g.axes.shape == (1, 2))\n    g = cat.catplot(x='g', y='y', row='h', data=self.df)\n    assert (g.axes.shape == '???')\n    g = cat.catplot(x='g', y='y', col='u', row='h', data=self.df)\n    assert (g.axes.shape == (2, 3))", "ground_truth": "(2, 1)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_496", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_facet_organization", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_facet_organization(self):\n    g = cat.catplot(x='g', y='y', data=self.df)\n    assert (g.axes.shape == (1, 1))\n    g = cat.catplot(x='g', y='y', col='h', data=self.df)\n    assert (g.axes.shape == (1, 2))\n    g = cat.catplot(x='g', y='y', row='h', data=self.df)\n    assert (g.axes.shape == (2, 1))\n    g = cat.catplot(x='g', y='y', col='u', row='h', data=self.df)\n    assert (g.axes.shape == (2, 3))", "masked_code": "def test_facet_organization(self):\n    g = cat.catplot(x='g', y='y', data=self.df)\n    assert (g.axes.shape == (1, 1))\n    g = cat.catplot(x='g', y='y', col='h', data=self.df)\n    assert (g.axes.shape == (1, 2))\n    g = cat.catplot(x='g', y='y', row='h', data=self.df)\n    assert (g.axes.shape == (2, 1))\n    g = cat.catplot(x='g', y='y', col='u', row='h', data=self.df)\n    assert (g.axes.shape == '???')", "ground_truth": "(2, 3)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_497", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == '???')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "want_lines", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_498", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == '???')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "want_lines", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_499", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == '???')\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "want_elements", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_500", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == '???')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "want_elements", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_501", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == '???')\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "(want_elements + self.h.nunique())", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_502", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == '???')\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "want_elements", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_503", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == '???')\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "want_elements", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_504", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == '???')\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "want_elements", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_505", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == '???')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "want_artists", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_506", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == '???')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "want_artists", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_507", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == '???')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "want_artists", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_508", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == '???')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "want_elements", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_509", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == '???')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "want_elements", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_510", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == '???')\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "ground_truth": "want_elements", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_511", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_elements", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == want_elements)", "masked_code": "def test_plot_elements(self):\n    g = cat.catplot(x='g', y='y', data=self.df, kind='point')\n    want_lines = (1 + self.g.unique().size)\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='point')\n    want_lines = ((len(self.g.unique()) * len(self.h.unique())) + (2 * len(self.h.unique())))\n    assert (len(g.ax.lines) == want_lines)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='bar')\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.patches) == (want_elements + self.h.nunique()))\n    assert (len(g.ax.lines) == want_elements)\n    g = cat.catplot(x='g', data=self.df, kind='count')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(x='g', hue='h', data=self.df, kind='count')\n    want_elements = ((self.g.nunique() * self.h.nunique()) + self.h.nunique())\n    assert (len(g.ax.patches) == want_elements)\n    assert (len(g.ax.lines) == 0)\n    g = cat.catplot(y='y', data=self.df, kind='box')\n    want_artists = 1\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='box')\n    want_artists = self.g.unique().size\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='box')\n    want_artists = (self.g.nunique() * self.h.nunique())\n    assert (len(self.get_box_artists(g.ax)) == want_artists)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='violin', inner=None)\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='violin', inner=None)\n    want_elements = (self.g.nunique() * self.h.nunique())\n    assert (len(g.ax.collections) == want_elements)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='strip')\n    want_elements = self.g.unique().size\n    assert (len(g.ax.collections) == want_elements)\n    for strip in g.ax.collections:\n        assert same_color(strip.get_facecolors(), 'C0')\n    g = cat.catplot(x='g', y='y', hue='h', data=self.df, kind='strip')\n    want_elements = self.g.nunique()\n    assert (len(g.ax.collections) == '???')", "ground_truth": "want_elements", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_512", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_colors", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_colors(self):\n    ax = cat.barplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', color='purple')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', palette='Set2', hue='h')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df)\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, color='purple', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, palette='Set2', hue='h', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')", "masked_code": "def test_plot_colors(self):\n    ax = cat.barplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == '???')\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', color='purple')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', palette='Set2', hue='h')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df)\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, color='purple', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, palette='Set2', hue='h', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')", "ground_truth": "p2.get_facecolor()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_513", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_colors", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_colors(self):\n    ax = cat.barplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', color='purple')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', palette='Set2', hue='h')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df)\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, color='purple', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, palette='Set2', hue='h', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')", "masked_code": "def test_plot_colors(self):\n    ax = cat.barplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', color='purple')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == '???')\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', palette='Set2', hue='h')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df)\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, color='purple', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, palette='Set2', hue='h', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')", "ground_truth": "p2.get_facecolor()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_514", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_colors", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_colors(self):\n    ax = cat.barplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', color='purple')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', palette='Set2', hue='h')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df)\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, color='purple', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, palette='Set2', hue='h', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')", "masked_code": "def test_plot_colors(self):\n    ax = cat.barplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', color='purple')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', palette='Set2', hue='h')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == '???')\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df)\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, color='purple', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, palette='Set2', hue='h', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')", "ground_truth": "p2.get_facecolor()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_515", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_colors", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_colors(self):\n    ax = cat.barplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', color='purple')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', palette='Set2', hue='h')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df)\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, color='purple', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, palette='Set2', hue='h', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')", "masked_code": "def test_plot_colors(self):\n    ax = cat.barplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', color='purple')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', palette='Set2', hue='h')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df)\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == '???')\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, color='purple', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, palette='Set2', hue='h', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')", "ground_truth": "l2.get_color()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_516", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_colors", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_colors(self):\n    ax = cat.barplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', color='purple')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', palette='Set2', hue='h')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df)\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, color='purple', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, palette='Set2', hue='h', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')", "masked_code": "def test_plot_colors(self):\n    ax = cat.barplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', color='purple')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', palette='Set2', hue='h')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df)\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, color='purple', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == '???')\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, palette='Set2', hue='h', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')", "ground_truth": "l2.get_color()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_517", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_plot_colors", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_plot_colors(self):\n    ax = cat.barplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', color='purple')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', palette='Set2', hue='h')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df)\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, color='purple', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, palette='Set2', hue='h', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')", "masked_code": "def test_plot_colors(self):\n    ax = cat.barplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', color='purple')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.barplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, kind='bar', palette='Set2', hue='h')\n    for (p1, p2) in zip(ax.patches, g.ax.patches):\n        assert (p1.get_facecolor() == p2.get_facecolor())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df)\n    g = cat.catplot(x='g', y='y', data=self.df)\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, color='purple')\n    g = cat.catplot(x='g', y='y', data=self.df, color='purple', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == l2.get_color())\n    plt.close('all')\n    ax = cat.pointplot(x='g', y='y', data=self.df, palette='Set2', hue='h')\n    g = cat.catplot(x='g', y='y', data=self.df, palette='Set2', hue='h', kind='point')\n    for (l1, l2) in zip(ax.lines, g.ax.lines):\n        assert (l1.get_color() == '???')\n    plt.close('all')", "ground_truth": "l2.get_color()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_518", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_share_xy", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_share_xy(self):\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, color='b')\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == ((- 0.5), 0.5))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, color='r')\n    for ax in g.axes.flat:\n        assert (ax.get_ylim() == (0.5, (- 0.5)))\n    order = self.df.g.unique()\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))", "masked_code": "def test_share_xy(self):\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == '???')\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, color='b')\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == ((- 0.5), 0.5))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, color='r')\n    for ax in g.axes.flat:\n        assert (ax.get_ylim() == (0.5, (- 0.5)))\n    order = self.df.g.unique()\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))", "ground_truth": "len(self.df.g.unique())", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_519", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_share_xy", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_share_xy(self):\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, color='b')\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == ((- 0.5), 0.5))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, color='r')\n    for ax in g.axes.flat:\n        assert (ax.get_ylim() == (0.5, (- 0.5)))\n    order = self.df.g.unique()\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))", "masked_code": "def test_share_xy(self):\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == '???')\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, color='b')\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == ((- 0.5), 0.5))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, color='r')\n    for ax in g.axes.flat:\n        assert (ax.get_ylim() == (0.5, (- 0.5)))\n    order = self.df.g.unique()\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))", "ground_truth": "len(self.df.g.unique())", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_520", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_share_xy", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_share_xy(self):\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, color='b')\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == ((- 0.5), 0.5))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, color='r')\n    for ax in g.axes.flat:\n        assert (ax.get_ylim() == (0.5, (- 0.5)))\n    order = self.df.g.unique()\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))", "masked_code": "def test_share_xy(self):\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, color='b')\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == '???')\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, color='r')\n    for ax in g.axes.flat:\n        assert (ax.get_ylim() == (0.5, (- 0.5)))\n    order = self.df.g.unique()\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))", "ground_truth": "((- 0.5), 0.5)", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_521", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_share_xy", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_share_xy(self):\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, color='b')\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == ((- 0.5), 0.5))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, color='r')\n    for ax in g.axes.flat:\n        assert (ax.get_ylim() == (0.5, (- 0.5)))\n    order = self.df.g.unique()\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))", "masked_code": "def test_share_xy(self):\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, color='b')\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == ((- 0.5), 0.5))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, color='r')\n    for ax in g.axes.flat:\n        assert (ax.get_ylim() == '???')\n    order = self.df.g.unique()\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))", "ground_truth": "(0.5, (- 0.5))", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_522", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_share_xy", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_share_xy(self):\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, color='b')\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == ((- 0.5), 0.5))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, color='r')\n    for ax in g.axes.flat:\n        assert (ax.get_ylim() == (0.5, (- 0.5)))\n    order = self.df.g.unique()\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))", "masked_code": "def test_share_xy(self):\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, color='b')\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == ((- 0.5), 0.5))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, color='r')\n    for ax in g.axes.flat:\n        assert (ax.get_ylim() == (0.5, (- 0.5)))\n    order = self.df.g.unique()\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == '???')\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))", "ground_truth": "len(self.df.g.unique())", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_523", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestCatPlot", "funcname": "test_share_xy", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_share_xy(self):\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, color='b')\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == ((- 0.5), 0.5))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, color='r')\n    for ax in g.axes.flat:\n        assert (ax.get_ylim() == (0.5, (- 0.5)))\n    order = self.df.g.unique()\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))", "masked_code": "def test_share_xy(self):\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=True)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, kind='bar')\n    for ax in g.axes.flat:\n        assert (len(ax.patches) == 1)\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, color='b')\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == ((- 0.5), 0.5))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, color='r')\n    for ax in g.axes.flat:\n        assert (ax.get_ylim() == (0.5, (- 0.5)))\n    order = self.df.g.unique()\n    g = cat.catplot(x='g', y='y', col='g', data=self.df, sharex=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == len(self.df.g.unique()))\n    g = cat.catplot(x='y', y='g', col='g', data=self.df, sharey=False, order=order)\n    for ax in g.axes.flat:\n        assert (len(ax.collections) == '???')", "ground_truth": "len(self.df.g.unique())", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_524", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxPlotContainer", "funcname": "test_repr", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_repr(self, container, wide_array):\n    n = wide_array.shape[1]\n    assert (str(container) == f'<BoxPlotContainer object with {n} boxes>')", "masked_code": "def test_repr(self, container, wide_array):\n    n = wide_array.shape[1]\n    assert (str(container) == '???')", "ground_truth": "f'<BoxPlotContainer object with {n} boxes>'", "quality_analysis": {"complexity_score": 4, "left_complexity": 4, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_525", "reponame": "seaborn", "testpath": "tests/test_categorical.py", "testname": "test_categorical.py", "classname": "TestBoxPlotContainer", "funcname": "test_label", "imports": ["import itertools", "from functools import partial", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgb, to_rgba", "import pytest", "from pytest import approx", "from numpy.testing import assert_array_equal, assert_array_less, assert_array_almost_equal", "from seaborn import categorical as cat", "from seaborn._base import categorical_order", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal", "from seaborn.categorical import _CategoricalPlotter, Beeswarm, BoxPlotContainer, catplot, barplot, boxplot, boxenplot, countplot, pointplot, stripplot, swarmplot, violinplot", "from seaborn.palettes import color_palette", "from seaborn.utils import _draw_figure, _version_predates, desaturate"], "code": "def test_label(self, container):\n    label = 'a box plot'\n    container.set_label(label)\n    assert (container.get_label() == label)", "masked_code": "def test_label(self, container):\n    label = 'a box plot'\n    container.set_label(label)\n    assert (container.get_label() == '???')", "ground_truth": "label", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_526", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestDistPlot", "funcname": "test_hist_bins", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_hist_bins(self):\n    fd_edges = np.histogram_bin_edges(self.x, 'fd')\n    with pytest.warns(UserWarning):\n        ax = distplot(self.x)\n    for (edge, bar) in zip(fd_edges, ax.patches):\n        assert (pytest.approx(edge) == bar.get_x())\n    plt.close(ax.figure)\n    n = 25\n    n_edges = np.histogram_bin_edges(self.x, n)\n    with pytest.warns(UserWarning):\n        ax = distplot(self.x, bins=n)\n    for (edge, bar) in zip(n_edges, ax.patches):\n        assert (pytest.approx(edge) == bar.get_x())", "masked_code": "def test_hist_bins(self):\n    fd_edges = np.histogram_bin_edges(self.x, 'fd')\n    with pytest.warns(UserWarning):\n        ax = distplot(self.x)\n    for (edge, bar) in zip(fd_edges, ax.patches):\n        assert (pytest.approx(edge) == '???')\n    plt.close(ax.figure)\n    n = 25\n    n_edges = np.histogram_bin_edges(self.x, n)\n    with pytest.warns(UserWarning):\n        ax = distplot(self.x, bins=n)\n    for (edge, bar) in zip(n_edges, ax.patches):\n        assert (pytest.approx(edge) == bar.get_x())", "ground_truth": "bar.get_x()", "quality_analysis": {"complexity_score": 7, "left_complexity": 4, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_527", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestDistPlot", "funcname": "test_hist_bins", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_hist_bins(self):\n    fd_edges = np.histogram_bin_edges(self.x, 'fd')\n    with pytest.warns(UserWarning):\n        ax = distplot(self.x)\n    for (edge, bar) in zip(fd_edges, ax.patches):\n        assert (pytest.approx(edge) == bar.get_x())\n    plt.close(ax.figure)\n    n = 25\n    n_edges = np.histogram_bin_edges(self.x, n)\n    with pytest.warns(UserWarning):\n        ax = distplot(self.x, bins=n)\n    for (edge, bar) in zip(n_edges, ax.patches):\n        assert (pytest.approx(edge) == bar.get_x())", "masked_code": "def test_hist_bins(self):\n    fd_edges = np.histogram_bin_edges(self.x, 'fd')\n    with pytest.warns(UserWarning):\n        ax = distplot(self.x)\n    for (edge, bar) in zip(fd_edges, ax.patches):\n        assert (pytest.approx(edge) == bar.get_x())\n    plt.close(ax.figure)\n    n = 25\n    n_edges = np.histogram_bin_edges(self.x, n)\n    with pytest.warns(UserWarning):\n        ax = distplot(self.x, bins=n)\n    for (edge, bar) in zip(n_edges, ax.patches):\n        assert (pytest.approx(edge) == '???')", "ground_truth": "bar.get_x()", "quality_analysis": {"complexity_score": 7, "left_complexity": 4, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_528", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestDistPlot", "funcname": "test_elements", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_elements(self):\n    with pytest.warns(UserWarning):\n        n = 10\n        ax = distplot(self.x, bins=n, hist=True, kde=False, rug=False, fit=None)\n        assert (len(ax.patches) == 10)\n        assert (len(ax.lines) == 0)\n        assert (len(ax.collections) == 0)\n        plt.close(ax.figure)\n        ax = distplot(self.x, hist=False, kde=True, rug=False, fit=None)\n        assert (len(ax.patches) == 0)\n        assert (len(ax.lines) == 1)\n        assert (len(ax.collections) == 0)\n        plt.close(ax.figure)\n        ax = distplot(self.x, hist=False, kde=False, rug=True, fit=None)\n        assert (len(ax.patches) == 0)\n        assert (len(ax.lines) == 0)\n        assert (len(ax.collections) == 1)\n\n        class Norm():\n            'Dummy object that looks like a scipy RV'\n\n            def fit(self, x):\n                return ()\n\n            def pdf(self, x, *params):\n                return np.zeros_like(x)\n        plt.close(ax.figure)\n        ax = distplot(self.x, hist=False, kde=False, rug=False, fit=Norm())\n        assert (len(ax.patches) == 0)\n        assert (len(ax.lines) == 1)\n        assert (len(ax.collections) == 0)", "masked_code": "def test_elements(self):\n    with pytest.warns(UserWarning):\n        n = 10\n        ax = distplot(self.x, bins=n, hist=True, kde=False, rug=False, fit=None)\n        assert (len(ax.patches) == '???')\n        assert (len(ax.lines) == 0)\n        assert (len(ax.collections) == 0)\n        plt.close(ax.figure)\n        ax = distplot(self.x, hist=False, kde=True, rug=False, fit=None)\n        assert (len(ax.patches) == 0)\n        assert (len(ax.lines) == 1)\n        assert (len(ax.collections) == 0)\n        plt.close(ax.figure)\n        ax = distplot(self.x, hist=False, kde=False, rug=True, fit=None)\n        assert (len(ax.patches) == 0)\n        assert (len(ax.lines) == 0)\n        assert (len(ax.collections) == 1)\n\n        class Norm():\n            'Dummy object that looks like a scipy RV'\n\n            def fit(self, x):\n                return ()\n\n            def pdf(self, x, *params):\n                return np.zeros_like(x)\n        plt.close(ax.figure)\n        ax = distplot(self.x, hist=False, kde=False, rug=False, fit=Norm())\n        assert (len(ax.patches) == 0)\n        assert (len(ax.lines) == 1)\n        assert (len(ax.collections) == 0)", "ground_truth": "10", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_529", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestDistPlot", "funcname": "test_distplot_with_nans", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_distplot_with_nans(self):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    x_null = np.append(self.x, [np.nan])\n    with pytest.warns(UserWarning):\n        distplot(self.x, ax=ax1)\n        distplot(x_null, ax=ax2)\n    line1 = ax1.lines[0]\n    line2 = ax2.lines[0]\n    assert np.array_equal(line1.get_xydata(), line2.get_xydata())\n    for (bar1, bar2) in zip(ax1.patches, ax2.patches):\n        assert (bar1.get_xy() == bar2.get_xy())\n        assert (bar1.get_height() == bar2.get_height())", "masked_code": "def test_distplot_with_nans(self):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    x_null = np.append(self.x, [np.nan])\n    with pytest.warns(UserWarning):\n        distplot(self.x, ax=ax1)\n        distplot(x_null, ax=ax2)\n    line1 = ax1.lines[0]\n    line2 = ax2.lines[0]\n    assert np.array_equal(line1.get_xydata(), line2.get_xydata())\n    for (bar1, bar2) in zip(ax1.patches, ax2.patches):\n        assert (bar1.get_xy() == '???')\n        assert (bar1.get_height() == bar2.get_height())", "ground_truth": "bar2.get_xy()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_530", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestDistPlot", "funcname": "test_distplot_with_nans", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_distplot_with_nans(self):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    x_null = np.append(self.x, [np.nan])\n    with pytest.warns(UserWarning):\n        distplot(self.x, ax=ax1)\n        distplot(x_null, ax=ax2)\n    line1 = ax1.lines[0]\n    line2 = ax2.lines[0]\n    assert np.array_equal(line1.get_xydata(), line2.get_xydata())\n    for (bar1, bar2) in zip(ax1.patches, ax2.patches):\n        assert (bar1.get_xy() == bar2.get_xy())\n        assert (bar1.get_height() == bar2.get_height())", "masked_code": "def test_distplot_with_nans(self):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    x_null = np.append(self.x, [np.nan])\n    with pytest.warns(UserWarning):\n        distplot(self.x, ax=ax1)\n        distplot(x_null, ax=ax2)\n    line1 = ax1.lines[0]\n    line2 = ax2.lines[0]\n    assert np.array_equal(line1.get_xydata(), line2.get_xydata())\n    for (bar1, bar2) in zip(ax1.patches, ax2.patches):\n        assert (bar1.get_xy() == bar2.get_xy())\n        assert (bar1.get_height() == '???')", "ground_truth": "bar2.get_height()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_531", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestRugPlot", "funcname": "test_expand_margins", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_expand_margins(self, flat_array):\n    (f, ax) = plt.subplots()\n    (x1, y1) = ax.margins()\n    rugplot(x=flat_array, expand_margins=False)\n    (x2, y2) = ax.margins()\n    assert (x1 == x2)\n    assert (y1 == y2)\n    (f, ax) = plt.subplots()\n    (x1, y1) = ax.margins()\n    height = 0.05\n    rugplot(x=flat_array, height=height)\n    (x2, y2) = ax.margins()\n    assert (x1 == x2)\n    assert ((y1 + (height * 2)) == pytest.approx(y2))", "masked_code": "def test_expand_margins(self, flat_array):\n    (f, ax) = plt.subplots()\n    (x1, y1) = ax.margins()\n    rugplot(x=flat_array, expand_margins=False)\n    (x2, y2) = ax.margins()\n    assert (x1 == x2)\n    assert (y1 == y2)\n    (f, ax) = plt.subplots()\n    (x1, y1) = ax.margins()\n    height = 0.05\n    rugplot(x=flat_array, height=height)\n    (x2, y2) = ax.margins()\n    assert (x1 == x2)\n    assert ((y1 + (height * 2)) == '???')", "ground_truth": "pytest.approx(y2)", "quality_analysis": {"complexity_score": 11, "left_complexity": 7, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_532", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestRugPlot", "funcname": "test_axis_labels", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_axis_labels(self, flat_series):\n    ax = rugplot(x=flat_series)\n    assert (ax.get_xlabel() == flat_series.name)\n    assert (not ax.get_ylabel())", "masked_code": "def test_axis_labels(self, flat_series):\n    ax = rugplot(x=flat_series)\n    assert (ax.get_xlabel() == '???')\n    assert (not ax.get_ylabel())", "ground_truth": "flat_series.name", "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_533", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_datetime_scale", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_datetime_scale(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    kdeplot(x=long_df['t'], fill=True, ax=ax1)\n    kdeplot(x=long_df['t'], fill=False, ax=ax2)\n    assert (ax1.get_xlim() == ax2.get_xlim())", "masked_code": "def test_datetime_scale(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    kdeplot(x=long_df['t'], fill=True, ax=ax1)\n    kdeplot(x=long_df['t'], fill=False, ax=ax2)\n    assert (ax1.get_xlim() == '???')", "ground_truth": "ax2.get_xlim()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_534", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_cut", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, cut=0, legend=False)\n    xdata_0 = ax.lines[0].get_xdata()\n    assert (xdata_0.min() == x.min())\n    assert (xdata_0.max() == x.max())\n    kdeplot(x=x, cut=2, legend=False)\n    xdata_2 = ax.lines[1].get_xdata()\n    assert (xdata_2.min() < xdata_0.min())\n    assert (xdata_2.max() > xdata_0.max())\n    assert (len(xdata_0) == len(xdata_2))", "masked_code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, cut=0, legend=False)\n    xdata_0 = ax.lines[0].get_xdata()\n    assert (xdata_0.min() == '???')\n    assert (xdata_0.max() == x.max())\n    kdeplot(x=x, cut=2, legend=False)\n    xdata_2 = ax.lines[1].get_xdata()\n    assert (xdata_2.min() < xdata_0.min())\n    assert (xdata_2.max() > xdata_0.max())\n    assert (len(xdata_0) == len(xdata_2))", "ground_truth": "x.min()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_535", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_cut", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, cut=0, legend=False)\n    xdata_0 = ax.lines[0].get_xdata()\n    assert (xdata_0.min() == x.min())\n    assert (xdata_0.max() == x.max())\n    kdeplot(x=x, cut=2, legend=False)\n    xdata_2 = ax.lines[1].get_xdata()\n    assert (xdata_2.min() < xdata_0.min())\n    assert (xdata_2.max() > xdata_0.max())\n    assert (len(xdata_0) == len(xdata_2))", "masked_code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, cut=0, legend=False)\n    xdata_0 = ax.lines[0].get_xdata()\n    assert (xdata_0.min() == x.min())\n    assert (xdata_0.max() == '???')\n    kdeplot(x=x, cut=2, legend=False)\n    xdata_2 = ax.lines[1].get_xdata()\n    assert (xdata_2.min() < xdata_0.min())\n    assert (xdata_2.max() > xdata_0.max())\n    assert (len(xdata_0) == len(xdata_2))", "ground_truth": "x.max()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_536", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_cut", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, cut=0, legend=False)\n    xdata_0 = ax.lines[0].get_xdata()\n    assert (xdata_0.min() == x.min())\n    assert (xdata_0.max() == x.max())\n    kdeplot(x=x, cut=2, legend=False)\n    xdata_2 = ax.lines[1].get_xdata()\n    assert (xdata_2.min() < xdata_0.min())\n    assert (xdata_2.max() > xdata_0.max())\n    assert (len(xdata_0) == len(xdata_2))", "masked_code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, cut=0, legend=False)\n    xdata_0 = ax.lines[0].get_xdata()\n    assert (xdata_0.min() == x.min())\n    assert (xdata_0.max() == x.max())\n    kdeplot(x=x, cut=2, legend=False)\n    xdata_2 = ax.lines[1].get_xdata()\n    assert (xdata_2.min() < xdata_0.min())\n    assert (xdata_2.max() > xdata_0.max())\n    assert (len(xdata_0) == '???')", "ground_truth": "len(xdata_2)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_537", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_line_is_density", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_line_is_density(self, long_df):\n    ax = kdeplot(data=long_df, x='x', cut=5)\n    (x, y) = ax.lines[0].get_xydata().T\n    assert (integrate(y, x) == pytest.approx(1))", "masked_code": "def test_line_is_density(self, long_df):\n    ax = kdeplot(data=long_df, x='x', cut=5)\n    (x, y) = ax.lines[0].get_xydata().T\n    assert (integrate(y, x) == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_538", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_cumulative", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "@pytest.mark.skipif(_no_scipy, reason='Test requires scipy')\ndef test_cumulative(self, long_df):\n    ax = kdeplot(data=long_df, x='x', cut=5, cumulative=True)\n    y = ax.lines[0].get_ydata()\n    assert (y[0] == pytest.approx(0))\n    assert (y[(- 1)] == pytest.approx(1))", "masked_code": "@pytest.mark.skipif(_no_scipy, reason='Test requires scipy')\ndef test_cumulative(self, long_df):\n    ax = kdeplot(data=long_df, x='x', cut=5, cumulative=True)\n    y = ax.lines[0].get_ydata()\n    assert (y[0] == '???')\n    assert (y[(- 1)] == pytest.approx(1))", "ground_truth": "pytest.approx(0)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_539", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_cumulative", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "@pytest.mark.skipif(_no_scipy, reason='Test requires scipy')\ndef test_cumulative(self, long_df):\n    ax = kdeplot(data=long_df, x='x', cut=5, cumulative=True)\n    y = ax.lines[0].get_ydata()\n    assert (y[0] == pytest.approx(0))\n    assert (y[(- 1)] == pytest.approx(1))", "masked_code": "@pytest.mark.skipif(_no_scipy, reason='Test requires scipy')\ndef test_cumulative(self, long_df):\n    ax = kdeplot(data=long_df, x='x', cut=5, cumulative=True)\n    y = ax.lines[0].get_ydata()\n    assert (y[0] == pytest.approx(0))\n    assert (y[(- 1)] == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 11, "left_complexity": 7, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_540", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_common_norm", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_common_norm(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(data=long_df, x='x', hue='c', common_norm=True, cut=10, ax=ax1)\n    kdeplot(data=long_df, x='x', hue='c', common_norm=False, cut=10, ax=ax2)\n    total_area = 0\n    for line in ax1.lines:\n        (xdata, ydata) = line.get_xydata().T\n        total_area += integrate(ydata, xdata)\n    assert (total_area == pytest.approx(1))\n    for line in ax2.lines:\n        (xdata, ydata) = line.get_xydata().T\n        assert (integrate(ydata, xdata) == pytest.approx(1))", "masked_code": "def test_common_norm(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(data=long_df, x='x', hue='c', common_norm=True, cut=10, ax=ax1)\n    kdeplot(data=long_df, x='x', hue='c', common_norm=False, cut=10, ax=ax2)\n    total_area = 0\n    for line in ax1.lines:\n        (xdata, ydata) = line.get_xydata().T\n        total_area += integrate(ydata, xdata)\n    assert (total_area == pytest.approx(1))\n    for line in ax2.lines:\n        (xdata, ydata) = line.get_xydata().T\n        assert (integrate(ydata, xdata) == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_541", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_common_grid", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_common_grid(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    order = ('a', 'b', 'c')\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=False, cut=0, ax=ax1)\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=True, cut=0, ax=ax2)\n    for (line, level) in zip(ax1.lines[::(- 1)], order):\n        xdata = line.get_xdata()\n        assert (xdata.min() == long_df.loc[((long_df['a'] == level), 'x')].min())\n        assert (xdata.max() == long_df.loc[((long_df['a'] == level), 'x')].max())\n    for line in ax2.lines:\n        xdata = line.get_xdata().T\n        assert (xdata.min() == long_df['x'].min())\n        assert (xdata.max() == long_df['x'].max())", "masked_code": "def test_common_grid(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    order = ('a', 'b', 'c')\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=False, cut=0, ax=ax1)\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=True, cut=0, ax=ax2)\n    for (line, level) in zip(ax1.lines[::(- 1)], order):\n        xdata = line.get_xdata()\n        assert (xdata.min() == '???')\n        assert (xdata.max() == long_df.loc[((long_df['a'] == level), 'x')].max())\n    for line in ax2.lines:\n        xdata = line.get_xdata().T\n        assert (xdata.min() == long_df['x'].min())\n        assert (xdata.max() == long_df['x'].max())", "ground_truth": "long_df.loc[((long_df['a'] == level), 'x')].min()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_542", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_common_grid", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_common_grid(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    order = ('a', 'b', 'c')\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=False, cut=0, ax=ax1)\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=True, cut=0, ax=ax2)\n    for (line, level) in zip(ax1.lines[::(- 1)], order):\n        xdata = line.get_xdata()\n        assert (xdata.min() == long_df.loc[((long_df['a'] == level), 'x')].min())\n        assert (xdata.max() == long_df.loc[((long_df['a'] == level), 'x')].max())\n    for line in ax2.lines:\n        xdata = line.get_xdata().T\n        assert (xdata.min() == long_df['x'].min())\n        assert (xdata.max() == long_df['x'].max())", "masked_code": "def test_common_grid(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    order = ('a', 'b', 'c')\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=False, cut=0, ax=ax1)\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=True, cut=0, ax=ax2)\n    for (line, level) in zip(ax1.lines[::(- 1)], order):\n        xdata = line.get_xdata()\n        assert (xdata.min() == long_df.loc[((long_df['a'] == level), 'x')].min())\n        assert (xdata.max() == '???')\n    for line in ax2.lines:\n        xdata = line.get_xdata().T\n        assert (xdata.min() == long_df['x'].min())\n        assert (xdata.max() == long_df['x'].max())", "ground_truth": "long_df.loc[((long_df['a'] == level), 'x')].max()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_543", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_common_grid", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_common_grid(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    order = ('a', 'b', 'c')\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=False, cut=0, ax=ax1)\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=True, cut=0, ax=ax2)\n    for (line, level) in zip(ax1.lines[::(- 1)], order):\n        xdata = line.get_xdata()\n        assert (xdata.min() == long_df.loc[((long_df['a'] == level), 'x')].min())\n        assert (xdata.max() == long_df.loc[((long_df['a'] == level), 'x')].max())\n    for line in ax2.lines:\n        xdata = line.get_xdata().T\n        assert (xdata.min() == long_df['x'].min())\n        assert (xdata.max() == long_df['x'].max())", "masked_code": "def test_common_grid(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    order = ('a', 'b', 'c')\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=False, cut=0, ax=ax1)\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=True, cut=0, ax=ax2)\n    for (line, level) in zip(ax1.lines[::(- 1)], order):\n        xdata = line.get_xdata()\n        assert (xdata.min() == long_df.loc[((long_df['a'] == level), 'x')].min())\n        assert (xdata.max() == long_df.loc[((long_df['a'] == level), 'x')].max())\n    for line in ax2.lines:\n        xdata = line.get_xdata().T\n        assert (xdata.min() == '???')\n        assert (xdata.max() == long_df['x'].max())", "ground_truth": "long_df['x'].min()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_544", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_common_grid", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_common_grid(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    order = ('a', 'b', 'c')\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=False, cut=0, ax=ax1)\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=True, cut=0, ax=ax2)\n    for (line, level) in zip(ax1.lines[::(- 1)], order):\n        xdata = line.get_xdata()\n        assert (xdata.min() == long_df.loc[((long_df['a'] == level), 'x')].min())\n        assert (xdata.max() == long_df.loc[((long_df['a'] == level), 'x')].max())\n    for line in ax2.lines:\n        xdata = line.get_xdata().T\n        assert (xdata.min() == long_df['x'].min())\n        assert (xdata.max() == long_df['x'].max())", "masked_code": "def test_common_grid(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    order = ('a', 'b', 'c')\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=False, cut=0, ax=ax1)\n    kdeplot(data=long_df, x='x', hue='a', hue_order=order, common_grid=True, cut=0, ax=ax2)\n    for (line, level) in zip(ax1.lines[::(- 1)], order):\n        xdata = line.get_xdata()\n        assert (xdata.min() == long_df.loc[((long_df['a'] == level), 'x')].min())\n        assert (xdata.max() == long_df.loc[((long_df['a'] == level), 'x')].max())\n    for line in ax2.lines:\n        xdata = line.get_xdata().T\n        assert (xdata.min() == long_df['x'].min())\n        assert (xdata.max() == '???')", "ground_truth": "long_df['x'].max()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_545", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_log_scale_explicit", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_log_scale_explicit(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    (f, (ax1, ax2, ax3)) = plt.subplots(ncols=3)\n    ax1.set_xscale('log')\n    kdeplot(x=x, ax=ax1)\n    kdeplot(x=x, log_scale=True, ax=ax2)\n    kdeplot(x=x, log_scale=10, ax=ax3)\n    for ax in f.axes:\n        assert (ax.get_xscale() == 'log')\n    supports = [ax.lines[0].get_xdata() for ax in f.axes]\n    for (a, b) in itertools.product(supports, supports):\n        assert_array_equal(a, b)\n    densities = [ax.lines[0].get_ydata() for ax in f.axes]\n    for (a, b) in itertools.product(densities, densities):\n        assert_array_equal(a, b)\n    (f, ax) = plt.subplots()\n    kdeplot(y=x, log_scale=True, ax=ax)\n    assert (ax.get_yscale() == 'log')", "masked_code": "def test_log_scale_explicit(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    (f, (ax1, ax2, ax3)) = plt.subplots(ncols=3)\n    ax1.set_xscale('log')\n    kdeplot(x=x, ax=ax1)\n    kdeplot(x=x, log_scale=True, ax=ax2)\n    kdeplot(x=x, log_scale=10, ax=ax3)\n    for ax in f.axes:\n        assert (ax.get_xscale() == 'log')\n    supports = [ax.lines[0].get_xdata() for ax in f.axes]\n    for (a, b) in itertools.product(supports, supports):\n        assert_array_equal(a, b)\n    densities = [ax.lines[0].get_ydata() for ax in f.axes]\n    for (a, b) in itertools.product(densities, densities):\n        assert_array_equal(a, b)\n    (f, ax) = plt.subplots()\n    kdeplot(y=x, log_scale=True, ax=ax)\n    assert (ax.get_yscale() == '???')", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_546", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_log_scale_explicit", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_log_scale_explicit(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    (f, (ax1, ax2, ax3)) = plt.subplots(ncols=3)\n    ax1.set_xscale('log')\n    kdeplot(x=x, ax=ax1)\n    kdeplot(x=x, log_scale=True, ax=ax2)\n    kdeplot(x=x, log_scale=10, ax=ax3)\n    for ax in f.axes:\n        assert (ax.get_xscale() == 'log')\n    supports = [ax.lines[0].get_xdata() for ax in f.axes]\n    for (a, b) in itertools.product(supports, supports):\n        assert_array_equal(a, b)\n    densities = [ax.lines[0].get_ydata() for ax in f.axes]\n    for (a, b) in itertools.product(densities, densities):\n        assert_array_equal(a, b)\n    (f, ax) = plt.subplots()\n    kdeplot(y=x, log_scale=True, ax=ax)\n    assert (ax.get_yscale() == 'log')", "masked_code": "def test_log_scale_explicit(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    (f, (ax1, ax2, ax3)) = plt.subplots(ncols=3)\n    ax1.set_xscale('log')\n    kdeplot(x=x, ax=ax1)\n    kdeplot(x=x, log_scale=True, ax=ax2)\n    kdeplot(x=x, log_scale=10, ax=ax3)\n    for ax in f.axes:\n        assert (ax.get_xscale() == '???')\n    supports = [ax.lines[0].get_xdata() for ax in f.axes]\n    for (a, b) in itertools.product(supports, supports):\n        assert_array_equal(a, b)\n    densities = [ax.lines[0].get_ydata() for ax in f.axes]\n    for (a, b) in itertools.product(densities, densities):\n        assert_array_equal(a, b)\n    (f, ax) = plt.subplots()\n    kdeplot(y=x, log_scale=True, ax=ax)\n    assert (ax.get_yscale() == 'log')", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_547", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_weight_norm", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_weight_norm(self, rng):\n    vals = rng.normal(0, 1, 50)\n    x = np.concatenate([vals, vals])\n    w = np.repeat([1, 2], 50)\n    ax = kdeplot(x=x, weights=w, hue=w, common_norm=True)\n    (x1, y1) = ax.lines[0].get_xydata().T\n    (x2, y2) = ax.lines[1].get_xydata().T\n    assert (integrate(y1, x1) == pytest.approx((2 * integrate(y2, x2))))", "masked_code": "def test_weight_norm(self, rng):\n    vals = rng.normal(0, 1, 50)\n    x = np.concatenate([vals, vals])\n    w = np.repeat([1, 2], 50)\n    ax = kdeplot(x=x, weights=w, hue=w, common_norm=True)\n    (x1, y1) = ax.lines[0].get_xydata().T\n    (x2, y2) = ax.lines[1].get_xydata().T\n    assert (integrate(y1, x1) == '???')", "ground_truth": "pytest.approx((2 * integrate(y2, x2)))", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_548", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_sticky_edges", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_sticky_edges(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(data=long_df, x='x', fill=True, ax=ax1)\n    assert (ax1.collections[0].sticky_edges.y[:] == [0, np.inf])\n    kdeplot(data=long_df, x='x', hue='a', multiple='fill', fill=True, ax=ax2)\n    assert (ax2.collections[0].sticky_edges.y[:] == [0, 1])", "masked_code": "def test_sticky_edges(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(data=long_df, x='x', fill=True, ax=ax1)\n    assert (ax1.collections[0].sticky_edges.y[:] == '???')\n    kdeplot(data=long_df, x='x', hue='a', multiple='fill', fill=True, ax=ax2)\n    assert (ax2.collections[0].sticky_edges.y[:] == [0, 1])", "ground_truth": "[0, np.inf]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_549", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_sticky_edges", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_sticky_edges(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(data=long_df, x='x', fill=True, ax=ax1)\n    assert (ax1.collections[0].sticky_edges.y[:] == [0, np.inf])\n    kdeplot(data=long_df, x='x', hue='a', multiple='fill', fill=True, ax=ax2)\n    assert (ax2.collections[0].sticky_edges.y[:] == [0, 1])", "masked_code": "def test_sticky_edges(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(data=long_df, x='x', fill=True, ax=ax1)\n    assert (ax1.collections[0].sticky_edges.y[:] == [0, np.inf])\n    kdeplot(data=long_df, x='x', hue='a', multiple='fill', fill=True, ax=ax2)\n    assert (ax2.collections[0].sticky_edges.y[:] == '???')", "ground_truth": "[0, 1]", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_550", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_line_kws", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_line_kws(self, flat_array):\n    lw = 3\n    color = (0.2, 0.5, 0.8)\n    ax = kdeplot(x=flat_array, linewidth=lw, color=color)\n    (line,) = ax.lines\n    assert (line.get_linewidth() == lw)\n    assert_colors_equal(line.get_color(), color)", "masked_code": "def test_line_kws(self, flat_array):\n    lw = 3\n    color = (0.2, 0.5, 0.8)\n    ax = kdeplot(x=flat_array, linewidth=lw, color=color)\n    (line,) = ax.lines\n    assert (line.get_linewidth() == '???')\n    assert_colors_equal(line.get_color(), color)", "ground_truth": "lw", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_551", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_axis_labels", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_axis_labels(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(data=long_df, x='x', ax=ax1)\n    assert (ax1.get_xlabel() == 'x')\n    assert (ax1.get_ylabel() == 'Density')\n    kdeplot(data=long_df, y='y', ax=ax2)\n    assert (ax2.get_xlabel() == 'Density')\n    assert (ax2.get_ylabel() == 'y')", "masked_code": "def test_axis_labels(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(data=long_df, x='x', ax=ax1)\n    assert (ax1.get_xlabel() == 'x')\n    assert (ax1.get_ylabel() == '???')\n    kdeplot(data=long_df, y='y', ax=ax2)\n    assert (ax2.get_xlabel() == 'Density')\n    assert (ax2.get_ylabel() == 'y')", "ground_truth": "'Density'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_552", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_axis_labels", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_axis_labels(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(data=long_df, x='x', ax=ax1)\n    assert (ax1.get_xlabel() == 'x')\n    assert (ax1.get_ylabel() == 'Density')\n    kdeplot(data=long_df, y='y', ax=ax2)\n    assert (ax2.get_xlabel() == 'Density')\n    assert (ax2.get_ylabel() == 'y')", "masked_code": "def test_axis_labels(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(data=long_df, x='x', ax=ax1)\n    assert (ax1.get_xlabel() == 'x')\n    assert (ax1.get_ylabel() == 'Density')\n    kdeplot(data=long_df, y='y', ax=ax2)\n    assert (ax2.get_xlabel() == '???')\n    assert (ax2.get_ylabel() == 'y')", "ground_truth": "'Density'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_553", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotUnivariate", "funcname": "test_legend", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_legend(self, long_df):\n    ax = kdeplot(data=long_df, x='x', hue='a')\n    assert (ax.legend_.get_title().get_text() == 'a')\n    legend_labels = ax.legend_.get_texts()\n    order = categorical_order(long_df['a'])\n    for (label, level) in zip(legend_labels, order):\n        assert (label.get_text() == level)\n    legend_artists = ax.legend_.findobj(mpl.lines.Line2D)\n    if _version_predates(mpl, '3.5.0b0'):\n        legend_artists = legend_artists[::2]\n    palette = color_palette()\n    for (artist, color) in zip(legend_artists, palette):\n        assert_colors_equal(artist.get_color(), color)\n    ax.clear()\n    kdeplot(data=long_df, x='x', hue='a', legend=False)\n    assert (ax.legend_ is None)", "masked_code": "def test_legend(self, long_df):\n    ax = kdeplot(data=long_df, x='x', hue='a')\n    assert (ax.legend_.get_title().get_text() == 'a')\n    legend_labels = ax.legend_.get_texts()\n    order = categorical_order(long_df['a'])\n    for (label, level) in zip(legend_labels, order):\n        assert (label.get_text() == '???')\n    legend_artists = ax.legend_.findobj(mpl.lines.Line2D)\n    if _version_predates(mpl, '3.5.0b0'):\n        legend_artists = legend_artists[::2]\n    palette = color_palette()\n    for (artist, color) in zip(legend_artists, palette):\n        assert_colors_equal(artist.get_color(), color)\n    ax.clear()\n    kdeplot(data=long_df, x='x', hue='a', legend=False)\n    assert (ax.legend_ is None)", "ground_truth": "level", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_554", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotBivariate", "funcname": "test_log_scale", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_log_scale(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    y = rng.uniform(0, 1, 100)\n    levels = (0.2, 0.5, 1)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, y=y, log_scale=True, levels=levels, ax=ax)\n    assert (ax.get_xscale() == 'log')\n    assert (ax.get_yscale() == 'log')\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(x=x, y=y, log_scale=(10, False), levels=levels, ax=ax1)\n    assert (ax1.get_xscale() == 'log')\n    assert (ax1.get_yscale() == 'linear')\n    p = _DistributionPlotter()\n    kde = KDE()\n    (density, (xx, yy)) = kde(np.log10(x), y)\n    levels = p._quantile_to_level(density, levels)\n    ax2.contour((10 ** xx), yy, density, levels=levels)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)", "masked_code": "def test_log_scale(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    y = rng.uniform(0, 1, 100)\n    levels = (0.2, 0.5, 1)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, y=y, log_scale=True, levels=levels, ax=ax)\n    assert (ax.get_xscale() == '???')\n    assert (ax.get_yscale() == 'log')\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(x=x, y=y, log_scale=(10, False), levels=levels, ax=ax1)\n    assert (ax1.get_xscale() == 'log')\n    assert (ax1.get_yscale() == 'linear')\n    p = _DistributionPlotter()\n    kde = KDE()\n    (density, (xx, yy)) = kde(np.log10(x), y)\n    levels = p._quantile_to_level(density, levels)\n    ax2.contour((10 ** xx), yy, density, levels=levels)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_555", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotBivariate", "funcname": "test_log_scale", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_log_scale(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    y = rng.uniform(0, 1, 100)\n    levels = (0.2, 0.5, 1)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, y=y, log_scale=True, levels=levels, ax=ax)\n    assert (ax.get_xscale() == 'log')\n    assert (ax.get_yscale() == 'log')\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(x=x, y=y, log_scale=(10, False), levels=levels, ax=ax1)\n    assert (ax1.get_xscale() == 'log')\n    assert (ax1.get_yscale() == 'linear')\n    p = _DistributionPlotter()\n    kde = KDE()\n    (density, (xx, yy)) = kde(np.log10(x), y)\n    levels = p._quantile_to_level(density, levels)\n    ax2.contour((10 ** xx), yy, density, levels=levels)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)", "masked_code": "def test_log_scale(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    y = rng.uniform(0, 1, 100)\n    levels = (0.2, 0.5, 1)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, y=y, log_scale=True, levels=levels, ax=ax)\n    assert (ax.get_xscale() == 'log')\n    assert (ax.get_yscale() == '???')\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(x=x, y=y, log_scale=(10, False), levels=levels, ax=ax1)\n    assert (ax1.get_xscale() == 'log')\n    assert (ax1.get_yscale() == 'linear')\n    p = _DistributionPlotter()\n    kde = KDE()\n    (density, (xx, yy)) = kde(np.log10(x), y)\n    levels = p._quantile_to_level(density, levels)\n    ax2.contour((10 ** xx), yy, density, levels=levels)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_556", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotBivariate", "funcname": "test_log_scale", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_log_scale(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    y = rng.uniform(0, 1, 100)\n    levels = (0.2, 0.5, 1)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, y=y, log_scale=True, levels=levels, ax=ax)\n    assert (ax.get_xscale() == 'log')\n    assert (ax.get_yscale() == 'log')\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(x=x, y=y, log_scale=(10, False), levels=levels, ax=ax1)\n    assert (ax1.get_xscale() == 'log')\n    assert (ax1.get_yscale() == 'linear')\n    p = _DistributionPlotter()\n    kde = KDE()\n    (density, (xx, yy)) = kde(np.log10(x), y)\n    levels = p._quantile_to_level(density, levels)\n    ax2.contour((10 ** xx), yy, density, levels=levels)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)", "masked_code": "def test_log_scale(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    y = rng.uniform(0, 1, 100)\n    levels = (0.2, 0.5, 1)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, y=y, log_scale=True, levels=levels, ax=ax)\n    assert (ax.get_xscale() == 'log')\n    assert (ax.get_yscale() == 'log')\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(x=x, y=y, log_scale=(10, False), levels=levels, ax=ax1)\n    assert (ax1.get_xscale() == '???')\n    assert (ax1.get_yscale() == 'linear')\n    p = _DistributionPlotter()\n    kde = KDE()\n    (density, (xx, yy)) = kde(np.log10(x), y)\n    levels = p._quantile_to_level(density, levels)\n    ax2.contour((10 ** xx), yy, density, levels=levels)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_557", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotBivariate", "funcname": "test_log_scale", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_log_scale(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    y = rng.uniform(0, 1, 100)\n    levels = (0.2, 0.5, 1)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, y=y, log_scale=True, levels=levels, ax=ax)\n    assert (ax.get_xscale() == 'log')\n    assert (ax.get_yscale() == 'log')\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(x=x, y=y, log_scale=(10, False), levels=levels, ax=ax1)\n    assert (ax1.get_xscale() == 'log')\n    assert (ax1.get_yscale() == 'linear')\n    p = _DistributionPlotter()\n    kde = KDE()\n    (density, (xx, yy)) = kde(np.log10(x), y)\n    levels = p._quantile_to_level(density, levels)\n    ax2.contour((10 ** xx), yy, density, levels=levels)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)", "masked_code": "def test_log_scale(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    y = rng.uniform(0, 1, 100)\n    levels = (0.2, 0.5, 1)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, y=y, log_scale=True, levels=levels, ax=ax)\n    assert (ax.get_xscale() == 'log')\n    assert (ax.get_yscale() == 'log')\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(x=x, y=y, log_scale=(10, False), levels=levels, ax=ax1)\n    assert (ax1.get_xscale() == 'log')\n    assert (ax1.get_yscale() == '???')\n    p = _DistributionPlotter()\n    kde = KDE()\n    (density, (xx, yy)) = kde(np.log10(x), y)\n    levels = p._quantile_to_level(density, levels)\n    ax2.contour((10 ** xx), yy, density, levels=levels)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)", "ground_truth": "'linear'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_558", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotBivariate", "funcname": "test_log_scale", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_log_scale(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    y = rng.uniform(0, 1, 100)\n    levels = (0.2, 0.5, 1)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, y=y, log_scale=True, levels=levels, ax=ax)\n    assert (ax.get_xscale() == 'log')\n    assert (ax.get_yscale() == 'log')\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(x=x, y=y, log_scale=(10, False), levels=levels, ax=ax1)\n    assert (ax1.get_xscale() == 'log')\n    assert (ax1.get_yscale() == 'linear')\n    p = _DistributionPlotter()\n    kde = KDE()\n    (density, (xx, yy)) = kde(np.log10(x), y)\n    levels = p._quantile_to_level(density, levels)\n    ax2.contour((10 ** xx), yy, density, levels=levels)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)", "masked_code": "def test_log_scale(self, rng):\n    x = rng.lognormal(0, 1, 100)\n    y = rng.uniform(0, 1, 100)\n    levels = (0.2, 0.5, 1)\n    (f, ax) = plt.subplots()\n    kdeplot(x=x, y=y, log_scale=True, levels=levels, ax=ax)\n    assert (ax.get_xscale() == 'log')\n    assert (ax.get_yscale() == 'log')\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    kdeplot(x=x, y=y, log_scale=(10, False), levels=levels, ax=ax1)\n    assert (ax1.get_xscale() == 'log')\n    assert (ax1.get_yscale() == 'linear')\n    p = _DistributionPlotter()\n    kde = KDE()\n    (density, (xx, yy)) = kde(np.log10(x), y)\n    levels = p._quantile_to_level(density, levels)\n    ax2.contour((10 ** xx), yy, density, levels=levels)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == '???')\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)", "ground_truth": "len(get_contour_coords(c2))", "quality_analysis": {"complexity_score": 14, "left_complexity": 7, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_559", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotBivariate", "funcname": "test_levels_and_thresh", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_levels_and_thresh(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    n = 8\n    thresh = 0.1\n    plot_kws = dict(data=long_df, x='x', y='y')\n    kdeplot(**plot_kws, levels=n, thresh=thresh, ax=ax1)\n    kdeplot(**plot_kws, levels=np.linspace(thresh, 1, n), ax=ax2)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)\n    with pytest.raises(ValueError):\n        kdeplot(**plot_kws, levels=[0, 1, 2])\n    ax1.clear()\n    ax2.clear()\n    kdeplot(**plot_kws, levels=n, thresh=None, ax=ax1)\n    kdeplot(**plot_kws, levels=n, thresh=0, ax=ax2)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert_array_equal(c1.get_facecolors(), c2.get_facecolors())", "masked_code": "def test_levels_and_thresh(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    n = 8\n    thresh = 0.1\n    plot_kws = dict(data=long_df, x='x', y='y')\n    kdeplot(**plot_kws, levels=n, thresh=thresh, ax=ax1)\n    kdeplot(**plot_kws, levels=np.linspace(thresh, 1, n), ax=ax2)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == '???')\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)\n    with pytest.raises(ValueError):\n        kdeplot(**plot_kws, levels=[0, 1, 2])\n    ax1.clear()\n    ax2.clear()\n    kdeplot(**plot_kws, levels=n, thresh=None, ax=ax1)\n    kdeplot(**plot_kws, levels=n, thresh=0, ax=ax2)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert_array_equal(c1.get_facecolors(), c2.get_facecolors())", "ground_truth": "len(get_contour_coords(c2))", "quality_analysis": {"complexity_score": 14, "left_complexity": 7, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_560", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotBivariate", "funcname": "test_levels_and_thresh", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_levels_and_thresh(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    n = 8\n    thresh = 0.1\n    plot_kws = dict(data=long_df, x='x', y='y')\n    kdeplot(**plot_kws, levels=n, thresh=thresh, ax=ax1)\n    kdeplot(**plot_kws, levels=np.linspace(thresh, 1, n), ax=ax2)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)\n    with pytest.raises(ValueError):\n        kdeplot(**plot_kws, levels=[0, 1, 2])\n    ax1.clear()\n    ax2.clear()\n    kdeplot(**plot_kws, levels=n, thresh=None, ax=ax1)\n    kdeplot(**plot_kws, levels=n, thresh=0, ax=ax2)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert_array_equal(c1.get_facecolors(), c2.get_facecolors())", "masked_code": "def test_levels_and_thresh(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(ncols=2)\n    n = 8\n    thresh = 0.1\n    plot_kws = dict(data=long_df, x='x', y='y')\n    kdeplot(**plot_kws, levels=n, thresh=thresh, ax=ax1)\n    kdeplot(**plot_kws, levels=np.linspace(thresh, 1, n), ax=ax2)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == len(get_contour_coords(c2)))\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)\n    with pytest.raises(ValueError):\n        kdeplot(**plot_kws, levels=[0, 1, 2])\n    ax1.clear()\n    ax2.clear()\n    kdeplot(**plot_kws, levels=n, thresh=None, ax=ax1)\n    kdeplot(**plot_kws, levels=n, thresh=0, ax=ax2)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert (len(get_contour_coords(c1)) == '???')\n        for (arr1, arr2) in zip(get_contour_coords(c1), get_contour_coords(c2)):\n            assert_array_equal(arr1, arr2)\n    for (c1, c2) in zip(ax1.collections, ax2.collections):\n        assert_array_equal(c1.get_facecolors(), c2.get_facecolors())", "ground_truth": "len(get_contour_coords(c2))", "quality_analysis": {"complexity_score": 14, "left_complexity": 7, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_561", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestKDEPlotBivariate", "funcname": "test_quantile_to_level", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_quantile_to_level(self, rng):\n    x = rng.uniform(0, 1, 100000)\n    isoprop = np.linspace(0.1, 1, 6)\n    levels = _DistributionPlotter()._quantile_to_level(x, isoprop)\n    for (h, p) in zip(levels, isoprop):\n        assert ((x[(x <= h)].sum() / x.sum()) == pytest.approx(p, abs=0.0001))", "masked_code": "def test_quantile_to_level(self, rng):\n    x = rng.uniform(0, 1, 100000)\n    isoprop = np.linspace(0.1, 1, 6)\n    levels = _DistributionPlotter()._quantile_to_level(x, isoprop)\n    for (h, p) in zip(levels, isoprop):\n        assert ((x[(x <= h)].sum() / x.sum()) == '???')", "ground_truth": "pytest.approx(p, abs=0.0001)", "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_562", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_wide_vs_long_data", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_wide_vs_long_data(self, wide_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(data=wide_df, ax=ax1, common_bins=False)\n    for col in wide_df.columns[::(- 1)]:\n        histplot(data=wide_df, x=col, ax=ax2)\n    for (a, b) in zip(ax1.patches, ax2.patches):\n        assert (a.get_height() == b.get_height())\n        assert (a.get_xy() == b.get_xy())", "masked_code": "def test_wide_vs_long_data(self, wide_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(data=wide_df, ax=ax1, common_bins=False)\n    for col in wide_df.columns[::(- 1)]:\n        histplot(data=wide_df, x=col, ax=ax2)\n    for (a, b) in zip(ax1.patches, ax2.patches):\n        assert (a.get_height() == '???')\n        assert (a.get_xy() == b.get_xy())", "ground_truth": "b.get_height()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_563", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_wide_vs_long_data", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_wide_vs_long_data(self, wide_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(data=wide_df, ax=ax1, common_bins=False)\n    for col in wide_df.columns[::(- 1)]:\n        histplot(data=wide_df, x=col, ax=ax2)\n    for (a, b) in zip(ax1.patches, ax2.patches):\n        assert (a.get_height() == b.get_height())\n        assert (a.get_xy() == b.get_xy())", "masked_code": "def test_wide_vs_long_data(self, wide_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(data=wide_df, ax=ax1, common_bins=False)\n    for col in wide_df.columns[::(- 1)]:\n        histplot(data=wide_df, x=col, ax=ax2)\n    for (a, b) in zip(ax1.patches, ax2.patches):\n        assert (a.get_height() == b.get_height())\n        assert (a.get_xy() == '???')", "ground_truth": "b.get_xy()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_564", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_flat_vector", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_flat_vector(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(data=long_df['x'], ax=ax1)\n    histplot(data=long_df, x='x', ax=ax2)\n    for (a, b) in zip(ax1.patches, ax2.patches):\n        assert (a.get_height() == b.get_height())\n        assert (a.get_xy() == b.get_xy())", "masked_code": "def test_flat_vector(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(data=long_df['x'], ax=ax1)\n    histplot(data=long_df, x='x', ax=ax2)\n    for (a, b) in zip(ax1.patches, ax2.patches):\n        assert (a.get_height() == '???')\n        assert (a.get_xy() == b.get_xy())", "ground_truth": "b.get_height()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_565", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_flat_vector", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_flat_vector(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(data=long_df['x'], ax=ax1)\n    histplot(data=long_df, x='x', ax=ax2)\n    for (a, b) in zip(ax1.patches, ax2.patches):\n        assert (a.get_height() == b.get_height())\n        assert (a.get_xy() == b.get_xy())", "masked_code": "def test_flat_vector(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(data=long_df['x'], ax=ax1)\n    histplot(data=long_df, x='x', ax=ax2)\n    for (a, b) in zip(ax1.patches, ax2.patches):\n        assert (a.get_height() == b.get_height())\n        assert (a.get_xy() == '???')", "ground_truth": "b.get_xy()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_566", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_variable_assignment", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_variable_assignment(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(data=long_df, x='x', ax=ax1)\n    histplot(data=long_df, y='x', ax=ax2)\n    for (a, b) in zip(ax1.patches, ax2.patches):\n        assert (a.get_height() == b.get_width())", "masked_code": "def test_variable_assignment(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(data=long_df, x='x', ax=ax1)\n    histplot(data=long_df, y='x', ax=ax2)\n    for (a, b) in zip(ax1.patches, ax2.patches):\n        assert (a.get_height() == '???')", "ground_truth": "b.get_width()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_567", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_count_stat", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_count_stat(self, flat_series):\n    ax = histplot(flat_series, stat='count')\n    bar_heights = [b.get_height() for b in ax.patches]\n    assert (sum(bar_heights) == len(flat_series))", "masked_code": "def test_count_stat(self, flat_series):\n    ax = histplot(flat_series, stat='count')\n    bar_heights = [b.get_height() for b in ax.patches]\n    assert (sum(bar_heights) == '???')", "ground_truth": "len(flat_series)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_568", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_density_stat", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_density_stat(self, flat_series):\n    ax = histplot(flat_series, stat='density')\n    bar_heights = [b.get_height() for b in ax.patches]\n    bar_widths = [b.get_width() for b in ax.patches]\n    assert (np.multiply(bar_heights, bar_widths).sum() == pytest.approx(1))", "masked_code": "def test_density_stat(self, flat_series):\n    ax = histplot(flat_series, stat='density')\n    bar_heights = [b.get_height() for b in ax.patches]\n    bar_widths = [b.get_width() for b in ax.patches]\n    assert (np.multiply(bar_heights, bar_widths).sum() == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_569", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_density_stat_common_norm", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_density_stat_common_norm(self, long_df):\n    ax = histplot(data=long_df, x='x', hue='a', stat='density', common_norm=True, element='bars')\n    bar_heights = [b.get_height() for b in ax.patches]\n    bar_widths = [b.get_width() for b in ax.patches]\n    assert (np.multiply(bar_heights, bar_widths).sum() == pytest.approx(1))", "masked_code": "def test_density_stat_common_norm(self, long_df):\n    ax = histplot(data=long_df, x='x', hue='a', stat='density', common_norm=True, element='bars')\n    bar_heights = [b.get_height() for b in ax.patches]\n    bar_widths = [b.get_width() for b in ax.patches]\n    assert (np.multiply(bar_heights, bar_widths).sum() == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_570", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_density_stat_unique_norm", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_density_stat_unique_norm(self, long_df):\n    n = 10\n    ax = histplot(data=long_df, x='x', hue='a', stat='density', bins=n, common_norm=False, element='bars')\n    bar_groups = (ax.patches[:n], ax.patches[(- n):])\n    for bars in bar_groups:\n        bar_heights = [b.get_height() for b in bars]\n        bar_widths = [b.get_width() for b in bars]\n        bar_areas = np.multiply(bar_heights, bar_widths)\n        assert (bar_areas.sum() == pytest.approx(1))", "masked_code": "def test_density_stat_unique_norm(self, long_df):\n    n = 10\n    ax = histplot(data=long_df, x='x', hue='a', stat='density', bins=n, common_norm=False, element='bars')\n    bar_groups = (ax.patches[:n], ax.patches[(- n):])\n    for bars in bar_groups:\n        bar_heights = [b.get_height() for b in bars]\n        bar_widths = [b.get_width() for b in bars]\n        bar_areas = np.multiply(bar_heights, bar_widths)\n        assert (bar_areas.sum() == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_571", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_probability_stat", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_probability_stat(self, flat_series, height_norm_arg):\n    ax = histplot(flat_series, stat=height_norm_arg)\n    bar_heights = [b.get_height() for b in ax.patches]\n    assert (sum(bar_heights) == pytest.approx(1))", "masked_code": "def test_probability_stat(self, flat_series, height_norm_arg):\n    ax = histplot(flat_series, stat=height_norm_arg)\n    bar_heights = [b.get_height() for b in ax.patches]\n    assert (sum(bar_heights) == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_572", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_probability_stat_common_norm", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_probability_stat_common_norm(self, long_df, height_norm_arg):\n    ax = histplot(data=long_df, x='x', hue='a', stat=height_norm_arg, common_norm=True, element='bars')\n    bar_heights = [b.get_height() for b in ax.patches]\n    assert (sum(bar_heights) == pytest.approx(1))", "masked_code": "def test_probability_stat_common_norm(self, long_df, height_norm_arg):\n    ax = histplot(data=long_df, x='x', hue='a', stat=height_norm_arg, common_norm=True, element='bars')\n    bar_heights = [b.get_height() for b in ax.patches]\n    assert (sum(bar_heights) == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_573", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_probability_stat_unique_norm", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_probability_stat_unique_norm(self, long_df, height_norm_arg):\n    n = 10\n    ax = histplot(data=long_df, x='x', hue='a', stat=height_norm_arg, bins=n, common_norm=False, element='bars')\n    bar_groups = (ax.patches[:n], ax.patches[(- n):])\n    for bars in bar_groups:\n        bar_heights = [b.get_height() for b in bars]\n        assert (sum(bar_heights) == pytest.approx(1))", "masked_code": "def test_probability_stat_unique_norm(self, long_df, height_norm_arg):\n    n = 10\n    ax = histplot(data=long_df, x='x', hue='a', stat=height_norm_arg, bins=n, common_norm=False, element='bars')\n    bar_groups = (ax.patches[:n], ax.patches[(- n):])\n    for bars in bar_groups:\n        bar_heights = [b.get_height() for b in bars]\n        assert (sum(bar_heights) == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_574", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_percent_stat", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_percent_stat(self, flat_series):\n    ax = histplot(flat_series, stat='percent')\n    bar_heights = [b.get_height() for b in ax.patches]\n    assert (sum(bar_heights) == 100)", "masked_code": "def test_percent_stat(self, flat_series):\n    ax = histplot(flat_series, stat='percent')\n    bar_heights = [b.get_height() for b in ax.patches]\n    assert (sum(bar_heights) == '???')", "ground_truth": "100", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_575", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_weights_with_missing", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_weights_with_missing(self, null_df):\n    ax = histplot(null_df, x='x', weights='s', bins=5)\n    bar_heights = [bar.get_height() for bar in ax.patches]\n    total_weight = null_df[['x', 's']].dropna()['s'].sum()\n    assert (sum(bar_heights) == pytest.approx(total_weight))", "masked_code": "def test_weights_with_missing(self, null_df):\n    ax = histplot(null_df, x='x', weights='s', bins=5)\n    bar_heights = [bar.get_height() for bar in ax.patches]\n    total_weight = null_df[['x', 's']].dropna()['s'].sum()\n    assert (sum(bar_heights) == '???')", "ground_truth": "pytest.approx(total_weight)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_576", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_weight_norm", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_weight_norm(self, rng):\n    vals = rng.normal(0, 1, 50)\n    x = np.concatenate([vals, vals])\n    w = np.repeat([1, 2], 50)\n    ax = histplot(x=x, weights=w, hue=w, common_norm=True, stat='density', bins=5)\n    y1 = [bar.get_height() for bar in ax.patches[:5]]\n    y2 = [bar.get_height() for bar in ax.patches[5:]]\n    assert (sum(y1) == (2 * sum(y2)))", "masked_code": "def test_weight_norm(self, rng):\n    vals = rng.normal(0, 1, 50)\n    x = np.concatenate([vals, vals])\n    w = np.repeat([1, 2], 50)\n    ax = histplot(x=x, weights=w, hue=w, common_norm=True, stat='density', bins=5)\n    y1 = [bar.get_height() for bar in ax.patches[:5]]\n    y2 = [bar.get_height() for bar in ax.patches[5:]]\n    assert (sum(y1) == '???')", "ground_truth": "(2 * sum(y2))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_577", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_discrete", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_discrete(self, long_df):\n    ax = histplot(long_df, x='s', discrete=True)\n    data_min = long_df['s'].min()\n    data_max = long_df['s'].max()\n    assert (len(ax.patches) == ((data_max - data_min) + 1))\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_width() == 1)\n        assert (bar.get_x() == ((data_min + i) - 0.5))", "masked_code": "def test_discrete(self, long_df):\n    ax = histplot(long_df, x='s', discrete=True)\n    data_min = long_df['s'].min()\n    data_max = long_df['s'].max()\n    assert (len(ax.patches) == '???')\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_width() == 1)\n        assert (bar.get_x() == ((data_min + i) - 0.5))", "ground_truth": "((data_max - data_min) + 1)", "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_578", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_discrete", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_discrete(self, long_df):\n    ax = histplot(long_df, x='s', discrete=True)\n    data_min = long_df['s'].min()\n    data_max = long_df['s'].max()\n    assert (len(ax.patches) == ((data_max - data_min) + 1))\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_width() == 1)\n        assert (bar.get_x() == ((data_min + i) - 0.5))", "masked_code": "def test_discrete(self, long_df):\n    ax = histplot(long_df, x='s', discrete=True)\n    data_min = long_df['s'].min()\n    data_max = long_df['s'].max()\n    assert (len(ax.patches) == ((data_max - data_min) + 1))\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_width() == 1)\n        assert (bar.get_x() == '???')", "ground_truth": "((data_min + i) - 0.5)", "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_579", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_datetime_scale", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_datetime_scale(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(x=long_df['t'], fill=True, ax=ax1)\n    histplot(x=long_df['t'], fill=False, ax=ax2)\n    assert (ax1.get_xlim() == ax2.get_xlim())", "masked_code": "def test_datetime_scale(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(x=long_df['t'], fill=True, ax=ax1)\n    histplot(x=long_df['t'], fill=False, ax=ax2)\n    assert (ax1.get_xlim() == '???')", "ground_truth": "ax2.get_xlim()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_580", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_kde_default_cut", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_kde_default_cut(self, flat_series):\n    ax = histplot(flat_series, kde=True)\n    support = ax.lines[0].get_xdata()\n    assert (support.min() == flat_series.min())\n    assert (support.max() == flat_series.max())", "masked_code": "def test_kde_default_cut(self, flat_series):\n    ax = histplot(flat_series, kde=True)\n    support = ax.lines[0].get_xdata()\n    assert (support.min() == '???')\n    assert (support.max() == flat_series.max())", "ground_truth": "flat_series.min()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_581", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_kde_default_cut", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_kde_default_cut(self, flat_series):\n    ax = histplot(flat_series, kde=True)\n    support = ax.lines[0].get_xdata()\n    assert (support.min() == flat_series.min())\n    assert (support.max() == flat_series.max())", "masked_code": "def test_kde_default_cut(self, flat_series):\n    ax = histplot(flat_series, kde=True)\n    support = ax.lines[0].get_xdata()\n    assert (support.min() == flat_series.min())\n    assert (support.max() == '???')", "ground_truth": "flat_series.max()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_582", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_kde_line_kws", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_kde_line_kws(self, flat_series):\n    lw = 5\n    ax = histplot(flat_series, kde=True, line_kws=dict(lw=lw))\n    assert (ax.lines[0].get_linewidth() == lw)", "masked_code": "def test_kde_line_kws(self, flat_series):\n    lw = 5\n    ax = histplot(flat_series, kde=True, line_kws=dict(lw=lw))\n    assert (ax.lines[0].get_linewidth() == '???')", "ground_truth": "lw", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_583", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_element_default", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_element_default(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(long_df, x='x', ax=ax1)\n    histplot(long_df, x='x', ax=ax2, element='bars')\n    assert (len(ax1.patches) == len(ax2.patches))\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(long_df, x='x', hue='a', ax=ax1)\n    histplot(long_df, x='x', hue='a', ax=ax2, element='bars')\n    assert (len(ax1.patches) == len(ax2.patches))", "masked_code": "def test_element_default(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(long_df, x='x', ax=ax1)\n    histplot(long_df, x='x', ax=ax2, element='bars')\n    assert (len(ax1.patches) == '???')\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(long_df, x='x', hue='a', ax=ax1)\n    histplot(long_df, x='x', hue='a', ax=ax2, element='bars')\n    assert (len(ax1.patches) == len(ax2.patches))", "ground_truth": "len(ax2.patches)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_584", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_element_default", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_element_default(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(long_df, x='x', ax=ax1)\n    histplot(long_df, x='x', ax=ax2, element='bars')\n    assert (len(ax1.patches) == len(ax2.patches))\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(long_df, x='x', hue='a', ax=ax1)\n    histplot(long_df, x='x', hue='a', ax=ax2, element='bars')\n    assert (len(ax1.patches) == len(ax2.patches))", "masked_code": "def test_element_default(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(long_df, x='x', ax=ax1)\n    histplot(long_df, x='x', ax=ax2, element='bars')\n    assert (len(ax1.patches) == len(ax2.patches))\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(long_df, x='x', hue='a', ax=ax1)\n    histplot(long_df, x='x', hue='a', ax=ax2, element='bars')\n    assert (len(ax1.patches) == '???')", "ground_truth": "len(ax2.patches)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_585", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_bars_no_fill", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_bars_no_fill(self, flat_series):\n    alpha = 0.5\n    ax = histplot(flat_series, element='bars', fill=False, alpha=alpha)\n    for bar in ax.patches:\n        assert (bar.get_facecolor() == (0, 0, 0, 0))\n        assert (bar.get_edgecolor()[(- 1)] == alpha)", "masked_code": "def test_bars_no_fill(self, flat_series):\n    alpha = 0.5\n    ax = histplot(flat_series, element='bars', fill=False, alpha=alpha)\n    for bar in ax.patches:\n        assert (bar.get_facecolor() == '???')\n        assert (bar.get_edgecolor()[(- 1)] == alpha)", "ground_truth": "(0, 0, 0, 0)", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_586", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_bars_no_fill", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_bars_no_fill(self, flat_series):\n    alpha = 0.5\n    ax = histplot(flat_series, element='bars', fill=False, alpha=alpha)\n    for bar in ax.patches:\n        assert (bar.get_facecolor() == (0, 0, 0, 0))\n        assert (bar.get_edgecolor()[(- 1)] == alpha)", "masked_code": "def test_bars_no_fill(self, flat_series):\n    alpha = 0.5\n    ax = histplot(flat_series, element='bars', fill=False, alpha=alpha)\n    for bar in ax.patches:\n        assert (bar.get_facecolor() == (0, 0, 0, 0))\n        assert (bar.get_edgecolor()[(- 1)] == '???')", "ground_truth": "alpha", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_587", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_step_fill", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_step_fill(self, flat_series):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    n = 10\n    histplot(flat_series, element='bars', fill=True, bins=n, ax=ax1)\n    histplot(flat_series, element='step', fill=True, bins=n, ax=ax2)\n    bar_heights = [b.get_height() for b in ax1.patches]\n    bar_widths = [b.get_width() for b in ax1.patches]\n    bar_edges = [b.get_x() for b in ax1.patches]\n    fill = ax2.collections[0]\n    (x, y) = fill.get_paths()[0].vertices[::(- 1)].T\n    assert_array_equal(x[1:(2 * n):2], bar_edges)\n    assert_array_equal(y[1:(2 * n):2], bar_heights)\n    assert (x[(n * 2)] == (bar_edges[(- 1)] + bar_widths[(- 1)]))\n    assert (y[(n * 2)] == bar_heights[(- 1)])", "masked_code": "def test_step_fill(self, flat_series):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    n = 10\n    histplot(flat_series, element='bars', fill=True, bins=n, ax=ax1)\n    histplot(flat_series, element='step', fill=True, bins=n, ax=ax2)\n    bar_heights = [b.get_height() for b in ax1.patches]\n    bar_widths = [b.get_width() for b in ax1.patches]\n    bar_edges = [b.get_x() for b in ax1.patches]\n    fill = ax2.collections[0]\n    (x, y) = fill.get_paths()[0].vertices[::(- 1)].T\n    assert_array_equal(x[1:(2 * n):2], bar_edges)\n    assert_array_equal(y[1:(2 * n):2], bar_heights)\n    assert (x[(n * 2)] == '???')\n    assert (y[(n * 2)] == bar_heights[(- 1)])", "ground_truth": "(bar_edges[(- 1)] + bar_widths[(- 1)])", "quality_analysis": {"complexity_score": 24, "left_complexity": 8, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_588", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_step_fill", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_step_fill(self, flat_series):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    n = 10\n    histplot(flat_series, element='bars', fill=True, bins=n, ax=ax1)\n    histplot(flat_series, element='step', fill=True, bins=n, ax=ax2)\n    bar_heights = [b.get_height() for b in ax1.patches]\n    bar_widths = [b.get_width() for b in ax1.patches]\n    bar_edges = [b.get_x() for b in ax1.patches]\n    fill = ax2.collections[0]\n    (x, y) = fill.get_paths()[0].vertices[::(- 1)].T\n    assert_array_equal(x[1:(2 * n):2], bar_edges)\n    assert_array_equal(y[1:(2 * n):2], bar_heights)\n    assert (x[(n * 2)] == (bar_edges[(- 1)] + bar_widths[(- 1)]))\n    assert (y[(n * 2)] == bar_heights[(- 1)])", "masked_code": "def test_step_fill(self, flat_series):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    n = 10\n    histplot(flat_series, element='bars', fill=True, bins=n, ax=ax1)\n    histplot(flat_series, element='step', fill=True, bins=n, ax=ax2)\n    bar_heights = [b.get_height() for b in ax1.patches]\n    bar_widths = [b.get_width() for b in ax1.patches]\n    bar_edges = [b.get_x() for b in ax1.patches]\n    fill = ax2.collections[0]\n    (x, y) = fill.get_paths()[0].vertices[::(- 1)].T\n    assert_array_equal(x[1:(2 * n):2], bar_edges)\n    assert_array_equal(y[1:(2 * n):2], bar_heights)\n    assert (x[(n * 2)] == (bar_edges[(- 1)] + bar_widths[(- 1)]))\n    assert (y[(n * 2)] == '???')", "ground_truth": "bar_heights[(- 1)]", "quality_analysis": {"complexity_score": 15, "left_complexity": 8, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_589", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_step_no_fill", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_step_no_fill(self, flat_series):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(flat_series, element='bars', fill=False, ax=ax1)\n    histplot(flat_series, element='step', fill=False, ax=ax2)\n    bar_heights = [b.get_height() for b in ax1.patches]\n    bar_widths = [b.get_width() for b in ax1.patches]\n    bar_edges = [b.get_x() for b in ax1.patches]\n    (x, y) = ax2.lines[0].get_xydata().T\n    assert_array_equal(x[:(- 1)], bar_edges)\n    assert_array_equal(y[:(- 1)], bar_heights)\n    assert (x[(- 1)] == (bar_edges[(- 1)] + bar_widths[(- 1)]))\n    assert (y[(- 1)] == y[(- 2)])", "masked_code": "def test_step_no_fill(self, flat_series):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(flat_series, element='bars', fill=False, ax=ax1)\n    histplot(flat_series, element='step', fill=False, ax=ax2)\n    bar_heights = [b.get_height() for b in ax1.patches]\n    bar_widths = [b.get_width() for b in ax1.patches]\n    bar_edges = [b.get_x() for b in ax1.patches]\n    (x, y) = ax2.lines[0].get_xydata().T\n    assert_array_equal(x[:(- 1)], bar_edges)\n    assert_array_equal(y[:(- 1)], bar_heights)\n    assert (x[(- 1)] == '???')\n    assert (y[(- 1)] == y[(- 2)])", "ground_truth": "(bar_edges[(- 1)] + bar_widths[(- 1)])", "quality_analysis": {"complexity_score": 23, "left_complexity": 7, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_590", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_step_no_fill", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_step_no_fill(self, flat_series):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(flat_series, element='bars', fill=False, ax=ax1)\n    histplot(flat_series, element='step', fill=False, ax=ax2)\n    bar_heights = [b.get_height() for b in ax1.patches]\n    bar_widths = [b.get_width() for b in ax1.patches]\n    bar_edges = [b.get_x() for b in ax1.patches]\n    (x, y) = ax2.lines[0].get_xydata().T\n    assert_array_equal(x[:(- 1)], bar_edges)\n    assert_array_equal(y[:(- 1)], bar_heights)\n    assert (x[(- 1)] == (bar_edges[(- 1)] + bar_widths[(- 1)]))\n    assert (y[(- 1)] == y[(- 2)])", "masked_code": "def test_step_no_fill(self, flat_series):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(flat_series, element='bars', fill=False, ax=ax1)\n    histplot(flat_series, element='step', fill=False, ax=ax2)\n    bar_heights = [b.get_height() for b in ax1.patches]\n    bar_widths = [b.get_width() for b in ax1.patches]\n    bar_edges = [b.get_x() for b in ax1.patches]\n    (x, y) = ax2.lines[0].get_xydata().T\n    assert_array_equal(x[:(- 1)], bar_edges)\n    assert_array_equal(y[:(- 1)], bar_heights)\n    assert (x[(- 1)] == (bar_edges[(- 1)] + bar_widths[(- 1)]))\n    assert (y[(- 1)] == '???')", "ground_truth": "y[(- 2)]", "quality_analysis": {"complexity_score": 14, "left_complexity": 7, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_591", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_weights_with_auto_bins", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_weights_with_auto_bins(self, long_df):\n    with pytest.warns(UserWarning):\n        ax = histplot(long_df, x='x', weights='f')\n    assert (len(ax.patches) == 10)", "masked_code": "def test_weights_with_auto_bins(self, long_df):\n    with pytest.warns(UserWarning):\n        ax = histplot(long_df, x='x', weights='f')\n    assert (len(ax.patches) == '???')", "ground_truth": "10", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_592", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_shrink", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_shrink(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    bw = 2\n    shrink = 0.4\n    histplot(long_df, x='x', binwidth=bw, ax=ax1)\n    histplot(long_df, x='x', binwidth=bw, shrink=shrink, ax=ax2)\n    for (p1, p2) in zip(ax1.patches, ax2.patches):\n        (w1, w2) = (p1.get_width(), p2.get_width())\n        assert (w2 == pytest.approx((shrink * w1)))\n        (x1, x2) = (p1.get_x(), p2.get_x())\n        assert ((x2 + (w2 / 2)) == pytest.approx((x1 + (w1 / 2))))", "masked_code": "def test_shrink(self, long_df):\n    (f, (ax1, ax2)) = plt.subplots(2)\n    bw = 2\n    shrink = 0.4\n    histplot(long_df, x='x', binwidth=bw, ax=ax1)\n    histplot(long_df, x='x', binwidth=bw, shrink=shrink, ax=ax2)\n    for (p1, p2) in zip(ax1.patches, ax2.patches):\n        (w1, w2) = (p1.get_width(), p2.get_width())\n        assert (w2 == pytest.approx((shrink * w1)))\n        (x1, x2) = (p1.get_x(), p2.get_x())\n        assert ((x2 + (w2 / 2)) == '???')", "ground_truth": "pytest.approx((x1 + (w1 / 2)))", "quality_analysis": {"complexity_score": 17, "left_complexity": 7, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_593", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_auto_linewidth", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "@pytest.mark.parametrize('fill', [True, False])\ndef test_auto_linewidth(self, flat_series, fill):\n    get_lw = (lambda ax: ax.patches[0].get_linewidth())\n    kws = dict(element='bars', fill=fill)\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(flat_series, **kws, bins=10, ax=ax1)\n    histplot(flat_series, **kws, bins=100, ax=ax2)\n    assert (get_lw(ax1) > get_lw(ax2))\n    (f, ax1) = plt.subplots(figsize=(10, 5))\n    (f, ax2) = plt.subplots(figsize=(2, 5))\n    histplot(flat_series, **kws, bins=30, ax=ax1)\n    histplot(flat_series, **kws, bins=30, ax=ax2)\n    assert (get_lw(ax1) > get_lw(ax2))\n    (f, ax1) = plt.subplots(figsize=(4, 5))\n    (f, ax2) = plt.subplots(figsize=(4, 5))\n    histplot(flat_series, **kws, bins=30, ax=ax1)\n    histplot((10 ** flat_series), **kws, bins=30, log_scale=True, ax=ax2)\n    assert (get_lw(ax1) == pytest.approx(get_lw(ax2)))\n    (f, ax1) = plt.subplots(figsize=(4, 5))\n    (f, ax2) = plt.subplots(figsize=(4, 5))\n    histplot(y=[0, 1, 1], **kws, discrete=True, ax=ax1)\n    histplot(y=['a', 'b', 'b'], **kws, ax=ax2)\n    assert (get_lw(ax1) == pytest.approx(get_lw(ax2)))", "masked_code": "@pytest.mark.parametrize('fill', [True, False])\ndef test_auto_linewidth(self, flat_series, fill):\n    get_lw = (lambda ax: ax.patches[0].get_linewidth())\n    kws = dict(element='bars', fill=fill)\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(flat_series, **kws, bins=10, ax=ax1)\n    histplot(flat_series, **kws, bins=100, ax=ax2)\n    assert (get_lw(ax1) > get_lw(ax2))\n    (f, ax1) = plt.subplots(figsize=(10, 5))\n    (f, ax2) = plt.subplots(figsize=(2, 5))\n    histplot(flat_series, **kws, bins=30, ax=ax1)\n    histplot(flat_series, **kws, bins=30, ax=ax2)\n    assert (get_lw(ax1) > get_lw(ax2))\n    (f, ax1) = plt.subplots(figsize=(4, 5))\n    (f, ax2) = plt.subplots(figsize=(4, 5))\n    histplot(flat_series, **kws, bins=30, ax=ax1)\n    histplot((10 ** flat_series), **kws, bins=30, log_scale=True, ax=ax2)\n    assert (get_lw(ax1) == '???')\n    (f, ax1) = plt.subplots(figsize=(4, 5))\n    (f, ax2) = plt.subplots(figsize=(4, 5))\n    histplot(y=[0, 1, 1], **kws, discrete=True, ax=ax1)\n    histplot(y=['a', 'b', 'b'], **kws, ax=ax2)\n    assert (get_lw(ax1) == pytest.approx(get_lw(ax2)))", "ground_truth": "pytest.approx(get_lw(ax2))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_594", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_auto_linewidth", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "@pytest.mark.parametrize('fill', [True, False])\ndef test_auto_linewidth(self, flat_series, fill):\n    get_lw = (lambda ax: ax.patches[0].get_linewidth())\n    kws = dict(element='bars', fill=fill)\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(flat_series, **kws, bins=10, ax=ax1)\n    histplot(flat_series, **kws, bins=100, ax=ax2)\n    assert (get_lw(ax1) > get_lw(ax2))\n    (f, ax1) = plt.subplots(figsize=(10, 5))\n    (f, ax2) = plt.subplots(figsize=(2, 5))\n    histplot(flat_series, **kws, bins=30, ax=ax1)\n    histplot(flat_series, **kws, bins=30, ax=ax2)\n    assert (get_lw(ax1) > get_lw(ax2))\n    (f, ax1) = plt.subplots(figsize=(4, 5))\n    (f, ax2) = plt.subplots(figsize=(4, 5))\n    histplot(flat_series, **kws, bins=30, ax=ax1)\n    histplot((10 ** flat_series), **kws, bins=30, log_scale=True, ax=ax2)\n    assert (get_lw(ax1) == pytest.approx(get_lw(ax2)))\n    (f, ax1) = plt.subplots(figsize=(4, 5))\n    (f, ax2) = plt.subplots(figsize=(4, 5))\n    histplot(y=[0, 1, 1], **kws, discrete=True, ax=ax1)\n    histplot(y=['a', 'b', 'b'], **kws, ax=ax2)\n    assert (get_lw(ax1) == pytest.approx(get_lw(ax2)))", "masked_code": "@pytest.mark.parametrize('fill', [True, False])\ndef test_auto_linewidth(self, flat_series, fill):\n    get_lw = (lambda ax: ax.patches[0].get_linewidth())\n    kws = dict(element='bars', fill=fill)\n    (f, (ax1, ax2)) = plt.subplots(2)\n    histplot(flat_series, **kws, bins=10, ax=ax1)\n    histplot(flat_series, **kws, bins=100, ax=ax2)\n    assert (get_lw(ax1) > get_lw(ax2))\n    (f, ax1) = plt.subplots(figsize=(10, 5))\n    (f, ax2) = plt.subplots(figsize=(2, 5))\n    histplot(flat_series, **kws, bins=30, ax=ax1)\n    histplot(flat_series, **kws, bins=30, ax=ax2)\n    assert (get_lw(ax1) > get_lw(ax2))\n    (f, ax1) = plt.subplots(figsize=(4, 5))\n    (f, ax2) = plt.subplots(figsize=(4, 5))\n    histplot(flat_series, **kws, bins=30, ax=ax1)\n    histplot((10 ** flat_series), **kws, bins=30, log_scale=True, ax=ax2)\n    assert (get_lw(ax1) == pytest.approx(get_lw(ax2)))\n    (f, ax1) = plt.subplots(figsize=(4, 5))\n    (f, ax2) = plt.subplots(figsize=(4, 5))\n    histplot(y=[0, 1, 1], **kws, discrete=True, ax=ax1)\n    histplot(y=['a', 'b', 'b'], **kws, ax=ax2)\n    assert (get_lw(ax1) == '???')", "ground_truth": "pytest.approx(get_lw(ax2))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_595", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_bar_kwargs", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_bar_kwargs(self, flat_series):\n    lw = 2\n    ec = (1, 0.2, 0.9, 0.5)\n    ax = histplot(flat_series, binwidth=1, ec=ec, lw=lw)\n    for bar in ax.patches:\n        assert_colors_equal(bar.get_edgecolor(), ec)\n        assert (bar.get_linewidth() == lw)", "masked_code": "def test_bar_kwargs(self, flat_series):\n    lw = 2\n    ec = (1, 0.2, 0.9, 0.5)\n    ax = histplot(flat_series, binwidth=1, ec=ec, lw=lw)\n    for bar in ax.patches:\n        assert_colors_equal(bar.get_edgecolor(), ec)\n        assert (bar.get_linewidth() == '???')", "ground_truth": "lw", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_596", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_step_fill_kwargs", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_step_fill_kwargs(self, flat_series):\n    lw = 2\n    ec = (1, 0.2, 0.9, 0.5)\n    ax = histplot(flat_series, element='step', ec=ec, lw=lw)\n    poly = ax.collections[0]\n    assert_colors_equal(poly.get_edgecolor(), ec)\n    assert (poly.get_linewidth() == lw)", "masked_code": "def test_step_fill_kwargs(self, flat_series):\n    lw = 2\n    ec = (1, 0.2, 0.9, 0.5)\n    ax = histplot(flat_series, element='step', ec=ec, lw=lw)\n    poly = ax.collections[0]\n    assert_colors_equal(poly.get_edgecolor(), ec)\n    assert (poly.get_linewidth() == '???')", "ground_truth": "lw", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_597", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_step_line_kwargs", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_step_line_kwargs(self, flat_series):\n    lw = 2\n    ls = '--'\n    ax = histplot(flat_series, element='step', fill=False, lw=lw, ls=ls)\n    line = ax.lines[0]\n    assert (line.get_linewidth() == lw)\n    assert (line.get_linestyle() == ls)", "masked_code": "def test_step_line_kwargs(self, flat_series):\n    lw = 2\n    ls = '--'\n    ax = histplot(flat_series, element='step', fill=False, lw=lw, ls=ls)\n    line = ax.lines[0]\n    assert (line.get_linewidth() == '???')\n    assert (line.get_linestyle() == ls)", "ground_truth": "lw", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_598", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotUnivariate", "funcname": "test_step_line_kwargs", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_step_line_kwargs(self, flat_series):\n    lw = 2\n    ls = '--'\n    ax = histplot(flat_series, element='step', fill=False, lw=lw, ls=ls)\n    line = ax.lines[0]\n    assert (line.get_linewidth() == lw)\n    assert (line.get_linestyle() == ls)", "masked_code": "def test_step_line_kwargs(self, flat_series):\n    lw = 2\n    ls = '--'\n    ax = histplot(flat_series, element='step', fill=False, lw=lw, ls=ls)\n    line = ax.lines[0]\n    assert (line.get_linewidth() == lw)\n    assert (line.get_linestyle() == '???')", "ground_truth": "ls", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_599", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_mesh", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_mesh(self, long_df):\n    hist = Histogram()\n    (counts, (x_edges, y_edges)) = hist(long_df['x'], long_df['y'])\n    ax = histplot(long_df, x='x', y='y')\n    mesh = ax.collections[0]\n    mesh_data = mesh.get_array()\n    assert_array_equal(mesh_data.data.flat, counts.T.flat)\n    assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n    edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n    for (i, (y, x)) in enumerate(edges):\n        path = mesh.get_paths()[i]\n        assert (path.vertices[(0, 0)] == x)\n        assert (path.vertices[(0, 1)] == y)", "masked_code": "def test_mesh(self, long_df):\n    hist = Histogram()\n    (counts, (x_edges, y_edges)) = hist(long_df['x'], long_df['y'])\n    ax = histplot(long_df, x='x', y='y')\n    mesh = ax.collections[0]\n    mesh_data = mesh.get_array()\n    assert_array_equal(mesh_data.data.flat, counts.T.flat)\n    assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n    edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n    for (i, (y, x)) in enumerate(edges):\n        path = mesh.get_paths()[i]\n        assert (path.vertices[(0, 0)] == '???')\n        assert (path.vertices[(0, 1)] == y)", "ground_truth": "x", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_600", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_mesh", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_mesh(self, long_df):\n    hist = Histogram()\n    (counts, (x_edges, y_edges)) = hist(long_df['x'], long_df['y'])\n    ax = histplot(long_df, x='x', y='y')\n    mesh = ax.collections[0]\n    mesh_data = mesh.get_array()\n    assert_array_equal(mesh_data.data.flat, counts.T.flat)\n    assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n    edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n    for (i, (y, x)) in enumerate(edges):\n        path = mesh.get_paths()[i]\n        assert (path.vertices[(0, 0)] == x)\n        assert (path.vertices[(0, 1)] == y)", "masked_code": "def test_mesh(self, long_df):\n    hist = Histogram()\n    (counts, (x_edges, y_edges)) = hist(long_df['x'], long_df['y'])\n    ax = histplot(long_df, x='x', y='y')\n    mesh = ax.collections[0]\n    mesh_data = mesh.get_array()\n    assert_array_equal(mesh_data.data.flat, counts.T.flat)\n    assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n    edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n    for (i, (y, x)) in enumerate(edges):\n        path = mesh.get_paths()[i]\n        assert (path.vertices[(0, 0)] == x)\n        assert (path.vertices[(0, 1)] == '???')", "ground_truth": "y", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_601", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_mesh_with_hue", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_mesh_with_hue(self, long_df):\n    ax = histplot(long_df, x='x', y='y', hue='c')\n    hist = Histogram()\n    hist.define_bin_params(long_df['x'], long_df['y'])\n    for (i, sub_df) in long_df.groupby('c'):\n        mesh = ax.collections[i]\n        mesh_data = mesh.get_array()\n        (counts, (x_edges, y_edges)) = hist(sub_df['x'], sub_df['y'])\n        assert_array_equal(mesh_data.data.flat, counts.T.flat)\n        assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n        edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n        for (i, (y, x)) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert (path.vertices[(0, 0)] == x)\n            assert (path.vertices[(0, 1)] == y)", "masked_code": "def test_mesh_with_hue(self, long_df):\n    ax = histplot(long_df, x='x', y='y', hue='c')\n    hist = Histogram()\n    hist.define_bin_params(long_df['x'], long_df['y'])\n    for (i, sub_df) in long_df.groupby('c'):\n        mesh = ax.collections[i]\n        mesh_data = mesh.get_array()\n        (counts, (x_edges, y_edges)) = hist(sub_df['x'], sub_df['y'])\n        assert_array_equal(mesh_data.data.flat, counts.T.flat)\n        assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n        edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n        for (i, (y, x)) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert (path.vertices[(0, 0)] == '???')\n            assert (path.vertices[(0, 1)] == y)", "ground_truth": "x", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_602", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_mesh_with_hue", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_mesh_with_hue(self, long_df):\n    ax = histplot(long_df, x='x', y='y', hue='c')\n    hist = Histogram()\n    hist.define_bin_params(long_df['x'], long_df['y'])\n    for (i, sub_df) in long_df.groupby('c'):\n        mesh = ax.collections[i]\n        mesh_data = mesh.get_array()\n        (counts, (x_edges, y_edges)) = hist(sub_df['x'], sub_df['y'])\n        assert_array_equal(mesh_data.data.flat, counts.T.flat)\n        assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n        edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n        for (i, (y, x)) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert (path.vertices[(0, 0)] == x)\n            assert (path.vertices[(0, 1)] == y)", "masked_code": "def test_mesh_with_hue(self, long_df):\n    ax = histplot(long_df, x='x', y='y', hue='c')\n    hist = Histogram()\n    hist.define_bin_params(long_df['x'], long_df['y'])\n    for (i, sub_df) in long_df.groupby('c'):\n        mesh = ax.collections[i]\n        mesh_data = mesh.get_array()\n        (counts, (x_edges, y_edges)) = hist(sub_df['x'], sub_df['y'])\n        assert_array_equal(mesh_data.data.flat, counts.T.flat)\n        assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n        edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n        for (i, (y, x)) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert (path.vertices[(0, 0)] == x)\n            assert (path.vertices[(0, 1)] == '???')", "ground_truth": "y", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_603", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_mesh_with_hue_unique_bins", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_mesh_with_hue_unique_bins(self, long_df):\n    ax = histplot(long_df, x='x', y='y', hue='c', common_bins=False)\n    for (i, sub_df) in long_df.groupby('c'):\n        hist = Histogram()\n        mesh = ax.collections[i]\n        mesh_data = mesh.get_array()\n        (counts, (x_edges, y_edges)) = hist(sub_df['x'], sub_df['y'])\n        assert_array_equal(mesh_data.data.flat, counts.T.flat)\n        assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n        edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n        for (i, (y, x)) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert (path.vertices[(0, 0)] == x)\n            assert (path.vertices[(0, 1)] == y)", "masked_code": "def test_mesh_with_hue_unique_bins(self, long_df):\n    ax = histplot(long_df, x='x', y='y', hue='c', common_bins=False)\n    for (i, sub_df) in long_df.groupby('c'):\n        hist = Histogram()\n        mesh = ax.collections[i]\n        mesh_data = mesh.get_array()\n        (counts, (x_edges, y_edges)) = hist(sub_df['x'], sub_df['y'])\n        assert_array_equal(mesh_data.data.flat, counts.T.flat)\n        assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n        edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n        for (i, (y, x)) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert (path.vertices[(0, 0)] == '???')\n            assert (path.vertices[(0, 1)] == y)", "ground_truth": "x", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_604", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_mesh_with_hue_unique_bins", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_mesh_with_hue_unique_bins(self, long_df):\n    ax = histplot(long_df, x='x', y='y', hue='c', common_bins=False)\n    for (i, sub_df) in long_df.groupby('c'):\n        hist = Histogram()\n        mesh = ax.collections[i]\n        mesh_data = mesh.get_array()\n        (counts, (x_edges, y_edges)) = hist(sub_df['x'], sub_df['y'])\n        assert_array_equal(mesh_data.data.flat, counts.T.flat)\n        assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n        edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n        for (i, (y, x)) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert (path.vertices[(0, 0)] == x)\n            assert (path.vertices[(0, 1)] == y)", "masked_code": "def test_mesh_with_hue_unique_bins(self, long_df):\n    ax = histplot(long_df, x='x', y='y', hue='c', common_bins=False)\n    for (i, sub_df) in long_df.groupby('c'):\n        hist = Histogram()\n        mesh = ax.collections[i]\n        mesh_data = mesh.get_array()\n        (counts, (x_edges, y_edges)) = hist(sub_df['x'], sub_df['y'])\n        assert_array_equal(mesh_data.data.flat, counts.T.flat)\n        assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n        edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n        for (i, (y, x)) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert (path.vertices[(0, 0)] == x)\n            assert (path.vertices[(0, 1)] == '???')", "ground_truth": "y", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_605", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_mesh_with_col_unique_bins", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_mesh_with_col_unique_bins(self, long_df):\n    g = displot(long_df, x='x', y='y', col='c', common_bins=False)\n    for (i, sub_df) in long_df.groupby('c'):\n        hist = Histogram()\n        mesh = g.axes.flat[i].collections[0]\n        mesh_data = mesh.get_array()\n        (counts, (x_edges, y_edges)) = hist(sub_df['x'], sub_df['y'])\n        assert_array_equal(mesh_data.data.flat, counts.T.flat)\n        assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n        edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n        for (i, (y, x)) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert (path.vertices[(0, 0)] == x)\n            assert (path.vertices[(0, 1)] == y)", "masked_code": "def test_mesh_with_col_unique_bins(self, long_df):\n    g = displot(long_df, x='x', y='y', col='c', common_bins=False)\n    for (i, sub_df) in long_df.groupby('c'):\n        hist = Histogram()\n        mesh = g.axes.flat[i].collections[0]\n        mesh_data = mesh.get_array()\n        (counts, (x_edges, y_edges)) = hist(sub_df['x'], sub_df['y'])\n        assert_array_equal(mesh_data.data.flat, counts.T.flat)\n        assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n        edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n        for (i, (y, x)) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert (path.vertices[(0, 0)] == '???')\n            assert (path.vertices[(0, 1)] == y)", "ground_truth": "x", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_606", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_mesh_with_col_unique_bins", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_mesh_with_col_unique_bins(self, long_df):\n    g = displot(long_df, x='x', y='y', col='c', common_bins=False)\n    for (i, sub_df) in long_df.groupby('c'):\n        hist = Histogram()\n        mesh = g.axes.flat[i].collections[0]\n        mesh_data = mesh.get_array()\n        (counts, (x_edges, y_edges)) = hist(sub_df['x'], sub_df['y'])\n        assert_array_equal(mesh_data.data.flat, counts.T.flat)\n        assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n        edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n        for (i, (y, x)) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert (path.vertices[(0, 0)] == x)\n            assert (path.vertices[(0, 1)] == y)", "masked_code": "def test_mesh_with_col_unique_bins(self, long_df):\n    g = displot(long_df, x='x', y='y', col='c', common_bins=False)\n    for (i, sub_df) in long_df.groupby('c'):\n        hist = Histogram()\n        mesh = g.axes.flat[i].collections[0]\n        mesh_data = mesh.get_array()\n        (counts, (x_edges, y_edges)) = hist(sub_df['x'], sub_df['y'])\n        assert_array_equal(mesh_data.data.flat, counts.T.flat)\n        assert_array_equal(mesh_data.mask.flat, (counts.T.flat == 0))\n        edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n        for (i, (y, x)) in enumerate(edges):\n            path = mesh.get_paths()[i]\n            assert (path.vertices[(0, 0)] == x)\n            assert (path.vertices[(0, 1)] == '???')", "ground_truth": "y", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_607", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_mesh_log_scale", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_mesh_log_scale(self, rng):\n    (x, y) = rng.lognormal(0, 1, (2, 1000))\n    hist = Histogram()\n    (counts, (x_edges, y_edges)) = hist(np.log10(x), np.log10(y))\n    ax = histplot(x=x, y=y, log_scale=True)\n    mesh = ax.collections[0]\n    mesh_data = mesh.get_array()\n    assert_array_equal(mesh_data.data.flat, counts.T.flat)\n    edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n    for (i, (y_i, x_i)) in enumerate(edges):\n        path = mesh.get_paths()[i]\n        assert (path.vertices[(0, 0)] == pytest.approx((10 ** x_i)))\n        assert (path.vertices[(0, 1)] == pytest.approx((10 ** y_i)))", "masked_code": "def test_mesh_log_scale(self, rng):\n    (x, y) = rng.lognormal(0, 1, (2, 1000))\n    hist = Histogram()\n    (counts, (x_edges, y_edges)) = hist(np.log10(x), np.log10(y))\n    ax = histplot(x=x, y=y, log_scale=True)\n    mesh = ax.collections[0]\n    mesh_data = mesh.get_array()\n    assert_array_equal(mesh_data.data.flat, counts.T.flat)\n    edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n    for (i, (y_i, x_i)) in enumerate(edges):\n        path = mesh.get_paths()[i]\n        assert (path.vertices[(0, 0)] == '???')\n        assert (path.vertices[(0, 1)] == pytest.approx((10 ** y_i)))", "ground_truth": "pytest.approx((10 ** x_i))", "quality_analysis": {"complexity_score": 16, "left_complexity": 9, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_608", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_mesh_log_scale", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_mesh_log_scale(self, rng):\n    (x, y) = rng.lognormal(0, 1, (2, 1000))\n    hist = Histogram()\n    (counts, (x_edges, y_edges)) = hist(np.log10(x), np.log10(y))\n    ax = histplot(x=x, y=y, log_scale=True)\n    mesh = ax.collections[0]\n    mesh_data = mesh.get_array()\n    assert_array_equal(mesh_data.data.flat, counts.T.flat)\n    edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n    for (i, (y_i, x_i)) in enumerate(edges):\n        path = mesh.get_paths()[i]\n        assert (path.vertices[(0, 0)] == pytest.approx((10 ** x_i)))\n        assert (path.vertices[(0, 1)] == pytest.approx((10 ** y_i)))", "masked_code": "def test_mesh_log_scale(self, rng):\n    (x, y) = rng.lognormal(0, 1, (2, 1000))\n    hist = Histogram()\n    (counts, (x_edges, y_edges)) = hist(np.log10(x), np.log10(y))\n    ax = histplot(x=x, y=y, log_scale=True)\n    mesh = ax.collections[0]\n    mesh_data = mesh.get_array()\n    assert_array_equal(mesh_data.data.flat, counts.T.flat)\n    edges = itertools.product(y_edges[:(- 1)], x_edges[:(- 1)])\n    for (i, (y_i, x_i)) in enumerate(edges):\n        path = mesh.get_paths()[i]\n        assert (path.vertices[(0, 0)] == pytest.approx((10 ** x_i)))\n        assert (path.vertices[(0, 1)] == '???')", "ground_truth": "pytest.approx((10 ** y_i))", "quality_analysis": {"complexity_score": 16, "left_complexity": 9, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_609", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_mesh_sticky_edges", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_mesh_sticky_edges(self, long_df):\n    ax = histplot(long_df, x='x', y='y', thresh=None)\n    mesh = ax.collections[0]\n    assert (mesh.sticky_edges.x == [long_df['x'].min(), long_df['x'].max()])\n    assert (mesh.sticky_edges.y == [long_df['y'].min(), long_df['y'].max()])\n    ax.clear()\n    ax = histplot(long_df, x='x', y='y')\n    mesh = ax.collections[0]\n    assert (not mesh.sticky_edges.x)\n    assert (not mesh.sticky_edges.y)", "masked_code": "def test_mesh_sticky_edges(self, long_df):\n    ax = histplot(long_df, x='x', y='y', thresh=None)\n    mesh = ax.collections[0]\n    assert (mesh.sticky_edges.x == '???')\n    assert (mesh.sticky_edges.y == [long_df['y'].min(), long_df['y'].max()])\n    ax.clear()\n    ax = histplot(long_df, x='x', y='y')\n    mesh = ax.collections[0]\n    assert (not mesh.sticky_edges.x)\n    assert (not mesh.sticky_edges.y)", "ground_truth": "[long_df['x'].min(), long_df['x'].max()]", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_610", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_mesh_sticky_edges", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_mesh_sticky_edges(self, long_df):\n    ax = histplot(long_df, x='x', y='y', thresh=None)\n    mesh = ax.collections[0]\n    assert (mesh.sticky_edges.x == [long_df['x'].min(), long_df['x'].max()])\n    assert (mesh.sticky_edges.y == [long_df['y'].min(), long_df['y'].max()])\n    ax.clear()\n    ax = histplot(long_df, x='x', y='y')\n    mesh = ax.collections[0]\n    assert (not mesh.sticky_edges.x)\n    assert (not mesh.sticky_edges.y)", "masked_code": "def test_mesh_sticky_edges(self, long_df):\n    ax = histplot(long_df, x='x', y='y', thresh=None)\n    mesh = ax.collections[0]\n    assert (mesh.sticky_edges.x == [long_df['x'].min(), long_df['x'].max()])\n    assert (mesh.sticky_edges.y == '???')\n    ax.clear()\n    ax = histplot(long_df, x='x', y='y')\n    mesh = ax.collections[0]\n    assert (not mesh.sticky_edges.x)\n    assert (not mesh.sticky_edges.y)", "ground_truth": "[long_df['y'].min(), long_df['y'].max()]", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_611", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_mesh_normalization", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "@pytest.mark.parametrize('stat', ['probability', 'proportion', 'percent'])\ndef test_mesh_normalization(self, long_df, stat):\n    ax = histplot(long_df, x='x', y='y', stat=stat)\n    mesh_data = ax.collections[0].get_array()\n    expected_sum = {'percent': 100}.get(stat, 1)\n    assert (mesh_data.data.sum() == expected_sum)", "masked_code": "@pytest.mark.parametrize('stat', ['probability', 'proportion', 'percent'])\ndef test_mesh_normalization(self, long_df, stat):\n    ax = histplot(long_df, x='x', y='y', stat=stat)\n    mesh_data = ax.collections[0].get_array()\n    expected_sum = {'percent': 100}.get(stat, 1)\n    assert (mesh_data.data.sum() == '???')", "ground_truth": "expected_sum", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_612", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_color_limits", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_color_limits(self, long_df):\n    (f, (ax1, ax2, ax3)) = plt.subplots(3)\n    kws = dict(data=long_df, x='x', y='y')\n    hist = Histogram()\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    histplot(**kws, ax=ax1)\n    assert (ax1.collections[0].get_clim() == (0, counts.max()))\n    vmax = 10\n    histplot(**kws, vmax=vmax, ax=ax2)\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    assert (ax2.collections[0].get_clim() == (0, vmax))\n    pmax = 0.8\n    pthresh = 0.1\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, pmax=pmax, pthresh=pthresh, ax=ax3)\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    mesh = ax3.collections[0]\n    assert (mesh.get_clim() == (0, f(counts, pmax)))\n    assert_array_equal(mesh.get_array().mask.flat, (counts <= f(counts, pthresh)).T.flat)", "masked_code": "def test_color_limits(self, long_df):\n    (f, (ax1, ax2, ax3)) = plt.subplots(3)\n    kws = dict(data=long_df, x='x', y='y')\n    hist = Histogram()\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    histplot(**kws, ax=ax1)\n    assert (ax1.collections[0].get_clim() == '???')\n    vmax = 10\n    histplot(**kws, vmax=vmax, ax=ax2)\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    assert (ax2.collections[0].get_clim() == (0, vmax))\n    pmax = 0.8\n    pthresh = 0.1\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, pmax=pmax, pthresh=pthresh, ax=ax3)\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    mesh = ax3.collections[0]\n    assert (mesh.get_clim() == (0, f(counts, pmax)))\n    assert_array_equal(mesh.get_array().mask.flat, (counts <= f(counts, pthresh)).T.flat)", "ground_truth": "(0, counts.max())", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_613", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_color_limits", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_color_limits(self, long_df):\n    (f, (ax1, ax2, ax3)) = plt.subplots(3)\n    kws = dict(data=long_df, x='x', y='y')\n    hist = Histogram()\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    histplot(**kws, ax=ax1)\n    assert (ax1.collections[0].get_clim() == (0, counts.max()))\n    vmax = 10\n    histplot(**kws, vmax=vmax, ax=ax2)\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    assert (ax2.collections[0].get_clim() == (0, vmax))\n    pmax = 0.8\n    pthresh = 0.1\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, pmax=pmax, pthresh=pthresh, ax=ax3)\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    mesh = ax3.collections[0]\n    assert (mesh.get_clim() == (0, f(counts, pmax)))\n    assert_array_equal(mesh.get_array().mask.flat, (counts <= f(counts, pthresh)).T.flat)", "masked_code": "def test_color_limits(self, long_df):\n    (f, (ax1, ax2, ax3)) = plt.subplots(3)\n    kws = dict(data=long_df, x='x', y='y')\n    hist = Histogram()\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    histplot(**kws, ax=ax1)\n    assert (ax1.collections[0].get_clim() == (0, counts.max()))\n    vmax = 10\n    histplot(**kws, vmax=vmax, ax=ax2)\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    assert (ax2.collections[0].get_clim() == '???')\n    pmax = 0.8\n    pthresh = 0.1\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, pmax=pmax, pthresh=pthresh, ax=ax3)\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    mesh = ax3.collections[0]\n    assert (mesh.get_clim() == (0, f(counts, pmax)))\n    assert_array_equal(mesh.get_array().mask.flat, (counts <= f(counts, pthresh)).T.flat)", "ground_truth": "(0, vmax)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_614", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_color_limits", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_color_limits(self, long_df):\n    (f, (ax1, ax2, ax3)) = plt.subplots(3)\n    kws = dict(data=long_df, x='x', y='y')\n    hist = Histogram()\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    histplot(**kws, ax=ax1)\n    assert (ax1.collections[0].get_clim() == (0, counts.max()))\n    vmax = 10\n    histplot(**kws, vmax=vmax, ax=ax2)\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    assert (ax2.collections[0].get_clim() == (0, vmax))\n    pmax = 0.8\n    pthresh = 0.1\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, pmax=pmax, pthresh=pthresh, ax=ax3)\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    mesh = ax3.collections[0]\n    assert (mesh.get_clim() == (0, f(counts, pmax)))\n    assert_array_equal(mesh.get_array().mask.flat, (counts <= f(counts, pthresh)).T.flat)", "masked_code": "def test_color_limits(self, long_df):\n    (f, (ax1, ax2, ax3)) = plt.subplots(3)\n    kws = dict(data=long_df, x='x', y='y')\n    hist = Histogram()\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    histplot(**kws, ax=ax1)\n    assert (ax1.collections[0].get_clim() == (0, counts.max()))\n    vmax = 10\n    histplot(**kws, vmax=vmax, ax=ax2)\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    assert (ax2.collections[0].get_clim() == (0, vmax))\n    pmax = 0.8\n    pthresh = 0.1\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, pmax=pmax, pthresh=pthresh, ax=ax3)\n    (counts, _) = hist(long_df['x'], long_df['y'])\n    mesh = ax3.collections[0]\n    assert (mesh.get_clim() == '???')\n    assert_array_equal(mesh.get_array().mask.flat, (counts <= f(counts, pthresh)).T.flat)", "ground_truth": "(0, f(counts, pmax))", "quality_analysis": {"complexity_score": 11, "left_complexity": 3, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_615", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_hue_color_limits", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_hue_color_limits(self, long_df):\n    (_, (ax1, ax2, ax3, ax4)) = plt.subplots(4)\n    kws = dict(data=long_df, x='x', y='y', hue='c', bins=4)\n    hist = Histogram(bins=kws['bins'])\n    hist.define_bin_params(long_df['x'], long_df['y'])\n    (full_counts, _) = hist(long_df['x'], long_df['y'])\n    sub_counts = []\n    for (_, sub_df) in long_df.groupby(kws['hue']):\n        (c, _) = hist(sub_df['x'], sub_df['y'])\n        sub_counts.append(c)\n    pmax = 0.8\n    pthresh = 0.05\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, common_norm=True, ax=ax1)\n    for (i, mesh) in enumerate(ax1.collections):\n        assert (mesh.get_clim() == (0, full_counts.max()))\n    histplot(**kws, common_norm=False, ax=ax2)\n    for (i, mesh) in enumerate(ax2.collections):\n        assert (mesh.get_clim() == (0, sub_counts[i].max()))\n    histplot(**kws, common_norm=True, pmax=pmax, pthresh=pthresh, ax=ax3)\n    for (i, mesh) in enumerate(ax3.collections):\n        assert (mesh.get_clim() == (0, f(full_counts, pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(full_counts, pthresh)).T.flat)\n    histplot(**kws, common_norm=False, pmax=pmax, pthresh=pthresh, ax=ax4)\n    for (i, mesh) in enumerate(ax4.collections):\n        assert (mesh.get_clim() == (0, f(sub_counts[i], pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(sub_counts[i], pthresh)).T.flat)", "masked_code": "def test_hue_color_limits(self, long_df):\n    (_, (ax1, ax2, ax3, ax4)) = plt.subplots(4)\n    kws = dict(data=long_df, x='x', y='y', hue='c', bins=4)\n    hist = Histogram(bins=kws['bins'])\n    hist.define_bin_params(long_df['x'], long_df['y'])\n    (full_counts, _) = hist(long_df['x'], long_df['y'])\n    sub_counts = []\n    for (_, sub_df) in long_df.groupby(kws['hue']):\n        (c, _) = hist(sub_df['x'], sub_df['y'])\n        sub_counts.append(c)\n    pmax = 0.8\n    pthresh = 0.05\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, common_norm=True, ax=ax1)\n    for (i, mesh) in enumerate(ax1.collections):\n        assert (mesh.get_clim() == '???')\n    histplot(**kws, common_norm=False, ax=ax2)\n    for (i, mesh) in enumerate(ax2.collections):\n        assert (mesh.get_clim() == (0, sub_counts[i].max()))\n    histplot(**kws, common_norm=True, pmax=pmax, pthresh=pthresh, ax=ax3)\n    for (i, mesh) in enumerate(ax3.collections):\n        assert (mesh.get_clim() == (0, f(full_counts, pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(full_counts, pthresh)).T.flat)\n    histplot(**kws, common_norm=False, pmax=pmax, pthresh=pthresh, ax=ax4)\n    for (i, mesh) in enumerate(ax4.collections):\n        assert (mesh.get_clim() == (0, f(sub_counts[i], pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(sub_counts[i], pthresh)).T.flat)", "ground_truth": "(0, full_counts.max())", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_616", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_hue_color_limits", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_hue_color_limits(self, long_df):\n    (_, (ax1, ax2, ax3, ax4)) = plt.subplots(4)\n    kws = dict(data=long_df, x='x', y='y', hue='c', bins=4)\n    hist = Histogram(bins=kws['bins'])\n    hist.define_bin_params(long_df['x'], long_df['y'])\n    (full_counts, _) = hist(long_df['x'], long_df['y'])\n    sub_counts = []\n    for (_, sub_df) in long_df.groupby(kws['hue']):\n        (c, _) = hist(sub_df['x'], sub_df['y'])\n        sub_counts.append(c)\n    pmax = 0.8\n    pthresh = 0.05\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, common_norm=True, ax=ax1)\n    for (i, mesh) in enumerate(ax1.collections):\n        assert (mesh.get_clim() == (0, full_counts.max()))\n    histplot(**kws, common_norm=False, ax=ax2)\n    for (i, mesh) in enumerate(ax2.collections):\n        assert (mesh.get_clim() == (0, sub_counts[i].max()))\n    histplot(**kws, common_norm=True, pmax=pmax, pthresh=pthresh, ax=ax3)\n    for (i, mesh) in enumerate(ax3.collections):\n        assert (mesh.get_clim() == (0, f(full_counts, pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(full_counts, pthresh)).T.flat)\n    histplot(**kws, common_norm=False, pmax=pmax, pthresh=pthresh, ax=ax4)\n    for (i, mesh) in enumerate(ax4.collections):\n        assert (mesh.get_clim() == (0, f(sub_counts[i], pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(sub_counts[i], pthresh)).T.flat)", "masked_code": "def test_hue_color_limits(self, long_df):\n    (_, (ax1, ax2, ax3, ax4)) = plt.subplots(4)\n    kws = dict(data=long_df, x='x', y='y', hue='c', bins=4)\n    hist = Histogram(bins=kws['bins'])\n    hist.define_bin_params(long_df['x'], long_df['y'])\n    (full_counts, _) = hist(long_df['x'], long_df['y'])\n    sub_counts = []\n    for (_, sub_df) in long_df.groupby(kws['hue']):\n        (c, _) = hist(sub_df['x'], sub_df['y'])\n        sub_counts.append(c)\n    pmax = 0.8\n    pthresh = 0.05\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, common_norm=True, ax=ax1)\n    for (i, mesh) in enumerate(ax1.collections):\n        assert (mesh.get_clim() == (0, full_counts.max()))\n    histplot(**kws, common_norm=False, ax=ax2)\n    for (i, mesh) in enumerate(ax2.collections):\n        assert (mesh.get_clim() == '???')\n    histplot(**kws, common_norm=True, pmax=pmax, pthresh=pthresh, ax=ax3)\n    for (i, mesh) in enumerate(ax3.collections):\n        assert (mesh.get_clim() == (0, f(full_counts, pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(full_counts, pthresh)).T.flat)\n    histplot(**kws, common_norm=False, pmax=pmax, pthresh=pthresh, ax=ax4)\n    for (i, mesh) in enumerate(ax4.collections):\n        assert (mesh.get_clim() == (0, f(sub_counts[i], pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(sub_counts[i], pthresh)).T.flat)", "ground_truth": "(0, sub_counts[i].max())", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_617", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_hue_color_limits", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_hue_color_limits(self, long_df):\n    (_, (ax1, ax2, ax3, ax4)) = plt.subplots(4)\n    kws = dict(data=long_df, x='x', y='y', hue='c', bins=4)\n    hist = Histogram(bins=kws['bins'])\n    hist.define_bin_params(long_df['x'], long_df['y'])\n    (full_counts, _) = hist(long_df['x'], long_df['y'])\n    sub_counts = []\n    for (_, sub_df) in long_df.groupby(kws['hue']):\n        (c, _) = hist(sub_df['x'], sub_df['y'])\n        sub_counts.append(c)\n    pmax = 0.8\n    pthresh = 0.05\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, common_norm=True, ax=ax1)\n    for (i, mesh) in enumerate(ax1.collections):\n        assert (mesh.get_clim() == (0, full_counts.max()))\n    histplot(**kws, common_norm=False, ax=ax2)\n    for (i, mesh) in enumerate(ax2.collections):\n        assert (mesh.get_clim() == (0, sub_counts[i].max()))\n    histplot(**kws, common_norm=True, pmax=pmax, pthresh=pthresh, ax=ax3)\n    for (i, mesh) in enumerate(ax3.collections):\n        assert (mesh.get_clim() == (0, f(full_counts, pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(full_counts, pthresh)).T.flat)\n    histplot(**kws, common_norm=False, pmax=pmax, pthresh=pthresh, ax=ax4)\n    for (i, mesh) in enumerate(ax4.collections):\n        assert (mesh.get_clim() == (0, f(sub_counts[i], pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(sub_counts[i], pthresh)).T.flat)", "masked_code": "def test_hue_color_limits(self, long_df):\n    (_, (ax1, ax2, ax3, ax4)) = plt.subplots(4)\n    kws = dict(data=long_df, x='x', y='y', hue='c', bins=4)\n    hist = Histogram(bins=kws['bins'])\n    hist.define_bin_params(long_df['x'], long_df['y'])\n    (full_counts, _) = hist(long_df['x'], long_df['y'])\n    sub_counts = []\n    for (_, sub_df) in long_df.groupby(kws['hue']):\n        (c, _) = hist(sub_df['x'], sub_df['y'])\n        sub_counts.append(c)\n    pmax = 0.8\n    pthresh = 0.05\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, common_norm=True, ax=ax1)\n    for (i, mesh) in enumerate(ax1.collections):\n        assert (mesh.get_clim() == (0, full_counts.max()))\n    histplot(**kws, common_norm=False, ax=ax2)\n    for (i, mesh) in enumerate(ax2.collections):\n        assert (mesh.get_clim() == (0, sub_counts[i].max()))\n    histplot(**kws, common_norm=True, pmax=pmax, pthresh=pthresh, ax=ax3)\n    for (i, mesh) in enumerate(ax3.collections):\n        assert (mesh.get_clim() == '???')\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(full_counts, pthresh)).T.flat)\n    histplot(**kws, common_norm=False, pmax=pmax, pthresh=pthresh, ax=ax4)\n    for (i, mesh) in enumerate(ax4.collections):\n        assert (mesh.get_clim() == (0, f(sub_counts[i], pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(sub_counts[i], pthresh)).T.flat)", "ground_truth": "(0, f(full_counts, pmax))", "quality_analysis": {"complexity_score": 11, "left_complexity": 3, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_618", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestHistPlotBivariate", "funcname": "test_hue_color_limits", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_hue_color_limits(self, long_df):\n    (_, (ax1, ax2, ax3, ax4)) = plt.subplots(4)\n    kws = dict(data=long_df, x='x', y='y', hue='c', bins=4)\n    hist = Histogram(bins=kws['bins'])\n    hist.define_bin_params(long_df['x'], long_df['y'])\n    (full_counts, _) = hist(long_df['x'], long_df['y'])\n    sub_counts = []\n    for (_, sub_df) in long_df.groupby(kws['hue']):\n        (c, _) = hist(sub_df['x'], sub_df['y'])\n        sub_counts.append(c)\n    pmax = 0.8\n    pthresh = 0.05\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, common_norm=True, ax=ax1)\n    for (i, mesh) in enumerate(ax1.collections):\n        assert (mesh.get_clim() == (0, full_counts.max()))\n    histplot(**kws, common_norm=False, ax=ax2)\n    for (i, mesh) in enumerate(ax2.collections):\n        assert (mesh.get_clim() == (0, sub_counts[i].max()))\n    histplot(**kws, common_norm=True, pmax=pmax, pthresh=pthresh, ax=ax3)\n    for (i, mesh) in enumerate(ax3.collections):\n        assert (mesh.get_clim() == (0, f(full_counts, pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(full_counts, pthresh)).T.flat)\n    histplot(**kws, common_norm=False, pmax=pmax, pthresh=pthresh, ax=ax4)\n    for (i, mesh) in enumerate(ax4.collections):\n        assert (mesh.get_clim() == (0, f(sub_counts[i], pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(sub_counts[i], pthresh)).T.flat)", "masked_code": "def test_hue_color_limits(self, long_df):\n    (_, (ax1, ax2, ax3, ax4)) = plt.subplots(4)\n    kws = dict(data=long_df, x='x', y='y', hue='c', bins=4)\n    hist = Histogram(bins=kws['bins'])\n    hist.define_bin_params(long_df['x'], long_df['y'])\n    (full_counts, _) = hist(long_df['x'], long_df['y'])\n    sub_counts = []\n    for (_, sub_df) in long_df.groupby(kws['hue']):\n        (c, _) = hist(sub_df['x'], sub_df['y'])\n        sub_counts.append(c)\n    pmax = 0.8\n    pthresh = 0.05\n    f = _DistributionPlotter()._quantile_to_level\n    histplot(**kws, common_norm=True, ax=ax1)\n    for (i, mesh) in enumerate(ax1.collections):\n        assert (mesh.get_clim() == (0, full_counts.max()))\n    histplot(**kws, common_norm=False, ax=ax2)\n    for (i, mesh) in enumerate(ax2.collections):\n        assert (mesh.get_clim() == (0, sub_counts[i].max()))\n    histplot(**kws, common_norm=True, pmax=pmax, pthresh=pthresh, ax=ax3)\n    for (i, mesh) in enumerate(ax3.collections):\n        assert (mesh.get_clim() == (0, f(full_counts, pmax)))\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(full_counts, pthresh)).T.flat)\n    histplot(**kws, common_norm=False, pmax=pmax, pthresh=pthresh, ax=ax4)\n    for (i, mesh) in enumerate(ax4.collections):\n        assert (mesh.get_clim() == '???')\n        assert_array_equal(mesh.get_array().mask.flat, (sub_counts[i] <= f(sub_counts[i], pthresh)).T.flat)", "ground_truth": "(0, f(sub_counts[i], pmax))", "quality_analysis": {"complexity_score": 15, "left_complexity": 3, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_619", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestECDFPlotUnivariate", "funcname": "test_line_kwargs", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_line_kwargs(self, long_df):\n    color = 'r'\n    ls = '--'\n    lw = 3\n    ax = ecdfplot(long_df, x='x', color=color, ls=ls, lw=lw)\n    for line in ax.lines:\n        assert_colors_equal(line.get_color(), color)\n        assert (line.get_linestyle() == ls)\n        assert (line.get_linewidth() == lw)", "masked_code": "def test_line_kwargs(self, long_df):\n    color = 'r'\n    ls = '--'\n    lw = 3\n    ax = ecdfplot(long_df, x='x', color=color, ls=ls, lw=lw)\n    for line in ax.lines:\n        assert_colors_equal(line.get_color(), color)\n        assert (line.get_linestyle() == '???')\n        assert (line.get_linewidth() == lw)", "ground_truth": "ls", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_620", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestECDFPlotUnivariate", "funcname": "test_line_kwargs", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_line_kwargs(self, long_df):\n    color = 'r'\n    ls = '--'\n    lw = 3\n    ax = ecdfplot(long_df, x='x', color=color, ls=ls, lw=lw)\n    for line in ax.lines:\n        assert_colors_equal(line.get_color(), color)\n        assert (line.get_linestyle() == ls)\n        assert (line.get_linewidth() == lw)", "masked_code": "def test_line_kwargs(self, long_df):\n    color = 'r'\n    ls = '--'\n    lw = 3\n    ax = ecdfplot(long_df, x='x', color=color, ls=ls, lw=lw)\n    for line in ax.lines:\n        assert_colors_equal(line.get_color(), color)\n        assert (line.get_linestyle() == ls)\n        assert (line.get_linewidth() == '???')", "ground_truth": "lw", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_621", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestECDFPlotUnivariate", "funcname": "test_drawstyle", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "@pytest.mark.parametrize('data_var', ['x', 'y'])\ndef test_drawstyle(self, flat_series, data_var):\n    ax = ecdfplot(**{data_var: flat_series})\n    drawstyles = dict(x='steps-post', y='steps-pre')\n    assert (ax.lines[0].get_drawstyle() == drawstyles[data_var])", "masked_code": "@pytest.mark.parametrize('data_var', ['x', 'y'])\ndef test_drawstyle(self, flat_series, data_var):\n    ax = ecdfplot(**{data_var: flat_series})\n    drawstyles = dict(x='steps-post', y='steps-pre')\n    assert (ax.lines[0].get_drawstyle() == '???')", "ground_truth": "drawstyles[data_var]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_622", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestECDFPlotUnivariate", "funcname": "test_proportion_limits", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "@pytest.mark.parametrize('data_var,stat_var', [['x', 'y'], ['y', 'x']])\ndef test_proportion_limits(self, flat_series, data_var, stat_var):\n    ax = ecdfplot(**{data_var: flat_series})\n    data = getattr(ax.lines[0], f'get_{stat_var}data')()\n    assert (data[0] == 0)\n    assert (data[(- 1)] == 1)\n    sticky_edges = getattr(ax.lines[0].sticky_edges, stat_var)\n    assert (sticky_edges[:] == [0, 1])", "masked_code": "@pytest.mark.parametrize('data_var,stat_var', [['x', 'y'], ['y', 'x']])\ndef test_proportion_limits(self, flat_series, data_var, stat_var):\n    ax = ecdfplot(**{data_var: flat_series})\n    data = getattr(ax.lines[0], f'get_{stat_var}data')()\n    assert (data[0] == 0)\n    assert (data[(- 1)] == 1)\n    sticky_edges = getattr(ax.lines[0].sticky_edges, stat_var)\n    assert (sticky_edges[:] == '???')", "ground_truth": "[0, 1]", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_623", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestECDFPlotUnivariate", "funcname": "test_proportion_limits_complementary", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "@pytest.mark.parametrize('data_var,stat_var', [['x', 'y'], ['y', 'x']])\ndef test_proportion_limits_complementary(self, flat_series, data_var, stat_var):\n    ax = ecdfplot(**{data_var: flat_series}, complementary=True)\n    data = getattr(ax.lines[0], f'get_{stat_var}data')()\n    assert (data[0] == 1)\n    assert (data[(- 1)] == 0)\n    sticky_edges = getattr(ax.lines[0].sticky_edges, stat_var)\n    assert (sticky_edges[:] == [0, 1])", "masked_code": "@pytest.mark.parametrize('data_var,stat_var', [['x', 'y'], ['y', 'x']])\ndef test_proportion_limits_complementary(self, flat_series, data_var, stat_var):\n    ax = ecdfplot(**{data_var: flat_series}, complementary=True)\n    data = getattr(ax.lines[0], f'get_{stat_var}data')()\n    assert (data[0] == 1)\n    assert (data[(- 1)] == 0)\n    sticky_edges = getattr(ax.lines[0].sticky_edges, stat_var)\n    assert (sticky_edges[:] == '???')", "ground_truth": "[0, 1]", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_624", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestECDFPlotUnivariate", "funcname": "test_proportion_count", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "@pytest.mark.parametrize('data_var,stat_var', [['x', 'y'], ['y', 'x']])\ndef test_proportion_count(self, flat_series, data_var, stat_var):\n    n = len(flat_series)\n    ax = ecdfplot(**{data_var: flat_series}, stat='count')\n    data = getattr(ax.lines[0], f'get_{stat_var}data')()\n    assert (data[0] == 0)\n    assert (data[(- 1)] == n)\n    sticky_edges = getattr(ax.lines[0].sticky_edges, stat_var)\n    assert (sticky_edges[:] == [0, n])", "masked_code": "@pytest.mark.parametrize('data_var,stat_var', [['x', 'y'], ['y', 'x']])\ndef test_proportion_count(self, flat_series, data_var, stat_var):\n    n = len(flat_series)\n    ax = ecdfplot(**{data_var: flat_series}, stat='count')\n    data = getattr(ax.lines[0], f'get_{stat_var}data')()\n    assert (data[0] == 0)\n    assert (data[(- 1)] == '???')\n    sticky_edges = getattr(ax.lines[0].sticky_edges, stat_var)\n    assert (sticky_edges[:] == [0, n])", "ground_truth": "n", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_625", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestECDFPlotUnivariate", "funcname": "test_proportion_count", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "@pytest.mark.parametrize('data_var,stat_var', [['x', 'y'], ['y', 'x']])\ndef test_proportion_count(self, flat_series, data_var, stat_var):\n    n = len(flat_series)\n    ax = ecdfplot(**{data_var: flat_series}, stat='count')\n    data = getattr(ax.lines[0], f'get_{stat_var}data')()\n    assert (data[0] == 0)\n    assert (data[(- 1)] == n)\n    sticky_edges = getattr(ax.lines[0].sticky_edges, stat_var)\n    assert (sticky_edges[:] == [0, n])", "masked_code": "@pytest.mark.parametrize('data_var,stat_var', [['x', 'y'], ['y', 'x']])\ndef test_proportion_count(self, flat_series, data_var, stat_var):\n    n = len(flat_series)\n    ax = ecdfplot(**{data_var: flat_series}, stat='count')\n    data = getattr(ax.lines[0], f'get_{stat_var}data')()\n    assert (data[0] == 0)\n    assert (data[(- 1)] == n)\n    sticky_edges = getattr(ax.lines[0].sticky_edges, stat_var)\n    assert (sticky_edges[:] == '???')", "ground_truth": "[0, n]", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_626", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestDisPlot", "funcname": "test_array_faceting", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "@pytest.mark.parametrize('key', ['col', 'row'])\ndef test_array_faceting(self, long_df, key):\n    a = long_df['a'].to_numpy()\n    vals = categorical_order(a)\n    g = displot(long_df, x='x', **{key: a})\n    assert (len(g.axes.flat) == len(vals))\n    for (ax, val) in zip(g.axes.flat, vals):\n        assert (val in ax.get_title())", "masked_code": "@pytest.mark.parametrize('key', ['col', 'row'])\ndef test_array_faceting(self, long_df, key):\n    a = long_df['a'].to_numpy()\n    vals = categorical_order(a)\n    g = displot(long_df, x='x', **{key: a})\n    assert (len(g.axes.flat) == '???')\n    for (ax, val) in zip(g.axes.flat, vals):\n        assert (val in ax.get_title())", "ground_truth": "len(vals)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_627", "reponame": "seaborn", "testpath": "tests/test_distributions.py", "testname": "test_distributions.py", "classname": "TestDisPlot", "funcname": "test_facetgrid_data", "imports": ["import itertools", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import to_rgb, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn import distributions as dist", "from seaborn.palettes import color_palette, light_palette", "from seaborn._base import categorical_order", "from seaborn._statistics import KDE, Histogram, _no_scipy", "from seaborn.distributions import _DistributionPlotter, displot, distplot, histplot, ecdfplot, kdeplot, rugplot", "from seaborn.utils import _version_predates", "from seaborn.axisgrid import FacetGrid", "from seaborn._testing import assert_plots_equal, assert_legends_equal, assert_colors_equal"], "code": "def test_facetgrid_data(self, long_df):\n    g = displot(data=long_df.to_dict(orient='list'), x='z', hue=long_df['a'].rename('hue_var'), col=long_df['c'].to_numpy())\n    expected_cols = set((long_df.columns.to_list() + ['hue_var', '_col_']))\n    assert (set(g.data.columns) == expected_cols)\n    assert_array_equal(g.data['hue_var'], long_df['a'])\n    assert_array_equal(g.data['_col_'], long_df['c'])", "masked_code": "def test_facetgrid_data(self, long_df):\n    g = displot(data=long_df.to_dict(orient='list'), x='z', hue=long_df['a'].rename('hue_var'), col=long_df['c'].to_numpy())\n    expected_cols = set((long_df.columns.to_list() + ['hue_var', '_col_']))\n    assert (set(g.data.columns) == '???')\n    assert_array_equal(g.data['hue_var'], long_df['a'])\n    assert_array_equal(g.data['_col_'], long_df['c'])", "ground_truth": "expected_cols", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_628", "reponame": "seaborn", "testpath": "tests/test_docstrings.py", "testname": "test_docstrings.py", "classname": "TestDocstringComponents", "funcname": "test_from_dict", "imports": ["from seaborn._docstrings import DocstringComponents"], "code": "def test_from_dict(self):\n    obj = DocstringComponents(EXAMPLE_DICT)\n    assert (obj.param_a == 'a : str\\n    The first parameter.')", "masked_code": "def test_from_dict(self):\n    obj = DocstringComponents(EXAMPLE_DICT)\n    assert (obj.param_a == '???')", "ground_truth": "'a : str\\n    The first parameter.'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_629", "reponame": "seaborn", "testpath": "tests/test_docstrings.py", "testname": "test_docstrings.py", "classname": "TestDocstringComponents", "funcname": "test_from_nested_components", "imports": ["from seaborn._docstrings import DocstringComponents"], "code": "def test_from_nested_components(self):\n    obj_inner = DocstringComponents(EXAMPLE_DICT)\n    obj_outer = DocstringComponents.from_nested_components(inner=obj_inner)\n    assert (obj_outer.inner.param_a == 'a : str\\n    The first parameter.')", "masked_code": "def test_from_nested_components(self):\n    obj_inner = DocstringComponents(EXAMPLE_DICT)\n    obj_outer = DocstringComponents.from_nested_components(inner=obj_inner)\n    assert (obj_outer.inner.param_a == '???')", "ground_truth": "'a : str\\n    The first parameter.'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_630", "reponame": "seaborn", "testpath": "tests/test_docstrings.py", "testname": "test_docstrings.py", "classname": "TestDocstringComponents", "funcname": "test_from_function", "imports": ["from seaborn._docstrings import DocstringComponents"], "code": "def test_from_function(self):\n    obj = DocstringComponents.from_function_params(example_func)\n    assert (obj.a == 'a : str\\n    A function parameter.')", "masked_code": "def test_from_function(self):\n    obj = DocstringComponents.from_function_params(example_func)\n    assert (obj.a == '???')", "ground_truth": "'a : str\\n    A function parameter.'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_631", "reponame": "seaborn", "testpath": "tests/test_docstrings.py", "testname": "test_docstrings.py", "classname": "TestDocstringComponents", "funcname": "test_from_method", "imports": ["from seaborn._docstrings import DocstringComponents"], "code": "def test_from_method(self):\n    obj = DocstringComponents.from_function_params(ExampleClass.example_method)\n    assert (obj.a == 'a : str\\n    A method parameter.')", "masked_code": "def test_from_method(self):\n    obj = DocstringComponents.from_function_params(ExampleClass.example_method)\n    assert (obj.a == '???')", "ground_truth": "'a : str\\n    A method parameter.'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_632", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_df_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_df_input(self):\n    p = mat._HeatMapper(self.df_norm, **self.default_kws)\n    npt.assert_array_equal(p.plot_data, self.x_norm)\n    pdt.assert_frame_equal(p.data, self.df_norm)\n    npt.assert_array_equal(p.xticklabels, np.arange(8))\n    npt.assert_array_equal(p.yticklabels, self.letters.values)\n    assert (p.xlabel == '')\n    assert (p.ylabel == 'letters')", "masked_code": "def test_df_input(self):\n    p = mat._HeatMapper(self.df_norm, **self.default_kws)\n    npt.assert_array_equal(p.plot_data, self.x_norm)\n    pdt.assert_frame_equal(p.data, self.df_norm)\n    npt.assert_array_equal(p.xticklabels, np.arange(8))\n    npt.assert_array_equal(p.yticklabels, self.letters.values)\n    assert (p.xlabel == '')\n    assert (p.ylabel == '???')", "ground_truth": "'letters'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_633", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_df_multindex_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_df_multindex_input(self):\n    df = self.df_norm.copy()\n    index = pd.MultiIndex.from_tuples([('A', 1), ('B', 2), ('C', 3), ('D', 4)], names=['letter', 'number'])\n    index.name = 'letter-number'\n    df.index = index\n    p = mat._HeatMapper(df, **self.default_kws)\n    combined_tick_labels = ['A-1', 'B-2', 'C-3', 'D-4']\n    npt.assert_array_equal(p.yticklabels, combined_tick_labels)\n    assert (p.ylabel == 'letter-number')\n    p = mat._HeatMapper(df.T, **self.default_kws)\n    npt.assert_array_equal(p.xticklabels, combined_tick_labels)\n    assert (p.xlabel == 'letter-number')", "masked_code": "def test_df_multindex_input(self):\n    df = self.df_norm.copy()\n    index = pd.MultiIndex.from_tuples([('A', 1), ('B', 2), ('C', 3), ('D', 4)], names=['letter', 'number'])\n    index.name = 'letter-number'\n    df.index = index\n    p = mat._HeatMapper(df, **self.default_kws)\n    combined_tick_labels = ['A-1', 'B-2', 'C-3', 'D-4']\n    npt.assert_array_equal(p.yticklabels, combined_tick_labels)\n    assert (p.ylabel == '???')\n    p = mat._HeatMapper(df.T, **self.default_kws)\n    npt.assert_array_equal(p.xticklabels, combined_tick_labels)\n    assert (p.xlabel == 'letter-number')", "ground_truth": "'letter-number'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_634", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_df_multindex_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_df_multindex_input(self):\n    df = self.df_norm.copy()\n    index = pd.MultiIndex.from_tuples([('A', 1), ('B', 2), ('C', 3), ('D', 4)], names=['letter', 'number'])\n    index.name = 'letter-number'\n    df.index = index\n    p = mat._HeatMapper(df, **self.default_kws)\n    combined_tick_labels = ['A-1', 'B-2', 'C-3', 'D-4']\n    npt.assert_array_equal(p.yticklabels, combined_tick_labels)\n    assert (p.ylabel == 'letter-number')\n    p = mat._HeatMapper(df.T, **self.default_kws)\n    npt.assert_array_equal(p.xticklabels, combined_tick_labels)\n    assert (p.xlabel == 'letter-number')", "masked_code": "def test_df_multindex_input(self):\n    df = self.df_norm.copy()\n    index = pd.MultiIndex.from_tuples([('A', 1), ('B', 2), ('C', 3), ('D', 4)], names=['letter', 'number'])\n    index.name = 'letter-number'\n    df.index = index\n    p = mat._HeatMapper(df, **self.default_kws)\n    combined_tick_labels = ['A-1', 'B-2', 'C-3', 'D-4']\n    npt.assert_array_equal(p.yticklabels, combined_tick_labels)\n    assert (p.ylabel == 'letter-number')\n    p = mat._HeatMapper(df.T, **self.default_kws)\n    npt.assert_array_equal(p.xticklabels, combined_tick_labels)\n    assert (p.xlabel == '???')", "ground_truth": "'letter-number'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_635", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_mask_limits", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_mask_limits(self):\n    'Make sure masked cells are not used to calculate extremes'\n    kws = self.default_kws.copy()\n    mask = (self.x_norm > 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    mask = (self.x_norm < 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())", "masked_code": "def test_mask_limits(self):\n    'Make sure masked cells are not used to calculate extremes'\n    kws = self.default_kws.copy()\n    mask = (self.x_norm > 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmax == '???')\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    mask = (self.x_norm < 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())", "ground_truth": "np.ma.array(self.x_norm, mask=mask).max()", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_636", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_mask_limits", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_mask_limits(self):\n    'Make sure masked cells are not used to calculate extremes'\n    kws = self.default_kws.copy()\n    mask = (self.x_norm > 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    mask = (self.x_norm < 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())", "masked_code": "def test_mask_limits(self):\n    'Make sure masked cells are not used to calculate extremes'\n    kws = self.default_kws.copy()\n    mask = (self.x_norm > 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())\n    assert (p.vmin == '???')\n    mask = (self.x_norm < 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())", "ground_truth": "np.ma.array(self.x_norm, mask=mask).min()", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_637", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_mask_limits", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_mask_limits(self):\n    'Make sure masked cells are not used to calculate extremes'\n    kws = self.default_kws.copy()\n    mask = (self.x_norm > 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    mask = (self.x_norm < 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())", "masked_code": "def test_mask_limits(self):\n    'Make sure masked cells are not used to calculate extremes'\n    kws = self.default_kws.copy()\n    mask = (self.x_norm > 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    mask = (self.x_norm < 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmin == '???')\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())", "ground_truth": "np.ma.array(self.x_norm, mask=mask).min()", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_638", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_mask_limits", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_mask_limits(self):\n    'Make sure masked cells are not used to calculate extremes'\n    kws = self.default_kws.copy()\n    mask = (self.x_norm > 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    mask = (self.x_norm < 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())", "masked_code": "def test_mask_limits(self):\n    'Make sure masked cells are not used to calculate extremes'\n    kws = self.default_kws.copy()\n    mask = (self.x_norm > 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmax == np.ma.array(self.x_norm, mask=mask).max())\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    mask = (self.x_norm < 0)\n    kws['mask'] = mask\n    p = mat._HeatMapper(self.x_norm, **kws)\n    assert (p.vmin == np.ma.array(self.x_norm, mask=mask).min())\n    assert (p.vmax == '???')", "ground_truth": "np.ma.array(self.x_norm, mask=mask).max()", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_639", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_default_vlims", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_default_vlims(self):\n    p = mat._HeatMapper(self.df_unif, **self.default_kws)\n    assert (p.vmin == self.x_unif.min())\n    assert (p.vmax == self.x_unif.max())", "masked_code": "def test_default_vlims(self):\n    p = mat._HeatMapper(self.df_unif, **self.default_kws)\n    assert (p.vmin == '???')\n    assert (p.vmax == self.x_unif.max())", "ground_truth": "self.x_unif.min()", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_640", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_default_vlims", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_default_vlims(self):\n    p = mat._HeatMapper(self.df_unif, **self.default_kws)\n    assert (p.vmin == self.x_unif.min())\n    assert (p.vmax == self.x_unif.max())", "masked_code": "def test_default_vlims(self):\n    p = mat._HeatMapper(self.df_unif, **self.default_kws)\n    assert (p.vmin == self.x_unif.min())\n    assert (p.vmax == '???')", "ground_truth": "self.x_unif.max()", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_641", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_robust_vlims", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_robust_vlims(self):\n    kws = self.default_kws.copy()\n    kws['robust'] = True\n    p = mat._HeatMapper(self.df_unif, **kws)\n    assert (p.vmin == np.percentile(self.x_unif, 2))\n    assert (p.vmax == np.percentile(self.x_unif, 98))", "masked_code": "def test_robust_vlims(self):\n    kws = self.default_kws.copy()\n    kws['robust'] = True\n    p = mat._HeatMapper(self.df_unif, **kws)\n    assert (p.vmin == '???')\n    assert (p.vmax == np.percentile(self.x_unif, 98))", "ground_truth": "np.percentile(self.x_unif, 2)", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_642", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_robust_vlims", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_robust_vlims(self):\n    kws = self.default_kws.copy()\n    kws['robust'] = True\n    p = mat._HeatMapper(self.df_unif, **kws)\n    assert (p.vmin == np.percentile(self.x_unif, 2))\n    assert (p.vmax == np.percentile(self.x_unif, 98))", "masked_code": "def test_robust_vlims(self):\n    kws = self.default_kws.copy()\n    kws['robust'] = True\n    p = mat._HeatMapper(self.df_unif, **kws)\n    assert (p.vmin == np.percentile(self.x_unif, 2))\n    assert (p.vmax == '???')", "ground_truth": "np.percentile(self.x_unif, 98)", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_643", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_custom_diverging_vlims", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_custom_diverging_vlims(self):\n    kws = self.default_kws.copy()\n    kws['vmin'] = (- 4)\n    kws['vmax'] = 5\n    kws['center'] = 0\n    p = mat._HeatMapper(self.df_norm, **kws)\n    assert (p.vmin == (- 4))\n    assert (p.vmax == 5)", "masked_code": "def test_custom_diverging_vlims(self):\n    kws = self.default_kws.copy()\n    kws['vmin'] = (- 4)\n    kws['vmax'] = 5\n    kws['center'] = 0\n    p = mat._HeatMapper(self.df_norm, **kws)\n    assert (p.vmin == '???')\n    assert (p.vmax == 5)", "ground_truth": "(- 4)", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_644", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_custom_diverging_vlims", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_custom_diverging_vlims(self):\n    kws = self.default_kws.copy()\n    kws['vmin'] = (- 4)\n    kws['vmax'] = 5\n    kws['center'] = 0\n    p = mat._HeatMapper(self.df_norm, **kws)\n    assert (p.vmin == (- 4))\n    assert (p.vmax == 5)", "masked_code": "def test_custom_diverging_vlims(self):\n    kws = self.default_kws.copy()\n    kws['vmin'] = (- 4)\n    kws['vmax'] = 5\n    kws['center'] = 0\n    p = mat._HeatMapper(self.df_norm, **kws)\n    assert (p.vmin == (- 4))\n    assert (p.vmax == '???')", "ground_truth": "5", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_645", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_array_with_nans", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_array_with_nans(self):\n    x1 = self.rs.rand(10, 10)\n    nulls = (np.zeros(10) * np.nan)\n    x2 = np.c_[(x1, nulls)]\n    m1 = mat._HeatMapper(x1, **self.default_kws)\n    m2 = mat._HeatMapper(x2, **self.default_kws)\n    assert (m1.vmin == m2.vmin)\n    assert (m1.vmax == m2.vmax)", "masked_code": "def test_array_with_nans(self):\n    x1 = self.rs.rand(10, 10)\n    nulls = (np.zeros(10) * np.nan)\n    x2 = np.c_[(x1, nulls)]\n    m1 = mat._HeatMapper(x1, **self.default_kws)\n    m2 = mat._HeatMapper(x2, **self.default_kws)\n    assert (m1.vmin == '???')\n    assert (m1.vmax == m2.vmax)", "ground_truth": "m2.vmin", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_646", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_array_with_nans", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_array_with_nans(self):\n    x1 = self.rs.rand(10, 10)\n    nulls = (np.zeros(10) * np.nan)\n    x2 = np.c_[(x1, nulls)]\n    m1 = mat._HeatMapper(x1, **self.default_kws)\n    m2 = mat._HeatMapper(x2, **self.default_kws)\n    assert (m1.vmin == m2.vmin)\n    assert (m1.vmax == m2.vmax)", "masked_code": "def test_array_with_nans(self):\n    x1 = self.rs.rand(10, 10)\n    nulls = (np.zeros(10) * np.nan)\n    x2 = np.c_[(x1, nulls)]\n    m1 = mat._HeatMapper(x1, **self.default_kws)\n    m2 = mat._HeatMapper(x2, **self.default_kws)\n    assert (m1.vmin == m2.vmin)\n    assert (m1.vmax == '???')", "ground_truth": "m2.vmax", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_647", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_custom_cmap", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_custom_cmap(self):\n    kws = self.default_kws.copy()\n    kws['cmap'] = 'BuGn'\n    p = mat._HeatMapper(self.df_unif, **kws)\n    assert (p.cmap == mpl.cm.BuGn)", "masked_code": "def test_custom_cmap(self):\n    kws = self.default_kws.copy()\n    kws['cmap'] = 'BuGn'\n    p = mat._HeatMapper(self.df_unif, **kws)\n    assert (p.cmap == '???')", "ground_truth": "mpl.cm.BuGn", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_648", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_centered_vlims", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_centered_vlims(self):\n    kws = self.default_kws.copy()\n    kws['center'] = 0.5\n    p = mat._HeatMapper(self.df_unif, **kws)\n    assert (p.vmin == self.df_unif.values.min())\n    assert (p.vmax == self.df_unif.values.max())", "masked_code": "def test_centered_vlims(self):\n    kws = self.default_kws.copy()\n    kws['center'] = 0.5\n    p = mat._HeatMapper(self.df_unif, **kws)\n    assert (p.vmin == '???')\n    assert (p.vmax == self.df_unif.values.max())", "ground_truth": "self.df_unif.values.min()", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_649", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_centered_vlims", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_centered_vlims(self):\n    kws = self.default_kws.copy()\n    kws['center'] = 0.5\n    p = mat._HeatMapper(self.df_unif, **kws)\n    assert (p.vmin == self.df_unif.values.min())\n    assert (p.vmax == self.df_unif.values.max())", "masked_code": "def test_centered_vlims(self):\n    kws = self.default_kws.copy()\n    kws['center'] = 0.5\n    p = mat._HeatMapper(self.df_unif, **kws)\n    assert (p.vmin == self.df_unif.values.min())\n    assert (p.vmax == '???')", "ground_truth": "self.df_unif.values.max()", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_650", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_ticklabels_off", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_ticklabels_off(self):\n    kws = self.default_kws.copy()\n    kws['xticklabels'] = False\n    kws['yticklabels'] = False\n    p = mat._HeatMapper(self.df_norm, **kws)\n    assert (p.xticklabels == [])\n    assert (p.yticklabels == [])", "masked_code": "def test_ticklabels_off(self):\n    kws = self.default_kws.copy()\n    kws['xticklabels'] = False\n    kws['yticklabels'] = False\n    p = mat._HeatMapper(self.df_norm, **kws)\n    assert (p.xticklabels == '???')\n    assert (p.yticklabels == [])", "ground_truth": "[]", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_651", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_ticklabels_off", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_ticklabels_off(self):\n    kws = self.default_kws.copy()\n    kws['xticklabels'] = False\n    kws['yticklabels'] = False\n    p = mat._HeatMapper(self.df_norm, **kws)\n    assert (p.xticklabels == [])\n    assert (p.yticklabels == [])", "masked_code": "def test_ticklabels_off(self):\n    kws = self.default_kws.copy()\n    kws['xticklabels'] = False\n    kws['yticklabels'] = False\n    p = mat._HeatMapper(self.df_norm, **kws)\n    assert (p.xticklabels == [])\n    assert (p.yticklabels == '???')", "ground_truth": "[]", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_652", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_custom_ticklabels", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_custom_ticklabels(self):\n    kws = self.default_kws.copy()\n    xticklabels = list('iheartheatmaps'[:self.df_norm.shape[1]])\n    yticklabels = list('heatmapsarecool'[:self.df_norm.shape[0]])\n    kws['xticklabels'] = xticklabels\n    kws['yticklabels'] = yticklabels\n    p = mat._HeatMapper(self.df_norm, **kws)\n    assert (p.xticklabels == xticklabels)\n    assert (p.yticklabels == yticklabels)", "masked_code": "def test_custom_ticklabels(self):\n    kws = self.default_kws.copy()\n    xticklabels = list('iheartheatmaps'[:self.df_norm.shape[1]])\n    yticklabels = list('heatmapsarecool'[:self.df_norm.shape[0]])\n    kws['xticklabels'] = xticklabels\n    kws['yticklabels'] = yticklabels\n    p = mat._HeatMapper(self.df_norm, **kws)\n    assert (p.xticklabels == '???')\n    assert (p.yticklabels == yticklabels)", "ground_truth": "xticklabels", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_653", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_custom_ticklabels", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_custom_ticklabels(self):\n    kws = self.default_kws.copy()\n    xticklabels = list('iheartheatmaps'[:self.df_norm.shape[1]])\n    yticklabels = list('heatmapsarecool'[:self.df_norm.shape[0]])\n    kws['xticklabels'] = xticklabels\n    kws['yticklabels'] = yticklabels\n    p = mat._HeatMapper(self.df_norm, **kws)\n    assert (p.xticklabels == xticklabels)\n    assert (p.yticklabels == yticklabels)", "masked_code": "def test_custom_ticklabels(self):\n    kws = self.default_kws.copy()\n    xticklabels = list('iheartheatmaps'[:self.df_norm.shape[1]])\n    yticklabels = list('heatmapsarecool'[:self.df_norm.shape[0]])\n    kws['xticklabels'] = xticklabels\n    kws['yticklabels'] = yticklabels\n    p = mat._HeatMapper(self.df_norm, **kws)\n    assert (p.xticklabels == xticklabels)\n    assert (p.yticklabels == '???')", "ground_truth": "yticklabels", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_654", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_annotation", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_annotation(self):\n    ax = mat.heatmap(self.df_norm, annot=True, fmt='.1f', annot_kws={'fontsize': 14})\n    for (val, text) in zip(self.x_norm.flat, ax.texts):\n        assert (text.get_text() == f'{val:.1f}')\n        assert (text.get_fontsize() == 14)", "masked_code": "def test_heatmap_annotation(self):\n    ax = mat.heatmap(self.df_norm, annot=True, fmt='.1f', annot_kws={'fontsize': 14})\n    for (val, text) in zip(self.x_norm.flat, ax.texts):\n        assert (text.get_text() == '???')\n        assert (text.get_fontsize() == 14)", "ground_truth": "f'{val:.1f}'", "quality_analysis": {"complexity_score": 3, "left_complexity": 3, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_655", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_annotation", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_annotation(self):\n    ax = mat.heatmap(self.df_norm, annot=True, fmt='.1f', annot_kws={'fontsize': 14})\n    for (val, text) in zip(self.x_norm.flat, ax.texts):\n        assert (text.get_text() == f'{val:.1f}')\n        assert (text.get_fontsize() == 14)", "masked_code": "def test_heatmap_annotation(self):\n    ax = mat.heatmap(self.df_norm, annot=True, fmt='.1f', annot_kws={'fontsize': 14})\n    for (val, text) in zip(self.x_norm.flat, ax.texts):\n        assert (text.get_text() == f'{val:.1f}')\n        assert (text.get_fontsize() == '???')", "ground_truth": "14", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_656", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_annotation_overwrite_kws", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_annotation_overwrite_kws(self):\n    annot_kws = dict(color='0.3', va='bottom', ha='left')\n    ax = mat.heatmap(self.df_norm, annot=True, fmt='.1f', annot_kws=annot_kws)\n    for text in ax.texts:\n        assert (text.get_color() == '0.3')\n        assert (text.get_ha() == 'left')\n        assert (text.get_va() == 'bottom')", "masked_code": "def test_heatmap_annotation_overwrite_kws(self):\n    annot_kws = dict(color='0.3', va='bottom', ha='left')\n    ax = mat.heatmap(self.df_norm, annot=True, fmt='.1f', annot_kws=annot_kws)\n    for text in ax.texts:\n        assert (text.get_color() == '???')\n        assert (text.get_ha() == 'left')\n        assert (text.get_va() == 'bottom')", "ground_truth": "'0.3'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_657", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_annotation_overwrite_kws", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_annotation_overwrite_kws(self):\n    annot_kws = dict(color='0.3', va='bottom', ha='left')\n    ax = mat.heatmap(self.df_norm, annot=True, fmt='.1f', annot_kws=annot_kws)\n    for text in ax.texts:\n        assert (text.get_color() == '0.3')\n        assert (text.get_ha() == 'left')\n        assert (text.get_va() == 'bottom')", "masked_code": "def test_heatmap_annotation_overwrite_kws(self):\n    annot_kws = dict(color='0.3', va='bottom', ha='left')\n    ax = mat.heatmap(self.df_norm, annot=True, fmt='.1f', annot_kws=annot_kws)\n    for text in ax.texts:\n        assert (text.get_color() == '0.3')\n        assert (text.get_ha() == '???')\n        assert (text.get_va() == 'bottom')", "ground_truth": "'left'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_658", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_annotation_overwrite_kws", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_annotation_overwrite_kws(self):\n    annot_kws = dict(color='0.3', va='bottom', ha='left')\n    ax = mat.heatmap(self.df_norm, annot=True, fmt='.1f', annot_kws=annot_kws)\n    for text in ax.texts:\n        assert (text.get_color() == '0.3')\n        assert (text.get_ha() == 'left')\n        assert (text.get_va() == 'bottom')", "masked_code": "def test_heatmap_annotation_overwrite_kws(self):\n    annot_kws = dict(color='0.3', va='bottom', ha='left')\n    ax = mat.heatmap(self.df_norm, annot=True, fmt='.1f', annot_kws=annot_kws)\n    for text in ax.texts:\n        assert (text.get_color() == '0.3')\n        assert (text.get_ha() == 'left')\n        assert (text.get_va() == '???')", "ground_truth": "'bottom'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_659", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_annotation_with_mask", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_annotation_with_mask(self):\n    df = pd.DataFrame(data={'a': [1, 1, 1], 'b': [2, np.nan, 2], 'c': [3, 3, np.nan]})\n    mask = np.isnan(df.values)\n    df_masked = np.ma.masked_where(mask, df)\n    ax = mat.heatmap(df, annot=True, fmt='.1f', mask=mask)\n    assert (len(df_masked.compressed()) == len(ax.texts))\n    for (val, text) in zip(df_masked.compressed(), ax.texts):\n        assert (f'{val:.1f}' == text.get_text())", "masked_code": "def test_heatmap_annotation_with_mask(self):\n    df = pd.DataFrame(data={'a': [1, 1, 1], 'b': [2, np.nan, 2], 'c': [3, 3, np.nan]})\n    mask = np.isnan(df.values)\n    df_masked = np.ma.masked_where(mask, df)\n    ax = mat.heatmap(df, annot=True, fmt='.1f', mask=mask)\n    assert (len(df_masked.compressed()) == '???')\n    for (val, text) in zip(df_masked.compressed(), ax.texts):\n        assert (f'{val:.1f}' == text.get_text())", "ground_truth": "len(ax.texts)", "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_660", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_annotation_mesh_colors", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_annotation_mesh_colors(self):\n    ax = mat.heatmap(self.df_norm, annot=True)\n    mesh = ax.collections[0]\n    assert (len(mesh.get_facecolors()) == self.df_norm.values.size)\n    plt.close('all')", "masked_code": "def test_heatmap_annotation_mesh_colors(self):\n    ax = mat.heatmap(self.df_norm, annot=True)\n    mesh = ax.collections[0]\n    assert (len(mesh.get_facecolors()) == '???')\n    plt.close('all')", "ground_truth": "self.df_norm.values.size", "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_661", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_annotation_other_data", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_annotation_other_data(self):\n    annot_data = (self.df_norm + 10)\n    ax = mat.heatmap(self.df_norm, annot=annot_data, fmt='.1f', annot_kws={'fontsize': 14})\n    for (val, text) in zip(annot_data.values.flat, ax.texts):\n        assert (text.get_text() == f'{val:.1f}')\n        assert (text.get_fontsize() == 14)", "masked_code": "def test_heatmap_annotation_other_data(self):\n    annot_data = (self.df_norm + 10)\n    ax = mat.heatmap(self.df_norm, annot=annot_data, fmt='.1f', annot_kws={'fontsize': 14})\n    for (val, text) in zip(annot_data.values.flat, ax.texts):\n        assert (text.get_text() == '???')\n        assert (text.get_fontsize() == 14)", "ground_truth": "f'{val:.1f}'", "quality_analysis": {"complexity_score": 3, "left_complexity": 3, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_662", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_annotation_other_data", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_annotation_other_data(self):\n    annot_data = (self.df_norm + 10)\n    ax = mat.heatmap(self.df_norm, annot=annot_data, fmt='.1f', annot_kws={'fontsize': 14})\n    for (val, text) in zip(annot_data.values.flat, ax.texts):\n        assert (text.get_text() == f'{val:.1f}')\n        assert (text.get_fontsize() == 14)", "masked_code": "def test_heatmap_annotation_other_data(self):\n    annot_data = (self.df_norm + 10)\n    ax = mat.heatmap(self.df_norm, annot=annot_data, fmt='.1f', annot_kws={'fontsize': 14})\n    for (val, text) in zip(annot_data.values.flat, ax.texts):\n        assert (text.get_text() == f'{val:.1f}')\n        assert (text.get_fontsize() == '???')", "ground_truth": "14", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_663", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_annotation_with_limited_ticklabels", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_annotation_with_limited_ticklabels(self):\n    ax = mat.heatmap(self.df_norm, fmt='.2f', annot=True, xticklabels=False, yticklabels=False)\n    for (val, text) in zip(self.x_norm.flat, ax.texts):\n        assert (text.get_text() == f'{val:.2f}')", "masked_code": "def test_heatmap_annotation_with_limited_ticklabels(self):\n    ax = mat.heatmap(self.df_norm, fmt='.2f', annot=True, xticklabels=False, yticklabels=False)\n    for (val, text) in zip(self.x_norm.flat, ax.texts):\n        assert (text.get_text() == '???')", "ground_truth": "f'{val:.2f}'", "quality_analysis": {"complexity_score": 3, "left_complexity": 3, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_664", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_axes", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_axes(self):\n    ax = mat.heatmap(self.df_norm)\n    xtl = [int(l.get_text()) for l in ax.get_xticklabels()]\n    assert (xtl == list(self.df_norm.columns))\n    ytl = [l.get_text() for l in ax.get_yticklabels()]\n    assert (ytl == list(self.df_norm.index))\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == 'letters')\n    assert (ax.get_xlim() == (0, 8))\n    assert (ax.get_ylim() == (4, 0))", "masked_code": "def test_heatmap_axes(self):\n    ax = mat.heatmap(self.df_norm)\n    xtl = [int(l.get_text()) for l in ax.get_xticklabels()]\n    assert (xtl == list(self.df_norm.columns))\n    ytl = [l.get_text() for l in ax.get_yticklabels()]\n    assert (ytl == list(self.df_norm.index))\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == '???')\n    assert (ax.get_xlim() == (0, 8))\n    assert (ax.get_ylim() == (4, 0))", "ground_truth": "'letters'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_665", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_axes", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_axes(self):\n    ax = mat.heatmap(self.df_norm)\n    xtl = [int(l.get_text()) for l in ax.get_xticklabels()]\n    assert (xtl == list(self.df_norm.columns))\n    ytl = [l.get_text() for l in ax.get_yticklabels()]\n    assert (ytl == list(self.df_norm.index))\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == 'letters')\n    assert (ax.get_xlim() == (0, 8))\n    assert (ax.get_ylim() == (4, 0))", "masked_code": "def test_heatmap_axes(self):\n    ax = mat.heatmap(self.df_norm)\n    xtl = [int(l.get_text()) for l in ax.get_xticklabels()]\n    assert (xtl == list(self.df_norm.columns))\n    ytl = [l.get_text() for l in ax.get_yticklabels()]\n    assert (ytl == list(self.df_norm.index))\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == 'letters')\n    assert (ax.get_xlim() == '???')\n    assert (ax.get_ylim() == (4, 0))", "ground_truth": "(0, 8)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_666", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_axes", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_axes(self):\n    ax = mat.heatmap(self.df_norm)\n    xtl = [int(l.get_text()) for l in ax.get_xticklabels()]\n    assert (xtl == list(self.df_norm.columns))\n    ytl = [l.get_text() for l in ax.get_yticklabels()]\n    assert (ytl == list(self.df_norm.index))\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == 'letters')\n    assert (ax.get_xlim() == (0, 8))\n    assert (ax.get_ylim() == (4, 0))", "masked_code": "def test_heatmap_axes(self):\n    ax = mat.heatmap(self.df_norm)\n    xtl = [int(l.get_text()) for l in ax.get_xticklabels()]\n    assert (xtl == list(self.df_norm.columns))\n    ytl = [l.get_text() for l in ax.get_yticklabels()]\n    assert (ytl == list(self.df_norm.index))\n    assert (ax.get_xlabel() == '')\n    assert (ax.get_ylabel() == 'letters')\n    assert (ax.get_xlim() == (0, 8))\n    assert (ax.get_ylim() == '???')", "ground_truth": "(4, 0)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_667", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_ticklabel_rotation", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_ticklabel_rotation(self):\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.heatmap(self.df_norm, xticklabels=1, yticklabels=1, ax=ax)\n    for t in ax.get_xticklabels():\n        assert (t.get_rotation() == 0)\n    for t in ax.get_yticklabels():\n        assert (t.get_rotation() == 90)\n    plt.close(f)\n    df = self.df_norm.copy()\n    df.columns = [(str(c) * 10) for c in df.columns]\n    df.index = [(i * 10) for i in df.index]\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.heatmap(df, xticklabels=1, yticklabels=1, ax=ax)\n    for t in ax.get_xticklabels():\n        assert (t.get_rotation() == 90)\n    for t in ax.get_yticklabels():\n        assert (t.get_rotation() == 0)\n    plt.close(f)", "masked_code": "def test_heatmap_ticklabel_rotation(self):\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.heatmap(self.df_norm, xticklabels=1, yticklabels=1, ax=ax)\n    for t in ax.get_xticklabels():\n        assert (t.get_rotation() == 0)\n    for t in ax.get_yticklabels():\n        assert (t.get_rotation() == '???')\n    plt.close(f)\n    df = self.df_norm.copy()\n    df.columns = [(str(c) * 10) for c in df.columns]\n    df.index = [(i * 10) for i in df.index]\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.heatmap(df, xticklabels=1, yticklabels=1, ax=ax)\n    for t in ax.get_xticklabels():\n        assert (t.get_rotation() == 90)\n    for t in ax.get_yticklabels():\n        assert (t.get_rotation() == 0)\n    plt.close(f)", "ground_truth": "90", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_668", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_ticklabel_rotation", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_ticklabel_rotation(self):\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.heatmap(self.df_norm, xticklabels=1, yticklabels=1, ax=ax)\n    for t in ax.get_xticklabels():\n        assert (t.get_rotation() == 0)\n    for t in ax.get_yticklabels():\n        assert (t.get_rotation() == 90)\n    plt.close(f)\n    df = self.df_norm.copy()\n    df.columns = [(str(c) * 10) for c in df.columns]\n    df.index = [(i * 10) for i in df.index]\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.heatmap(df, xticklabels=1, yticklabels=1, ax=ax)\n    for t in ax.get_xticklabels():\n        assert (t.get_rotation() == 90)\n    for t in ax.get_yticklabels():\n        assert (t.get_rotation() == 0)\n    plt.close(f)", "masked_code": "def test_heatmap_ticklabel_rotation(self):\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.heatmap(self.df_norm, xticklabels=1, yticklabels=1, ax=ax)\n    for t in ax.get_xticklabels():\n        assert (t.get_rotation() == 0)\n    for t in ax.get_yticklabels():\n        assert (t.get_rotation() == 90)\n    plt.close(f)\n    df = self.df_norm.copy()\n    df.columns = [(str(c) * 10) for c in df.columns]\n    df.index = [(i * 10) for i in df.index]\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.heatmap(df, xticklabels=1, yticklabels=1, ax=ax)\n    for t in ax.get_xticklabels():\n        assert (t.get_rotation() == '???')\n    for t in ax.get_yticklabels():\n        assert (t.get_rotation() == 0)\n    plt.close(f)", "ground_truth": "90", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_669", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_heatmap_inner_lines", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_heatmap_inner_lines(self):\n    c = (0, 0, 1, 1)\n    ax = mat.heatmap(self.df_norm, linewidths=2, linecolor=c)\n    mesh = ax.collections[0]\n    assert (mesh.get_linewidths()[0] == 2)\n    assert (tuple(mesh.get_edgecolor()[0]) == c)", "masked_code": "def test_heatmap_inner_lines(self):\n    c = (0, 0, 1, 1)\n    ax = mat.heatmap(self.df_norm, linewidths=2, linecolor=c)\n    mesh = ax.collections[0]\n    assert (mesh.get_linewidths()[0] == 2)\n    assert (tuple(mesh.get_edgecolor()[0]) == '???')", "ground_truth": "c", "quality_analysis": {"complexity_score": 11, "left_complexity": 10, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_670", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestHeatmap", "funcname": "test_mask_validation", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_mask_validation(self):\n    mask = mat._matrix_mask(self.df_norm, None)\n    assert (mask.shape == self.df_norm.shape)\n    assert (mask.values.sum() == 0)\n    with pytest.raises(ValueError):\n        bad_array_mask = (self.rs.randn(3, 6) > 0)\n        mat._matrix_mask(self.df_norm, bad_array_mask)\n    with pytest.raises(ValueError):\n        bad_df_mask = pd.DataFrame((self.rs.randn(4, 8) > 0))\n        mat._matrix_mask(self.df_norm, bad_df_mask)", "masked_code": "def test_mask_validation(self):\n    mask = mat._matrix_mask(self.df_norm, None)\n    assert (mask.shape == '???')\n    assert (mask.values.sum() == 0)\n    with pytest.raises(ValueError):\n        bad_array_mask = (self.rs.randn(3, 6) > 0)\n        mat._matrix_mask(self.df_norm, bad_array_mask)\n    with pytest.raises(ValueError):\n        bad_df_mask = pd.DataFrame((self.rs.randn(4, 8) > 0))\n        mat._matrix_mask(self.df_norm, bad_df_mask)", "ground_truth": "self.df_norm.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_671", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_ndarray_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_ndarray_input(self):\n    p = mat._DendrogramPlotter(self.x_norm, **self.default_kws)\n    npt.assert_array_equal(p.array.T, self.x_norm)\n    pdt.assert_frame_equal(p.data.T, pd.DataFrame(self.x_norm))\n    npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n    assert (p.dendrogram == self.x_norm_dendrogram)\n    npt.assert_array_equal(p.reordered_ind, self.x_norm_leaves)\n    npt.assert_array_equal(p.xticklabels, self.x_norm_leaves)\n    npt.assert_array_equal(p.yticklabels, [])\n    assert (p.xlabel is None)\n    assert (p.ylabel == '')", "masked_code": "def test_ndarray_input(self):\n    p = mat._DendrogramPlotter(self.x_norm, **self.default_kws)\n    npt.assert_array_equal(p.array.T, self.x_norm)\n    pdt.assert_frame_equal(p.data.T, pd.DataFrame(self.x_norm))\n    npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n    assert (p.dendrogram == '???')\n    npt.assert_array_equal(p.reordered_ind, self.x_norm_leaves)\n    npt.assert_array_equal(p.xticklabels, self.x_norm_leaves)\n    npt.assert_array_equal(p.yticklabels, [])\n    assert (p.xlabel is None)\n    assert (p.ylabel == '')", "ground_truth": "self.x_norm_dendrogram", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_672", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_df_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_df_input(self):\n    p = mat._DendrogramPlotter(self.df_norm, **self.default_kws)\n    npt.assert_array_equal(p.array.T, np.asarray(self.df_norm))\n    pdt.assert_frame_equal(p.data.T, self.df_norm)\n    npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n    assert (p.dendrogram == self.x_norm_dendrogram)\n    npt.assert_array_equal(p.xticklabels, np.asarray(self.df_norm.columns)[self.x_norm_leaves])\n    npt.assert_array_equal(p.yticklabels, [])\n    assert (p.xlabel == 'letters')\n    assert (p.ylabel == '')", "masked_code": "def test_df_input(self):\n    p = mat._DendrogramPlotter(self.df_norm, **self.default_kws)\n    npt.assert_array_equal(p.array.T, np.asarray(self.df_norm))\n    pdt.assert_frame_equal(p.data.T, self.df_norm)\n    npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n    assert (p.dendrogram == '???')\n    npt.assert_array_equal(p.xticklabels, np.asarray(self.df_norm.columns)[self.x_norm_leaves])\n    npt.assert_array_equal(p.yticklabels, [])\n    assert (p.xlabel == 'letters')\n    assert (p.ylabel == '')", "ground_truth": "self.x_norm_dendrogram", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_673", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_df_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_df_input(self):\n    p = mat._DendrogramPlotter(self.df_norm, **self.default_kws)\n    npt.assert_array_equal(p.array.T, np.asarray(self.df_norm))\n    pdt.assert_frame_equal(p.data.T, self.df_norm)\n    npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n    assert (p.dendrogram == self.x_norm_dendrogram)\n    npt.assert_array_equal(p.xticklabels, np.asarray(self.df_norm.columns)[self.x_norm_leaves])\n    npt.assert_array_equal(p.yticklabels, [])\n    assert (p.xlabel == 'letters')\n    assert (p.ylabel == '')", "masked_code": "def test_df_input(self):\n    p = mat._DendrogramPlotter(self.df_norm, **self.default_kws)\n    npt.assert_array_equal(p.array.T, np.asarray(self.df_norm))\n    pdt.assert_frame_equal(p.data.T, self.df_norm)\n    npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n    assert (p.dendrogram == self.x_norm_dendrogram)\n    npt.assert_array_equal(p.xticklabels, np.asarray(self.df_norm.columns)[self.x_norm_leaves])\n    npt.assert_array_equal(p.yticklabels, [])\n    assert (p.xlabel == '???')\n    assert (p.ylabel == '')", "ground_truth": "'letters'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_674", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_df_multindex_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_df_multindex_input(self):\n    df = self.df_norm.copy()\n    index = pd.MultiIndex.from_tuples([('A', 1), ('B', 2), ('C', 3), ('D', 4)], names=['letter', 'number'])\n    index.name = 'letter-number'\n    df.index = index\n    kws = self.default_kws.copy()\n    kws['label'] = True\n    p = mat._DendrogramPlotter(df.T, **kws)\n    xticklabels = ['A-1', 'B-2', 'C-3', 'D-4']\n    xticklabels = [xticklabels[i] for i in p.reordered_ind]\n    npt.assert_array_equal(p.xticklabels, xticklabels)\n    npt.assert_array_equal(p.yticklabels, [])\n    assert (p.xlabel == 'letter-number')", "masked_code": "def test_df_multindex_input(self):\n    df = self.df_norm.copy()\n    index = pd.MultiIndex.from_tuples([('A', 1), ('B', 2), ('C', 3), ('D', 4)], names=['letter', 'number'])\n    index.name = 'letter-number'\n    df.index = index\n    kws = self.default_kws.copy()\n    kws['label'] = True\n    p = mat._DendrogramPlotter(df.T, **kws)\n    xticklabels = ['A-1', 'B-2', 'C-3', 'D-4']\n    xticklabels = [xticklabels[i] for i in p.reordered_ind]\n    npt.assert_array_equal(p.xticklabels, xticklabels)\n    npt.assert_array_equal(p.yticklabels, [])\n    assert (p.xlabel == '???')", "ground_truth": "'letter-number'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_675", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_axis0_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_axis0_input(self):\n    kws = self.default_kws.copy()\n    kws['axis'] = 0\n    p = mat._DendrogramPlotter(self.df_norm.T, **kws)\n    npt.assert_array_equal(p.array, np.asarray(self.df_norm.T))\n    pdt.assert_frame_equal(p.data, self.df_norm.T)\n    npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n    assert (p.dendrogram == self.x_norm_dendrogram)\n    npt.assert_array_equal(p.xticklabels, self.df_norm_leaves)\n    npt.assert_array_equal(p.yticklabels, [])\n    assert (p.xlabel == 'letters')\n    assert (p.ylabel == '')", "masked_code": "def test_axis0_input(self):\n    kws = self.default_kws.copy()\n    kws['axis'] = 0\n    p = mat._DendrogramPlotter(self.df_norm.T, **kws)\n    npt.assert_array_equal(p.array, np.asarray(self.df_norm.T))\n    pdt.assert_frame_equal(p.data, self.df_norm.T)\n    npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n    assert (p.dendrogram == '???')\n    npt.assert_array_equal(p.xticklabels, self.df_norm_leaves)\n    npt.assert_array_equal(p.yticklabels, [])\n    assert (p.xlabel == 'letters')\n    assert (p.ylabel == '')", "ground_truth": "self.x_norm_dendrogram", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_676", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_axis0_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_axis0_input(self):\n    kws = self.default_kws.copy()\n    kws['axis'] = 0\n    p = mat._DendrogramPlotter(self.df_norm.T, **kws)\n    npt.assert_array_equal(p.array, np.asarray(self.df_norm.T))\n    pdt.assert_frame_equal(p.data, self.df_norm.T)\n    npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n    assert (p.dendrogram == self.x_norm_dendrogram)\n    npt.assert_array_equal(p.xticklabels, self.df_norm_leaves)\n    npt.assert_array_equal(p.yticklabels, [])\n    assert (p.xlabel == 'letters')\n    assert (p.ylabel == '')", "masked_code": "def test_axis0_input(self):\n    kws = self.default_kws.copy()\n    kws['axis'] = 0\n    p = mat._DendrogramPlotter(self.df_norm.T, **kws)\n    npt.assert_array_equal(p.array, np.asarray(self.df_norm.T))\n    pdt.assert_frame_equal(p.data, self.df_norm.T)\n    npt.assert_array_equal(p.linkage, self.x_norm_linkage)\n    assert (p.dendrogram == self.x_norm_dendrogram)\n    npt.assert_array_equal(p.xticklabels, self.df_norm_leaves)\n    npt.assert_array_equal(p.yticklabels, [])\n    assert (p.xlabel == '???')\n    assert (p.ylabel == '')", "ground_truth": "'letters'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_677", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_rotate_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_rotate_input(self):\n    kws = self.default_kws.copy()\n    kws['rotate'] = True\n    p = mat._DendrogramPlotter(self.df_norm, **kws)\n    npt.assert_array_equal(p.array.T, np.asarray(self.df_norm))\n    pdt.assert_frame_equal(p.data.T, self.df_norm)\n    npt.assert_array_equal(p.xticklabels, [])\n    npt.assert_array_equal(p.yticklabels, self.df_norm_leaves)\n    assert (p.xlabel == '')\n    assert (p.ylabel == 'letters')", "masked_code": "def test_rotate_input(self):\n    kws = self.default_kws.copy()\n    kws['rotate'] = True\n    p = mat._DendrogramPlotter(self.df_norm, **kws)\n    npt.assert_array_equal(p.array.T, np.asarray(self.df_norm))\n    pdt.assert_frame_equal(p.data.T, self.df_norm)\n    npt.assert_array_equal(p.xticklabels, [])\n    npt.assert_array_equal(p.yticklabels, self.df_norm_leaves)\n    assert (p.xlabel == '')\n    assert (p.ylabel == '???')", "ground_truth": "'letters'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_678", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_custom_linkage", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_custom_linkage(self):\n    kws = self.default_kws.copy()\n    try:\n        import fastcluster\n        linkage = fastcluster.linkage_vector(self.x_norm, method='single', metric='euclidean')\n    except ImportError:\n        d = distance.pdist(self.x_norm, metric='euclidean')\n        linkage = hierarchy.linkage(d, method='single')\n    dendrogram = hierarchy.dendrogram(linkage, no_plot=True, color_threshold=(- np.inf))\n    kws['linkage'] = linkage\n    p = mat._DendrogramPlotter(self.df_norm, **kws)\n    npt.assert_array_equal(p.linkage, linkage)\n    assert (p.dendrogram == dendrogram)", "masked_code": "def test_custom_linkage(self):\n    kws = self.default_kws.copy()\n    try:\n        import fastcluster\n        linkage = fastcluster.linkage_vector(self.x_norm, method='single', metric='euclidean')\n    except ImportError:\n        d = distance.pdist(self.x_norm, metric='euclidean')\n        linkage = hierarchy.linkage(d, method='single')\n    dendrogram = hierarchy.dendrogram(linkage, no_plot=True, color_threshold=(- np.inf))\n    kws['linkage'] = linkage\n    p = mat._DendrogramPlotter(self.df_norm, **kws)\n    npt.assert_array_equal(p.linkage, linkage)\n    assert (p.dendrogram == '???')", "ground_truth": "dendrogram", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_679", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_label_false", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_label_false(self):\n    kws = self.default_kws.copy()\n    kws['label'] = False\n    p = mat._DendrogramPlotter(self.df_norm, **kws)\n    assert (p.xticks == [])\n    assert (p.yticks == [])\n    assert (p.xticklabels == [])\n    assert (p.yticklabels == [])\n    assert (p.xlabel == '')\n    assert (p.ylabel == '')", "masked_code": "def test_label_false(self):\n    kws = self.default_kws.copy()\n    kws['label'] = False\n    p = mat._DendrogramPlotter(self.df_norm, **kws)\n    assert (p.xticks == '???')\n    assert (p.yticks == [])\n    assert (p.xticklabels == [])\n    assert (p.yticklabels == [])\n    assert (p.xlabel == '')\n    assert (p.ylabel == '')", "ground_truth": "[]", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_680", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_label_false", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_label_false(self):\n    kws = self.default_kws.copy()\n    kws['label'] = False\n    p = mat._DendrogramPlotter(self.df_norm, **kws)\n    assert (p.xticks == [])\n    assert (p.yticks == [])\n    assert (p.xticklabels == [])\n    assert (p.yticklabels == [])\n    assert (p.xlabel == '')\n    assert (p.ylabel == '')", "masked_code": "def test_label_false(self):\n    kws = self.default_kws.copy()\n    kws['label'] = False\n    p = mat._DendrogramPlotter(self.df_norm, **kws)\n    assert (p.xticks == [])\n    assert (p.yticks == '???')\n    assert (p.xticklabels == [])\n    assert (p.yticklabels == [])\n    assert (p.xlabel == '')\n    assert (p.ylabel == '')", "ground_truth": "[]", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_681", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_label_false", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_label_false(self):\n    kws = self.default_kws.copy()\n    kws['label'] = False\n    p = mat._DendrogramPlotter(self.df_norm, **kws)\n    assert (p.xticks == [])\n    assert (p.yticks == [])\n    assert (p.xticklabels == [])\n    assert (p.yticklabels == [])\n    assert (p.xlabel == '')\n    assert (p.ylabel == '')", "masked_code": "def test_label_false(self):\n    kws = self.default_kws.copy()\n    kws['label'] = False\n    p = mat._DendrogramPlotter(self.df_norm, **kws)\n    assert (p.xticks == [])\n    assert (p.yticks == [])\n    assert (p.xticklabels == '???')\n    assert (p.yticklabels == [])\n    assert (p.xlabel == '')\n    assert (p.ylabel == '')", "ground_truth": "[]", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_682", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_label_false", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_label_false(self):\n    kws = self.default_kws.copy()\n    kws['label'] = False\n    p = mat._DendrogramPlotter(self.df_norm, **kws)\n    assert (p.xticks == [])\n    assert (p.yticks == [])\n    assert (p.xticklabels == [])\n    assert (p.yticklabels == [])\n    assert (p.xlabel == '')\n    assert (p.ylabel == '')", "masked_code": "def test_label_false(self):\n    kws = self.default_kws.copy()\n    kws['label'] = False\n    p = mat._DendrogramPlotter(self.df_norm, **kws)\n    assert (p.xticks == [])\n    assert (p.yticks == [])\n    assert (p.xticklabels == [])\n    assert (p.yticklabels == '???')\n    assert (p.xlabel == '')\n    assert (p.ylabel == '')", "ground_truth": "[]", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_683", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_dendrogram_plot", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_dendrogram_plot(self):\n    d = mat.dendrogram(self.x_norm, **self.default_kws)\n    ax = plt.gca()\n    xlim = ax.get_xlim()\n    xmax = (len(d.reordered_ind) * 10)\n    assert (xlim[0] == 0)\n    assert (xlim[1] == xmax)\n    assert (len(ax.collections[0].get_paths()) == len(d.dependent_coord))", "masked_code": "def test_dendrogram_plot(self):\n    d = mat.dendrogram(self.x_norm, **self.default_kws)\n    ax = plt.gca()\n    xlim = ax.get_xlim()\n    xmax = (len(d.reordered_ind) * 10)\n    assert (xlim[0] == 0)\n    assert (xlim[1] == '???')\n    assert (len(ax.collections[0].get_paths()) == len(d.dependent_coord))", "ground_truth": "xmax", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_684", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_dendrogram_plot", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_dendrogram_plot(self):\n    d = mat.dendrogram(self.x_norm, **self.default_kws)\n    ax = plt.gca()\n    xlim = ax.get_xlim()\n    xmax = (len(d.reordered_ind) * 10)\n    assert (xlim[0] == 0)\n    assert (xlim[1] == xmax)\n    assert (len(ax.collections[0].get_paths()) == len(d.dependent_coord))", "masked_code": "def test_dendrogram_plot(self):\n    d = mat.dendrogram(self.x_norm, **self.default_kws)\n    ax = plt.gca()\n    xlim = ax.get_xlim()\n    xmax = (len(d.reordered_ind) * 10)\n    assert (xlim[0] == 0)\n    assert (xlim[1] == xmax)\n    assert (len(ax.collections[0].get_paths()) == '???')", "ground_truth": "len(d.dependent_coord)", "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_685", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_dendrogram_rotate", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_dendrogram_rotate(self):\n    kws = self.default_kws.copy()\n    kws['rotate'] = True\n    d = mat.dendrogram(self.x_norm, **kws)\n    ax = plt.gca()\n    ylim = ax.get_ylim()\n    ymax = (len(d.reordered_ind) * 10)\n    assert (ylim[1] == 0)\n    assert (ylim[0] == ymax)", "masked_code": "def test_dendrogram_rotate(self):\n    kws = self.default_kws.copy()\n    kws['rotate'] = True\n    d = mat.dendrogram(self.x_norm, **kws)\n    ax = plt.gca()\n    ylim = ax.get_ylim()\n    ymax = (len(d.reordered_ind) * 10)\n    assert (ylim[1] == 0)\n    assert (ylim[0] == '???')", "ground_truth": "ymax", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_686", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestDendrogram", "funcname": "test_dendrogram_ticklabel_rotation", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_dendrogram_ticklabel_rotation(self):\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.dendrogram(self.df_norm, ax=ax)\n    for t in ax.get_xticklabels():\n        assert (t.get_rotation() == 0)\n    plt.close(f)\n    df = self.df_norm.copy()\n    df.columns = [(str(c) * 10) for c in df.columns]\n    df.index = [(i * 10) for i in df.index]\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.dendrogram(df, ax=ax)\n    for t in ax.get_xticklabels():\n        assert (t.get_rotation() == 90)\n    plt.close(f)\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.dendrogram(df.T, axis=0, rotate=True)\n    for t in ax.get_yticklabels():\n        assert (t.get_rotation() == 0)\n    plt.close(f)", "masked_code": "def test_dendrogram_ticklabel_rotation(self):\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.dendrogram(self.df_norm, ax=ax)\n    for t in ax.get_xticklabels():\n        assert (t.get_rotation() == 0)\n    plt.close(f)\n    df = self.df_norm.copy()\n    df.columns = [(str(c) * 10) for c in df.columns]\n    df.index = [(i * 10) for i in df.index]\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.dendrogram(df, ax=ax)\n    for t in ax.get_xticklabels():\n        assert (t.get_rotation() == '???')\n    plt.close(f)\n    (f, ax) = plt.subplots(figsize=(2, 2))\n    mat.dendrogram(df.T, axis=0, rotate=True)\n    for t in ax.get_yticklabels():\n        assert (t.get_rotation() == 0)\n    plt.close(f)", "ground_truth": "90", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_687", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_ndarray_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_ndarray_input(self):\n    cg = mat.ClusterGrid(self.x_norm, **self.default_kws)\n    pdt.assert_frame_equal(cg.data, pd.DataFrame(self.x_norm))\n    assert (len(cg.fig.axes) == 4)\n    assert (cg.ax_row_colors is None)\n    assert (cg.ax_col_colors is None)", "masked_code": "def test_ndarray_input(self):\n    cg = mat.ClusterGrid(self.x_norm, **self.default_kws)\n    pdt.assert_frame_equal(cg.data, pd.DataFrame(self.x_norm))\n    assert (len(cg.fig.axes) == '???')\n    assert (cg.ax_row_colors is None)\n    assert (cg.ax_col_colors is None)", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_688", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_colors_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_colors_input(self):\n    kws = self.default_kws.copy()\n    kws['row_colors'] = self.row_colors\n    kws['col_colors'] = self.col_colors\n    cg = mat.ClusterGrid(self.df_norm, **kws)\n    npt.assert_array_equal(cg.row_colors, self.row_colors)\n    npt.assert_array_equal(cg.col_colors, self.col_colors)\n    assert (len(cg.fig.axes) == 6)", "masked_code": "def test_colors_input(self):\n    kws = self.default_kws.copy()\n    kws['row_colors'] = self.row_colors\n    kws['col_colors'] = self.col_colors\n    cg = mat.ClusterGrid(self.df_norm, **kws)\n    npt.assert_array_equal(cg.row_colors, self.row_colors)\n    npt.assert_array_equal(cg.col_colors, self.col_colors)\n    assert (len(cg.fig.axes) == '???')", "ground_truth": "6", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_689", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_categorical_colors_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_categorical_colors_input(self):\n    kws = self.default_kws.copy()\n    row_colors = pd.Series(self.row_colors, dtype='category')\n    col_colors = pd.Series(self.col_colors, dtype='category', index=self.df_norm.columns)\n    kws['row_colors'] = row_colors\n    kws['col_colors'] = col_colors\n    exp_row_colors = list(map(mpl.colors.to_rgb, row_colors))\n    exp_col_colors = list(map(mpl.colors.to_rgb, col_colors))\n    cg = mat.ClusterGrid(self.df_norm, **kws)\n    npt.assert_array_equal(cg.row_colors, exp_row_colors)\n    npt.assert_array_equal(cg.col_colors, exp_col_colors)\n    assert (len(cg.fig.axes) == 6)", "masked_code": "def test_categorical_colors_input(self):\n    kws = self.default_kws.copy()\n    row_colors = pd.Series(self.row_colors, dtype='category')\n    col_colors = pd.Series(self.col_colors, dtype='category', index=self.df_norm.columns)\n    kws['row_colors'] = row_colors\n    kws['col_colors'] = col_colors\n    exp_row_colors = list(map(mpl.colors.to_rgb, row_colors))\n    exp_col_colors = list(map(mpl.colors.to_rgb, col_colors))\n    cg = mat.ClusterGrid(self.df_norm, **kws)\n    npt.assert_array_equal(cg.row_colors, exp_row_colors)\n    npt.assert_array_equal(cg.col_colors, exp_col_colors)\n    assert (len(cg.fig.axes) == '???')", "ground_truth": "6", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_690", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_nested_colors_input", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_nested_colors_input(self):\n    kws = self.default_kws.copy()\n    row_colors = [self.row_colors, self.row_colors]\n    col_colors = [self.col_colors, self.col_colors]\n    kws['row_colors'] = row_colors\n    kws['col_colors'] = col_colors\n    cm = mat.ClusterGrid(self.df_norm, **kws)\n    npt.assert_array_equal(cm.row_colors, row_colors)\n    npt.assert_array_equal(cm.col_colors, col_colors)\n    assert (len(cm.fig.axes) == 6)", "masked_code": "def test_nested_colors_input(self):\n    kws = self.default_kws.copy()\n    row_colors = [self.row_colors, self.row_colors]\n    col_colors = [self.col_colors, self.col_colors]\n    kws['row_colors'] = row_colors\n    kws['col_colors'] = col_colors\n    cm = mat.ClusterGrid(self.df_norm, **kws)\n    npt.assert_array_equal(cm.row_colors, row_colors)\n    npt.assert_array_equal(cm.col_colors, col_colors)\n    assert (len(cm.fig.axes) == '???')", "ground_truth": "6", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_691", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_colors_input_custom_cmap", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_colors_input_custom_cmap(self):\n    kws = self.default_kws.copy()\n    kws['cmap'] = mpl.cm.PRGn\n    kws['row_colors'] = self.row_colors\n    kws['col_colors'] = self.col_colors\n    cg = mat.clustermap(self.df_norm, **kws)\n    npt.assert_array_equal(cg.row_colors, self.row_colors)\n    npt.assert_array_equal(cg.col_colors, self.col_colors)\n    assert (len(cg.fig.axes) == 6)", "masked_code": "def test_colors_input_custom_cmap(self):\n    kws = self.default_kws.copy()\n    kws['cmap'] = mpl.cm.PRGn\n    kws['row_colors'] = self.row_colors\n    kws['col_colors'] = self.col_colors\n    cg = mat.clustermap(self.df_norm, **kws)\n    npt.assert_array_equal(cg.row_colors, self.row_colors)\n    npt.assert_array_equal(cg.col_colors, self.col_colors)\n    assert (len(cg.fig.axes) == '???')", "ground_truth": "6", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_692", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_plot_dendrograms", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_plot_dendrograms(self):\n    cm = mat.clustermap(self.df_norm, **self.default_kws)\n    assert (len(cm.ax_row_dendrogram.collections[0].get_paths()) == len(cm.dendrogram_row.independent_coord))\n    assert (len(cm.ax_col_dendrogram.collections[0].get_paths()) == len(cm.dendrogram_col.independent_coord))\n    data2d = self.df_norm.iloc[(cm.dendrogram_row.reordered_ind, cm.dendrogram_col.reordered_ind)]\n    pdt.assert_frame_equal(cm.data2d, data2d)", "masked_code": "def test_plot_dendrograms(self):\n    cm = mat.clustermap(self.df_norm, **self.default_kws)\n    assert (len(cm.ax_row_dendrogram.collections[0].get_paths()) == '???')\n    assert (len(cm.ax_col_dendrogram.collections[0].get_paths()) == len(cm.dendrogram_col.independent_coord))\n    data2d = self.df_norm.iloc[(cm.dendrogram_row.reordered_ind, cm.dendrogram_col.reordered_ind)]\n    pdt.assert_frame_equal(cm.data2d, data2d)", "ground_truth": "len(cm.dendrogram_row.independent_coord)", "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_693", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_plot_dendrograms", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_plot_dendrograms(self):\n    cm = mat.clustermap(self.df_norm, **self.default_kws)\n    assert (len(cm.ax_row_dendrogram.collections[0].get_paths()) == len(cm.dendrogram_row.independent_coord))\n    assert (len(cm.ax_col_dendrogram.collections[0].get_paths()) == len(cm.dendrogram_col.independent_coord))\n    data2d = self.df_norm.iloc[(cm.dendrogram_row.reordered_ind, cm.dendrogram_col.reordered_ind)]\n    pdt.assert_frame_equal(cm.data2d, data2d)", "masked_code": "def test_plot_dendrograms(self):\n    cm = mat.clustermap(self.df_norm, **self.default_kws)\n    assert (len(cm.ax_row_dendrogram.collections[0].get_paths()) == len(cm.dendrogram_row.independent_coord))\n    assert (len(cm.ax_col_dendrogram.collections[0].get_paths()) == '???')\n    data2d = self.df_norm.iloc[(cm.dendrogram_row.reordered_ind, cm.dendrogram_col.reordered_ind)]\n    pdt.assert_frame_equal(cm.data2d, data2d)", "ground_truth": "len(cm.dendrogram_col.independent_coord)", "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_694", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_df", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_df(self):\n    kws = self.default_kws.copy()\n    kws['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors), 'row_2': list(self.row_colors)}, index=self.df_norm.index, columns=['row_1', 'row_2'])\n    kws['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors), 'col_2': list(self.col_colors)}, index=self.df_norm.columns, columns=['col_1', 'col_2'])\n    cm = mat.clustermap(self.df_norm, **kws)\n    row_labels = [l.get_text() for l in cm.ax_row_colors.get_xticklabels()]\n    assert (cm.row_color_labels == ['row_1', 'row_2'])\n    assert (row_labels == cm.row_color_labels)\n    col_labels = [l.get_text() for l in cm.ax_col_colors.get_yticklabels()]\n    assert (cm.col_color_labels == ['col_1', 'col_2'])\n    assert (col_labels == cm.col_color_labels)", "masked_code": "def test_row_col_colors_df(self):\n    kws = self.default_kws.copy()\n    kws['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors), 'row_2': list(self.row_colors)}, index=self.df_norm.index, columns=['row_1', 'row_2'])\n    kws['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors), 'col_2': list(self.col_colors)}, index=self.df_norm.columns, columns=['col_1', 'col_2'])\n    cm = mat.clustermap(self.df_norm, **kws)\n    row_labels = [l.get_text() for l in cm.ax_row_colors.get_xticklabels()]\n    assert (cm.row_color_labels == '???')\n    assert (row_labels == cm.row_color_labels)\n    col_labels = [l.get_text() for l in cm.ax_col_colors.get_yticklabels()]\n    assert (cm.col_color_labels == ['col_1', 'col_2'])\n    assert (col_labels == cm.col_color_labels)", "ground_truth": "['row_1', 'row_2']", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_695", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_df", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_df(self):\n    kws = self.default_kws.copy()\n    kws['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors), 'row_2': list(self.row_colors)}, index=self.df_norm.index, columns=['row_1', 'row_2'])\n    kws['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors), 'col_2': list(self.col_colors)}, index=self.df_norm.columns, columns=['col_1', 'col_2'])\n    cm = mat.clustermap(self.df_norm, **kws)\n    row_labels = [l.get_text() for l in cm.ax_row_colors.get_xticklabels()]\n    assert (cm.row_color_labels == ['row_1', 'row_2'])\n    assert (row_labels == cm.row_color_labels)\n    col_labels = [l.get_text() for l in cm.ax_col_colors.get_yticklabels()]\n    assert (cm.col_color_labels == ['col_1', 'col_2'])\n    assert (col_labels == cm.col_color_labels)", "masked_code": "def test_row_col_colors_df(self):\n    kws = self.default_kws.copy()\n    kws['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors), 'row_2': list(self.row_colors)}, index=self.df_norm.index, columns=['row_1', 'row_2'])\n    kws['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors), 'col_2': list(self.col_colors)}, index=self.df_norm.columns, columns=['col_1', 'col_2'])\n    cm = mat.clustermap(self.df_norm, **kws)\n    row_labels = [l.get_text() for l in cm.ax_row_colors.get_xticklabels()]\n    assert (cm.row_color_labels == ['row_1', 'row_2'])\n    assert (row_labels == cm.row_color_labels)\n    col_labels = [l.get_text() for l in cm.ax_col_colors.get_yticklabels()]\n    assert (cm.col_color_labels == '???')\n    assert (col_labels == cm.col_color_labels)", "ground_truth": "['col_1', 'col_2']", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_696", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_df_shuffled", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_df_shuffled(self):\n    (m, n) = self.df_norm.shape\n    shuffled_inds = [self.df_norm.index[i] for i in (list(range(0, m, 2)) + list(range(1, m, 2)))]\n    shuffled_cols = [self.df_norm.columns[i] for i in (list(range(0, n, 2)) + list(range(1, n, 2)))]\n    kws = self.default_kws.copy()\n    row_colors = pd.DataFrame({'row_annot': list(self.row_colors)}, index=self.df_norm.index)\n    kws['row_colors'] = row_colors.loc[shuffled_inds]\n    col_colors = pd.DataFrame({'col_annot': list(self.col_colors)}, index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.loc[shuffled_cols]\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors)[0] == list(self.col_colors))\n    assert (list(cm.row_colors)[0] == list(self.row_colors))", "masked_code": "def test_row_col_colors_df_shuffled(self):\n    (m, n) = self.df_norm.shape\n    shuffled_inds = [self.df_norm.index[i] for i in (list(range(0, m, 2)) + list(range(1, m, 2)))]\n    shuffled_cols = [self.df_norm.columns[i] for i in (list(range(0, n, 2)) + list(range(1, n, 2)))]\n    kws = self.default_kws.copy()\n    row_colors = pd.DataFrame({'row_annot': list(self.row_colors)}, index=self.df_norm.index)\n    kws['row_colors'] = row_colors.loc[shuffled_inds]\n    col_colors = pd.DataFrame({'col_annot': list(self.col_colors)}, index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.loc[shuffled_cols]\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors)[0] == '???')\n    assert (list(cm.row_colors)[0] == list(self.row_colors))", "ground_truth": "list(self.col_colors)", "quality_analysis": {"complexity_score": 14, "left_complexity": 9, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_697", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_df_shuffled", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_df_shuffled(self):\n    (m, n) = self.df_norm.shape\n    shuffled_inds = [self.df_norm.index[i] for i in (list(range(0, m, 2)) + list(range(1, m, 2)))]\n    shuffled_cols = [self.df_norm.columns[i] for i in (list(range(0, n, 2)) + list(range(1, n, 2)))]\n    kws = self.default_kws.copy()\n    row_colors = pd.DataFrame({'row_annot': list(self.row_colors)}, index=self.df_norm.index)\n    kws['row_colors'] = row_colors.loc[shuffled_inds]\n    col_colors = pd.DataFrame({'col_annot': list(self.col_colors)}, index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.loc[shuffled_cols]\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors)[0] == list(self.col_colors))\n    assert (list(cm.row_colors)[0] == list(self.row_colors))", "masked_code": "def test_row_col_colors_df_shuffled(self):\n    (m, n) = self.df_norm.shape\n    shuffled_inds = [self.df_norm.index[i] for i in (list(range(0, m, 2)) + list(range(1, m, 2)))]\n    shuffled_cols = [self.df_norm.columns[i] for i in (list(range(0, n, 2)) + list(range(1, n, 2)))]\n    kws = self.default_kws.copy()\n    row_colors = pd.DataFrame({'row_annot': list(self.row_colors)}, index=self.df_norm.index)\n    kws['row_colors'] = row_colors.loc[shuffled_inds]\n    col_colors = pd.DataFrame({'col_annot': list(self.col_colors)}, index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.loc[shuffled_cols]\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors)[0] == list(self.col_colors))\n    assert (list(cm.row_colors)[0] == '???')", "ground_truth": "list(self.row_colors)", "quality_analysis": {"complexity_score": 14, "left_complexity": 9, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_698", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_df_missing", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_df_missing(self):\n    kws = self.default_kws.copy()\n    row_colors = pd.DataFrame({'row_annot': list(self.row_colors)}, index=self.df_norm.index)\n    kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n    col_colors = pd.DataFrame({'col_annot': list(self.col_colors)}, index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors)[0] == ([(1.0, 1.0, 1.0)] + list(self.col_colors[1:])))\n    assert (list(cm.row_colors)[0] == ([(1.0, 1.0, 1.0)] + list(self.row_colors[1:])))", "masked_code": "def test_row_col_colors_df_missing(self):\n    kws = self.default_kws.copy()\n    row_colors = pd.DataFrame({'row_annot': list(self.row_colors)}, index=self.df_norm.index)\n    kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n    col_colors = pd.DataFrame({'col_annot': list(self.col_colors)}, index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors)[0] == '???')\n    assert (list(cm.row_colors)[0] == ([(1.0, 1.0, 1.0)] + list(self.row_colors[1:])))", "ground_truth": "([(1.0, 1.0, 1.0)] + list(self.col_colors[1:]))", "quality_analysis": {"complexity_score": 26, "left_complexity": 9, "right_complexity": 17, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_699", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_df_missing", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_df_missing(self):\n    kws = self.default_kws.copy()\n    row_colors = pd.DataFrame({'row_annot': list(self.row_colors)}, index=self.df_norm.index)\n    kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n    col_colors = pd.DataFrame({'col_annot': list(self.col_colors)}, index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors)[0] == ([(1.0, 1.0, 1.0)] + list(self.col_colors[1:])))\n    assert (list(cm.row_colors)[0] == ([(1.0, 1.0, 1.0)] + list(self.row_colors[1:])))", "masked_code": "def test_row_col_colors_df_missing(self):\n    kws = self.default_kws.copy()\n    row_colors = pd.DataFrame({'row_annot': list(self.row_colors)}, index=self.df_norm.index)\n    kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n    col_colors = pd.DataFrame({'col_annot': list(self.col_colors)}, index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors)[0] == ([(1.0, 1.0, 1.0)] + list(self.col_colors[1:])))\n    assert (list(cm.row_colors)[0] == '???')", "ground_truth": "([(1.0, 1.0, 1.0)] + list(self.row_colors[1:]))", "quality_analysis": {"complexity_score": 26, "left_complexity": 9, "right_complexity": 17, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_700", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_df_one_axis", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_df_one_axis(self):\n    kws1 = self.default_kws.copy()\n    kws1['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors), 'row_2': list(self.row_colors)}, index=self.df_norm.index, columns=['row_1', 'row_2'])\n    cm1 = mat.clustermap(self.df_norm, **kws1)\n    row_labels = [l.get_text() for l in cm1.ax_row_colors.get_xticklabels()]\n    assert (cm1.row_color_labels == ['row_1', 'row_2'])\n    assert (row_labels == cm1.row_color_labels)\n    kws2 = self.default_kws.copy()\n    kws2['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors), 'col_2': list(self.col_colors)}, index=self.df_norm.columns, columns=['col_1', 'col_2'])\n    cm2 = mat.clustermap(self.df_norm, **kws2)\n    col_labels = [l.get_text() for l in cm2.ax_col_colors.get_yticklabels()]\n    assert (cm2.col_color_labels == ['col_1', 'col_2'])\n    assert (col_labels == cm2.col_color_labels)", "masked_code": "def test_row_col_colors_df_one_axis(self):\n    kws1 = self.default_kws.copy()\n    kws1['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors), 'row_2': list(self.row_colors)}, index=self.df_norm.index, columns=['row_1', 'row_2'])\n    cm1 = mat.clustermap(self.df_norm, **kws1)\n    row_labels = [l.get_text() for l in cm1.ax_row_colors.get_xticklabels()]\n    assert (cm1.row_color_labels == '???')\n    assert (row_labels == cm1.row_color_labels)\n    kws2 = self.default_kws.copy()\n    kws2['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors), 'col_2': list(self.col_colors)}, index=self.df_norm.columns, columns=['col_1', 'col_2'])\n    cm2 = mat.clustermap(self.df_norm, **kws2)\n    col_labels = [l.get_text() for l in cm2.ax_col_colors.get_yticklabels()]\n    assert (cm2.col_color_labels == ['col_1', 'col_2'])\n    assert (col_labels == cm2.col_color_labels)", "ground_truth": "['row_1', 'row_2']", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_701", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_df_one_axis", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_df_one_axis(self):\n    kws1 = self.default_kws.copy()\n    kws1['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors), 'row_2': list(self.row_colors)}, index=self.df_norm.index, columns=['row_1', 'row_2'])\n    cm1 = mat.clustermap(self.df_norm, **kws1)\n    row_labels = [l.get_text() for l in cm1.ax_row_colors.get_xticklabels()]\n    assert (cm1.row_color_labels == ['row_1', 'row_2'])\n    assert (row_labels == cm1.row_color_labels)\n    kws2 = self.default_kws.copy()\n    kws2['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors), 'col_2': list(self.col_colors)}, index=self.df_norm.columns, columns=['col_1', 'col_2'])\n    cm2 = mat.clustermap(self.df_norm, **kws2)\n    col_labels = [l.get_text() for l in cm2.ax_col_colors.get_yticklabels()]\n    assert (cm2.col_color_labels == ['col_1', 'col_2'])\n    assert (col_labels == cm2.col_color_labels)", "masked_code": "def test_row_col_colors_df_one_axis(self):\n    kws1 = self.default_kws.copy()\n    kws1['row_colors'] = pd.DataFrame({'row_1': list(self.row_colors), 'row_2': list(self.row_colors)}, index=self.df_norm.index, columns=['row_1', 'row_2'])\n    cm1 = mat.clustermap(self.df_norm, **kws1)\n    row_labels = [l.get_text() for l in cm1.ax_row_colors.get_xticklabels()]\n    assert (cm1.row_color_labels == ['row_1', 'row_2'])\n    assert (row_labels == cm1.row_color_labels)\n    kws2 = self.default_kws.copy()\n    kws2['col_colors'] = pd.DataFrame({'col_1': list(self.col_colors), 'col_2': list(self.col_colors)}, index=self.df_norm.columns, columns=['col_1', 'col_2'])\n    cm2 = mat.clustermap(self.df_norm, **kws2)\n    col_labels = [l.get_text() for l in cm2.ax_col_colors.get_yticklabels()]\n    assert (cm2.col_color_labels == '???')\n    assert (col_labels == cm2.col_color_labels)", "ground_truth": "['col_1', 'col_2']", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_702", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_series", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_series(self):\n    kws = self.default_kws.copy()\n    kws['row_colors'] = pd.Series(list(self.row_colors), name='row_annot', index=self.df_norm.index)\n    kws['col_colors'] = pd.Series(list(self.col_colors), name='col_annot', index=self.df_norm.columns)\n    cm = mat.clustermap(self.df_norm, **kws)\n    row_labels = [l.get_text() for l in cm.ax_row_colors.get_xticklabels()]\n    assert (cm.row_color_labels == ['row_annot'])\n    assert (row_labels == cm.row_color_labels)\n    col_labels = [l.get_text() for l in cm.ax_col_colors.get_yticklabels()]\n    assert (cm.col_color_labels == ['col_annot'])\n    assert (col_labels == cm.col_color_labels)", "masked_code": "def test_row_col_colors_series(self):\n    kws = self.default_kws.copy()\n    kws['row_colors'] = pd.Series(list(self.row_colors), name='row_annot', index=self.df_norm.index)\n    kws['col_colors'] = pd.Series(list(self.col_colors), name='col_annot', index=self.df_norm.columns)\n    cm = mat.clustermap(self.df_norm, **kws)\n    row_labels = [l.get_text() for l in cm.ax_row_colors.get_xticklabels()]\n    assert (cm.row_color_labels == '???')\n    assert (row_labels == cm.row_color_labels)\n    col_labels = [l.get_text() for l in cm.ax_col_colors.get_yticklabels()]\n    assert (cm.col_color_labels == ['col_annot'])\n    assert (col_labels == cm.col_color_labels)", "ground_truth": "['row_annot']", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_703", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_series", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_series(self):\n    kws = self.default_kws.copy()\n    kws['row_colors'] = pd.Series(list(self.row_colors), name='row_annot', index=self.df_norm.index)\n    kws['col_colors'] = pd.Series(list(self.col_colors), name='col_annot', index=self.df_norm.columns)\n    cm = mat.clustermap(self.df_norm, **kws)\n    row_labels = [l.get_text() for l in cm.ax_row_colors.get_xticklabels()]\n    assert (cm.row_color_labels == ['row_annot'])\n    assert (row_labels == cm.row_color_labels)\n    col_labels = [l.get_text() for l in cm.ax_col_colors.get_yticklabels()]\n    assert (cm.col_color_labels == ['col_annot'])\n    assert (col_labels == cm.col_color_labels)", "masked_code": "def test_row_col_colors_series(self):\n    kws = self.default_kws.copy()\n    kws['row_colors'] = pd.Series(list(self.row_colors), name='row_annot', index=self.df_norm.index)\n    kws['col_colors'] = pd.Series(list(self.col_colors), name='col_annot', index=self.df_norm.columns)\n    cm = mat.clustermap(self.df_norm, **kws)\n    row_labels = [l.get_text() for l in cm.ax_row_colors.get_xticklabels()]\n    assert (cm.row_color_labels == ['row_annot'])\n    assert (row_labels == cm.row_color_labels)\n    col_labels = [l.get_text() for l in cm.ax_col_colors.get_yticklabels()]\n    assert (cm.col_color_labels == '???')\n    assert (col_labels == cm.col_color_labels)", "ground_truth": "['col_annot']", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_704", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_series_shuffled", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_series_shuffled(self):\n    (m, n) = self.df_norm.shape\n    shuffled_inds = [self.df_norm.index[i] for i in (list(range(0, m, 2)) + list(range(1, m, 2)))]\n    shuffled_cols = [self.df_norm.columns[i] for i in (list(range(0, n, 2)) + list(range(1, n, 2)))]\n    kws = self.default_kws.copy()\n    row_colors = pd.Series(list(self.row_colors), name='row_annot', index=self.df_norm.index)\n    kws['row_colors'] = row_colors.loc[shuffled_inds]\n    col_colors = pd.Series(list(self.col_colors), name='col_annot', index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.loc[shuffled_cols]\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors) == list(self.col_colors))\n    assert (list(cm.row_colors) == list(self.row_colors))", "masked_code": "def test_row_col_colors_series_shuffled(self):\n    (m, n) = self.df_norm.shape\n    shuffled_inds = [self.df_norm.index[i] for i in (list(range(0, m, 2)) + list(range(1, m, 2)))]\n    shuffled_cols = [self.df_norm.columns[i] for i in (list(range(0, n, 2)) + list(range(1, n, 2)))]\n    kws = self.default_kws.copy()\n    row_colors = pd.Series(list(self.row_colors), name='row_annot', index=self.df_norm.index)\n    kws['row_colors'] = row_colors.loc[shuffled_inds]\n    col_colors = pd.Series(list(self.col_colors), name='col_annot', index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.loc[shuffled_cols]\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors) == '???')\n    assert (list(cm.row_colors) == list(self.row_colors))", "ground_truth": "list(self.col_colors)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_705", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_series_shuffled", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_series_shuffled(self):\n    (m, n) = self.df_norm.shape\n    shuffled_inds = [self.df_norm.index[i] for i in (list(range(0, m, 2)) + list(range(1, m, 2)))]\n    shuffled_cols = [self.df_norm.columns[i] for i in (list(range(0, n, 2)) + list(range(1, n, 2)))]\n    kws = self.default_kws.copy()\n    row_colors = pd.Series(list(self.row_colors), name='row_annot', index=self.df_norm.index)\n    kws['row_colors'] = row_colors.loc[shuffled_inds]\n    col_colors = pd.Series(list(self.col_colors), name='col_annot', index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.loc[shuffled_cols]\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors) == list(self.col_colors))\n    assert (list(cm.row_colors) == list(self.row_colors))", "masked_code": "def test_row_col_colors_series_shuffled(self):\n    (m, n) = self.df_norm.shape\n    shuffled_inds = [self.df_norm.index[i] for i in (list(range(0, m, 2)) + list(range(1, m, 2)))]\n    shuffled_cols = [self.df_norm.columns[i] for i in (list(range(0, n, 2)) + list(range(1, n, 2)))]\n    kws = self.default_kws.copy()\n    row_colors = pd.Series(list(self.row_colors), name='row_annot', index=self.df_norm.index)\n    kws['row_colors'] = row_colors.loc[shuffled_inds]\n    col_colors = pd.Series(list(self.col_colors), name='col_annot', index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.loc[shuffled_cols]\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors) == list(self.col_colors))\n    assert (list(cm.row_colors) == '???')", "ground_truth": "list(self.row_colors)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_706", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_series_missing", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_series_missing(self):\n    kws = self.default_kws.copy()\n    row_colors = pd.Series(list(self.row_colors), name='row_annot', index=self.df_norm.index)\n    kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n    col_colors = pd.Series(list(self.col_colors), name='col_annot', index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors) == ([(1.0, 1.0, 1.0)] + list(self.col_colors[1:])))\n    assert (list(cm.row_colors) == ([(1.0, 1.0, 1.0)] + list(self.row_colors[1:])))", "masked_code": "def test_row_col_colors_series_missing(self):\n    kws = self.default_kws.copy()\n    row_colors = pd.Series(list(self.row_colors), name='row_annot', index=self.df_norm.index)\n    kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n    col_colors = pd.Series(list(self.col_colors), name='col_annot', index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors) == '???')\n    assert (list(cm.row_colors) == ([(1.0, 1.0, 1.0)] + list(self.row_colors[1:])))", "ground_truth": "([(1.0, 1.0, 1.0)] + list(self.col_colors[1:]))", "quality_analysis": {"complexity_score": 22, "left_complexity": 5, "right_complexity": 17, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_707", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_row_col_colors_series_missing", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_row_col_colors_series_missing(self):\n    kws = self.default_kws.copy()\n    row_colors = pd.Series(list(self.row_colors), name='row_annot', index=self.df_norm.index)\n    kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n    col_colors = pd.Series(list(self.col_colors), name='col_annot', index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors) == ([(1.0, 1.0, 1.0)] + list(self.col_colors[1:])))\n    assert (list(cm.row_colors) == ([(1.0, 1.0, 1.0)] + list(self.row_colors[1:])))", "masked_code": "def test_row_col_colors_series_missing(self):\n    kws = self.default_kws.copy()\n    row_colors = pd.Series(list(self.row_colors), name='row_annot', index=self.df_norm.index)\n    kws['row_colors'] = row_colors.drop(self.df_norm.index[0])\n    col_colors = pd.Series(list(self.col_colors), name='col_annot', index=self.df_norm.columns)\n    kws['col_colors'] = col_colors.drop(self.df_norm.columns[0])\n    cm = mat.clustermap(self.df_norm, **kws)\n    assert (list(cm.col_colors) == ([(1.0, 1.0, 1.0)] + list(self.col_colors[1:])))\n    assert (list(cm.row_colors) == '???')", "ground_truth": "([(1.0, 1.0, 1.0)] + list(self.row_colors[1:]))", "quality_analysis": {"complexity_score": 22, "left_complexity": 5, "right_complexity": 17, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_708", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_size_ratios", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_size_ratios(self):\n    kws1 = self.default_kws.copy()\n    kws1.update(dendrogram_ratio=0.2, colors_ratio=0.03, col_colors=self.col_colors, row_colors=self.row_colors)\n    kws2 = kws1.copy()\n    kws2.update(dendrogram_ratio=0.3, colors_ratio=0.05)\n    g1 = mat.clustermap(self.df_norm, **kws1)\n    g2 = mat.clustermap(self.df_norm, **kws2)\n    assert (g2.ax_col_dendrogram.get_position().height > g1.ax_col_dendrogram.get_position().height)\n    assert (g2.ax_col_colors.get_position().height > g1.ax_col_colors.get_position().height)\n    assert (g2.ax_heatmap.get_position().height < g1.ax_heatmap.get_position().height)\n    assert (g2.ax_row_dendrogram.get_position().width > g1.ax_row_dendrogram.get_position().width)\n    assert (g2.ax_row_colors.get_position().width > g1.ax_row_colors.get_position().width)\n    assert (g2.ax_heatmap.get_position().width < g1.ax_heatmap.get_position().width)\n    kws1 = self.default_kws.copy()\n    kws1.update(col_colors=self.col_colors)\n    kws2 = kws1.copy()\n    kws2.update(col_colors=[self.col_colors, self.col_colors])\n    g1 = mat.clustermap(self.df_norm, **kws1)\n    g2 = mat.clustermap(self.df_norm, **kws2)\n    assert (g2.ax_col_colors.get_position().height > g1.ax_col_colors.get_position().height)\n    kws1 = self.default_kws.copy()\n    kws1.update(dendrogram_ratio=(0.2, 0.2))\n    kws2 = kws1.copy()\n    kws2.update(dendrogram_ratio=(0.2, 0.3))\n    g1 = mat.clustermap(self.df_norm, **kws1)\n    g2 = mat.clustermap(self.df_norm, **kws2)\n    assert (g1.gs.get_width_ratios() == g2.gs.get_width_ratios())\n    assert (g2.ax_col_dendrogram.get_position().height > g1.ax_col_dendrogram.get_position().height)", "masked_code": "def test_size_ratios(self):\n    kws1 = self.default_kws.copy()\n    kws1.update(dendrogram_ratio=0.2, colors_ratio=0.03, col_colors=self.col_colors, row_colors=self.row_colors)\n    kws2 = kws1.copy()\n    kws2.update(dendrogram_ratio=0.3, colors_ratio=0.05)\n    g1 = mat.clustermap(self.df_norm, **kws1)\n    g2 = mat.clustermap(self.df_norm, **kws2)\n    assert (g2.ax_col_dendrogram.get_position().height > g1.ax_col_dendrogram.get_position().height)\n    assert (g2.ax_col_colors.get_position().height > g1.ax_col_colors.get_position().height)\n    assert (g2.ax_heatmap.get_position().height < g1.ax_heatmap.get_position().height)\n    assert (g2.ax_row_dendrogram.get_position().width > g1.ax_row_dendrogram.get_position().width)\n    assert (g2.ax_row_colors.get_position().width > g1.ax_row_colors.get_position().width)\n    assert (g2.ax_heatmap.get_position().width < g1.ax_heatmap.get_position().width)\n    kws1 = self.default_kws.copy()\n    kws1.update(col_colors=self.col_colors)\n    kws2 = kws1.copy()\n    kws2.update(col_colors=[self.col_colors, self.col_colors])\n    g1 = mat.clustermap(self.df_norm, **kws1)\n    g2 = mat.clustermap(self.df_norm, **kws2)\n    assert (g2.ax_col_colors.get_position().height > g1.ax_col_colors.get_position().height)\n    kws1 = self.default_kws.copy()\n    kws1.update(dendrogram_ratio=(0.2, 0.2))\n    kws2 = kws1.copy()\n    kws2.update(dendrogram_ratio=(0.2, 0.3))\n    g1 = mat.clustermap(self.df_norm, **kws1)\n    g2 = mat.clustermap(self.df_norm, **kws2)\n    assert (g1.gs.get_width_ratios() == '???')\n    assert (g2.ax_col_dendrogram.get_position().height > g1.ax_col_dendrogram.get_position().height)", "ground_truth": "g2.gs.get_width_ratios()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_709", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_cbar_pos", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_cbar_pos(self):\n    kws = self.default_kws.copy()\n    kws['cbar_pos'] = (0.2, 0.1, 0.4, 0.3)\n    g = mat.clustermap(self.df_norm, **kws)\n    pos = g.ax_cbar.get_position()\n    assert (pytest.approx(tuple(pos.p0)) == kws['cbar_pos'][:2])\n    assert (pytest.approx(pos.width) == kws['cbar_pos'][2])\n    assert (pytest.approx(pos.height) == kws['cbar_pos'][3])\n    kws['cbar_pos'] = None\n    g = mat.clustermap(self.df_norm, **kws)\n    assert (g.ax_cbar is None)", "masked_code": "def test_cbar_pos(self):\n    kws = self.default_kws.copy()\n    kws['cbar_pos'] = (0.2, 0.1, 0.4, 0.3)\n    g = mat.clustermap(self.df_norm, **kws)\n    pos = g.ax_cbar.get_position()\n    assert (pytest.approx(tuple(pos.p0)) == '???')\n    assert (pytest.approx(pos.width) == kws['cbar_pos'][2])\n    assert (pytest.approx(pos.height) == kws['cbar_pos'][3])\n    kws['cbar_pos'] = None\n    g = mat.clustermap(self.df_norm, **kws)\n    assert (g.ax_cbar is None)", "ground_truth": "kws['cbar_pos'][:2]", "quality_analysis": {"complexity_score": 16, "left_complexity": 8, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_710", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_cbar_pos", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_cbar_pos(self):\n    kws = self.default_kws.copy()\n    kws['cbar_pos'] = (0.2, 0.1, 0.4, 0.3)\n    g = mat.clustermap(self.df_norm, **kws)\n    pos = g.ax_cbar.get_position()\n    assert (pytest.approx(tuple(pos.p0)) == kws['cbar_pos'][:2])\n    assert (pytest.approx(pos.width) == kws['cbar_pos'][2])\n    assert (pytest.approx(pos.height) == kws['cbar_pos'][3])\n    kws['cbar_pos'] = None\n    g = mat.clustermap(self.df_norm, **kws)\n    assert (g.ax_cbar is None)", "masked_code": "def test_cbar_pos(self):\n    kws = self.default_kws.copy()\n    kws['cbar_pos'] = (0.2, 0.1, 0.4, 0.3)\n    g = mat.clustermap(self.df_norm, **kws)\n    pos = g.ax_cbar.get_position()\n    assert (pytest.approx(tuple(pos.p0)) == kws['cbar_pos'][:2])\n    assert (pytest.approx(pos.width) == '???')\n    assert (pytest.approx(pos.height) == kws['cbar_pos'][3])\n    kws['cbar_pos'] = None\n    g = mat.clustermap(self.df_norm, **kws)\n    assert (g.ax_cbar is None)", "ground_truth": "kws['cbar_pos'][2]", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_711", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_cbar_pos", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_cbar_pos(self):\n    kws = self.default_kws.copy()\n    kws['cbar_pos'] = (0.2, 0.1, 0.4, 0.3)\n    g = mat.clustermap(self.df_norm, **kws)\n    pos = g.ax_cbar.get_position()\n    assert (pytest.approx(tuple(pos.p0)) == kws['cbar_pos'][:2])\n    assert (pytest.approx(pos.width) == kws['cbar_pos'][2])\n    assert (pytest.approx(pos.height) == kws['cbar_pos'][3])\n    kws['cbar_pos'] = None\n    g = mat.clustermap(self.df_norm, **kws)\n    assert (g.ax_cbar is None)", "masked_code": "def test_cbar_pos(self):\n    kws = self.default_kws.copy()\n    kws['cbar_pos'] = (0.2, 0.1, 0.4, 0.3)\n    g = mat.clustermap(self.df_norm, **kws)\n    pos = g.ax_cbar.get_position()\n    assert (pytest.approx(tuple(pos.p0)) == kws['cbar_pos'][:2])\n    assert (pytest.approx(pos.width) == kws['cbar_pos'][2])\n    assert (pytest.approx(pos.height) == '???')\n    kws['cbar_pos'] = None\n    g = mat.clustermap(self.df_norm, **kws)\n    assert (g.ax_cbar is None)", "ground_truth": "kws['cbar_pos'][3]", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_712", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_clustermap_annotation", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_clustermap_annotation(self):\n    g = mat.clustermap(self.df_norm, annot=True, fmt='.1f')\n    for (val, text) in zip(np.asarray(g.data2d).flat, g.ax_heatmap.texts):\n        assert (text.get_text() == f'{val:.1f}')\n    g = mat.clustermap(self.df_norm, annot=self.df_norm, fmt='.1f')\n    for (val, text) in zip(np.asarray(g.data2d).flat, g.ax_heatmap.texts):\n        assert (text.get_text() == f'{val:.1f}')", "masked_code": "def test_clustermap_annotation(self):\n    g = mat.clustermap(self.df_norm, annot=True, fmt='.1f')\n    for (val, text) in zip(np.asarray(g.data2d).flat, g.ax_heatmap.texts):\n        assert (text.get_text() == '???')\n    g = mat.clustermap(self.df_norm, annot=self.df_norm, fmt='.1f')\n    for (val, text) in zip(np.asarray(g.data2d).flat, g.ax_heatmap.texts):\n        assert (text.get_text() == f'{val:.1f}')", "ground_truth": "f'{val:.1f}'", "quality_analysis": {"complexity_score": 3, "left_complexity": 3, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_713", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_clustermap_annotation", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_clustermap_annotation(self):\n    g = mat.clustermap(self.df_norm, annot=True, fmt='.1f')\n    for (val, text) in zip(np.asarray(g.data2d).flat, g.ax_heatmap.texts):\n        assert (text.get_text() == f'{val:.1f}')\n    g = mat.clustermap(self.df_norm, annot=self.df_norm, fmt='.1f')\n    for (val, text) in zip(np.asarray(g.data2d).flat, g.ax_heatmap.texts):\n        assert (text.get_text() == f'{val:.1f}')", "masked_code": "def test_clustermap_annotation(self):\n    g = mat.clustermap(self.df_norm, annot=True, fmt='.1f')\n    for (val, text) in zip(np.asarray(g.data2d).flat, g.ax_heatmap.texts):\n        assert (text.get_text() == f'{val:.1f}')\n    g = mat.clustermap(self.df_norm, annot=self.df_norm, fmt='.1f')\n    for (val, text) in zip(np.asarray(g.data2d).flat, g.ax_heatmap.texts):\n        assert (text.get_text() == '???')", "ground_truth": "f'{val:.1f}'", "quality_analysis": {"complexity_score": 3, "left_complexity": 3, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_714", "reponame": "seaborn", "testpath": "tests/test_matrix.py", "testname": "test_matrix.py", "classname": "TestClustermap", "funcname": "test_tree_kws", "imports": ["import tempfile", "import copy", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import numpy.testing as npt", "import pandas.testing as pdt", "import pytest", "from seaborn import matrix as mat", "from seaborn import color_palette", "from seaborn._compat import get_colormap", "from seaborn._testing import assert_colors_equal"], "code": "def test_tree_kws(self):\n    rgb = (1, 0.5, 0.2)\n    g = mat.clustermap(self.df_norm, tree_kws=dict(color=rgb))\n    for ax in [g.ax_col_dendrogram, g.ax_row_dendrogram]:\n        (tree,) = ax.collections\n        assert (tuple(tree.get_color().squeeze())[:3] == rgb)", "masked_code": "def test_tree_kws(self):\n    rgb = (1, 0.5, 0.2)\n    g = mat.clustermap(self.df_norm, tree_kws=dict(color=rgb))\n    for ax in [g.ax_col_dendrogram, g.ax_row_dendrogram]:\n        (tree,) = ax.collections\n        assert (tuple(tree.get_color().squeeze())[:3] == '???')", "ground_truth": "rgb", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_715", "reponame": "seaborn", "testpath": "tests/test_miscplot.py", "testname": "test_miscplot.py", "classname": "TestPalPlot", "funcname": "test_palplot_size", "imports": ["import matplotlib.pyplot as plt", "from seaborn import miscplot as misc", "from seaborn.palettes import color_palette", "from .test_utils import _network"], "code": "def test_palplot_size(self):\n    pal4 = color_palette('husl', 4)\n    misc.palplot(pal4)\n    size4 = plt.gcf().get_size_inches()\n    assert (tuple(size4) == (4, 1))\n    pal5 = color_palette('husl', 5)\n    misc.palplot(pal5)\n    size5 = plt.gcf().get_size_inches()\n    assert (tuple(size5) == (5, 1))\n    palbig = color_palette('husl', 3)\n    misc.palplot(palbig, 2)\n    sizebig = plt.gcf().get_size_inches()\n    assert (tuple(sizebig) == (6, 2))", "masked_code": "def test_palplot_size(self):\n    pal4 = color_palette('husl', 4)\n    misc.palplot(pal4)\n    size4 = plt.gcf().get_size_inches()\n    assert (tuple(size4) == '???')\n    pal5 = color_palette('husl', 5)\n    misc.palplot(pal5)\n    size5 = plt.gcf().get_size_inches()\n    assert (tuple(size5) == (5, 1))\n    palbig = color_palette('husl', 3)\n    misc.palplot(palbig, 2)\n    sizebig = plt.gcf().get_size_inches()\n    assert (tuple(sizebig) == (6, 2))", "ground_truth": "(4, 1)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_716", "reponame": "seaborn", "testpath": "tests/test_miscplot.py", "testname": "test_miscplot.py", "classname": "TestPalPlot", "funcname": "test_palplot_size", "imports": ["import matplotlib.pyplot as plt", "from seaborn import miscplot as misc", "from seaborn.palettes import color_palette", "from .test_utils import _network"], "code": "def test_palplot_size(self):\n    pal4 = color_palette('husl', 4)\n    misc.palplot(pal4)\n    size4 = plt.gcf().get_size_inches()\n    assert (tuple(size4) == (4, 1))\n    pal5 = color_palette('husl', 5)\n    misc.palplot(pal5)\n    size5 = plt.gcf().get_size_inches()\n    assert (tuple(size5) == (5, 1))\n    palbig = color_palette('husl', 3)\n    misc.palplot(palbig, 2)\n    sizebig = plt.gcf().get_size_inches()\n    assert (tuple(sizebig) == (6, 2))", "masked_code": "def test_palplot_size(self):\n    pal4 = color_palette('husl', 4)\n    misc.palplot(pal4)\n    size4 = plt.gcf().get_size_inches()\n    assert (tuple(size4) == (4, 1))\n    pal5 = color_palette('husl', 5)\n    misc.palplot(pal5)\n    size5 = plt.gcf().get_size_inches()\n    assert (tuple(size5) == '???')\n    palbig = color_palette('husl', 3)\n    misc.palplot(palbig, 2)\n    sizebig = plt.gcf().get_size_inches()\n    assert (tuple(sizebig) == (6, 2))", "ground_truth": "(5, 1)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_717", "reponame": "seaborn", "testpath": "tests/test_miscplot.py", "testname": "test_miscplot.py", "classname": "TestPalPlot", "funcname": "test_palplot_size", "imports": ["import matplotlib.pyplot as plt", "from seaborn import miscplot as misc", "from seaborn.palettes import color_palette", "from .test_utils import _network"], "code": "def test_palplot_size(self):\n    pal4 = color_palette('husl', 4)\n    misc.palplot(pal4)\n    size4 = plt.gcf().get_size_inches()\n    assert (tuple(size4) == (4, 1))\n    pal5 = color_palette('husl', 5)\n    misc.palplot(pal5)\n    size5 = plt.gcf().get_size_inches()\n    assert (tuple(size5) == (5, 1))\n    palbig = color_palette('husl', 3)\n    misc.palplot(palbig, 2)\n    sizebig = plt.gcf().get_size_inches()\n    assert (tuple(sizebig) == (6, 2))", "masked_code": "def test_palplot_size(self):\n    pal4 = color_palette('husl', 4)\n    misc.palplot(pal4)\n    size4 = plt.gcf().get_size_inches()\n    assert (tuple(size4) == (4, 1))\n    pal5 = color_palette('husl', 5)\n    misc.palplot(pal5)\n    size5 = plt.gcf().get_size_inches()\n    assert (tuple(size5) == (5, 1))\n    palbig = color_palette('husl', 3)\n    misc.palplot(palbig, 2)\n    sizebig = plt.gcf().get_size_inches()\n    assert (tuple(sizebig) == '???')", "ground_truth": "(6, 2)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_718", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_palette_context", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_palette_context(self):\n    default_pal = palettes.color_palette()\n    context_pal = palettes.color_palette('muted')\n    with palettes.color_palette(context_pal):\n        assert (utils.get_color_cycle() == context_pal)\n    assert (utils.get_color_cycle() == default_pal)", "masked_code": "def test_palette_context(self):\n    default_pal = palettes.color_palette()\n    context_pal = palettes.color_palette('muted')\n    with palettes.color_palette(context_pal):\n        assert (utils.get_color_cycle() == context_pal)\n    assert (utils.get_color_cycle() == '???')", "ground_truth": "default_pal", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_719", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_palette_context", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_palette_context(self):\n    default_pal = palettes.color_palette()\n    context_pal = palettes.color_palette('muted')\n    with palettes.color_palette(context_pal):\n        assert (utils.get_color_cycle() == context_pal)\n    assert (utils.get_color_cycle() == default_pal)", "masked_code": "def test_palette_context(self):\n    default_pal = palettes.color_palette()\n    context_pal = palettes.color_palette('muted')\n    with palettes.color_palette(context_pal):\n        assert (utils.get_color_cycle() == '???')\n    assert (utils.get_color_cycle() == default_pal)", "ground_truth": "context_pal", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_720", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_big_palette_context", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_big_palette_context(self):\n    original_pal = palettes.color_palette('deep', n_colors=8)\n    context_pal = palettes.color_palette('husl', 10)\n    rcmod.set_palette(original_pal)\n    with palettes.color_palette(context_pal, 10):\n        assert (utils.get_color_cycle() == context_pal)\n    assert (utils.get_color_cycle() == original_pal)\n    rcmod.set()", "masked_code": "def test_big_palette_context(self):\n    original_pal = palettes.color_palette('deep', n_colors=8)\n    context_pal = palettes.color_palette('husl', 10)\n    rcmod.set_palette(original_pal)\n    with palettes.color_palette(context_pal, 10):\n        assert (utils.get_color_cycle() == context_pal)\n    assert (utils.get_color_cycle() == '???')\n    rcmod.set()", "ground_truth": "original_pal", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_721", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_big_palette_context", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_big_palette_context(self):\n    original_pal = palettes.color_palette('deep', n_colors=8)\n    context_pal = palettes.color_palette('husl', 10)\n    rcmod.set_palette(original_pal)\n    with palettes.color_palette(context_pal, 10):\n        assert (utils.get_color_cycle() == context_pal)\n    assert (utils.get_color_cycle() == original_pal)\n    rcmod.set()", "masked_code": "def test_big_palette_context(self):\n    original_pal = palettes.color_palette('deep', n_colors=8)\n    context_pal = palettes.color_palette('husl', 10)\n    rcmod.set_palette(original_pal)\n    with palettes.color_palette(context_pal, 10):\n        assert (utils.get_color_cycle() == '???')\n    assert (utils.get_color_cycle() == original_pal)\n    rcmod.set()", "ground_truth": "context_pal", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_722", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_palette_size", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_palette_size(self):\n    pal = palettes.color_palette('deep')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['deep'])\n    pal = palettes.color_palette('pastel6')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['pastel6'])\n    pal = palettes.color_palette('Set3')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['Set3'])\n    pal = palettes.color_palette('husl')\n    assert (len(pal) == 6)\n    pal = palettes.color_palette('Greens')\n    assert (len(pal) == 6)", "masked_code": "def test_palette_size(self):\n    pal = palettes.color_palette('deep')\n    assert (len(pal) == '???')\n    pal = palettes.color_palette('pastel6')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['pastel6'])\n    pal = palettes.color_palette('Set3')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['Set3'])\n    pal = palettes.color_palette('husl')\n    assert (len(pal) == 6)\n    pal = palettes.color_palette('Greens')\n    assert (len(pal) == 6)", "ground_truth": "palettes.QUAL_PALETTE_SIZES['deep']", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_723", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_palette_size", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_palette_size(self):\n    pal = palettes.color_palette('deep')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['deep'])\n    pal = palettes.color_palette('pastel6')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['pastel6'])\n    pal = palettes.color_palette('Set3')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['Set3'])\n    pal = palettes.color_palette('husl')\n    assert (len(pal) == 6)\n    pal = palettes.color_palette('Greens')\n    assert (len(pal) == 6)", "masked_code": "def test_palette_size(self):\n    pal = palettes.color_palette('deep')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['deep'])\n    pal = palettes.color_palette('pastel6')\n    assert (len(pal) == '???')\n    pal = palettes.color_palette('Set3')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['Set3'])\n    pal = palettes.color_palette('husl')\n    assert (len(pal) == 6)\n    pal = palettes.color_palette('Greens')\n    assert (len(pal) == 6)", "ground_truth": "palettes.QUAL_PALETTE_SIZES['pastel6']", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_724", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_palette_size", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_palette_size(self):\n    pal = palettes.color_palette('deep')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['deep'])\n    pal = palettes.color_palette('pastel6')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['pastel6'])\n    pal = palettes.color_palette('Set3')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['Set3'])\n    pal = palettes.color_palette('husl')\n    assert (len(pal) == 6)\n    pal = palettes.color_palette('Greens')\n    assert (len(pal) == 6)", "masked_code": "def test_palette_size(self):\n    pal = palettes.color_palette('deep')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['deep'])\n    pal = palettes.color_palette('pastel6')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['pastel6'])\n    pal = palettes.color_palette('Set3')\n    assert (len(pal) == '???')\n    pal = palettes.color_palette('husl')\n    assert (len(pal) == 6)\n    pal = palettes.color_palette('Greens')\n    assert (len(pal) == 6)", "ground_truth": "palettes.QUAL_PALETTE_SIZES['Set3']", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_725", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_palette_size", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_palette_size(self):\n    pal = palettes.color_palette('deep')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['deep'])\n    pal = palettes.color_palette('pastel6')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['pastel6'])\n    pal = palettes.color_palette('Set3')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['Set3'])\n    pal = palettes.color_palette('husl')\n    assert (len(pal) == 6)\n    pal = palettes.color_palette('Greens')\n    assert (len(pal) == 6)", "masked_code": "def test_palette_size(self):\n    pal = palettes.color_palette('deep')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['deep'])\n    pal = palettes.color_palette('pastel6')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['pastel6'])\n    pal = palettes.color_palette('Set3')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['Set3'])\n    pal = palettes.color_palette('husl')\n    assert (len(pal) == '???')\n    pal = palettes.color_palette('Greens')\n    assert (len(pal) == 6)", "ground_truth": "6", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_726", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_palette_size", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_palette_size(self):\n    pal = palettes.color_palette('deep')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['deep'])\n    pal = palettes.color_palette('pastel6')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['pastel6'])\n    pal = palettes.color_palette('Set3')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['Set3'])\n    pal = palettes.color_palette('husl')\n    assert (len(pal) == 6)\n    pal = palettes.color_palette('Greens')\n    assert (len(pal) == 6)", "masked_code": "def test_palette_size(self):\n    pal = palettes.color_palette('deep')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['deep'])\n    pal = palettes.color_palette('pastel6')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['pastel6'])\n    pal = palettes.color_palette('Set3')\n    assert (len(pal) == palettes.QUAL_PALETTE_SIZES['Set3'])\n    pal = palettes.color_palette('husl')\n    assert (len(pal) == 6)\n    pal = palettes.color_palette('Greens')\n    assert (len(pal) == '???')", "ground_truth": "6", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_727", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_seaborn_palettes", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_seaborn_palettes(self):\n    pals = ('deep', 'muted', 'pastel', 'bright', 'dark', 'colorblind')\n    for name in pals:\n        full = palettes.color_palette(name, 10).as_hex()\n        short = palettes.color_palette((name + '6'), 6).as_hex()\n        (b, _, g, r, m, _, _, _, y, c) = full\n        assert ([b, g, r, m, y, c] == list(short))", "masked_code": "def test_seaborn_palettes(self):\n    pals = ('deep', 'muted', 'pastel', 'bright', 'dark', 'colorblind')\n    for name in pals:\n        full = palettes.color_palette(name, 10).as_hex()\n        short = palettes.color_palette((name + '6'), 6).as_hex()\n        (b, _, g, r, m, _, _, _, y, c) = full\n        assert ([b, g, r, m, y, c] == '???')", "ground_truth": "list(short)", "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_728", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_palette_is_list_of_tuples", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_palette_is_list_of_tuples(self):\n    pal_in = np.array(['red', 'blue', 'green'])\n    pal_out = palettes.color_palette(pal_in, 3)\n    assert isinstance(pal_out, list)\n    assert isinstance(pal_out[0], tuple)\n    assert isinstance(pal_out[0][0], float)\n    assert (len(pal_out[0]) == 3)", "masked_code": "def test_palette_is_list_of_tuples(self):\n    pal_in = np.array(['red', 'blue', 'green'])\n    pal_out = palettes.color_palette(pal_in, 3)\n    assert isinstance(pal_out, list)\n    assert isinstance(pal_out[0], tuple)\n    assert isinstance(pal_out[0][0], float)\n    assert (len(pal_out[0]) == '???')", "ground_truth": "3", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_729", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_light_palette", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_light_palette(self):\n    n = 4\n    pal_forward = palettes.light_palette('red', n)\n    pal_reverse = palettes.light_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('light:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('light:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.light_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.light_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "masked_code": "def test_light_palette(self):\n    n = 4\n    pal_forward = palettes.light_palette('red', n)\n    pal_reverse = palettes.light_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == '???')\n    pal_f_from_string = palettes.color_palette('light:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('light:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.light_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.light_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "ground_truth": "red", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_730", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_light_palette", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_light_palette(self):\n    n = 4\n    pal_forward = palettes.light_palette('red', n)\n    pal_reverse = palettes.light_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('light:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('light:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.light_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.light_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "masked_code": "def test_light_palette(self):\n    n = 4\n    pal_forward = palettes.light_palette('red', n)\n    pal_reverse = palettes.light_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('light:red', n)\n    assert (pal_forward[3] == '???')\n    pal_r_from_string = palettes.color_palette('light:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.light_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.light_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "ground_truth": "pal_f_from_string[3]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_731", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_light_palette", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_light_palette(self):\n    n = 4\n    pal_forward = palettes.light_palette('red', n)\n    pal_reverse = palettes.light_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('light:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('light:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.light_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.light_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "masked_code": "def test_light_palette(self):\n    n = 4\n    pal_forward = palettes.light_palette('red', n)\n    pal_reverse = palettes.light_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('light:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('light:red_r', n)\n    assert (pal_reverse[3] == '???')\n    pal_cmap = palettes.light_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.light_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "ground_truth": "pal_r_from_string[3]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_732", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_light_palette", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_light_palette(self):\n    n = 4\n    pal_forward = palettes.light_palette('red', n)\n    pal_reverse = palettes.light_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('light:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('light:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.light_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.light_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "masked_code": "def test_light_palette(self):\n    n = 4\n    pal_forward = palettes.light_palette('red', n)\n    pal_reverse = palettes.light_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('light:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('light:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.light_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == '???')\n    pal_cmap = palettes.light_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "ground_truth": "pal_cmap_from_string(0.8)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_733", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_light_palette", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_light_palette(self):\n    n = 4\n    pal_forward = palettes.light_palette('red', n)\n    pal_reverse = palettes.light_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('light:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('light:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.light_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.light_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "masked_code": "def test_light_palette(self):\n    n = 4\n    pal_forward = palettes.light_palette('red', n)\n    pal_reverse = palettes.light_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('light:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('light:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.light_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.light_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == '???')", "ground_truth": "pal_cmap_from_string(0.8)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_734", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_dark_palette", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_dark_palette(self):\n    n = 4\n    pal_forward = palettes.dark_palette('red', n)\n    pal_reverse = palettes.dark_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('dark:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('dark:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "masked_code": "def test_dark_palette(self):\n    n = 4\n    pal_forward = palettes.dark_palette('red', n)\n    pal_reverse = palettes.dark_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == '???')\n    pal_f_from_string = palettes.color_palette('dark:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('dark:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "ground_truth": "red", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_735", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_dark_palette", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_dark_palette(self):\n    n = 4\n    pal_forward = palettes.dark_palette('red', n)\n    pal_reverse = palettes.dark_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('dark:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('dark:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "masked_code": "def test_dark_palette(self):\n    n = 4\n    pal_forward = palettes.dark_palette('red', n)\n    pal_reverse = palettes.dark_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('dark:red', n)\n    assert (pal_forward[3] == '???')\n    pal_r_from_string = palettes.color_palette('dark:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "ground_truth": "pal_f_from_string[3]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_736", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_dark_palette", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_dark_palette(self):\n    n = 4\n    pal_forward = palettes.dark_palette('red', n)\n    pal_reverse = palettes.dark_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('dark:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('dark:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "masked_code": "def test_dark_palette(self):\n    n = 4\n    pal_forward = palettes.dark_palette('red', n)\n    pal_reverse = palettes.dark_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('dark:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('dark:red_r', n)\n    assert (pal_reverse[3] == '???')\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "ground_truth": "pal_r_from_string[3]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_737", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_dark_palette", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_dark_palette(self):\n    n = 4\n    pal_forward = palettes.dark_palette('red', n)\n    pal_reverse = palettes.dark_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('dark:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('dark:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "masked_code": "def test_dark_palette(self):\n    n = 4\n    pal_forward = palettes.dark_palette('red', n)\n    pal_reverse = palettes.dark_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('dark:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('dark:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == '???')\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "ground_truth": "pal_cmap_from_string(0.8)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_738", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_dark_palette", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_dark_palette(self):\n    n = 4\n    pal_forward = palettes.dark_palette('red', n)\n    pal_reverse = palettes.dark_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('dark:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('dark:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))", "masked_code": "def test_dark_palette(self):\n    n = 4\n    pal_forward = palettes.dark_palette('red', n)\n    pal_reverse = palettes.dark_palette('red', n, reverse=True)\n    assert np.allclose(pal_forward, pal_reverse[::(- 1)])\n    red = mpl.colors.colorConverter.to_rgb('red')\n    assert (pal_forward[(- 1)] == red)\n    pal_f_from_string = palettes.color_palette('dark:red', n)\n    assert (pal_forward[3] == pal_f_from_string[3])\n    pal_r_from_string = palettes.color_palette('dark:red_r', n)\n    assert (pal_reverse[3] == pal_r_from_string[3])\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n    assert (pal_cmap(0.8) == pal_cmap_from_string(0.8))\n    pal_cmap = palettes.dark_palette('blue', as_cmap=True, reverse=True)\n    pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n    assert (pal_cmap(0.8) == '???')", "ground_truth": "pal_cmap_from_string(0.8)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_739", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_diverging_palette", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_diverging_palette(self):\n    (h_neg, h_pos) = (100, 200)\n    (sat, lum) = (70, 50)\n    args = (h_neg, h_pos, sat, lum)\n    n = 12\n    pal = palettes.diverging_palette(*args, n=n)\n    neg_pal = palettes.light_palette((h_neg, sat, lum), int((n // 2)), input='husl')\n    pos_pal = palettes.light_palette((h_pos, sat, lum), int((n // 2)), input='husl')\n    assert (len(pal) == n)\n    assert (pal[0] == neg_pal[(- 1)])\n    assert (pal[(- 1)] == pos_pal[(- 1)])\n    pal_dark = palettes.diverging_palette(*args, n=n, center='dark')\n    assert (np.mean(pal[int((n / 2))]) > np.mean(pal_dark[int((n / 2))]))\n    pal_cmap = palettes.diverging_palette(*args, as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)", "masked_code": "def test_diverging_palette(self):\n    (h_neg, h_pos) = (100, 200)\n    (sat, lum) = (70, 50)\n    args = (h_neg, h_pos, sat, lum)\n    n = 12\n    pal = palettes.diverging_palette(*args, n=n)\n    neg_pal = palettes.light_palette((h_neg, sat, lum), int((n // 2)), input='husl')\n    pos_pal = palettes.light_palette((h_pos, sat, lum), int((n // 2)), input='husl')\n    assert (len(pal) == '???')\n    assert (pal[0] == neg_pal[(- 1)])\n    assert (pal[(- 1)] == pos_pal[(- 1)])\n    pal_dark = palettes.diverging_palette(*args, n=n, center='dark')\n    assert (np.mean(pal[int((n / 2))]) > np.mean(pal_dark[int((n / 2))]))\n    pal_cmap = palettes.diverging_palette(*args, as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_740", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_diverging_palette", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_diverging_palette(self):\n    (h_neg, h_pos) = (100, 200)\n    (sat, lum) = (70, 50)\n    args = (h_neg, h_pos, sat, lum)\n    n = 12\n    pal = palettes.diverging_palette(*args, n=n)\n    neg_pal = palettes.light_palette((h_neg, sat, lum), int((n // 2)), input='husl')\n    pos_pal = palettes.light_palette((h_pos, sat, lum), int((n // 2)), input='husl')\n    assert (len(pal) == n)\n    assert (pal[0] == neg_pal[(- 1)])\n    assert (pal[(- 1)] == pos_pal[(- 1)])\n    pal_dark = palettes.diverging_palette(*args, n=n, center='dark')\n    assert (np.mean(pal[int((n / 2))]) > np.mean(pal_dark[int((n / 2))]))\n    pal_cmap = palettes.diverging_palette(*args, as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)", "masked_code": "def test_diverging_palette(self):\n    (h_neg, h_pos) = (100, 200)\n    (sat, lum) = (70, 50)\n    args = (h_neg, h_pos, sat, lum)\n    n = 12\n    pal = palettes.diverging_palette(*args, n=n)\n    neg_pal = palettes.light_palette((h_neg, sat, lum), int((n // 2)), input='husl')\n    pos_pal = palettes.light_palette((h_pos, sat, lum), int((n // 2)), input='husl')\n    assert (len(pal) == n)\n    assert (pal[0] == '???')\n    assert (pal[(- 1)] == pos_pal[(- 1)])\n    pal_dark = palettes.diverging_palette(*args, n=n, center='dark')\n    assert (np.mean(pal[int((n / 2))]) > np.mean(pal_dark[int((n / 2))]))\n    pal_cmap = palettes.diverging_palette(*args, as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)", "ground_truth": "neg_pal[(- 1)]", "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_741", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_diverging_palette", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_diverging_palette(self):\n    (h_neg, h_pos) = (100, 200)\n    (sat, lum) = (70, 50)\n    args = (h_neg, h_pos, sat, lum)\n    n = 12\n    pal = palettes.diverging_palette(*args, n=n)\n    neg_pal = palettes.light_palette((h_neg, sat, lum), int((n // 2)), input='husl')\n    pos_pal = palettes.light_palette((h_pos, sat, lum), int((n // 2)), input='husl')\n    assert (len(pal) == n)\n    assert (pal[0] == neg_pal[(- 1)])\n    assert (pal[(- 1)] == pos_pal[(- 1)])\n    pal_dark = palettes.diverging_palette(*args, n=n, center='dark')\n    assert (np.mean(pal[int((n / 2))]) > np.mean(pal_dark[int((n / 2))]))\n    pal_cmap = palettes.diverging_palette(*args, as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)", "masked_code": "def test_diverging_palette(self):\n    (h_neg, h_pos) = (100, 200)\n    (sat, lum) = (70, 50)\n    args = (h_neg, h_pos, sat, lum)\n    n = 12\n    pal = palettes.diverging_palette(*args, n=n)\n    neg_pal = palettes.light_palette((h_neg, sat, lum), int((n // 2)), input='husl')\n    pos_pal = palettes.light_palette((h_pos, sat, lum), int((n // 2)), input='husl')\n    assert (len(pal) == n)\n    assert (pal[0] == neg_pal[(- 1)])\n    assert (pal[(- 1)] == '???')\n    pal_dark = palettes.diverging_palette(*args, n=n, center='dark')\n    assert (np.mean(pal[int((n / 2))]) > np.mean(pal_dark[int((n / 2))]))\n    pal_cmap = palettes.diverging_palette(*args, as_cmap=True)\n    assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)", "ground_truth": "pos_pal[(- 1)]", "quality_analysis": {"complexity_score": 14, "left_complexity": 7, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_742", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_cubehelix_n_colors", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_cubehelix_n_colors(self):\n    for n in [3, 5, 8]:\n        pal = palettes.cubehelix_palette(n)\n        assert (len(pal) == n)", "masked_code": "def test_cubehelix_n_colors(self):\n    for n in [3, 5, 8]:\n        pal = palettes.cubehelix_palette(n)\n        assert (len(pal) == '???')", "ground_truth": "n", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_743", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_cubehelix_code", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_cubehelix_code(self):\n    color_palette = palettes.color_palette\n    cubehelix_palette = palettes.cubehelix_palette\n    pal1 = color_palette('ch:', 8)\n    pal2 = color_palette(cubehelix_palette(8))\n    assert (pal1 == pal2)\n    pal1 = color_palette('ch:.5, -.25,hue = .5,light=.75', 8)\n    pal2 = color_palette(cubehelix_palette(8, 0.5, (- 0.25), hue=0.5, light=0.75))\n    assert (pal1 == pal2)\n    pal1 = color_palette('ch:h=1,r=.5', 9)\n    pal2 = color_palette(cubehelix_palette(9, hue=1, rot=0.5))\n    assert (pal1 == pal2)\n    pal1 = color_palette('ch:_r', 6)\n    pal2 = color_palette(cubehelix_palette(6, reverse=True))\n    assert (pal1 == pal2)\n    pal1 = color_palette('ch:_r', as_cmap=True)\n    pal2 = cubehelix_palette(6, reverse=True, as_cmap=True)\n    assert (pal1(0.5) == pal2(0.5))", "masked_code": "def test_cubehelix_code(self):\n    color_palette = palettes.color_palette\n    cubehelix_palette = palettes.cubehelix_palette\n    pal1 = color_palette('ch:', 8)\n    pal2 = color_palette(cubehelix_palette(8))\n    assert (pal1 == pal2)\n    pal1 = color_palette('ch:.5, -.25,hue = .5,light=.75', 8)\n    pal2 = color_palette(cubehelix_palette(8, 0.5, (- 0.25), hue=0.5, light=0.75))\n    assert (pal1 == pal2)\n    pal1 = color_palette('ch:h=1,r=.5', 9)\n    pal2 = color_palette(cubehelix_palette(9, hue=1, rot=0.5))\n    assert (pal1 == pal2)\n    pal1 = color_palette('ch:_r', 6)\n    pal2 = color_palette(cubehelix_palette(6, reverse=True))\n    assert (pal1 == pal2)\n    pal1 = color_palette('ch:_r', as_cmap=True)\n    pal2 = cubehelix_palette(6, reverse=True, as_cmap=True)\n    assert (pal1(0.5) == '???')", "ground_truth": "pal2(0.5)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_744", "reponame": "seaborn", "testpath": "tests/test_palettes.py", "testname": "test_palettes.py", "classname": "TestColorPalettes", "funcname": "test_as_hex", "imports": ["import colorsys", "import numpy as np", "import matplotlib as mpl", "import pytest", "import numpy.testing as npt", "from seaborn import palettes, utils, rcmod", "from seaborn.external import husl", "from seaborn._compat import get_colormap", "from seaborn.colors import xkcd_rgb, crayons"], "code": "def test_as_hex(self):\n    pal = palettes.color_palette('deep')\n    for (rgb, hex) in zip(pal, pal.as_hex()):\n        assert (mpl.colors.rgb2hex(rgb) == hex)", "masked_code": "def test_as_hex(self):\n    pal = palettes.color_palette('deep')\n    for (rgb, hex) in zip(pal, pal.as_hex()):\n        assert (mpl.colors.rgb2hex(rgb) == '???')", "ground_truth": "hex", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_745", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestAxesStyle", "funcname": "test_rc_override", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "def test_rc_override(self):\n    rc = {'axes.facecolor': 'blue', 'foo.notaparam': 'bar'}\n    out = rcmod.axes_style('darkgrid', rc)\n    assert (out['axes.facecolor'] == 'blue')\n    assert ('foo.notaparam' not in out)", "masked_code": "def test_rc_override(self):\n    rc = {'axes.facecolor': 'blue', 'foo.notaparam': 'bar'}\n    out = rcmod.axes_style('darkgrid', rc)\n    assert (out['axes.facecolor'] == '???')\n    assert ('foo.notaparam' not in out)", "ground_truth": "'blue'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_746", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestAxesStyle", "funcname": "test_set_rc", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "def test_set_rc(self):\n    rcmod.set_theme(rc={'lines.linewidth': 4})\n    assert (mpl.rcParams['lines.linewidth'] == 4)\n    rcmod.set_theme()", "masked_code": "def test_set_rc(self):\n    rcmod.set_theme(rc={'lines.linewidth': 4})\n    assert (mpl.rcParams['lines.linewidth'] == '???')\n    rcmod.set_theme()", "ground_truth": "4", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_747", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestAxesStyle", "funcname": "test_set_with_palette", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "def test_set_with_palette(self):\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep', color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    pal = palettes.color_palette('deep')\n    rcmod.set_theme(palette=pal)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette=pal, color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme()", "masked_code": "def test_set_with_palette(self):\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep')\n    assert (utils.get_color_cycle() == '???')\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep', color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    pal = palettes.color_palette('deep')\n    rcmod.set_theme(palette=pal)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette=pal, color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme()", "ground_truth": "palettes.color_palette('deep', 10)", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_748", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestAxesStyle", "funcname": "test_set_with_palette", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "def test_set_with_palette(self):\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep', color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    pal = palettes.color_palette('deep')\n    rcmod.set_theme(palette=pal)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette=pal, color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme()", "masked_code": "def test_set_with_palette(self):\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep', color_codes=False)\n    assert (utils.get_color_cycle() == '???')\n    rcmod.reset_orig()\n    pal = palettes.color_palette('deep')\n    rcmod.set_theme(palette=pal)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette=pal, color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme()", "ground_truth": "palettes.color_palette('deep', 10)", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_749", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestAxesStyle", "funcname": "test_set_with_palette", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "def test_set_with_palette(self):\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep', color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    pal = palettes.color_palette('deep')\n    rcmod.set_theme(palette=pal)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette=pal, color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme()", "masked_code": "def test_set_with_palette(self):\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep', color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    pal = palettes.color_palette('deep')\n    rcmod.set_theme(palette=pal)\n    assert (utils.get_color_cycle() == '???')\n    rcmod.reset_orig()\n    rcmod.set_theme(palette=pal, color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme()", "ground_truth": "palettes.color_palette('deep', 10)", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_750", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestAxesStyle", "funcname": "test_set_with_palette", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "def test_set_with_palette(self):\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep', color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    pal = palettes.color_palette('deep')\n    rcmod.set_theme(palette=pal)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette=pal, color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme()", "masked_code": "def test_set_with_palette(self):\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette='deep', color_codes=False)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    pal = palettes.color_palette('deep')\n    rcmod.set_theme(palette=pal)\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.reset_orig()\n    rcmod.set_theme(palette=pal, color_codes=False)\n    assert (utils.get_color_cycle() == '???')\n    rcmod.reset_orig()\n    rcmod.set_theme()", "ground_truth": "palettes.color_palette('deep', 10)", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_751", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestPlottingContext", "funcname": "test_font_scale", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "def test_font_scale(self):\n    notebook_ref = rcmod.plotting_context('notebook')\n    notebook_big = rcmod.plotting_context('notebook', 2)\n    font_keys = ['font.size', 'axes.labelsize', 'axes.titlesize', 'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize', 'legend.title_fontsize']\n    for k in font_keys:\n        assert ((notebook_ref[k] * 2) == notebook_big[k])", "masked_code": "def test_font_scale(self):\n    notebook_ref = rcmod.plotting_context('notebook')\n    notebook_big = rcmod.plotting_context('notebook', 2)\n    font_keys = ['font.size', 'axes.labelsize', 'axes.titlesize', 'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize', 'legend.title_fontsize']\n    for k in font_keys:\n        assert ((notebook_ref[k] * 2) == '???')", "ground_truth": "notebook_big[k]", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_752", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestPlottingContext", "funcname": "test_rc_override", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "def test_rc_override(self):\n    (key, val) = ('grid.linewidth', 5)\n    rc = {key: val, 'foo': 'bar'}\n    out = rcmod.plotting_context('talk', rc=rc)\n    assert (out[key] == val)\n    assert ('foo' not in out)", "masked_code": "def test_rc_override(self):\n    (key, val) = ('grid.linewidth', 5)\n    rc = {key: val, 'foo': 'bar'}\n    out = rcmod.plotting_context('talk', rc=rc)\n    assert (out[key] == '???')\n    assert ('foo' not in out)", "ground_truth": "val", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_753", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestPalette", "funcname": "test_set_palette", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "def test_set_palette(self):\n    rcmod.set_palette('deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.set_palette('pastel6')\n    assert (utils.get_color_cycle() == palettes.color_palette('pastel6', 6))\n    rcmod.set_palette('dark', 4)\n    assert (utils.get_color_cycle() == palettes.color_palette('dark', 4))\n    rcmod.set_palette('Set2', color_codes=True)\n    assert (utils.get_color_cycle() == palettes.color_palette('Set2', 8))\n    assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.color_palette()[0])", "masked_code": "def test_set_palette(self):\n    rcmod.set_palette('deep')\n    assert (utils.get_color_cycle() == '???')\n    rcmod.set_palette('pastel6')\n    assert (utils.get_color_cycle() == palettes.color_palette('pastel6', 6))\n    rcmod.set_palette('dark', 4)\n    assert (utils.get_color_cycle() == palettes.color_palette('dark', 4))\n    rcmod.set_palette('Set2', color_codes=True)\n    assert (utils.get_color_cycle() == palettes.color_palette('Set2', 8))\n    assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.color_palette()[0])", "ground_truth": "palettes.color_palette('deep', 10)", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_754", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestPalette", "funcname": "test_set_palette", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "def test_set_palette(self):\n    rcmod.set_palette('deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.set_palette('pastel6')\n    assert (utils.get_color_cycle() == palettes.color_palette('pastel6', 6))\n    rcmod.set_palette('dark', 4)\n    assert (utils.get_color_cycle() == palettes.color_palette('dark', 4))\n    rcmod.set_palette('Set2', color_codes=True)\n    assert (utils.get_color_cycle() == palettes.color_palette('Set2', 8))\n    assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.color_palette()[0])", "masked_code": "def test_set_palette(self):\n    rcmod.set_palette('deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.set_palette('pastel6')\n    assert (utils.get_color_cycle() == '???')\n    rcmod.set_palette('dark', 4)\n    assert (utils.get_color_cycle() == palettes.color_palette('dark', 4))\n    rcmod.set_palette('Set2', color_codes=True)\n    assert (utils.get_color_cycle() == palettes.color_palette('Set2', 8))\n    assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.color_palette()[0])", "ground_truth": "palettes.color_palette('pastel6', 6)", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_755", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestPalette", "funcname": "test_set_palette", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "def test_set_palette(self):\n    rcmod.set_palette('deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.set_palette('pastel6')\n    assert (utils.get_color_cycle() == palettes.color_palette('pastel6', 6))\n    rcmod.set_palette('dark', 4)\n    assert (utils.get_color_cycle() == palettes.color_palette('dark', 4))\n    rcmod.set_palette('Set2', color_codes=True)\n    assert (utils.get_color_cycle() == palettes.color_palette('Set2', 8))\n    assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.color_palette()[0])", "masked_code": "def test_set_palette(self):\n    rcmod.set_palette('deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.set_palette('pastel6')\n    assert (utils.get_color_cycle() == palettes.color_palette('pastel6', 6))\n    rcmod.set_palette('dark', 4)\n    assert (utils.get_color_cycle() == '???')\n    rcmod.set_palette('Set2', color_codes=True)\n    assert (utils.get_color_cycle() == palettes.color_palette('Set2', 8))\n    assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.color_palette()[0])", "ground_truth": "palettes.color_palette('dark', 4)", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_756", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestPalette", "funcname": "test_set_palette", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "def test_set_palette(self):\n    rcmod.set_palette('deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.set_palette('pastel6')\n    assert (utils.get_color_cycle() == palettes.color_palette('pastel6', 6))\n    rcmod.set_palette('dark', 4)\n    assert (utils.get_color_cycle() == palettes.color_palette('dark', 4))\n    rcmod.set_palette('Set2', color_codes=True)\n    assert (utils.get_color_cycle() == palettes.color_palette('Set2', 8))\n    assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.color_palette()[0])", "masked_code": "def test_set_palette(self):\n    rcmod.set_palette('deep')\n    assert (utils.get_color_cycle() == palettes.color_palette('deep', 10))\n    rcmod.set_palette('pastel6')\n    assert (utils.get_color_cycle() == palettes.color_palette('pastel6', 6))\n    rcmod.set_palette('dark', 4)\n    assert (utils.get_color_cycle() == palettes.color_palette('dark', 4))\n    rcmod.set_palette('Set2', color_codes=True)\n    assert (utils.get_color_cycle() == '???')\n    assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.color_palette()[0])", "ground_truth": "palettes.color_palette('Set2', 8)", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_757", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestFonts", "funcname": "test_set_font", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "@pytest.mark.skipif(_no_verdana, reason='Verdana font is not present')\ndef test_set_font(self):\n    rcmod.set_theme(font='Verdana')\n    (_, ax) = plt.subplots()\n    ax.set_xlabel('foo')\n    assert (ax.xaxis.label.get_fontname() == 'Verdana')\n    rcmod.set_theme()", "masked_code": "@pytest.mark.skipif(_no_verdana, reason='Verdana font is not present')\ndef test_set_font(self):\n    rcmod.set_theme(font='Verdana')\n    (_, ax) = plt.subplots()\n    ax.set_xlabel('foo')\n    assert (ax.xaxis.label.get_fontname() == '???')\n    rcmod.set_theme()", "ground_truth": "'Verdana'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_758", "reponame": "seaborn", "testpath": "tests/test_rcmod.py", "testname": "test_rcmod.py", "classname": "TestFonts", "funcname": "test_different_sans_serif", "imports": ["import pytest", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import numpy.testing as npt", "from seaborn import rcmod, palettes, utils"], "code": "@pytest.mark.skipif(_no_verdana, reason='Verdana font is not present')\ndef test_different_sans_serif(self):\n    rcmod.set_theme()\n    rcmod.set_style(rc={'font.sans-serif': ['Verdana']})\n    (_, ax) = plt.subplots()\n    ax.set_xlabel('foo')\n    assert (ax.xaxis.label.get_fontname() == 'Verdana')\n    rcmod.set_theme()", "masked_code": "@pytest.mark.skipif(_no_verdana, reason='Verdana font is not present')\ndef test_different_sans_serif(self):\n    rcmod.set_theme()\n    rcmod.set_style(rc={'font.sans-serif': ['Verdana']})\n    (_, ax) = plt.subplots()\n    ax.set_xlabel('foo')\n    assert (ax.xaxis.label.get_fontname() == '???')\n    rcmod.set_theme()", "ground_truth": "'Verdana'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_759", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_dropna", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_dropna(self):\n    p = lm._RegressionPlotter('x', 'y_na', data=self.df)\n    assert (len(p.x) == pd.notnull(self.df.y_na).sum())\n    p = lm._RegressionPlotter('x', 'y_na', data=self.df, dropna=False)\n    assert (len(p.x) == len(self.df.y_na))", "masked_code": "def test_dropna(self):\n    p = lm._RegressionPlotter('x', 'y_na', data=self.df)\n    assert (len(p.x) == '???')\n    p = lm._RegressionPlotter('x', 'y_na', data=self.df, dropna=False)\n    assert (len(p.x) == len(self.df.y_na))", "ground_truth": "pd.notnull(self.df.y_na).sum()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_760", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_dropna", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_dropna(self):\n    p = lm._RegressionPlotter('x', 'y_na', data=self.df)\n    assert (len(p.x) == pd.notnull(self.df.y_na).sum())\n    p = lm._RegressionPlotter('x', 'y_na', data=self.df, dropna=False)\n    assert (len(p.x) == len(self.df.y_na))", "masked_code": "def test_dropna(self):\n    p = lm._RegressionPlotter('x', 'y_na', data=self.df)\n    assert (len(p.x) == pd.notnull(self.df.y_na).sum())\n    p = lm._RegressionPlotter('x', 'y_na', data=self.df, dropna=False)\n    assert (len(p.x) == '???')", "ground_truth": "len(self.df.y_na)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_761", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_ci", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_ci(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95)\n    assert (p.ci == 95)\n    assert (p.x_ci == 95)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci=68)\n    assert (p.ci == 95)\n    assert (p.x_ci == 68)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci='sd')\n    assert (p.ci == 95)\n    assert (p.x_ci == 'sd')", "masked_code": "def test_ci(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95)\n    assert (p.ci == '???')\n    assert (p.x_ci == 95)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci=68)\n    assert (p.ci == 95)\n    assert (p.x_ci == 68)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci='sd')\n    assert (p.ci == 95)\n    assert (p.x_ci == 'sd')", "ground_truth": "95", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_762", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_ci", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_ci(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95)\n    assert (p.ci == 95)\n    assert (p.x_ci == 95)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci=68)\n    assert (p.ci == 95)\n    assert (p.x_ci == 68)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci='sd')\n    assert (p.ci == 95)\n    assert (p.x_ci == 'sd')", "masked_code": "def test_ci(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95)\n    assert (p.ci == 95)\n    assert (p.x_ci == '???')\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci=68)\n    assert (p.ci == 95)\n    assert (p.x_ci == 68)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci='sd')\n    assert (p.ci == 95)\n    assert (p.x_ci == 'sd')", "ground_truth": "95", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_763", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_ci", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_ci(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95)\n    assert (p.ci == 95)\n    assert (p.x_ci == 95)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci=68)\n    assert (p.ci == 95)\n    assert (p.x_ci == 68)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci='sd')\n    assert (p.ci == 95)\n    assert (p.x_ci == 'sd')", "masked_code": "def test_ci(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95)\n    assert (p.ci == 95)\n    assert (p.x_ci == 95)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci=68)\n    assert (p.ci == '???')\n    assert (p.x_ci == 68)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci='sd')\n    assert (p.ci == 95)\n    assert (p.x_ci == 'sd')", "ground_truth": "95", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_764", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_ci", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_ci(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95)\n    assert (p.ci == 95)\n    assert (p.x_ci == 95)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci=68)\n    assert (p.ci == 95)\n    assert (p.x_ci == 68)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci='sd')\n    assert (p.ci == 95)\n    assert (p.x_ci == 'sd')", "masked_code": "def test_ci(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95)\n    assert (p.ci == 95)\n    assert (p.x_ci == 95)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci=68)\n    assert (p.ci == 95)\n    assert (p.x_ci == '???')\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci='sd')\n    assert (p.ci == 95)\n    assert (p.x_ci == 'sd')", "ground_truth": "68", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_765", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_ci", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_ci(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95)\n    assert (p.ci == 95)\n    assert (p.x_ci == 95)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci=68)\n    assert (p.ci == 95)\n    assert (p.x_ci == 68)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci='sd')\n    assert (p.ci == 95)\n    assert (p.x_ci == 'sd')", "masked_code": "def test_ci(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95)\n    assert (p.ci == 95)\n    assert (p.x_ci == 95)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci=68)\n    assert (p.ci == 95)\n    assert (p.x_ci == 68)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci='sd')\n    assert (p.ci == '???')\n    assert (p.x_ci == 'sd')", "ground_truth": "95", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_766", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_ci", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_ci(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95)\n    assert (p.ci == 95)\n    assert (p.x_ci == 95)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci=68)\n    assert (p.ci == 95)\n    assert (p.x_ci == 68)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci='sd')\n    assert (p.ci == 95)\n    assert (p.x_ci == 'sd')", "masked_code": "def test_ci(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95)\n    assert (p.ci == 95)\n    assert (p.x_ci == 95)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci=68)\n    assert (p.ci == 95)\n    assert (p.x_ci == 68)\n    p = lm._RegressionPlotter('x', 'y', data=self.df, ci=95, x_ci='sd')\n    assert (p.ci == 95)\n    assert (p.x_ci == '???')", "ground_truth": "'sd'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_767", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_robust_regression", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "@pytest.mark.skipif(_no_statsmodels, reason='no statsmodels')\ndef test_robust_regression(self):\n    p_ols = lm._RegressionPlotter('x', 'y', data=self.df, n_boot=self.n_boot)\n    (_, ols_yhat, _) = p_ols.fit_regression(x_range=((- 3), 3))\n    p_robust = lm._RegressionPlotter('x', 'y', data=self.df, robust=True, n_boot=self.n_boot)\n    (_, robust_yhat, _) = p_robust.fit_regression(x_range=((- 3), 3))\n    assert (len(ols_yhat) == len(robust_yhat))", "masked_code": "@pytest.mark.skipif(_no_statsmodels, reason='no statsmodels')\ndef test_robust_regression(self):\n    p_ols = lm._RegressionPlotter('x', 'y', data=self.df, n_boot=self.n_boot)\n    (_, ols_yhat, _) = p_ols.fit_regression(x_range=((- 3), 3))\n    p_robust = lm._RegressionPlotter('x', 'y', data=self.df, robust=True, n_boot=self.n_boot)\n    (_, robust_yhat, _) = p_robust.fit_regression(x_range=((- 3), 3))\n    assert (len(ols_yhat) == '???')", "ground_truth": "len(robust_yhat)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_768", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_lowess_regression", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "@pytest.mark.skipif(_no_statsmodels, reason='no statsmodels')\ndef test_lowess_regression(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, lowess=True)\n    (grid, yhat, err_bands) = p.fit_regression(x_range=((- 3), 3))\n    assert (len(grid) == len(yhat))\n    assert (err_bands is None)", "masked_code": "@pytest.mark.skipif(_no_statsmodels, reason='no statsmodels')\ndef test_lowess_regression(self):\n    p = lm._RegressionPlotter('x', 'y', data=self.df, lowess=True)\n    (grid, yhat, err_bands) = p.fit_regression(x_range=((- 3), 3))\n    assert (len(grid) == '???')\n    assert (err_bands is None)", "ground_truth": "len(yhat)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_769", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_regression_limits", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_regression_limits(self):\n    (f, ax) = plt.subplots()\n    ax.scatter(self.df.x, self.df.y)\n    p = lm._RegressionPlotter('x', 'y', data=self.df)\n    (grid, _, _) = p.fit_regression(ax)\n    xlim = ax.get_xlim()\n    assert (grid.min() == xlim[0])\n    assert (grid.max() == xlim[1])\n    p = lm._RegressionPlotter('x', 'y', data=self.df, truncate=True)\n    (grid, _, _) = p.fit_regression()\n    assert (grid.min() == self.df.x.min())\n    assert (grid.max() == self.df.x.max())", "masked_code": "def test_regression_limits(self):\n    (f, ax) = plt.subplots()\n    ax.scatter(self.df.x, self.df.y)\n    p = lm._RegressionPlotter('x', 'y', data=self.df)\n    (grid, _, _) = p.fit_regression(ax)\n    xlim = ax.get_xlim()\n    assert (grid.min() == '???')\n    assert (grid.max() == xlim[1])\n    p = lm._RegressionPlotter('x', 'y', data=self.df, truncate=True)\n    (grid, _, _) = p.fit_regression()\n    assert (grid.min() == self.df.x.min())\n    assert (grid.max() == self.df.x.max())", "ground_truth": "xlim[0]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_770", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_regression_limits", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_regression_limits(self):\n    (f, ax) = plt.subplots()\n    ax.scatter(self.df.x, self.df.y)\n    p = lm._RegressionPlotter('x', 'y', data=self.df)\n    (grid, _, _) = p.fit_regression(ax)\n    xlim = ax.get_xlim()\n    assert (grid.min() == xlim[0])\n    assert (grid.max() == xlim[1])\n    p = lm._RegressionPlotter('x', 'y', data=self.df, truncate=True)\n    (grid, _, _) = p.fit_regression()\n    assert (grid.min() == self.df.x.min())\n    assert (grid.max() == self.df.x.max())", "masked_code": "def test_regression_limits(self):\n    (f, ax) = plt.subplots()\n    ax.scatter(self.df.x, self.df.y)\n    p = lm._RegressionPlotter('x', 'y', data=self.df)\n    (grid, _, _) = p.fit_regression(ax)\n    xlim = ax.get_xlim()\n    assert (grid.min() == xlim[0])\n    assert (grid.max() == '???')\n    p = lm._RegressionPlotter('x', 'y', data=self.df, truncate=True)\n    (grid, _, _) = p.fit_regression()\n    assert (grid.min() == self.df.x.min())\n    assert (grid.max() == self.df.x.max())", "ground_truth": "xlim[1]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_771", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_regression_limits", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_regression_limits(self):\n    (f, ax) = plt.subplots()\n    ax.scatter(self.df.x, self.df.y)\n    p = lm._RegressionPlotter('x', 'y', data=self.df)\n    (grid, _, _) = p.fit_regression(ax)\n    xlim = ax.get_xlim()\n    assert (grid.min() == xlim[0])\n    assert (grid.max() == xlim[1])\n    p = lm._RegressionPlotter('x', 'y', data=self.df, truncate=True)\n    (grid, _, _) = p.fit_regression()\n    assert (grid.min() == self.df.x.min())\n    assert (grid.max() == self.df.x.max())", "masked_code": "def test_regression_limits(self):\n    (f, ax) = plt.subplots()\n    ax.scatter(self.df.x, self.df.y)\n    p = lm._RegressionPlotter('x', 'y', data=self.df)\n    (grid, _, _) = p.fit_regression(ax)\n    xlim = ax.get_xlim()\n    assert (grid.min() == xlim[0])\n    assert (grid.max() == xlim[1])\n    p = lm._RegressionPlotter('x', 'y', data=self.df, truncate=True)\n    (grid, _, _) = p.fit_regression()\n    assert (grid.min() == '???')\n    assert (grid.max() == self.df.x.max())", "ground_truth": "self.df.x.min()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_772", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlotter", "funcname": "test_regression_limits", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_regression_limits(self):\n    (f, ax) = plt.subplots()\n    ax.scatter(self.df.x, self.df.y)\n    p = lm._RegressionPlotter('x', 'y', data=self.df)\n    (grid, _, _) = p.fit_regression(ax)\n    xlim = ax.get_xlim()\n    assert (grid.min() == xlim[0])\n    assert (grid.max() == xlim[1])\n    p = lm._RegressionPlotter('x', 'y', data=self.df, truncate=True)\n    (grid, _, _) = p.fit_regression()\n    assert (grid.min() == self.df.x.min())\n    assert (grid.max() == self.df.x.max())", "masked_code": "def test_regression_limits(self):\n    (f, ax) = plt.subplots()\n    ax.scatter(self.df.x, self.df.y)\n    p = lm._RegressionPlotter('x', 'y', data=self.df)\n    (grid, _, _) = p.fit_regression(ax)\n    xlim = ax.get_xlim()\n    assert (grid.min() == xlim[0])\n    assert (grid.max() == xlim[1])\n    p = lm._RegressionPlotter('x', 'y', data=self.df, truncate=True)\n    (grid, _, _) = p.fit_regression()\n    assert (grid.min() == self.df.x.min())\n    assert (grid.max() == '???')", "ground_truth": "self.df.x.max()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_773", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_regplot_scatter_kws_alpha", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_regplot_scatter_kws_alpha(self):\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha is None)\n    assert (ax.collections[0]._facecolors[(0, 3)] == 0.5)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color, 'alpha': 0.4})\n    assert (ax.collections[0]._alpha == 0.4)\n    (f, ax) = plt.subplots()\n    color = 'r'\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    alpha = 0.3\n    ax = lm.regplot(x='x', y='y', data=self.df, x_bins=5, fit_reg=False, scatter_kws={'alpha': alpha})\n    for line in ax.lines:\n        assert (line.get_alpha() == alpha)", "masked_code": "def test_regplot_scatter_kws_alpha(self):\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha is None)\n    assert (ax.collections[0]._facecolors[(0, 3)] == '???')\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color, 'alpha': 0.4})\n    assert (ax.collections[0]._alpha == 0.4)\n    (f, ax) = plt.subplots()\n    color = 'r'\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    alpha = 0.3\n    ax = lm.regplot(x='x', y='y', data=self.df, x_bins=5, fit_reg=False, scatter_kws={'alpha': alpha})\n    for line in ax.lines:\n        assert (line.get_alpha() == alpha)", "ground_truth": "0.5", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_774", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_regplot_scatter_kws_alpha", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_regplot_scatter_kws_alpha(self):\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha is None)\n    assert (ax.collections[0]._facecolors[(0, 3)] == 0.5)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color, 'alpha': 0.4})\n    assert (ax.collections[0]._alpha == 0.4)\n    (f, ax) = plt.subplots()\n    color = 'r'\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    alpha = 0.3\n    ax = lm.regplot(x='x', y='y', data=self.df, x_bins=5, fit_reg=False, scatter_kws={'alpha': alpha})\n    for line in ax.lines:\n        assert (line.get_alpha() == alpha)", "masked_code": "def test_regplot_scatter_kws_alpha(self):\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha is None)\n    assert (ax.collections[0]._facecolors[(0, 3)] == 0.5)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == '???')\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color, 'alpha': 0.4})\n    assert (ax.collections[0]._alpha == 0.4)\n    (f, ax) = plt.subplots()\n    color = 'r'\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    alpha = 0.3\n    ax = lm.regplot(x='x', y='y', data=self.df, x_bins=5, fit_reg=False, scatter_kws={'alpha': alpha})\n    for line in ax.lines:\n        assert (line.get_alpha() == alpha)", "ground_truth": "0.8", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_775", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_regplot_scatter_kws_alpha", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_regplot_scatter_kws_alpha(self):\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha is None)\n    assert (ax.collections[0]._facecolors[(0, 3)] == 0.5)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color, 'alpha': 0.4})\n    assert (ax.collections[0]._alpha == 0.4)\n    (f, ax) = plt.subplots()\n    color = 'r'\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    alpha = 0.3\n    ax = lm.regplot(x='x', y='y', data=self.df, x_bins=5, fit_reg=False, scatter_kws={'alpha': alpha})\n    for line in ax.lines:\n        assert (line.get_alpha() == alpha)", "masked_code": "def test_regplot_scatter_kws_alpha(self):\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha is None)\n    assert (ax.collections[0]._facecolors[(0, 3)] == 0.5)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color, 'alpha': 0.4})\n    assert (ax.collections[0]._alpha == '???')\n    (f, ax) = plt.subplots()\n    color = 'r'\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    alpha = 0.3\n    ax = lm.regplot(x='x', y='y', data=self.df, x_bins=5, fit_reg=False, scatter_kws={'alpha': alpha})\n    for line in ax.lines:\n        assert (line.get_alpha() == alpha)", "ground_truth": "0.4", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_776", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_regplot_scatter_kws_alpha", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_regplot_scatter_kws_alpha(self):\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha is None)\n    assert (ax.collections[0]._facecolors[(0, 3)] == 0.5)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color, 'alpha': 0.4})\n    assert (ax.collections[0]._alpha == 0.4)\n    (f, ax) = plt.subplots()\n    color = 'r'\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    alpha = 0.3\n    ax = lm.regplot(x='x', y='y', data=self.df, x_bins=5, fit_reg=False, scatter_kws={'alpha': alpha})\n    for line in ax.lines:\n        assert (line.get_alpha() == alpha)", "masked_code": "def test_regplot_scatter_kws_alpha(self):\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha is None)\n    assert (ax.collections[0]._facecolors[(0, 3)] == 0.5)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color, 'alpha': 0.4})\n    assert (ax.collections[0]._alpha == 0.4)\n    (f, ax) = plt.subplots()\n    color = 'r'\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == '???')\n    (f, ax) = plt.subplots()\n    alpha = 0.3\n    ax = lm.regplot(x='x', y='y', data=self.df, x_bins=5, fit_reg=False, scatter_kws={'alpha': alpha})\n    for line in ax.lines:\n        assert (line.get_alpha() == alpha)", "ground_truth": "0.8", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_777", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_regplot_scatter_kws_alpha", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_regplot_scatter_kws_alpha(self):\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha is None)\n    assert (ax.collections[0]._facecolors[(0, 3)] == 0.5)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color, 'alpha': 0.4})\n    assert (ax.collections[0]._alpha == 0.4)\n    (f, ax) = plt.subplots()\n    color = 'r'\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    alpha = 0.3\n    ax = lm.regplot(x='x', y='y', data=self.df, x_bins=5, fit_reg=False, scatter_kws={'alpha': alpha})\n    for line in ax.lines:\n        assert (line.get_alpha() == alpha)", "masked_code": "def test_regplot_scatter_kws_alpha(self):\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha is None)\n    assert (ax.collections[0]._facecolors[(0, 3)] == 0.5)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    color = np.array([[0.3, 0.8, 0.5]])\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color, 'alpha': 0.4})\n    assert (ax.collections[0]._alpha == 0.4)\n    (f, ax) = plt.subplots()\n    color = 'r'\n    ax = lm.regplot(x='x', y='y', data=self.df, scatter_kws={'color': color})\n    assert (ax.collections[0]._alpha == 0.8)\n    (f, ax) = plt.subplots()\n    alpha = 0.3\n    ax = lm.regplot(x='x', y='y', data=self.df, x_bins=5, fit_reg=False, scatter_kws={'alpha': alpha})\n    for line in ax.lines:\n        assert (line.get_alpha() == '???')", "ground_truth": "alpha", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_778", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_regplot_binned", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_regplot_binned(self):\n    ax = lm.regplot(x='x', y='y', data=self.df, x_bins=5)\n    assert (len(ax.lines) == 6)\n    assert (len(ax.collections) == 2)", "masked_code": "def test_regplot_binned(self):\n    ax = lm.regplot(x='x', y='y', data=self.df, x_bins=5)\n    assert (len(ax.lines) == '???')\n    assert (len(ax.collections) == 2)", "ground_truth": "6", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_779", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_lmplot_hue", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_lmplot_hue(self):\n    g = lm.lmplot(x='x', y='y', data=self.df, hue='h')\n    ax = g.axes[(0, 0)]\n    assert (len(ax.lines) == 2)\n    assert (len(ax.collections) == 4)", "masked_code": "def test_lmplot_hue(self):\n    g = lm.lmplot(x='x', y='y', data=self.df, hue='h')\n    ax = g.axes[(0, 0)]\n    assert (len(ax.lines) == 2)\n    assert (len(ax.collections) == '???')", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_780", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_lmplot_markers", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_lmplot_markers(self):\n    g1 = lm.lmplot(x='x', y='y', data=self.df, hue='h', markers='s')\n    assert (g1.hue_kws == {'marker': ['s', 's']})\n    g2 = lm.lmplot(x='x', y='y', data=self.df, hue='h', markers=['o', 's'])\n    assert (g2.hue_kws == {'marker': ['o', 's']})\n    with pytest.raises(ValueError):\n        lm.lmplot(x='x', y='y', data=self.df, hue='h', markers=['o', 's', 'd'])", "masked_code": "def test_lmplot_markers(self):\n    g1 = lm.lmplot(x='x', y='y', data=self.df, hue='h', markers='s')\n    assert (g1.hue_kws == '???')\n    g2 = lm.lmplot(x='x', y='y', data=self.df, hue='h', markers=['o', 's'])\n    assert (g2.hue_kws == {'marker': ['o', 's']})\n    with pytest.raises(ValueError):\n        lm.lmplot(x='x', y='y', data=self.df, hue='h', markers=['o', 's', 'd'])", "ground_truth": "{'marker': ['s', 's']}", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_781", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_lmplot_markers", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_lmplot_markers(self):\n    g1 = lm.lmplot(x='x', y='y', data=self.df, hue='h', markers='s')\n    assert (g1.hue_kws == {'marker': ['s', 's']})\n    g2 = lm.lmplot(x='x', y='y', data=self.df, hue='h', markers=['o', 's'])\n    assert (g2.hue_kws == {'marker': ['o', 's']})\n    with pytest.raises(ValueError):\n        lm.lmplot(x='x', y='y', data=self.df, hue='h', markers=['o', 's', 'd'])", "masked_code": "def test_lmplot_markers(self):\n    g1 = lm.lmplot(x='x', y='y', data=self.df, hue='h', markers='s')\n    assert (g1.hue_kws == {'marker': ['s', 's']})\n    g2 = lm.lmplot(x='x', y='y', data=self.df, hue='h', markers=['o', 's'])\n    assert (g2.hue_kws == '???')\n    with pytest.raises(ValueError):\n        lm.lmplot(x='x', y='y', data=self.df, hue='h', markers=['o', 's', 'd'])", "ground_truth": "{'marker': ['o', 's']}", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_782", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_lmplot_marker_linewidths", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_lmplot_marker_linewidths(self):\n    g = lm.lmplot(x='x', y='y', data=self.df, hue='h', fit_reg=False, markers=['o', '+'])\n    c = g.axes[(0, 0)].collections\n    assert (c[1].get_linewidths()[0] == mpl.rcParams['lines.linewidth'])", "masked_code": "def test_lmplot_marker_linewidths(self):\n    g = lm.lmplot(x='x', y='y', data=self.df, hue='h', fit_reg=False, markers=['o', '+'])\n    c = g.axes[(0, 0)].collections\n    assert (c[1].get_linewidths()[0] == '???')", "ground_truth": "mpl.rcParams['lines.linewidth']", "quality_analysis": {"complexity_score": 13, "left_complexity": 7, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_783", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_lmplot_facets", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_lmplot_facets(self):\n    g = lm.lmplot(x='x', y='y', data=self.df, row='g', col='h')\n    assert (g.axes.shape == (3, 2))\n    g = lm.lmplot(x='x', y='y', data=self.df, col='u', col_wrap=4)\n    assert (g.axes.shape == (6,))\n    g = lm.lmplot(x='x', y='y', data=self.df, hue='h', col='u')\n    assert (g.axes.shape == (1, 6))", "masked_code": "def test_lmplot_facets(self):\n    g = lm.lmplot(x='x', y='y', data=self.df, row='g', col='h')\n    assert (g.axes.shape == '???')\n    g = lm.lmplot(x='x', y='y', data=self.df, col='u', col_wrap=4)\n    assert (g.axes.shape == (6,))\n    g = lm.lmplot(x='x', y='y', data=self.df, hue='h', col='u')\n    assert (g.axes.shape == (1, 6))", "ground_truth": "(3, 2)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_784", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_lmplot_facets", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_lmplot_facets(self):\n    g = lm.lmplot(x='x', y='y', data=self.df, row='g', col='h')\n    assert (g.axes.shape == (3, 2))\n    g = lm.lmplot(x='x', y='y', data=self.df, col='u', col_wrap=4)\n    assert (g.axes.shape == (6,))\n    g = lm.lmplot(x='x', y='y', data=self.df, hue='h', col='u')\n    assert (g.axes.shape == (1, 6))", "masked_code": "def test_lmplot_facets(self):\n    g = lm.lmplot(x='x', y='y', data=self.df, row='g', col='h')\n    assert (g.axes.shape == (3, 2))\n    g = lm.lmplot(x='x', y='y', data=self.df, col='u', col_wrap=4)\n    assert (g.axes.shape == '???')\n    g = lm.lmplot(x='x', y='y', data=self.df, hue='h', col='u')\n    assert (g.axes.shape == (1, 6))", "ground_truth": "(6,)", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_785", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_lmplot_facets", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_lmplot_facets(self):\n    g = lm.lmplot(x='x', y='y', data=self.df, row='g', col='h')\n    assert (g.axes.shape == (3, 2))\n    g = lm.lmplot(x='x', y='y', data=self.df, col='u', col_wrap=4)\n    assert (g.axes.shape == (6,))\n    g = lm.lmplot(x='x', y='y', data=self.df, hue='h', col='u')\n    assert (g.axes.shape == (1, 6))", "masked_code": "def test_lmplot_facets(self):\n    g = lm.lmplot(x='x', y='y', data=self.df, row='g', col='h')\n    assert (g.axes.shape == (3, 2))\n    g = lm.lmplot(x='x', y='y', data=self.df, col='u', col_wrap=4)\n    assert (g.axes.shape == (6,))\n    g = lm.lmplot(x='x', y='y', data=self.df, hue='h', col='u')\n    assert (g.axes.shape == '???')", "ground_truth": "(1, 6)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_786", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_lmplot_facet_truncate", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "@pytest.mark.parametrize('sharex', [True, False])\ndef test_lmplot_facet_truncate(self, sharex):\n    g = lm.lmplot(data=self.df, x='x', y='y', hue='g', col='h', truncate=False, facet_kws=dict(sharex=sharex))\n    for ax in g.axes.flat:\n        for line in ax.lines:\n            xdata = line.get_xdata()\n            assert (ax.get_xlim() == tuple(xdata[[0, (- 1)]]))", "masked_code": "@pytest.mark.parametrize('sharex', [True, False])\ndef test_lmplot_facet_truncate(self, sharex):\n    g = lm.lmplot(data=self.df, x='x', y='y', hue='g', col='h', truncate=False, facet_kws=dict(sharex=sharex))\n    for ax in g.axes.flat:\n        for line in ax.lines:\n            xdata = line.get_xdata()\n            assert (ax.get_xlim() == '???')", "ground_truth": "tuple(xdata[[0, (- 1)]])", "quality_analysis": {"complexity_score": 16, "left_complexity": 3, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_787", "reponame": "seaborn", "testpath": "tests/test_regression.py", "testname": "test_regression.py", "classname": "TestRegressionPlots", "funcname": "test_lmplot_facet_kws", "imports": ["import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "import pandas as pd", "import pytest", "import numpy.testing as npt", "import pandas.testing as pdt", "from seaborn import regression as lm", "from seaborn.palettes import color_palette"], "code": "def test_lmplot_facet_kws(self):\n    xlim = ((- 4), 20)\n    g = lm.lmplot(data=self.df, x='x', y='y', col='h', facet_kws={'xlim': xlim})\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == xlim)", "masked_code": "def test_lmplot_facet_kws(self):\n    xlim = ((- 4), 20)\n    g = lm.lmplot(data=self.df, x='x', y='y', col='h', facet_kws={'xlim': xlim})\n    for ax in g.axes.flat:\n        assert (ax.get_xlim() == '???')", "ground_truth": "xlim", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_788", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "SharedAxesLevelTests", "funcname": "test_color", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_color(self, long_df):\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))", "masked_code": "def test_color(self, long_df):\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == '???')\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))", "ground_truth": "to_rgba('C0')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_789", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "SharedAxesLevelTests", "funcname": "test_color", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_color(self, long_df):\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))", "masked_code": "def test_color(self, long_df):\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == '???')\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))", "ground_truth": "to_rgba('C1')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_790", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "SharedAxesLevelTests", "funcname": "test_color", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_color(self, long_df):\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))", "masked_code": "def test_color(self, long_df):\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n    assert (self.get_last_color(ax) == '???')\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))", "ground_truth": "to_rgba('C2')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_791", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "SharedAxesLevelTests", "funcname": "test_color", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_color(self, long_df):\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))", "masked_code": "def test_color(self, long_df):\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C0'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    self.func(data=long_df, x='x', y='y', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C1'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C2'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n    assert (self.get_last_color(ax) == '???')", "ground_truth": "to_rgba('C2')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_792", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_df_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_df_variables(self, wide_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(wide_df.index, wide_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(wide_df.columns.to_numpy(), wide_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == wide_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == wide_df.columns.name)\n    assert (p.variables['style'] == wide_df.columns.name)", "masked_code": "def test_wide_df_variables(self, wide_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_df)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(wide_df.index, wide_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(wide_df.columns.to_numpy(), wide_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == wide_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == wide_df.columns.name)\n    assert (p.variables['style'] == wide_df.columns.name)", "ground_truth": "'wide'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_793", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_df_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_df_variables(self, wide_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(wide_df.index, wide_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(wide_df.columns.to_numpy(), wide_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == wide_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == wide_df.columns.name)\n    assert (p.variables['style'] == wide_df.columns.name)", "masked_code": "def test_wide_df_variables(self, wide_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == '???')\n    assert (len(p.plot_data) == np.prod(wide_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(wide_df.index, wide_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(wide_df.columns.to_numpy(), wide_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == wide_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == wide_df.columns.name)\n    assert (p.variables['style'] == wide_df.columns.name)", "ground_truth": "['x', 'y', 'hue', 'style']", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_794", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_df_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_df_variables(self, wide_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(wide_df.index, wide_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(wide_df.columns.to_numpy(), wide_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == wide_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == wide_df.columns.name)\n    assert (p.variables['style'] == wide_df.columns.name)", "masked_code": "def test_wide_df_variables(self, wide_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == '???')\n    x = p.plot_data['x']\n    expected_x = np.tile(wide_df.index, wide_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(wide_df.columns.to_numpy(), wide_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == wide_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == wide_df.columns.name)\n    assert (p.variables['style'] == wide_df.columns.name)", "ground_truth": "np.prod(wide_df.shape)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_795", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_df_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_df_variables(self, wide_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(wide_df.index, wide_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(wide_df.columns.to_numpy(), wide_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == wide_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == wide_df.columns.name)\n    assert (p.variables['style'] == wide_df.columns.name)", "masked_code": "def test_wide_df_variables(self, wide_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(wide_df.index, wide_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(wide_df.columns.to_numpy(), wide_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == '???')\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == wide_df.columns.name)\n    assert (p.variables['style'] == wide_df.columns.name)", "ground_truth": "wide_df.index.name", "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_796", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_df_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_df_variables(self, wide_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(wide_df.index, wide_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(wide_df.columns.to_numpy(), wide_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == wide_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == wide_df.columns.name)\n    assert (p.variables['style'] == wide_df.columns.name)", "masked_code": "def test_wide_df_variables(self, wide_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(wide_df.index, wide_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(wide_df.columns.to_numpy(), wide_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == wide_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == '???')\n    assert (p.variables['style'] == wide_df.columns.name)", "ground_truth": "wide_df.columns.name", "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_797", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_df_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_df_variables(self, wide_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(wide_df.index, wide_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(wide_df.columns.to_numpy(), wide_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == wide_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == wide_df.columns.name)\n    assert (p.variables['style'] == wide_df.columns.name)", "masked_code": "def test_wide_df_variables(self, wide_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(wide_df.index, wide_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(wide_df.columns.to_numpy(), wide_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == wide_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == wide_df.columns.name)\n    assert (p.variables['style'] == '???')", "ground_truth": "wide_df.columns.name", "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_798", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_df_with_nonnumeric_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_df_with_nonnumeric_variables(self, long_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=long_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    numeric_df = long_df.select_dtypes('number')\n    assert (len(p.plot_data) == np.prod(numeric_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(numeric_df.index, numeric_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = numeric_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(numeric_df.columns.to_numpy(), numeric_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == numeric_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == numeric_df.columns.name)\n    assert (p.variables['style'] == numeric_df.columns.name)", "masked_code": "def test_wide_df_with_nonnumeric_variables(self, long_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=long_df)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    numeric_df = long_df.select_dtypes('number')\n    assert (len(p.plot_data) == np.prod(numeric_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(numeric_df.index, numeric_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = numeric_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(numeric_df.columns.to_numpy(), numeric_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == numeric_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == numeric_df.columns.name)\n    assert (p.variables['style'] == numeric_df.columns.name)", "ground_truth": "'wide'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_799", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_df_with_nonnumeric_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_df_with_nonnumeric_variables(self, long_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=long_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    numeric_df = long_df.select_dtypes('number')\n    assert (len(p.plot_data) == np.prod(numeric_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(numeric_df.index, numeric_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = numeric_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(numeric_df.columns.to_numpy(), numeric_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == numeric_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == numeric_df.columns.name)\n    assert (p.variables['style'] == numeric_df.columns.name)", "masked_code": "def test_wide_df_with_nonnumeric_variables(self, long_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=long_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == '???')\n    numeric_df = long_df.select_dtypes('number')\n    assert (len(p.plot_data) == np.prod(numeric_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(numeric_df.index, numeric_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = numeric_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(numeric_df.columns.to_numpy(), numeric_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == numeric_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == numeric_df.columns.name)\n    assert (p.variables['style'] == numeric_df.columns.name)", "ground_truth": "['x', 'y', 'hue', 'style']", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_800", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_df_with_nonnumeric_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_df_with_nonnumeric_variables(self, long_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=long_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    numeric_df = long_df.select_dtypes('number')\n    assert (len(p.plot_data) == np.prod(numeric_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(numeric_df.index, numeric_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = numeric_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(numeric_df.columns.to_numpy(), numeric_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == numeric_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == numeric_df.columns.name)\n    assert (p.variables['style'] == numeric_df.columns.name)", "masked_code": "def test_wide_df_with_nonnumeric_variables(self, long_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=long_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    numeric_df = long_df.select_dtypes('number')\n    assert (len(p.plot_data) == '???')\n    x = p.plot_data['x']\n    expected_x = np.tile(numeric_df.index, numeric_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = numeric_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(numeric_df.columns.to_numpy(), numeric_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == numeric_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == numeric_df.columns.name)\n    assert (p.variables['style'] == numeric_df.columns.name)", "ground_truth": "np.prod(numeric_df.shape)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_801", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_df_with_nonnumeric_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_df_with_nonnumeric_variables(self, long_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=long_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    numeric_df = long_df.select_dtypes('number')\n    assert (len(p.plot_data) == np.prod(numeric_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(numeric_df.index, numeric_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = numeric_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(numeric_df.columns.to_numpy(), numeric_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == numeric_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == numeric_df.columns.name)\n    assert (p.variables['style'] == numeric_df.columns.name)", "masked_code": "def test_wide_df_with_nonnumeric_variables(self, long_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=long_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    numeric_df = long_df.select_dtypes('number')\n    assert (len(p.plot_data) == np.prod(numeric_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(numeric_df.index, numeric_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = numeric_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(numeric_df.columns.to_numpy(), numeric_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == '???')\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == numeric_df.columns.name)\n    assert (p.variables['style'] == numeric_df.columns.name)", "ground_truth": "numeric_df.index.name", "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_802", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_df_with_nonnumeric_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_df_with_nonnumeric_variables(self, long_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=long_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    numeric_df = long_df.select_dtypes('number')\n    assert (len(p.plot_data) == np.prod(numeric_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(numeric_df.index, numeric_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = numeric_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(numeric_df.columns.to_numpy(), numeric_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == numeric_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == numeric_df.columns.name)\n    assert (p.variables['style'] == numeric_df.columns.name)", "masked_code": "def test_wide_df_with_nonnumeric_variables(self, long_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=long_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    numeric_df = long_df.select_dtypes('number')\n    assert (len(p.plot_data) == np.prod(numeric_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(numeric_df.index, numeric_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = numeric_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(numeric_df.columns.to_numpy(), numeric_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == numeric_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == '???')\n    assert (p.variables['style'] == numeric_df.columns.name)", "ground_truth": "numeric_df.columns.name", "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_803", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_df_with_nonnumeric_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_df_with_nonnumeric_variables(self, long_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=long_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    numeric_df = long_df.select_dtypes('number')\n    assert (len(p.plot_data) == np.prod(numeric_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(numeric_df.index, numeric_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = numeric_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(numeric_df.columns.to_numpy(), numeric_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == numeric_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == numeric_df.columns.name)\n    assert (p.variables['style'] == numeric_df.columns.name)", "masked_code": "def test_wide_df_with_nonnumeric_variables(self, long_df):\n    p = _RelationalPlotter()\n    p.assign_variables(data=long_df)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    numeric_df = long_df.select_dtypes('number')\n    assert (len(p.plot_data) == np.prod(numeric_df.shape))\n    x = p.plot_data['x']\n    expected_x = np.tile(numeric_df.index, numeric_df.shape[1])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = numeric_df.to_numpy().ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(numeric_df.columns.to_numpy(), numeric_df.shape[0])\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] == numeric_df.index.name)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] == numeric_df.columns.name)\n    assert (p.variables['style'] == '???')", "ground_truth": "numeric_df.columns.name", "quality_analysis": {"complexity_score": 8, "left_complexity": 6, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_804", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_array_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_array_variables(self, wide_array):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_array)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_array.shape))\n    (nrow, ncol) = wide_array.shape\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(nrow), ncol)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_array.ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(ncol), nrow)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_array_variables(self, wide_array):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_array)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_array.shape))\n    (nrow, ncol) = wide_array.shape\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(nrow), ncol)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_array.ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(ncol), nrow)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "'wide'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_805", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_array_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_array_variables(self, wide_array):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_array)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_array.shape))\n    (nrow, ncol) = wide_array.shape\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(nrow), ncol)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_array.ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(ncol), nrow)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_array_variables(self, wide_array):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_array)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == '???')\n    assert (len(p.plot_data) == np.prod(wide_array.shape))\n    (nrow, ncol) = wide_array.shape\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(nrow), ncol)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_array.ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(ncol), nrow)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "['x', 'y', 'hue', 'style']", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_806", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_array_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_array_variables(self, wide_array):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_array)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == np.prod(wide_array.shape))\n    (nrow, ncol) = wide_array.shape\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(nrow), ncol)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_array.ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(ncol), nrow)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_array_variables(self, wide_array):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_array)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    assert (len(p.plot_data) == '???')\n    (nrow, ncol) = wide_array.shape\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(nrow), ncol)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = wide_array.ravel(order='f')\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(ncol), nrow)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "np.prod(wide_array.shape)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_807", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_flat_array_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_flat_array_variables(self, flat_array):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_array)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == np.prod(flat_array.shape))\n    x = p.plot_data['x']\n    expected_x = np.arange(flat_array.shape[0])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_array\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)", "masked_code": "def test_flat_array_variables(self, flat_array):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_array)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == np.prod(flat_array.shape))\n    x = p.plot_data['x']\n    expected_x = np.arange(flat_array.shape[0])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_array\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)", "ground_truth": "'wide'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_808", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_flat_array_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_flat_array_variables(self, flat_array):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_array)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == np.prod(flat_array.shape))\n    x = p.plot_data['x']\n    expected_x = np.arange(flat_array.shape[0])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_array\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)", "masked_code": "def test_flat_array_variables(self, flat_array):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_array)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == '???')\n    assert (len(p.plot_data) == np.prod(flat_array.shape))\n    x = p.plot_data['x']\n    expected_x = np.arange(flat_array.shape[0])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_array\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)", "ground_truth": "['x', 'y']", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_809", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_flat_array_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_flat_array_variables(self, flat_array):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_array)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == np.prod(flat_array.shape))\n    x = p.plot_data['x']\n    expected_x = np.arange(flat_array.shape[0])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_array\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)", "masked_code": "def test_flat_array_variables(self, flat_array):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_array)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == '???')\n    x = p.plot_data['x']\n    expected_x = np.arange(flat_array.shape[0])\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_array\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)", "ground_truth": "np.prod(flat_array.shape)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_810", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_flat_list_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_flat_list_variables(self, flat_list):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_list)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_list))\n    x = p.plot_data['x']\n    expected_x = np.arange(len(flat_list))\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_list\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)", "masked_code": "def test_flat_list_variables(self, flat_list):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_list)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_list))\n    x = p.plot_data['x']\n    expected_x = np.arange(len(flat_list))\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_list\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)", "ground_truth": "'wide'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_811", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_flat_list_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_flat_list_variables(self, flat_list):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_list)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_list))\n    x = p.plot_data['x']\n    expected_x = np.arange(len(flat_list))\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_list\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)", "masked_code": "def test_flat_list_variables(self, flat_list):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_list)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == '???')\n    assert (len(p.plot_data) == len(flat_list))\n    x = p.plot_data['x']\n    expected_x = np.arange(len(flat_list))\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_list\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)", "ground_truth": "['x', 'y']", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_812", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_flat_list_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_flat_list_variables(self, flat_list):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_list)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_list))\n    x = p.plot_data['x']\n    expected_x = np.arange(len(flat_list))\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_list\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)", "masked_code": "def test_flat_list_variables(self, flat_list):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_list)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == '???')\n    x = p.plot_data['x']\n    expected_x = np.arange(len(flat_list))\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_list\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)", "ground_truth": "len(flat_list)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_813", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_flat_series_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_flat_series_variables(self, flat_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_series))\n    x = p.plot_data['x']\n    expected_x = flat_series.index\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_series\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is flat_series.index.name)\n    assert (p.variables['y'] is flat_series.name)", "masked_code": "def test_flat_series_variables(self, flat_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_series)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_series))\n    x = p.plot_data['x']\n    expected_x = flat_series.index\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_series\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is flat_series.index.name)\n    assert (p.variables['y'] is flat_series.name)", "ground_truth": "'wide'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_814", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_flat_series_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_flat_series_variables(self, flat_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_series))\n    x = p.plot_data['x']\n    expected_x = flat_series.index\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_series\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is flat_series.index.name)\n    assert (p.variables['y'] is flat_series.name)", "masked_code": "def test_flat_series_variables(self, flat_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == '???')\n    assert (len(p.plot_data) == len(flat_series))\n    x = p.plot_data['x']\n    expected_x = flat_series.index\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_series\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is flat_series.index.name)\n    assert (p.variables['y'] is flat_series.name)", "ground_truth": "['x', 'y']", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_815", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_flat_series_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_flat_series_variables(self, flat_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == len(flat_series))\n    x = p.plot_data['x']\n    expected_x = flat_series.index\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_series\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is flat_series.index.name)\n    assert (p.variables['y'] is flat_series.name)", "masked_code": "def test_flat_series_variables(self, flat_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=flat_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y'])\n    assert (len(p.plot_data) == '???')\n    x = p.plot_data['x']\n    expected_x = flat_series.index\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = flat_series\n    assert_array_equal(y, expected_y)\n    assert (p.variables['x'] is flat_series.index.name)\n    assert (p.variables['y'] is flat_series.name)", "ground_truth": "len(flat_series)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_816", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_list_of_series_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_list_of_series_variables(self, wide_list_of_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_series)\n    chunk_size = max((len(l) for l in wide_list_of_series))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    index_union = np.unique(np.concatenate([s.index for s in wide_list_of_series]))\n    x = p.plot_data['x']\n    expected_x = np.tile(index_union, chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = np.concatenate([s.reindex(index_union) for s in wide_list_of_series])\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    series_names = [s.name for s in wide_list_of_series]\n    expected_hue = np.repeat(series_names, chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_list_of_series_variables(self, wide_list_of_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_series)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_series)\n    chunk_size = max((len(l) for l in wide_list_of_series))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    index_union = np.unique(np.concatenate([s.index for s in wide_list_of_series]))\n    x = p.plot_data['x']\n    expected_x = np.tile(index_union, chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = np.concatenate([s.reindex(index_union) for s in wide_list_of_series])\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    series_names = [s.name for s in wide_list_of_series]\n    expected_hue = np.repeat(series_names, chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "'wide'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_817", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_list_of_series_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_list_of_series_variables(self, wide_list_of_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_series)\n    chunk_size = max((len(l) for l in wide_list_of_series))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    index_union = np.unique(np.concatenate([s.index for s in wide_list_of_series]))\n    x = p.plot_data['x']\n    expected_x = np.tile(index_union, chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = np.concatenate([s.reindex(index_union) for s in wide_list_of_series])\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    series_names = [s.name for s in wide_list_of_series]\n    expected_hue = np.repeat(series_names, chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_list_of_series_variables(self, wide_list_of_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == '???')\n    chunks = len(wide_list_of_series)\n    chunk_size = max((len(l) for l in wide_list_of_series))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    index_union = np.unique(np.concatenate([s.index for s in wide_list_of_series]))\n    x = p.plot_data['x']\n    expected_x = np.tile(index_union, chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = np.concatenate([s.reindex(index_union) for s in wide_list_of_series])\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    series_names = [s.name for s in wide_list_of_series]\n    expected_hue = np.repeat(series_names, chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "['x', 'y', 'hue', 'style']", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_818", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_list_of_series_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_list_of_series_variables(self, wide_list_of_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_series)\n    chunk_size = max((len(l) for l in wide_list_of_series))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    index_union = np.unique(np.concatenate([s.index for s in wide_list_of_series]))\n    x = p.plot_data['x']\n    expected_x = np.tile(index_union, chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = np.concatenate([s.reindex(index_union) for s in wide_list_of_series])\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    series_names = [s.name for s in wide_list_of_series]\n    expected_hue = np.repeat(series_names, chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_list_of_series_variables(self, wide_list_of_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_series)\n    chunk_size = max((len(l) for l in wide_list_of_series))\n    assert (len(p.plot_data) == '???')\n    index_union = np.unique(np.concatenate([s.index for s in wide_list_of_series]))\n    x = p.plot_data['x']\n    expected_x = np.tile(index_union, chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y']\n    expected_y = np.concatenate([s.reindex(index_union) for s in wide_list_of_series])\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    series_names = [s.name for s in wide_list_of_series]\n    expected_hue = np.repeat(series_names, chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "(chunks * chunk_size)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_819", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_list_of_arrays_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_list_of_arrays_variables(self, wide_list_of_arrays):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_arrays)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_arrays)\n    chunk_size = max((len(l) for l in wide_list_of_arrays))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(wide_list_of_arrays)\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(chunks), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_list_of_arrays_variables(self, wide_list_of_arrays):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_arrays)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_arrays)\n    chunk_size = max((len(l) for l in wide_list_of_arrays))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(wide_list_of_arrays)\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(chunks), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "'wide'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_820", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_list_of_arrays_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_list_of_arrays_variables(self, wide_list_of_arrays):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_arrays)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_arrays)\n    chunk_size = max((len(l) for l in wide_list_of_arrays))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(wide_list_of_arrays)\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(chunks), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_list_of_arrays_variables(self, wide_list_of_arrays):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_arrays)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == '???')\n    chunks = len(wide_list_of_arrays)\n    chunk_size = max((len(l) for l in wide_list_of_arrays))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(wide_list_of_arrays)\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(chunks), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "['x', 'y', 'hue', 'style']", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_821", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_list_of_arrays_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_list_of_arrays_variables(self, wide_list_of_arrays):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_arrays)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_arrays)\n    chunk_size = max((len(l) for l in wide_list_of_arrays))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(wide_list_of_arrays)\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(chunks), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_list_of_arrays_variables(self, wide_list_of_arrays):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_arrays)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_arrays)\n    chunk_size = max((len(l) for l in wide_list_of_arrays))\n    assert (len(p.plot_data) == '???')\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(wide_list_of_arrays)\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(chunks), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "(chunks * chunk_size)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_822", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_list_of_list_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_list_of_list_variables(self, wide_list_of_lists):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_lists)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_lists)\n    chunk_size = max((len(l) for l in wide_list_of_lists))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(wide_list_of_lists)\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(chunks), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_list_of_list_variables(self, wide_list_of_lists):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_lists)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_lists)\n    chunk_size = max((len(l) for l in wide_list_of_lists))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(wide_list_of_lists)\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(chunks), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "'wide'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_823", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_list_of_list_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_list_of_list_variables(self, wide_list_of_lists):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_lists)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_lists)\n    chunk_size = max((len(l) for l in wide_list_of_lists))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(wide_list_of_lists)\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(chunks), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_list_of_list_variables(self, wide_list_of_lists):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_lists)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == '???')\n    chunks = len(wide_list_of_lists)\n    chunk_size = max((len(l) for l in wide_list_of_lists))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(wide_list_of_lists)\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(chunks), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "['x', 'y', 'hue', 'style']", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_824", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_list_of_list_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_list_of_list_variables(self, wide_list_of_lists):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_lists)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_lists)\n    chunk_size = max((len(l) for l in wide_list_of_lists))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(wide_list_of_lists)\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(chunks), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_list_of_list_variables(self, wide_list_of_lists):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_list_of_lists)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_list_of_lists)\n    chunk_size = max((len(l) for l in wide_list_of_lists))\n    assert (len(p.plot_data) == '???')\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(wide_list_of_lists)\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(np.arange(chunks), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "(chunks * chunk_size)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_825", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_dict_of_series_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_dict_of_series_variables(self, wide_dict_of_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_series)\n    chunk_size = max((len(l) for l in wide_dict_of_series.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_series.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_series), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_dict_of_series_variables(self, wide_dict_of_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_series)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_series)\n    chunk_size = max((len(l) for l in wide_dict_of_series.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_series.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_series), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "'wide'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_826", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_dict_of_series_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_dict_of_series_variables(self, wide_dict_of_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_series)\n    chunk_size = max((len(l) for l in wide_dict_of_series.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_series.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_series), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_dict_of_series_variables(self, wide_dict_of_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == '???')\n    chunks = len(wide_dict_of_series)\n    chunk_size = max((len(l) for l in wide_dict_of_series.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_series.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_series), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "['x', 'y', 'hue', 'style']", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_827", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_dict_of_series_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_dict_of_series_variables(self, wide_dict_of_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_series)\n    chunk_size = max((len(l) for l in wide_dict_of_series.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_series.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_series), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_dict_of_series_variables(self, wide_dict_of_series):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_series)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_series)\n    chunk_size = max((len(l) for l in wide_dict_of_series.values()))\n    assert (len(p.plot_data) == '???')\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_series.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_series), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "(chunks * chunk_size)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_828", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_dict_of_arrays_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_dict_of_arrays_variables(self, wide_dict_of_arrays):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_arrays)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_arrays)\n    chunk_size = max((len(l) for l in wide_dict_of_arrays.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_arrays.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_arrays), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_dict_of_arrays_variables(self, wide_dict_of_arrays):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_arrays)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_arrays)\n    chunk_size = max((len(l) for l in wide_dict_of_arrays.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_arrays.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_arrays), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "'wide'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_829", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_dict_of_arrays_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_dict_of_arrays_variables(self, wide_dict_of_arrays):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_arrays)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_arrays)\n    chunk_size = max((len(l) for l in wide_dict_of_arrays.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_arrays.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_arrays), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_dict_of_arrays_variables(self, wide_dict_of_arrays):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_arrays)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == '???')\n    chunks = len(wide_dict_of_arrays)\n    chunk_size = max((len(l) for l in wide_dict_of_arrays.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_arrays.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_arrays), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "['x', 'y', 'hue', 'style']", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_830", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_dict_of_arrays_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_dict_of_arrays_variables(self, wide_dict_of_arrays):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_arrays)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_arrays)\n    chunk_size = max((len(l) for l in wide_dict_of_arrays.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_arrays.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_arrays), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_dict_of_arrays_variables(self, wide_dict_of_arrays):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_arrays)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_arrays)\n    chunk_size = max((len(l) for l in wide_dict_of_arrays.values()))\n    assert (len(p.plot_data) == '???')\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_arrays.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_arrays), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "(chunks * chunk_size)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_831", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_dict_of_lists_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_dict_of_lists_variables(self, wide_dict_of_lists):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_lists)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_lists)\n    chunk_size = max((len(l) for l in wide_dict_of_lists.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_lists.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_lists), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_dict_of_lists_variables(self, wide_dict_of_lists):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_lists)\n    assert (p.input_format == '???')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_lists)\n    chunk_size = max((len(l) for l in wide_dict_of_lists.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_lists.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_lists), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "'wide'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_832", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_dict_of_lists_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_dict_of_lists_variables(self, wide_dict_of_lists):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_lists)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_lists)\n    chunk_size = max((len(l) for l in wide_dict_of_lists.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_lists.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_lists), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_dict_of_lists_variables(self, wide_dict_of_lists):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_lists)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == '???')\n    chunks = len(wide_dict_of_lists)\n    chunk_size = max((len(l) for l in wide_dict_of_lists.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_lists.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_lists), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "['x', 'y', 'hue', 'style']", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_833", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_wide_dict_of_lists_variables", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_wide_dict_of_lists_variables(self, wide_dict_of_lists):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_lists)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_lists)\n    chunk_size = max((len(l) for l in wide_dict_of_lists.values()))\n    assert (len(p.plot_data) == (chunks * chunk_size))\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_lists.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_lists), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "masked_code": "def test_wide_dict_of_lists_variables(self, wide_dict_of_lists):\n    p = _RelationalPlotter()\n    p.assign_variables(data=wide_dict_of_lists)\n    assert (p.input_format == 'wide')\n    assert (list(p.variables) == ['x', 'y', 'hue', 'style'])\n    chunks = len(wide_dict_of_lists)\n    chunk_size = max((len(l) for l in wide_dict_of_lists.values()))\n    assert (len(p.plot_data) == '???')\n    x = p.plot_data['x']\n    expected_x = np.tile(np.arange(chunk_size), chunks)\n    assert_array_equal(x, expected_x)\n    y = p.plot_data['y'].dropna()\n    expected_y = np.concatenate(list(wide_dict_of_lists.values()))\n    assert_array_equal(y, expected_y)\n    hue = p.plot_data['hue']\n    expected_hue = np.repeat(list(wide_dict_of_lists), chunk_size)\n    assert_array_equal(hue, expected_hue)\n    style = p.plot_data['style']\n    expected_style = expected_hue\n    assert_array_equal(style, expected_style)\n    assert (p.variables['x'] is None)\n    assert (p.variables['y'] is None)\n    assert (p.variables['hue'] is None)\n    assert (p.variables['style'] is None)", "ground_truth": "(chunks * chunk_size)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_834", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_relplot_vectors", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_relplot_vectors(self, long_df, vector_type):\n    semantics = dict(x='x', y='y', hue='f', col='c')\n    kws = {key: long_df[val] for (key, val) in semantics.items()}\n    if (vector_type == 'numpy'):\n        kws = {k: v.to_numpy() for (k, v) in kws.items()}\n    elif (vector_type == 'list'):\n        kws = {k: v.to_list() for (k, v) in kws.items()}\n    g = relplot(data=long_df, **kws)\n    grouped = long_df.groupby('c')\n    assert (len(g.axes_dict) == len(grouped))\n    for ((_, grp_df), ax) in zip(grouped, g.axes.flat):\n        (x, y) = ax.collections[0].get_offsets().T\n        assert_array_equal(x, grp_df['x'])\n        assert_array_equal(y, grp_df['y'])", "masked_code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_relplot_vectors(self, long_df, vector_type):\n    semantics = dict(x='x', y='y', hue='f', col='c')\n    kws = {key: long_df[val] for (key, val) in semantics.items()}\n    if (vector_type == 'numpy'):\n        kws = {k: v.to_numpy() for (k, v) in kws.items()}\n    elif (vector_type == 'list'):\n        kws = {k: v.to_list() for (k, v) in kws.items()}\n    g = relplot(data=long_df, **kws)\n    grouped = long_df.groupby('c')\n    assert (len(g.axes_dict) == '???')\n    for ((_, grp_df), ax) in zip(grouped, g.axes.flat):\n        (x, y) = ax.collections[0].get_offsets().T\n        assert_array_equal(x, grp_df['x'])\n        assert_array_equal(y, grp_df['y'])", "ground_truth": "len(grouped)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_835", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_relplot_weighted_estimator", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_relplot_weighted_estimator(self, long_df):\n    g = relplot(data=long_df, x='a', y='y', weights='x', kind='line')\n    ydata = g.ax.lines[0].get_ydata()\n    for (i, level) in enumerate(categorical_order(long_df['a'])):\n        pos_df = long_df[(long_df['a'] == level)]\n        expected = np.average(pos_df['y'], weights=pos_df['x'])\n        assert (ydata[i] == pytest.approx(expected))", "masked_code": "def test_relplot_weighted_estimator(self, long_df):\n    g = relplot(data=long_df, x='a', y='y', weights='x', kind='line')\n    ydata = g.ax.lines[0].get_ydata()\n    for (i, level) in enumerate(categorical_order(long_df['a'])):\n        pos_df = long_df[(long_df['a'] == level)]\n        expected = np.average(pos_df['y'], weights=pos_df['x'])\n        assert (ydata[i] == '???')", "ground_truth": "pytest.approx(expected)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_836", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_relplot_legend", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_relplot_legend(self, long_df):\n    g = relplot(data=long_df, x='x', y='y')\n    assert (g._legend is None)\n    g = relplot(data=long_df, x='x', y='y', hue='a')\n    texts = [t.get_text() for t in g._legend.texts]\n    expected_texts = long_df['a'].unique()\n    assert_array_equal(texts, expected_texts)\n    g = relplot(data=long_df, x='x', y='y', hue='s', size='s')\n    texts = [t.get_text() for t in g._legend.texts]\n    assert_array_equal(texts, np.sort(texts))\n    g = relplot(data=long_df, x='x', y='y', hue='a', legend=False)\n    assert (g._legend is None)\n    palette = color_palette('deep', len(long_df['b'].unique()))\n    a_like_b = dict(zip(long_df['a'].unique(), long_df['b'].unique()))\n    long_df['a_like_b'] = long_df['a'].map(a_like_b)\n    g = relplot(data=long_df, x='x', y='y', hue='b', style='a_like_b', palette=palette, kind='line', estimator=None)\n    lines = g._legend.get_lines()[1:]\n    for (line, color) in zip(lines, palette):\n        assert (line.get_color() == color)", "masked_code": "def test_relplot_legend(self, long_df):\n    g = relplot(data=long_df, x='x', y='y')\n    assert (g._legend is None)\n    g = relplot(data=long_df, x='x', y='y', hue='a')\n    texts = [t.get_text() for t in g._legend.texts]\n    expected_texts = long_df['a'].unique()\n    assert_array_equal(texts, expected_texts)\n    g = relplot(data=long_df, x='x', y='y', hue='s', size='s')\n    texts = [t.get_text() for t in g._legend.texts]\n    assert_array_equal(texts, np.sort(texts))\n    g = relplot(data=long_df, x='x', y='y', hue='a', legend=False)\n    assert (g._legend is None)\n    palette = color_palette('deep', len(long_df['b'].unique()))\n    a_like_b = dict(zip(long_df['a'].unique(), long_df['b'].unique()))\n    long_df['a_like_b'] = long_df['a'].map(a_like_b)\n    g = relplot(data=long_df, x='x', y='y', hue='b', style='a_like_b', palette=palette, kind='line', estimator=None)\n    lines = g._legend.get_lines()[1:]\n    for (line, color) in zip(lines, palette):\n        assert (line.get_color() == '???')", "ground_truth": "color", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_837", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_relplot_data", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_relplot_data(self, long_df):\n    g = relplot(data=long_df.to_dict(orient='list'), x='x', y=long_df['y'].rename('y_var'), hue=long_df['a'].to_numpy(), col='c')\n    expected_cols = set((long_df.columns.to_list() + ['_hue_', 'y_var']))\n    assert (set(g.data.columns) == expected_cols)\n    assert_array_equal(g.data['y_var'], long_df['y'])\n    assert_array_equal(g.data['_hue_'], long_df['a'])", "masked_code": "def test_relplot_data(self, long_df):\n    g = relplot(data=long_df.to_dict(orient='list'), x='x', y=long_df['y'].rename('y_var'), hue=long_df['a'].to_numpy(), col='c')\n    expected_cols = set((long_df.columns.to_list() + ['_hue_', 'y_var']))\n    assert (set(g.data.columns) == '???')\n    assert_array_equal(g.data['y_var'], long_df['y'])\n    assert_array_equal(g.data['_hue_'], long_df['a'])", "ground_truth": "expected_cols", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_838", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_facet_variable_collision", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_facet_variable_collision(self, long_df):\n    col_data = long_df['c']\n    long_df = long_df.assign(size=col_data)\n    g = relplot(data=long_df, x='x', y='y', col='size')\n    assert (g.axes.shape == (1, len(col_data.unique())))", "masked_code": "def test_facet_variable_collision(self, long_df):\n    col_data = long_df['c']\n    long_df = long_df.assign(size=col_data)\n    g = relplot(data=long_df, x='x', y='y', col='size')\n    assert (g.axes.shape == '???')", "ground_truth": "(1, len(col_data.unique()))", "quality_analysis": {"complexity_score": 11, "left_complexity": 2, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_839", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_legend_attributes_hue", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_hue(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'marker': 'X'}\n    g = relplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, pt) in enumerate(get_legend_handles(g.legend)):\n        assert same_color(pt.get_color(), palette[i])\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (pt.get_marker() == kws['marker'])", "masked_code": "def test_legend_attributes_hue(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'marker': 'X'}\n    g = relplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, pt) in enumerate(get_legend_handles(g.legend)):\n        assert same_color(pt.get_color(), palette[i])\n        assert (pt.get_markersize() == '???')\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (pt.get_marker() == kws['marker'])", "ground_truth": "np.sqrt(kws['s'])", "quality_analysis": {"complexity_score": 11, "left_complexity": 3, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_840", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_legend_attributes_hue", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_hue(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'marker': 'X'}\n    g = relplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, pt) in enumerate(get_legend_handles(g.legend)):\n        assert same_color(pt.get_color(), palette[i])\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (pt.get_marker() == kws['marker'])", "masked_code": "def test_legend_attributes_hue(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'marker': 'X'}\n    g = relplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, pt) in enumerate(get_legend_handles(g.legend)):\n        assert same_color(pt.get_color(), palette[i])\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == '???')\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (pt.get_marker() == kws['marker'])", "ground_truth": "kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_841", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_legend_attributes_hue", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_hue(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'marker': 'X'}\n    g = relplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, pt) in enumerate(get_legend_handles(g.legend)):\n        assert same_color(pt.get_color(), palette[i])\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (pt.get_marker() == kws['marker'])", "masked_code": "def test_legend_attributes_hue(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'marker': 'X'}\n    g = relplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, pt) in enumerate(get_legend_handles(g.legend)):\n        assert same_color(pt.get_color(), palette[i])\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (pt.get_marker() == '???')", "ground_truth": "kws['marker']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_842", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_legend_attributes_style", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'color': 'r'}\n    g = relplot(long_df, x='x', y='y', style='a', **kws)\n    for pt in get_legend_handles(g.legend):\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        assert same_color(pt.get_color(), 'r')", "masked_code": "def test_legend_attributes_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'color': 'r'}\n    g = relplot(long_df, x='x', y='y', style='a', **kws)\n    for pt in get_legend_handles(g.legend):\n        assert (pt.get_markersize() == '???')\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        assert same_color(pt.get_color(), 'r')", "ground_truth": "np.sqrt(kws['s'])", "quality_analysis": {"complexity_score": 11, "left_complexity": 3, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_843", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_legend_attributes_style", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'color': 'r'}\n    g = relplot(long_df, x='x', y='y', style='a', **kws)\n    for pt in get_legend_handles(g.legend):\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        assert same_color(pt.get_color(), 'r')", "masked_code": "def test_legend_attributes_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'color': 'r'}\n    g = relplot(long_df, x='x', y='y', style='a', **kws)\n    for pt in get_legend_handles(g.legend):\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == '???')\n        assert same_color(pt.get_color(), 'r')", "ground_truth": "kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_844", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_legend_attributes_hue_and_style", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_hue_and_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1}\n    g = relplot(long_df, x='x', y='y', hue='a', style='b', **kws)\n    for pt in get_legend_handles(g.legend):\n        if (pt.get_label() not in ['a', 'b']):\n            assert (pt.get_markersize() == np.sqrt(kws['s']))\n            assert (pt.get_markeredgewidth() == kws['linewidth'])", "masked_code": "def test_legend_attributes_hue_and_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1}\n    g = relplot(long_df, x='x', y='y', hue='a', style='b', **kws)\n    for pt in get_legend_handles(g.legend):\n        if (pt.get_label() not in ['a', 'b']):\n            assert (pt.get_markersize() == '???')\n            assert (pt.get_markeredgewidth() == kws['linewidth'])", "ground_truth": "np.sqrt(kws['s'])", "quality_analysis": {"complexity_score": 11, "left_complexity": 3, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_845", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestRelationalPlotter", "funcname": "test_legend_attributes_hue_and_style", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_hue_and_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1}\n    g = relplot(long_df, x='x', y='y', hue='a', style='b', **kws)\n    for pt in get_legend_handles(g.legend):\n        if (pt.get_label() not in ['a', 'b']):\n            assert (pt.get_markersize() == np.sqrt(kws['s']))\n            assert (pt.get_markeredgewidth() == kws['linewidth'])", "masked_code": "def test_legend_attributes_hue_and_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1}\n    g = relplot(long_df, x='x', y='y', hue='a', style='b', **kws)\n    for pt in get_legend_handles(g.legend):\n        if (pt.get_label() not in ['a', 'b']):\n            assert (pt.get_markersize() == np.sqrt(kws['s']))\n            assert (pt.get_markeredgewidth() == '???')", "ground_truth": "kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_846", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_legend_log_norm", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "@pytest.mark.parametrize('var', ['hue', 'size'])\ndef test_legend_log_norm(self, var):\n    (x, y) = np.random.randn(2, 40)\n    z = np.tile(np.arange(20), 2)\n    norm = mpl.colors.LogNorm()\n    ax = lineplot(x=x, y=y, **{var: (z + 1), f'{var}_norm': norm})\n    (_, labels) = ax.get_legend_handles_labels()\n    assert ((float(labels[1]) / float(labels[0])) == 10)", "masked_code": "@pytest.mark.parametrize('var', ['hue', 'size'])\ndef test_legend_log_norm(self, var):\n    (x, y) = np.random.randn(2, 40)\n    z = np.tile(np.arange(20), 2)\n    norm = mpl.colors.LogNorm()\n    ax = lineplot(x=x, y=y, **{var: (z + 1), f'{var}_norm': norm})\n    (_, labels) = ax.get_legend_handles_labels()\n    assert ((float(labels[1]) / float(labels[0])) == '???')", "ground_truth": "10", "quality_analysis": {"complexity_score": 19, "left_complexity": 18, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_847", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == '???')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "'test'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_848", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == '???')\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "len(p._hue_map.levels)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_849", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == '???')\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "len(p._size_map.levels)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_850", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == '???')\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "len(p._hue_map.levels)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_851", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == '???')\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "len(p._style_map.levels)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_852", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == '???')\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "expected_line_count", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_853", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == '???')\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "[1, 2, 3]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_854", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == '???')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "9", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_855", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == '???' == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "len(ax.collections)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_856", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == '???' == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "len(ax.collections)", "quality_analysis": {"complexity_score": 9, "left_complexity": 4, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_857", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == '???')\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "len(p._hue_map.levels)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_858", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == '???')\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "n_units", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_859", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == '???')\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "n_units", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_860", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == '???')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "p._hue_map(level)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_861", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == '???')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "p._size_map(level)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_862", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == '???')\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "p._hue_map(level)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_863", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == '???')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "p._style_map(level, 'marker')", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_864", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == '???')\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "p._hue_map(hue)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_865", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == '???')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "p._style_map(style, 'marker')", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_866", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == 0.5)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=False, estimator=None)\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert_array_equal(line.get_xdata(), long_df.x.to_numpy())\n    assert_array_equal(line.get_ydata(), long_df.y.to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    (line,) = ax.lines\n    assert (line.get_color() == 'k')\n    assert (line.get_label() == 'test')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), sort=True, estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    sorted_data = long_df.sort_values(['x', 'y'])\n    assert_array_equal(line.get_xdata(), sorted_data.x.to_numpy())\n    assert_array_equal(line.get_ydata(), sorted_data.y.to_numpy())\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._size_map.levels))\n    for (line, level) in zip(ax.lines, p._size_map.levels):\n        assert (line.get_linewidth() == p._size_map(level))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(p._hue_map.levels))\n    assert (len(ax.lines) == len(p._style_map.levels))\n    for (line, level) in zip(ax.lines, p._hue_map.levels):\n        assert (line.get_color() == p._hue_map(level))\n        assert (line.get_marker() == p._style_map(level, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    levels = product(p._hue_map.levels, p._style_map.levels)\n    expected_line_count = (len(p._hue_map.levels) * len(p._style_map.levels))\n    assert (len(ax.lines) == expected_line_count)\n    for (line, (hue, style)) in zip(ax.lines, levels):\n        assert (line.get_color() == p._hue_map(hue))\n        assert (line.get_marker() == p._style_map(style, 'marker'))\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y'), estimator='mean', err_style='band', errorbar='sd', sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    expected_data = long_df.groupby('x').y.mean()\n    assert_array_equal(line.get_xdata(), expected_data.index.to_numpy())\n    assert np.allclose(line.get_ydata(), expected_data.to_numpy())\n    assert (len(ax.collections) == 1)\n    p = _LinePlotter(variables=dict(x=[1, 1, 1, 2, 2, 2, 3, 3, 3], y=[1, 2, 3, 3, np.nan, 5, 4, 5, 6]), estimator='mean', err_style='band', errorbar='ci', n_boot=100, sort=True)\n    ax.clear()\n    p.plot(ax, {})\n    (line,) = ax.lines\n    assert (line.get_xdata().tolist() == [1, 2, 3])\n    err_band = ax.collections[0].get_paths()\n    assert (len(err_band) == 1)\n    assert (len(err_band[0].vertices) == 9)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='band', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    assert (len(ax.lines) == len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.PolyCollection)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), estimator='mean', err_style='bars', errorbar='sd')\n    ax.clear()\n    p.plot(ax, {})\n    n_lines = len(ax.lines)\n    assert ((n_lines / 2) == len(ax.collections) == len(p._hue_map.levels))\n    assert (len(ax.collections) == len(p._hue_map.levels))\n    for c in ax.collections:\n        assert isinstance(c, mpl.collections.LineCollection)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units = len(repeated_df['u'].unique())\n    assert (len(ax.lines) == n_units)\n    p = _LinePlotter(data=repeated_df, variables=dict(x='x', y='y', hue='a', units='u'), estimator=None)\n    ax.clear()\n    p.plot(ax, {})\n    n_units *= len(repeated_df['a'].unique())\n    assert (len(ax.lines) == n_units)\n    p.estimator = 'mean'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='band', err_kws={'alpha': 0.5})\n    ax.clear()\n    p.plot(ax, {})\n    for band in ax.collections:\n        assert (band.get_alpha() == '???')\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue='a'), err_style='bars', err_kws={'elinewidth': 2})\n    ax.clear()\n    p.plot(ax, {})\n    for lines in ax.collections:\n        assert (lines.get_linestyles() == 2)\n    p.err_style = 'invalid'\n    with pytest.raises(ValueError):\n        p.plot(ax, {})\n    x_str = long_df['x'].astype(str)\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _LinePlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "0.5", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_867", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_weights", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_weights(self, long_df):\n    ax = lineplot(long_df, x='a', y='y', weights='x')\n    vals = ax.lines[0].get_ydata()\n    for (i, level) in enumerate(categorical_order(long_df['a'])):\n        pos_df = long_df[(long_df['a'] == level)]\n        expected = np.average(pos_df['y'], weights=pos_df['x'])\n        assert (vals[i] == pytest.approx(expected))", "masked_code": "def test_weights(self, long_df):\n    ax = lineplot(long_df, x='a', y='y', weights='x')\n    vals = ax.lines[0].get_ydata()\n    for (i, level) in enumerate(categorical_order(long_df['a'])):\n        pos_df = long_df[(long_df['a'] == level)]\n        expected = np.average(pos_df['y'], weights=pos_df['x'])\n        assert (vals[i] == '???')", "ground_truth": "pytest.approx(expected)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_868", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_orient", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_orient(self, long_df):\n    long_df = long_df.drop('x', axis=1).rename(columns={'s': 'y', 'y': 'x'})\n    ax1 = plt.figure().subplots()\n    lineplot(data=long_df, x='x', y='y', orient='y', errorbar='sd')\n    assert (len(ax1.lines) == len(ax1.collections))\n    (line,) = ax1.lines\n    expected = long_df.groupby('y').agg({'x': 'mean'}).reset_index()\n    assert_array_almost_equal(line.get_xdata(), expected['x'])\n    assert_array_almost_equal(line.get_ydata(), expected['y'])\n    ribbon_y = ax1.collections[0].get_paths()[0].vertices[(:, 1)]\n    assert_array_equal(np.unique(ribbon_y), long_df['y'].sort_values().unique())\n    ax2 = plt.figure().subplots()\n    lineplot(data=long_df, x='x', y='y', orient='y', errorbar='sd', err_style='bars')\n    segments = ax2.collections[0].get_segments()\n    for (i, val) in enumerate(sorted(long_df['y'].unique())):\n        assert (segments[i][(:, 1)] == val).all()\n    with pytest.raises(ValueError, match=\"`orient` must be either 'x' or 'y'\"):\n        lineplot(long_df, x='y', y='x', orient='bad')", "masked_code": "def test_orient(self, long_df):\n    long_df = long_df.drop('x', axis=1).rename(columns={'s': 'y', 'y': 'x'})\n    ax1 = plt.figure().subplots()\n    lineplot(data=long_df, x='x', y='y', orient='y', errorbar='sd')\n    assert (len(ax1.lines) == '???')\n    (line,) = ax1.lines\n    expected = long_df.groupby('y').agg({'x': 'mean'}).reset_index()\n    assert_array_almost_equal(line.get_xdata(), expected['x'])\n    assert_array_almost_equal(line.get_ydata(), expected['y'])\n    ribbon_y = ax1.collections[0].get_paths()[0].vertices[(:, 1)]\n    assert_array_equal(np.unique(ribbon_y), long_df['y'].sort_values().unique())\n    ax2 = plt.figure().subplots()\n    lineplot(data=long_df, x='x', y='y', orient='y', errorbar='sd', err_style='bars')\n    segments = ax2.collections[0].get_segments()\n    for (i, val) in enumerate(sorted(long_df['y'].unique())):\n        assert (segments[i][(:, 1)] == val).all()\n    with pytest.raises(ValueError, match=\"`orient` must be either 'x' or 'y'\"):\n        lineplot(long_df, x='y', y='x', orient='bad')", "ground_truth": "len(ax1.collections)", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_869", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_log_scale", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_log_scale(self):\n    (f, ax) = plt.subplots()\n    ax.set_xscale('log')\n    x = [1, 10, 100]\n    y = [1, 2, 3]\n    lineplot(x=x, y=y)\n    line = ax.lines[0]\n    assert_array_equal(line.get_xdata(), x)\n    assert_array_equal(line.get_ydata(), y)\n    (f, ax) = plt.subplots()\n    ax.set_xscale('log')\n    ax.set_yscale('log')\n    x = [1, 1, 2, 2]\n    y = [1, 10, 1, 100]\n    lineplot(x=x, y=y, err_style='bars', errorbar=('pi', 100))\n    line = ax.lines[0]\n    assert (line.get_ydata()[1] == 10)\n    ebars = ax.collections[0].get_segments()\n    assert_array_equal(ebars[0][(:, 1)], y[:2])\n    assert_array_equal(ebars[1][(:, 1)], y[2:])", "masked_code": "def test_log_scale(self):\n    (f, ax) = plt.subplots()\n    ax.set_xscale('log')\n    x = [1, 10, 100]\n    y = [1, 2, 3]\n    lineplot(x=x, y=y)\n    line = ax.lines[0]\n    assert_array_equal(line.get_xdata(), x)\n    assert_array_equal(line.get_ydata(), y)\n    (f, ax) = plt.subplots()\n    ax.set_xscale('log')\n    ax.set_yscale('log')\n    x = [1, 1, 2, 2]\n    y = [1, 10, 1, 100]\n    lineplot(x=x, y=y, err_style='bars', errorbar=('pi', 100))\n    line = ax.lines[0]\n    assert (line.get_ydata()[1] == '???')\n    ebars = ax.collections[0].get_segments()\n    assert_array_equal(ebars[0][(:, 1)], y[:2])\n    assert_array_equal(ebars[1][(:, 1)], y[2:])", "ground_truth": "10", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_870", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_nonmapped_dashes", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_nonmapped_dashes(self):\n    ax = lineplot(x=[1, 2], y=[1, 2], dashes=(2, 1))\n    line = ax.lines[0]\n    assert (line.get_linestyle() == '--')", "masked_code": "def test_nonmapped_dashes(self):\n    ax = lineplot(x=[1, 2], y=[1, 2], dashes=(2, 1))\n    line = ax.lines[0]\n    assert (line.get_linestyle() == '???')", "ground_truth": "'--'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_871", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_legend_attributes_with_hue", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_with_hue(self, long_df):\n    kws = {'marker': 'o', 'linewidth': 3}\n    ax = lineplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, line) in enumerate(get_legend_handles(ax.get_legend())):\n        assert same_color(line.get_color(), palette[i])\n        assert (line.get_linewidth() == kws['linewidth'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (line.get_marker() == kws['marker'])", "masked_code": "def test_legend_attributes_with_hue(self, long_df):\n    kws = {'marker': 'o', 'linewidth': 3}\n    ax = lineplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, line) in enumerate(get_legend_handles(ax.get_legend())):\n        assert same_color(line.get_color(), palette[i])\n        assert (line.get_linewidth() == '???')\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (line.get_marker() == kws['marker'])", "ground_truth": "kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_872", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_legend_attributes_with_hue", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_with_hue(self, long_df):\n    kws = {'marker': 'o', 'linewidth': 3}\n    ax = lineplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, line) in enumerate(get_legend_handles(ax.get_legend())):\n        assert same_color(line.get_color(), palette[i])\n        assert (line.get_linewidth() == kws['linewidth'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (line.get_marker() == kws['marker'])", "masked_code": "def test_legend_attributes_with_hue(self, long_df):\n    kws = {'marker': 'o', 'linewidth': 3}\n    ax = lineplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, line) in enumerate(get_legend_handles(ax.get_legend())):\n        assert same_color(line.get_color(), palette[i])\n        assert (line.get_linewidth() == kws['linewidth'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (line.get_marker() == '???')", "ground_truth": "kws['marker']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_873", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_legend_attributes_with_style", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_with_style(self, long_df):\n    kws = {'color': 'r', 'marker': 'o', 'linewidth': 3}\n    ax = lineplot(long_df, x='x', y='y', style='a', **kws)\n    for line in get_legend_handles(ax.get_legend()):\n        assert same_color(line.get_color(), kws['color'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (line.get_marker() == kws['marker'])\n        assert (line.get_linewidth() == kws['linewidth'])", "masked_code": "def test_legend_attributes_with_style(self, long_df):\n    kws = {'color': 'r', 'marker': 'o', 'linewidth': 3}\n    ax = lineplot(long_df, x='x', y='y', style='a', **kws)\n    for line in get_legend_handles(ax.get_legend()):\n        assert same_color(line.get_color(), kws['color'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (line.get_marker() == kws['marker'])\n        assert (line.get_linewidth() == '???')", "ground_truth": "kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_874", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_legend_attributes_with_style", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_with_style(self, long_df):\n    kws = {'color': 'r', 'marker': 'o', 'linewidth': 3}\n    ax = lineplot(long_df, x='x', y='y', style='a', **kws)\n    for line in get_legend_handles(ax.get_legend()):\n        assert same_color(line.get_color(), kws['color'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (line.get_marker() == kws['marker'])\n        assert (line.get_linewidth() == kws['linewidth'])", "masked_code": "def test_legend_attributes_with_style(self, long_df):\n    kws = {'color': 'r', 'marker': 'o', 'linewidth': 3}\n    ax = lineplot(long_df, x='x', y='y', style='a', **kws)\n    for line in get_legend_handles(ax.get_legend()):\n        assert same_color(line.get_color(), kws['color'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (line.get_marker() == '???')\n        assert (line.get_linewidth() == kws['linewidth'])", "ground_truth": "kws['marker']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_875", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_legend_attributes_with_hue_and_style", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_with_hue_and_style(self, long_df):\n    kws = {'marker': 'o', 'linewidth': 3}\n    ax = lineplot(long_df, x='x', y='y', hue='a', style='b', **kws)\n    for line in get_legend_handles(ax.get_legend()):\n        if (line.get_label() not in ['a', 'b']):\n            if (not _version_predates(mpl, '3.7.0')):\n                assert (line.get_marker() == kws['marker'])\n            assert (line.get_linewidth() == kws['linewidth'])", "masked_code": "def test_legend_attributes_with_hue_and_style(self, long_df):\n    kws = {'marker': 'o', 'linewidth': 3}\n    ax = lineplot(long_df, x='x', y='y', hue='a', style='b', **kws)\n    for line in get_legend_handles(ax.get_legend()):\n        if (line.get_label() not in ['a', 'b']):\n            if (not _version_predates(mpl, '3.7.0')):\n                assert (line.get_marker() == kws['marker'])\n            assert (line.get_linewidth() == '???')", "ground_truth": "kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_876", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_legend_attributes_with_hue_and_style", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_with_hue_and_style(self, long_df):\n    kws = {'marker': 'o', 'linewidth': 3}\n    ax = lineplot(long_df, x='x', y='y', hue='a', style='b', **kws)\n    for line in get_legend_handles(ax.get_legend()):\n        if (line.get_label() not in ['a', 'b']):\n            if (not _version_predates(mpl, '3.7.0')):\n                assert (line.get_marker() == kws['marker'])\n            assert (line.get_linewidth() == kws['linewidth'])", "masked_code": "def test_legend_attributes_with_hue_and_style(self, long_df):\n    kws = {'marker': 'o', 'linewidth': 3}\n    ax = lineplot(long_df, x='x', y='y', hue='a', style='b', **kws)\n    for line in get_legend_handles(ax.get_legend()):\n        if (line.get_label() not in ['a', 'b']):\n            if (not _version_predates(mpl, '3.7.0')):\n                assert (line.get_marker() == '???')\n            assert (line.get_linewidth() == kws['linewidth'])", "ground_truth": "kws['marker']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_877", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_lineplot_vs_relplot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_lineplot_vs_relplot(self, long_df, long_semantics):\n    ax = lineplot(data=long_df, legend=False, **long_semantics)\n    g = relplot(data=long_df, kind='line', legend=False, **long_semantics)\n    lin_lines = ax.lines\n    rel_lines = g.ax.lines\n    for (l1, l2) in zip(lin_lines, rel_lines):\n        assert_array_equal(l1.get_xydata(), l2.get_xydata())\n        assert same_color(l1.get_color(), l2.get_color())\n        assert (l1.get_linewidth() == l2.get_linewidth())\n        assert (l1.get_linestyle() == l2.get_linestyle())", "masked_code": "def test_lineplot_vs_relplot(self, long_df, long_semantics):\n    ax = lineplot(data=long_df, legend=False, **long_semantics)\n    g = relplot(data=long_df, kind='line', legend=False, **long_semantics)\n    lin_lines = ax.lines\n    rel_lines = g.ax.lines\n    for (l1, l2) in zip(lin_lines, rel_lines):\n        assert_array_equal(l1.get_xydata(), l2.get_xydata())\n        assert same_color(l1.get_color(), l2.get_color())\n        assert (l1.get_linewidth() == '???')\n        assert (l1.get_linestyle() == l2.get_linestyle())", "ground_truth": "l2.get_linewidth()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_878", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestLinePlotter", "funcname": "test_lineplot_vs_relplot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_lineplot_vs_relplot(self, long_df, long_semantics):\n    ax = lineplot(data=long_df, legend=False, **long_semantics)\n    g = relplot(data=long_df, kind='line', legend=False, **long_semantics)\n    lin_lines = ax.lines\n    rel_lines = g.ax.lines\n    for (l1, l2) in zip(lin_lines, rel_lines):\n        assert_array_equal(l1.get_xydata(), l2.get_xydata())\n        assert same_color(l1.get_color(), l2.get_color())\n        assert (l1.get_linewidth() == l2.get_linewidth())\n        assert (l1.get_linestyle() == l2.get_linestyle())", "masked_code": "def test_lineplot_vs_relplot(self, long_df, long_semantics):\n    ax = lineplot(data=long_df, legend=False, **long_semantics)\n    g = relplot(data=long_df, kind='line', legend=False, **long_semantics)\n    lin_lines = ax.lines\n    rel_lines = g.ax.lines\n    for (l1, l2) in zip(lin_lines, rel_lines):\n        assert_array_equal(l1.get_xydata(), l2.get_xydata())\n        assert same_color(l1.get_color(), l2.get_color())\n        assert (l1.get_linewidth() == l2.get_linewidth())\n        assert (l1.get_linestyle() == '???')", "ground_truth": "l2.get_linestyle()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_879", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_color", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_color(self, long_df):\n    super().test_color(long_df)\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', facecolor='C5', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C5'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', facecolors='C6', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C6'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', fc='C4', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C4'))", "masked_code": "def test_color(self, long_df):\n    super().test_color(long_df)\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', facecolor='C5', ax=ax)\n    assert (self.get_last_color(ax) == '???')\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', facecolors='C6', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C6'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', fc='C4', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C4'))", "ground_truth": "to_rgba('C5')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_880", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_color", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_color(self, long_df):\n    super().test_color(long_df)\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', facecolor='C5', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C5'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', facecolors='C6', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C6'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', fc='C4', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C4'))", "masked_code": "def test_color(self, long_df):\n    super().test_color(long_df)\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', facecolor='C5', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C5'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', facecolors='C6', ax=ax)\n    assert (self.get_last_color(ax) == '???')\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', fc='C4', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C4'))", "ground_truth": "to_rgba('C6')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_881", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_color", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_color(self, long_df):\n    super().test_color(long_df)\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', facecolor='C5', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C5'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', facecolors='C6', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C6'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', fc='C4', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C4'))", "masked_code": "def test_color(self, long_df):\n    super().test_color(long_df)\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', facecolor='C5', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C5'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', facecolors='C6', ax=ax)\n    assert (self.get_last_color(ax) == to_rgba('C6'))\n    ax = plt.figure().subplots()\n    self.func(data=long_df, x='x', y='y', fc='C4', ax=ax)\n    assert (self.get_last_color(ax) == '???')", "ground_truth": "to_rgba('C4')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_882", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_legend_attributes_hue", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_hue(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'marker': 'X'}\n    ax = scatterplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, pt) in enumerate(get_legend_handles(ax.get_legend())):\n        assert same_color(pt.get_color(), palette[i])\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (pt.get_marker() == kws['marker'])", "masked_code": "def test_legend_attributes_hue(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'marker': 'X'}\n    ax = scatterplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, pt) in enumerate(get_legend_handles(ax.get_legend())):\n        assert same_color(pt.get_color(), palette[i])\n        assert (pt.get_markersize() == '???')\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (pt.get_marker() == kws['marker'])", "ground_truth": "np.sqrt(kws['s'])", "quality_analysis": {"complexity_score": 11, "left_complexity": 3, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_883", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_legend_attributes_hue", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_hue(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'marker': 'X'}\n    ax = scatterplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, pt) in enumerate(get_legend_handles(ax.get_legend())):\n        assert same_color(pt.get_color(), palette[i])\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (pt.get_marker() == kws['marker'])", "masked_code": "def test_legend_attributes_hue(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'marker': 'X'}\n    ax = scatterplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, pt) in enumerate(get_legend_handles(ax.get_legend())):\n        assert same_color(pt.get_color(), palette[i])\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == '???')\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (pt.get_marker() == kws['marker'])", "ground_truth": "kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_884", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_legend_attributes_hue", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_hue(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'marker': 'X'}\n    ax = scatterplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, pt) in enumerate(get_legend_handles(ax.get_legend())):\n        assert same_color(pt.get_color(), palette[i])\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (pt.get_marker() == kws['marker'])", "masked_code": "def test_legend_attributes_hue(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'marker': 'X'}\n    ax = scatterplot(long_df, x='x', y='y', hue='a', **kws)\n    palette = color_palette()\n    for (i, pt) in enumerate(get_legend_handles(ax.get_legend())):\n        assert same_color(pt.get_color(), palette[i])\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        if (not _version_predates(mpl, '3.7.0')):\n            assert (pt.get_marker() == '???')", "ground_truth": "kws['marker']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_885", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_legend_attributes_style", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'color': 'r'}\n    ax = scatterplot(long_df, x='x', y='y', style='a', **kws)\n    for pt in get_legend_handles(ax.get_legend()):\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        assert same_color(pt.get_color(), 'r')", "masked_code": "def test_legend_attributes_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'color': 'r'}\n    ax = scatterplot(long_df, x='x', y='y', style='a', **kws)\n    for pt in get_legend_handles(ax.get_legend()):\n        assert (pt.get_markersize() == '???')\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        assert same_color(pt.get_color(), 'r')", "ground_truth": "np.sqrt(kws['s'])", "quality_analysis": {"complexity_score": 11, "left_complexity": 3, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_886", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_legend_attributes_style", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'color': 'r'}\n    ax = scatterplot(long_df, x='x', y='y', style='a', **kws)\n    for pt in get_legend_handles(ax.get_legend()):\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == kws['linewidth'])\n        assert same_color(pt.get_color(), 'r')", "masked_code": "def test_legend_attributes_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1, 'color': 'r'}\n    ax = scatterplot(long_df, x='x', y='y', style='a', **kws)\n    for pt in get_legend_handles(ax.get_legend()):\n        assert (pt.get_markersize() == np.sqrt(kws['s']))\n        assert (pt.get_markeredgewidth() == '???')\n        assert same_color(pt.get_color(), 'r')", "ground_truth": "kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_887", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_legend_attributes_hue_and_style", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_hue_and_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1}\n    ax = scatterplot(long_df, x='x', y='y', hue='a', style='b', **kws)\n    for pt in get_legend_handles(ax.get_legend()):\n        if (pt.get_label() not in ['a', 'b']):\n            assert (pt.get_markersize() == np.sqrt(kws['s']))\n            assert (pt.get_markeredgewidth() == kws['linewidth'])", "masked_code": "def test_legend_attributes_hue_and_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1}\n    ax = scatterplot(long_df, x='x', y='y', hue='a', style='b', **kws)\n    for pt in get_legend_handles(ax.get_legend()):\n        if (pt.get_label() not in ['a', 'b']):\n            assert (pt.get_markersize() == '???')\n            assert (pt.get_markeredgewidth() == kws['linewidth'])", "ground_truth": "np.sqrt(kws['s'])", "quality_analysis": {"complexity_score": 11, "left_complexity": 3, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_888", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_legend_attributes_hue_and_style", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_legend_attributes_hue_and_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1}\n    ax = scatterplot(long_df, x='x', y='y', hue='a', style='b', **kws)\n    for pt in get_legend_handles(ax.get_legend()):\n        if (pt.get_label() not in ['a', 'b']):\n            assert (pt.get_markersize() == np.sqrt(kws['s']))\n            assert (pt.get_markeredgewidth() == kws['linewidth'])", "masked_code": "def test_legend_attributes_hue_and_style(self, long_df):\n    kws = {'s': 50, 'linewidth': 1}\n    ax = scatterplot(long_df, x='x', y='y', hue='a', style='b', **kws)\n    for pt in get_legend_handles(ax.get_legend()):\n        if (pt.get_label() not in ['a', 'b']):\n            assert (pt.get_markersize() == np.sqrt(kws['s']))\n            assert (pt.get_markeredgewidth() == '???')", "ground_truth": "kws['linewidth']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_889", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_plot", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y'))\n    p.plot(ax, {})\n    points = ax.collections[0]\n    assert_array_equal(points.get_offsets(), long_df[['x', 'y']].to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    points = ax.collections[0]\n    assert same_color(points.get_facecolor(), 'k')\n    assert (points.get_label() == 'test')\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    points = ax.collections[0]\n    expected_colors = p._hue_map(p.plot_data['hue'])\n    assert same_color(points.get_facecolors(), expected_colors)\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', style='c'))\n    p.map_style(markers=['+', 'x'])\n    ax.clear()\n    color = (1, 0.3, 0.8)\n    p.plot(ax, {'color': color})\n    points = ax.collections[0]\n    assert same_color(points.get_edgecolors(), [color])\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    points = ax.collections[0]\n    expected_sizes = p._size_map(p.plot_data['size'])\n    assert_array_equal(points.get_sizes(), expected_sizes)\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    points = ax.collections[0]\n    expected_colors = p._hue_map(p.plot_data['hue'])\n    expected_paths = p._style_map(p.plot_data['style'], 'path')\n    assert same_color(points.get_facecolors(), expected_colors)\n    assert self.paths_equal(points.get_paths(), expected_paths)\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    points = ax.collections[0]\n    expected_colors = p._hue_map(p.plot_data['hue'])\n    expected_paths = p._style_map(p.plot_data['style'], 'path')\n    assert same_color(points.get_facecolors(), expected_colors)\n    assert self.paths_equal(points.get_paths(), expected_paths)\n    x_str = long_df['x'].astype(str)\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "masked_code": "def test_plot(self, long_df, repeated_df):\n    (f, ax) = plt.subplots()\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y'))\n    p.plot(ax, {})\n    points = ax.collections[0]\n    assert_array_equal(points.get_offsets(), long_df[['x', 'y']].to_numpy())\n    ax.clear()\n    p.plot(ax, {'color': 'k', 'label': 'test'})\n    points = ax.collections[0]\n    assert same_color(points.get_facecolor(), 'k')\n    assert (points.get_label() == '???')\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', hue='a'))\n    ax.clear()\n    p.plot(ax, {})\n    points = ax.collections[0]\n    expected_colors = p._hue_map(p.plot_data['hue'])\n    assert same_color(points.get_facecolors(), expected_colors)\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', style='c'))\n    p.map_style(markers=['+', 'x'])\n    ax.clear()\n    color = (1, 0.3, 0.8)\n    p.plot(ax, {'color': color})\n    points = ax.collections[0]\n    assert same_color(points.get_edgecolors(), [color])\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', size='a'))\n    ax.clear()\n    p.plot(ax, {})\n    points = ax.collections[0]\n    expected_sizes = p._size_map(p.plot_data['size'])\n    assert_array_equal(points.get_sizes(), expected_sizes)\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='a'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    points = ax.collections[0]\n    expected_colors = p._hue_map(p.plot_data['hue'])\n    expected_paths = p._style_map(p.plot_data['style'], 'path')\n    assert same_color(points.get_facecolors(), expected_colors)\n    assert self.paths_equal(points.get_paths(), expected_paths)\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', hue='a', style='b'))\n    p.map_style(markers=True)\n    ax.clear()\n    p.plot(ax, {})\n    points = ax.collections[0]\n    expected_colors = p._hue_map(p.plot_data['hue'])\n    expected_paths = p._style_map(p.plot_data['style'], 'path')\n    assert same_color(points.get_facecolors(), expected_colors)\n    assert self.paths_equal(points.get_paths(), expected_paths)\n    x_str = long_df['x'].astype(str)\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', hue=x_str))\n    ax.clear()\n    p.plot(ax, {})\n    p = _ScatterPlotter(data=long_df, variables=dict(x='x', y='y', size=x_str))\n    ax.clear()\n    p.plot(ax, {})", "ground_truth": "'test'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_890", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_hue_order", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_hue_order(self, long_df):\n    order = categorical_order(long_df['a'])\n    unused = order.pop()\n    ax = scatterplot(data=long_df, x='x', y='y', hue='a', hue_order=order)\n    points = ax.collections[0]\n    assert (points.get_facecolors()[(long_df['a'] == unused)] == 0).all()\n    assert ([t.get_text() for t in ax.legend_.texts] == order)", "masked_code": "def test_hue_order(self, long_df):\n    order = categorical_order(long_df['a'])\n    unused = order.pop()\n    ax = scatterplot(data=long_df, x='x', y='y', hue='a', hue_order=order)\n    points = ax.collections[0]\n    assert (points.get_facecolors()[(long_df['a'] == unused)] == 0).all()\n    assert ([t.get_text() for t in ax.legend_.texts] == '???')", "ground_truth": "order", "quality_analysis": {"complexity_score": 1, "left_complexity": 0, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_891", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_linewidths", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_linewidths(self, long_df):\n    (f, ax) = plt.subplots()\n    scatterplot(data=long_df, x='x', y='y', s=10)\n    scatterplot(data=long_df, x='x', y='y', s=20)\n    (points1, points2) = ax.collections\n    assert (points1.get_linewidths().item() < points2.get_linewidths().item())\n    ax.clear()\n    scatterplot(data=long_df, x='x', y='y', s=long_df['x'])\n    scatterplot(data=long_df, x='x', y='y', s=(long_df['x'] * 2))\n    (points1, points2) = ax.collections\n    assert (points1.get_linewidths().item() < points2.get_linewidths().item())\n    ax.clear()\n    lw = 2\n    scatterplot(data=long_df, x='x', y='y', linewidth=lw)\n    assert (ax.collections[0].get_linewidths().item() == lw)", "masked_code": "def test_linewidths(self, long_df):\n    (f, ax) = plt.subplots()\n    scatterplot(data=long_df, x='x', y='y', s=10)\n    scatterplot(data=long_df, x='x', y='y', s=20)\n    (points1, points2) = ax.collections\n    assert (points1.get_linewidths().item() < points2.get_linewidths().item())\n    ax.clear()\n    scatterplot(data=long_df, x='x', y='y', s=long_df['x'])\n    scatterplot(data=long_df, x='x', y='y', s=(long_df['x'] * 2))\n    (points1, points2) = ax.collections\n    assert (points1.get_linewidths().item() < points2.get_linewidths().item())\n    ax.clear()\n    lw = 2\n    scatterplot(data=long_df, x='x', y='y', linewidth=lw)\n    assert (ax.collections[0].get_linewidths().item() == '???')", "ground_truth": "lw", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_892", "reponame": "seaborn", "testpath": "tests/test_relational.py", "testname": "test_relational.py", "classname": "TestScatterPlotter", "funcname": "test_size_norm_extrapolation", "imports": ["from itertools import product", "import warnings", "import numpy as np", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from matplotlib.colors import same_color, to_rgba", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn.palettes import color_palette", "from seaborn._base import categorical_order, unique_markers", "from seaborn.relational import _RelationalPlotter, _LinePlotter, _ScatterPlotter, relplot, lineplot, scatterplot", "from seaborn.utils import _draw_figure, _version_predates", "from seaborn._compat import get_colormap, get_legend_handles", "from seaborn._testing import assert_plots_equal"], "code": "def test_size_norm_extrapolation(self):\n    x = np.arange(0, 20, 2)\n    (f, axs) = plt.subplots(1, 2, sharex=True, sharey=True)\n    slc = 5\n    kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n    scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n    scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n    assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].collections[0].get_sizes())\n    legends = [ax.legend_ for ax in axs]\n    legend_data = [{label.get_text(): handle.get_markersize() for (label, handle) in zip(legend.get_texts(), get_legend_handles(legend))} for legend in legends]\n    for key in (set(legend_data[0]) & set(legend_data[1])):\n        if (key == 'y'):\n            continue\n        assert (legend_data[0][key] == legend_data[1][key])", "masked_code": "def test_size_norm_extrapolation(self):\n    x = np.arange(0, 20, 2)\n    (f, axs) = plt.subplots(1, 2, sharex=True, sharey=True)\n    slc = 5\n    kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n    scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n    scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n    assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].collections[0].get_sizes())\n    legends = [ax.legend_ for ax in axs]\n    legend_data = [{label.get_text(): handle.get_markersize() for (label, handle) in zip(legend.get_texts(), get_legend_handles(legend))} for legend in legends]\n    for key in (set(legend_data[0]) & set(legend_data[1])):\n        if (key == 'y'):\n            continue\n        assert (legend_data[0][key] == '???')", "ground_truth": "legend_data[1][key]", "quality_analysis": {"complexity_score": 18, "left_complexity": 9, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_893", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_gridsize", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_gridsize(self, rng):\n    x = rng.normal(0, 3, 1000)\n    n = 200\n    kde = KDE(gridsize=n)\n    (density, support) = kde(x)\n    assert (density.size == n)\n    assert (support.size == n)", "masked_code": "def test_gridsize(self, rng):\n    x = rng.normal(0, 3, 1000)\n    n = 200\n    kde = KDE(gridsize=n)\n    (density, support) = kde(x)\n    assert (density.size == '???')\n    assert (support.size == n)", "ground_truth": "n", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_894", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_gridsize", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_gridsize(self, rng):\n    x = rng.normal(0, 3, 1000)\n    n = 200\n    kde = KDE(gridsize=n)\n    (density, support) = kde(x)\n    assert (density.size == n)\n    assert (support.size == n)", "masked_code": "def test_gridsize(self, rng):\n    x = rng.normal(0, 3, 1000)\n    n = 200\n    kde = KDE(gridsize=n)\n    (density, support) = kde(x)\n    assert (density.size == n)\n    assert (support.size == '???')", "ground_truth": "n", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_895", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_cut", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE(cut=0)\n    (_, support) = kde(x)\n    assert (support.min() == x.min())\n    assert (support.max() == x.max())\n    cut = 2\n    bw_scale = 0.5\n    bw = (x.std() * bw_scale)\n    kde = KDE(cut=cut, bw_method=bw_scale, gridsize=1000)\n    (_, support) = kde(x)\n    assert (support.min() == pytest.approx((x.min() - (bw * cut)), abs=0.01))\n    assert (support.max() == pytest.approx((x.max() + (bw * cut)), abs=0.01))", "masked_code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE(cut=0)\n    (_, support) = kde(x)\n    assert (support.min() == '???')\n    assert (support.max() == x.max())\n    cut = 2\n    bw_scale = 0.5\n    bw = (x.std() * bw_scale)\n    kde = KDE(cut=cut, bw_method=bw_scale, gridsize=1000)\n    (_, support) = kde(x)\n    assert (support.min() == pytest.approx((x.min() - (bw * cut)), abs=0.01))\n    assert (support.max() == pytest.approx((x.max() + (bw * cut)), abs=0.01))", "ground_truth": "x.min()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_896", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_cut", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE(cut=0)\n    (_, support) = kde(x)\n    assert (support.min() == x.min())\n    assert (support.max() == x.max())\n    cut = 2\n    bw_scale = 0.5\n    bw = (x.std() * bw_scale)\n    kde = KDE(cut=cut, bw_method=bw_scale, gridsize=1000)\n    (_, support) = kde(x)\n    assert (support.min() == pytest.approx((x.min() - (bw * cut)), abs=0.01))\n    assert (support.max() == pytest.approx((x.max() + (bw * cut)), abs=0.01))", "masked_code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE(cut=0)\n    (_, support) = kde(x)\n    assert (support.min() == x.min())\n    assert (support.max() == '???')\n    cut = 2\n    bw_scale = 0.5\n    bw = (x.std() * bw_scale)\n    kde = KDE(cut=cut, bw_method=bw_scale, gridsize=1000)\n    (_, support) = kde(x)\n    assert (support.min() == pytest.approx((x.min() - (bw * cut)), abs=0.01))\n    assert (support.max() == pytest.approx((x.max() + (bw * cut)), abs=0.01))", "ground_truth": "x.max()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_897", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_cut", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE(cut=0)\n    (_, support) = kde(x)\n    assert (support.min() == x.min())\n    assert (support.max() == x.max())\n    cut = 2\n    bw_scale = 0.5\n    bw = (x.std() * bw_scale)\n    kde = KDE(cut=cut, bw_method=bw_scale, gridsize=1000)\n    (_, support) = kde(x)\n    assert (support.min() == pytest.approx((x.min() - (bw * cut)), abs=0.01))\n    assert (support.max() == pytest.approx((x.max() + (bw * cut)), abs=0.01))", "masked_code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE(cut=0)\n    (_, support) = kde(x)\n    assert (support.min() == x.min())\n    assert (support.max() == x.max())\n    cut = 2\n    bw_scale = 0.5\n    bw = (x.std() * bw_scale)\n    kde = KDE(cut=cut, bw_method=bw_scale, gridsize=1000)\n    (_, support) = kde(x)\n    assert (support.min() == '???')\n    assert (support.max() == pytest.approx((x.max() + (bw * cut)), abs=0.01))", "ground_truth": "pytest.approx((x.min() - (bw * cut)), abs=0.01)", "quality_analysis": {"complexity_score": 15, "left_complexity": 3, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_898", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_cut", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE(cut=0)\n    (_, support) = kde(x)\n    assert (support.min() == x.min())\n    assert (support.max() == x.max())\n    cut = 2\n    bw_scale = 0.5\n    bw = (x.std() * bw_scale)\n    kde = KDE(cut=cut, bw_method=bw_scale, gridsize=1000)\n    (_, support) = kde(x)\n    assert (support.min() == pytest.approx((x.min() - (bw * cut)), abs=0.01))\n    assert (support.max() == pytest.approx((x.max() + (bw * cut)), abs=0.01))", "masked_code": "def test_cut(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE(cut=0)\n    (_, support) = kde(x)\n    assert (support.min() == x.min())\n    assert (support.max() == x.max())\n    cut = 2\n    bw_scale = 0.5\n    bw = (x.std() * bw_scale)\n    kde = KDE(cut=cut, bw_method=bw_scale, gridsize=1000)\n    (_, support) = kde(x)\n    assert (support.min() == pytest.approx((x.min() - (bw * cut)), abs=0.01))\n    assert (support.max() == '???')", "ground_truth": "pytest.approx((x.max() + (bw * cut)), abs=0.01)", "quality_analysis": {"complexity_score": 15, "left_complexity": 3, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_899", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_density_normalization", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_density_normalization(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE()\n    (density, support) = kde(x)\n    assert (self.integrate(density, support) == pytest.approx(1, abs=1e-05))", "masked_code": "def test_density_normalization(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE()\n    (density, support) = kde(x)\n    assert (self.integrate(density, support) == '???')", "ground_truth": "pytest.approx(1, abs=1e-05)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_900", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_cumulative", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "@pytest.mark.skipif(_no_scipy, reason='Test requires scipy')\ndef test_cumulative(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE(cumulative=True)\n    (density, _) = kde(x)\n    assert (density[0] == pytest.approx(0, abs=1e-05))\n    assert (density[(- 1)] == pytest.approx(1, abs=1e-05))", "masked_code": "@pytest.mark.skipif(_no_scipy, reason='Test requires scipy')\ndef test_cumulative(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE(cumulative=True)\n    (density, _) = kde(x)\n    assert (density[0] == '???')\n    assert (density[(- 1)] == pytest.approx(1, abs=1e-05))", "ground_truth": "pytest.approx(0, abs=1e-05)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_901", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_cumulative", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "@pytest.mark.skipif(_no_scipy, reason='Test requires scipy')\ndef test_cumulative(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE(cumulative=True)\n    (density, _) = kde(x)\n    assert (density[0] == pytest.approx(0, abs=1e-05))\n    assert (density[(- 1)] == pytest.approx(1, abs=1e-05))", "masked_code": "@pytest.mark.skipif(_no_scipy, reason='Test requires scipy')\ndef test_cumulative(self, rng):\n    x = rng.normal(0, 3, 1000)\n    kde = KDE(cumulative=True)\n    (density, _) = kde(x)\n    assert (density[0] == pytest.approx(0, abs=1e-05))\n    assert (density[(- 1)] == '???')", "ground_truth": "pytest.approx(1, abs=1e-05)", "quality_analysis": {"complexity_score": 11, "left_complexity": 7, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_902", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_bivariate_grid", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_grid(self, rng):\n    n = 100\n    (x, y) = rng.normal(0, 3, (2, 50))\n    kde = KDE(gridsize=n)\n    (density, (xx, yy)) = kde(x, y)\n    assert (density.shape == (n, n))\n    assert (xx.size == n)\n    assert (yy.size == n)", "masked_code": "def test_bivariate_grid(self, rng):\n    n = 100\n    (x, y) = rng.normal(0, 3, (2, 50))\n    kde = KDE(gridsize=n)\n    (density, (xx, yy)) = kde(x, y)\n    assert (density.shape == '???')\n    assert (xx.size == n)\n    assert (yy.size == n)", "ground_truth": "(n, n)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_903", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_bivariate_grid", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_grid(self, rng):\n    n = 100\n    (x, y) = rng.normal(0, 3, (2, 50))\n    kde = KDE(gridsize=n)\n    (density, (xx, yy)) = kde(x, y)\n    assert (density.shape == (n, n))\n    assert (xx.size == n)\n    assert (yy.size == n)", "masked_code": "def test_bivariate_grid(self, rng):\n    n = 100\n    (x, y) = rng.normal(0, 3, (2, 50))\n    kde = KDE(gridsize=n)\n    (density, (xx, yy)) = kde(x, y)\n    assert (density.shape == (n, n))\n    assert (xx.size == '???')\n    assert (yy.size == n)", "ground_truth": "n", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_904", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_bivariate_grid", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_grid(self, rng):\n    n = 100\n    (x, y) = rng.normal(0, 3, (2, 50))\n    kde = KDE(gridsize=n)\n    (density, (xx, yy)) = kde(x, y)\n    assert (density.shape == (n, n))\n    assert (xx.size == n)\n    assert (yy.size == n)", "masked_code": "def test_bivariate_grid(self, rng):\n    n = 100\n    (x, y) = rng.normal(0, 3, (2, 50))\n    kde = KDE(gridsize=n)\n    (density, (xx, yy)) = kde(x, y)\n    assert (density.shape == (n, n))\n    assert (xx.size == n)\n    assert (yy.size == '???')", "ground_truth": "n", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_905", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_bivariate_cumulative", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "@pytest.mark.skipif(_no_scipy, reason='Test requires scipy')\ndef test_bivariate_cumulative(self, rng):\n    (x, y) = rng.normal(0, 3, (2, 50))\n    kde = KDE(gridsize=100, cumulative=True)\n    (density, _) = kde(x, y)\n    assert (density[(0, 0)] == pytest.approx(0, abs=0.01))\n    assert (density[((- 1), (- 1))] == pytest.approx(1, abs=0.01))", "masked_code": "@pytest.mark.skipif(_no_scipy, reason='Test requires scipy')\ndef test_bivariate_cumulative(self, rng):\n    (x, y) = rng.normal(0, 3, (2, 50))\n    kde = KDE(gridsize=100, cumulative=True)\n    (density, _) = kde(x, y)\n    assert (density[(0, 0)] == '???')\n    assert (density[((- 1), (- 1))] == pytest.approx(1, abs=0.01))", "ground_truth": "pytest.approx(0, abs=0.01)", "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_906", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestKDE", "funcname": "test_bivariate_cumulative", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "@pytest.mark.skipif(_no_scipy, reason='Test requires scipy')\ndef test_bivariate_cumulative(self, rng):\n    (x, y) = rng.normal(0, 3, (2, 50))\n    kde = KDE(gridsize=100, cumulative=True)\n    (density, _) = kde(x, y)\n    assert (density[(0, 0)] == pytest.approx(0, abs=0.01))\n    assert (density[((- 1), (- 1))] == pytest.approx(1, abs=0.01))", "masked_code": "@pytest.mark.skipif(_no_scipy, reason='Test requires scipy')\ndef test_bivariate_cumulative(self, rng):\n    (x, y) = rng.normal(0, 3, (2, 50))\n    kde = KDE(gridsize=100, cumulative=True)\n    (density, _) = kde(x, y)\n    assert (density[(0, 0)] == pytest.approx(0, abs=0.01))\n    assert (density[((- 1), (- 1))] == '???')", "ground_truth": "pytest.approx(1, abs=0.01)", "quality_analysis": {"complexity_score": 16, "left_complexity": 12, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_907", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_string_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_string_bins(self, x):\n    h = Histogram(bins='sqrt')\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == (x.min(), x.max()))\n    assert (bin_kws['bins'] == int(np.sqrt(len(x))))", "masked_code": "def test_string_bins(self, x):\n    h = Histogram(bins='sqrt')\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == '???')\n    assert (bin_kws['bins'] == int(np.sqrt(len(x))))", "ground_truth": "(x.min(), x.max())", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_908", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_string_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_string_bins(self, x):\n    h = Histogram(bins='sqrt')\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == (x.min(), x.max()))\n    assert (bin_kws['bins'] == int(np.sqrt(len(x))))", "masked_code": "def test_string_bins(self, x):\n    h = Histogram(bins='sqrt')\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == (x.min(), x.max()))\n    assert (bin_kws['bins'] == '???')", "ground_truth": "int(np.sqrt(len(x)))", "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_909", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_int_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_int_bins(self, x):\n    n = 24\n    h = Histogram(bins=n)\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == (x.min(), x.max()))\n    assert (bin_kws['bins'] == n)", "masked_code": "def test_int_bins(self, x):\n    n = 24\n    h = Histogram(bins=n)\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == '???')\n    assert (bin_kws['bins'] == n)", "ground_truth": "(x.min(), x.max())", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_910", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_int_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_int_bins(self, x):\n    n = 24\n    h = Histogram(bins=n)\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == (x.min(), x.max()))\n    assert (bin_kws['bins'] == n)", "masked_code": "def test_int_bins(self, x):\n    n = 24\n    h = Histogram(bins=n)\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == (x.min(), x.max()))\n    assert (bin_kws['bins'] == '???')", "ground_truth": "n", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_911", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_int_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_int_bins(self, x, y):\n    (b1, b2) = (5, 10)\n    h = Histogram(bins=b1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == (b1 + 1))\n    h = Histogram(bins=(b1, b2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == (b2 + 1))", "masked_code": "def test_bivariate_int_bins(self, x, y):\n    (b1, b2) = (5, 10)\n    h = Histogram(bins=b1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == '???')\n    assert (len(e2) == (b1 + 1))\n    h = Histogram(bins=(b1, b2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == (b2 + 1))", "ground_truth": "(b1 + 1)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_912", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_int_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_int_bins(self, x, y):\n    (b1, b2) = (5, 10)\n    h = Histogram(bins=b1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == (b1 + 1))\n    h = Histogram(bins=(b1, b2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == (b2 + 1))", "masked_code": "def test_bivariate_int_bins(self, x, y):\n    (b1, b2) = (5, 10)\n    h = Histogram(bins=b1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == '???')\n    h = Histogram(bins=(b1, b2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == (b2 + 1))", "ground_truth": "(b1 + 1)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_913", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_int_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_int_bins(self, x, y):\n    (b1, b2) = (5, 10)\n    h = Histogram(bins=b1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == (b1 + 1))\n    h = Histogram(bins=(b1, b2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == (b2 + 1))", "masked_code": "def test_bivariate_int_bins(self, x, y):\n    (b1, b2) = (5, 10)\n    h = Histogram(bins=b1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == (b1 + 1))\n    h = Histogram(bins=(b1, b2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == '???')\n    assert (len(e2) == (b2 + 1))", "ground_truth": "(b1 + 1)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_914", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_int_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_int_bins(self, x, y):\n    (b1, b2) = (5, 10)\n    h = Histogram(bins=b1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == (b1 + 1))\n    h = Histogram(bins=(b1, b2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == (b2 + 1))", "masked_code": "def test_bivariate_int_bins(self, x, y):\n    (b1, b2) = (5, 10)\n    h = Histogram(bins=b1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == (b1 + 1))\n    h = Histogram(bins=(b1, b2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (len(e1) == (b1 + 1))\n    assert (len(e2) == '???')", "ground_truth": "(b2 + 1)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_915", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_binwidth", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_binwidth(self, x):\n    binwidth = 0.5\n    h = Histogram(binwidth=binwidth)\n    bin_kws = h.define_bin_params(x)\n    n_bins = bin_kws['bins']\n    (left, right) = bin_kws['range']\n    assert (((right - left) / n_bins) == pytest.approx(binwidth))", "masked_code": "def test_binwidth(self, x):\n    binwidth = 0.5\n    h = Histogram(binwidth=binwidth)\n    bin_kws = h.define_bin_params(x)\n    n_bins = bin_kws['bins']\n    (left, right) = bin_kws['range']\n    assert (((right - left) / n_bins) == '???')", "ground_truth": "pytest.approx(binwidth)", "quality_analysis": {"complexity_score": 11, "left_complexity": 7, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_916", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_binrange", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_binrange(self, x):\n    binrange = ((- 4), 4)\n    h = Histogram(binrange=binrange)\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == binrange)", "masked_code": "def test_binrange(self, x):\n    binrange = ((- 4), 4)\n    h = Histogram(binrange=binrange)\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == '???')", "ground_truth": "binrange", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_917", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_binrange", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "masked_code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == '???')\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "ground_truth": "r1[0]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_918", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_binrange", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "masked_code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == '???')\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "ground_truth": "r1[1]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_919", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_binrange", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "masked_code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == '???')\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "ground_truth": "r1[0]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_920", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_binrange", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "masked_code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == '???')\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "ground_truth": "r1[1]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_921", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_binrange", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "masked_code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == '???')\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "ground_truth": "r1[0]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_922", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_binrange", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "masked_code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == '???')\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "ground_truth": "r1[1]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_923", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_binrange", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "masked_code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == '???')\n    assert (e2.max() == r2[1])", "ground_truth": "r2[0]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_924", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_binrange", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == r2[1])", "masked_code": "def test_bivariate_binrange(self, x, y):\n    (r1, r2) = (((- 4), 4), ((- 10), 10))\n    h = Histogram(binrange=r1)\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r1[0])\n    assert (e2.max() == r1[1])\n    h = Histogram(binrange=(r1, r2))\n    (e1, e2) = h.define_bin_params(x, y)['bins']\n    assert (e1.min() == r1[0])\n    assert (e1.max() == r1[1])\n    assert (e2.min() == r2[0])\n    assert (e2.max() == '???')", "ground_truth": "r2[1]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_925", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_discrete_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_discrete_bins(self, rng):\n    x = rng.binomial(20, 0.5, 100)\n    h = Histogram(discrete=True)\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == ((x.min() - 0.5), (x.max() + 0.5)))\n    assert (bin_kws['bins'] == ((x.max() - x.min()) + 1))", "masked_code": "def test_discrete_bins(self, rng):\n    x = rng.binomial(20, 0.5, 100)\n    h = Histogram(discrete=True)\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == '???')\n    assert (bin_kws['bins'] == ((x.max() - x.min()) + 1))", "ground_truth": "((x.min() - 0.5), (x.max() + 0.5))", "quality_analysis": {"complexity_score": 19, "left_complexity": 5, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_926", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_discrete_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_discrete_bins(self, rng):\n    x = rng.binomial(20, 0.5, 100)\n    h = Histogram(discrete=True)\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == ((x.min() - 0.5), (x.max() + 0.5)))\n    assert (bin_kws['bins'] == ((x.max() - x.min()) + 1))", "masked_code": "def test_discrete_bins(self, rng):\n    x = rng.binomial(20, 0.5, 100)\n    h = Histogram(discrete=True)\n    bin_kws = h.define_bin_params(x)\n    assert (bin_kws['range'] == ((x.min() - 0.5), (x.max() + 0.5)))\n    assert (bin_kws['bins'] == '???')", "ground_truth": "((x.max() - x.min()) + 1)", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_927", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_odd_single_observation", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_odd_single_observation(self):\n    x = np.array([0.49928])\n    (h, e) = Histogram(binwidth=0.03)(x)\n    assert (len(h) == 1)\n    assert ((e[1] - e[0]) == pytest.approx(0.03))", "masked_code": "def test_odd_single_observation(self):\n    x = np.array([0.49928])\n    (h, e) = Histogram(binwidth=0.03)(x)\n    assert (len(h) == 1)\n    assert ((e[1] - e[0]) == '???')", "ground_truth": "pytest.approx(0.03)", "quality_analysis": {"complexity_score": 16, "left_complexity": 12, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_928", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_binwidth_roundoff", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_binwidth_roundoff(self):\n    x = np.array([2.4, 2.5, 2.6])\n    (h, e) = Histogram(binwidth=0.01)(x)\n    assert (h.sum() == 3)", "masked_code": "def test_binwidth_roundoff(self):\n    x = np.array([2.4, 2.5, 2.6])\n    (h, e) = Histogram(binwidth=0.01)(x)\n    assert (h.sum() == '???')", "ground_truth": "3", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_929", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_count_stat", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_count_stat(self, x):\n    h = Histogram(stat='count')\n    (heights, _) = h(x)\n    assert (heights.sum() == len(x))", "masked_code": "def test_count_stat(self, x):\n    h = Histogram(stat='count')\n    (heights, _) = h(x)\n    assert (heights.sum() == '???')", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_930", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_frequency_stat", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_frequency_stat(self, x):\n    h = Histogram(stat='frequency')\n    (heights, edges) = h(x)\n    assert ((heights * np.diff(edges)).sum() == len(x))", "masked_code": "def test_frequency_stat(self, x):\n    h = Histogram(stat='frequency')\n    (heights, edges) = h(x)\n    assert ((heights * np.diff(edges)).sum() == '???')", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_931", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_cumulative_count", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_cumulative_count(self, x):\n    h = Histogram(stat='count', cumulative=True)\n    (heights, _) = h(x)\n    assert (heights[(- 1)] == len(x))", "masked_code": "def test_cumulative_count(self, x):\n    h = Histogram(stat='count', cumulative=True)\n    (heights, _) = h(x)\n    assert (heights[(- 1)] == '???')", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 11, "left_complexity": 7, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_932", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_cumulative_frequency", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_cumulative_frequency(self, x):\n    h = Histogram(stat='frequency', cumulative=True)\n    (heights, _) = h(x)\n    assert (heights[(- 1)] == len(x))", "masked_code": "def test_cumulative_frequency(self, x):\n    h = Histogram(stat='frequency', cumulative=True)\n    (heights, _) = h(x)\n    assert (heights[(- 1)] == '???')", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 11, "left_complexity": 7, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_933", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_count_stat", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_count_stat(self, x, y):\n    h = Histogram(stat='count')\n    (heights, _) = h(x, y)\n    assert (heights.sum() == len(x))", "masked_code": "def test_bivariate_count_stat(self, x, y):\n    h = Histogram(stat='count')\n    (heights, _) = h(x, y)\n    assert (heights.sum() == '???')", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_934", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_density_stat", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_density_stat(self, x, y):\n    h = Histogram(stat='density')\n    (heights, (edges_x, edges_y)) = h(x, y)\n    areas = np.outer(np.diff(edges_x), np.diff(edges_y))\n    assert ((heights * areas).sum() == pytest.approx(1))", "masked_code": "def test_bivariate_density_stat(self, x, y):\n    h = Histogram(stat='density')\n    (heights, (edges_x, edges_y)) = h(x, y)\n    areas = np.outer(np.diff(edges_x), np.diff(edges_y))\n    assert ((heights * areas).sum() == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_935", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_frequency_stat", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_frequency_stat(self, x, y):\n    h = Histogram(stat='frequency')\n    (heights, (x_edges, y_edges)) = h(x, y)\n    area = np.outer(np.diff(x_edges), np.diff(y_edges))\n    assert ((heights * area).sum() == len(x))", "masked_code": "def test_bivariate_frequency_stat(self, x, y):\n    h = Histogram(stat='frequency')\n    (heights, (x_edges, y_edges)) = h(x, y)\n    area = np.outer(np.diff(x_edges), np.diff(y_edges))\n    assert ((heights * area).sum() == '???')", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_936", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_cumulative_count", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_cumulative_count(self, x, y):\n    h = Histogram(stat='count', cumulative=True)\n    (heights, _) = h(x, y)\n    assert (heights[((- 1), (- 1))] == len(x))", "masked_code": "def test_bivariate_cumulative_count(self, x, y):\n    h = Histogram(stat='count', cumulative=True)\n    (heights, _) = h(x, y)\n    assert (heights[((- 1), (- 1))] == '???')", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 16, "left_complexity": 12, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_937", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_cumulative_density", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_cumulative_density(self, x, y):\n    h = Histogram(stat='density', cumulative=True)\n    (heights, _) = h(x, y)\n    assert (heights[((- 1), (- 1))] == pytest.approx(1))", "masked_code": "def test_bivariate_cumulative_density(self, x, y):\n    h = Histogram(stat='density', cumulative=True)\n    (heights, _) = h(x, y)\n    assert (heights[((- 1), (- 1))] == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 16, "left_complexity": 12, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_938", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_cumulative_frequency", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_cumulative_frequency(self, x, y):\n    h = Histogram(stat='frequency', cumulative=True)\n    (heights, _) = h(x, y)\n    assert (heights[((- 1), (- 1))] == len(x))", "masked_code": "def test_bivariate_cumulative_frequency(self, x, y):\n    h = Histogram(stat='frequency', cumulative=True)\n    (heights, _) = h(x, y)\n    assert (heights[((- 1), (- 1))] == '???')", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 16, "left_complexity": 12, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_939", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestHistogram", "funcname": "test_bivariate_cumulative_probability", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_bivariate_cumulative_probability(self, x, y):\n    h = Histogram(stat='probability', cumulative=True)\n    (heights, _) = h(x, y)\n    assert (heights[((- 1), (- 1))] == pytest.approx(1))", "masked_code": "def test_bivariate_cumulative_probability(self, x, y):\n    h = Histogram(stat='probability', cumulative=True)\n    (heights, _) = h(x, y)\n    assert (heights[((- 1), (- 1))] == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 16, "left_complexity": 12, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_940", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_func_estimator", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_func_estimator(self, long_df):\n    func = np.mean\n    agg = EstimateAggregator(func)\n    out = agg(long_df, 'x')\n    assert (out['x'] == func(long_df['x']))", "masked_code": "def test_func_estimator(self, long_df):\n    func = np.mean\n    agg = EstimateAggregator(func)\n    out = agg(long_df, 'x')\n    assert (out['x'] == '???')", "ground_truth": "func(long_df['x'])", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_941", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_name_estimator", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_name_estimator(self, long_df):\n    agg = EstimateAggregator('mean')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())", "masked_code": "def test_name_estimator(self, long_df):\n    agg = EstimateAggregator('mean')\n    out = agg(long_df, 'x')\n    assert (out['x'] == '???')", "ground_truth": "long_df['x'].mean()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_942", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_custom_func_estimator", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_custom_func_estimator(self, long_df):\n\n    def func(x):\n        return np.asarray(x).min()\n    agg = EstimateAggregator(func)\n    out = agg(long_df, 'x')\n    assert (out['x'] == func(long_df['x']))", "masked_code": "def test_custom_func_estimator(self, long_df):\n\n    def func(x):\n        return np.asarray(x).min()\n    agg = EstimateAggregator(func)\n    out = agg(long_df, 'x')\n    assert (out['x'] == '???')", "ground_truth": "func(long_df['x'])", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_943", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_se_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_se_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'se')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].sem()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].sem()))\n    agg = EstimateAggregator('mean', ('se', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].sem())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].sem())))", "masked_code": "def test_se_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'se')\n    out = agg(long_df, 'x')\n    assert (out['x'] == '???')\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].sem()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].sem()))\n    agg = EstimateAggregator('mean', ('se', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].sem())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].sem())))", "ground_truth": "long_df['x'].mean()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_944", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_se_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_se_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'se')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].sem()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].sem()))\n    agg = EstimateAggregator('mean', ('se', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].sem())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].sem())))", "masked_code": "def test_se_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'se')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == '???')\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].sem()))\n    agg = EstimateAggregator('mean', ('se', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].sem())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].sem())))", "ground_truth": "(long_df['x'].mean() - long_df['x'].sem())", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_945", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_se_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_se_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'se')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].sem()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].sem()))\n    agg = EstimateAggregator('mean', ('se', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].sem())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].sem())))", "masked_code": "def test_se_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'se')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].sem()))\n    assert (out['xmax'] == '???')\n    agg = EstimateAggregator('mean', ('se', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].sem())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].sem())))", "ground_truth": "(long_df['x'].mean() + long_df['x'].sem())", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_946", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_se_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_se_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'se')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].sem()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].sem()))\n    agg = EstimateAggregator('mean', ('se', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].sem())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].sem())))", "masked_code": "def test_se_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'se')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].sem()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].sem()))\n    agg = EstimateAggregator('mean', ('se', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == '???')\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].sem())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].sem())))", "ground_truth": "long_df['x'].mean()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_947", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_se_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_se_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'se')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].sem()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].sem()))\n    agg = EstimateAggregator('mean', ('se', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].sem())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].sem())))", "masked_code": "def test_se_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'se')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].sem()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].sem()))\n    agg = EstimateAggregator('mean', ('se', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == '???')\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].sem())))", "ground_truth": "(long_df['x'].mean() - (2 * long_df['x'].sem()))", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_948", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_se_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_se_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'se')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].sem()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].sem()))\n    agg = EstimateAggregator('mean', ('se', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].sem())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].sem())))", "masked_code": "def test_se_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'se')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].sem()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].sem()))\n    agg = EstimateAggregator('mean', ('se', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].sem())))\n    assert (out['xmax'] == '???')", "ground_truth": "(long_df['x'].mean() + (2 * long_df['x'].sem()))", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_949", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_sd_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_sd_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'sd')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].std()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].std()))\n    agg = EstimateAggregator('mean', ('sd', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].std())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].std())))", "masked_code": "def test_sd_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'sd')\n    out = agg(long_df, 'x')\n    assert (out['x'] == '???')\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].std()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].std()))\n    agg = EstimateAggregator('mean', ('sd', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].std())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].std())))", "ground_truth": "long_df['x'].mean()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_950", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_sd_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_sd_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'sd')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].std()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].std()))\n    agg = EstimateAggregator('mean', ('sd', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].std())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].std())))", "masked_code": "def test_sd_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'sd')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == '???')\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].std()))\n    agg = EstimateAggregator('mean', ('sd', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].std())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].std())))", "ground_truth": "(long_df['x'].mean() - long_df['x'].std())", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_951", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_sd_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_sd_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'sd')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].std()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].std()))\n    agg = EstimateAggregator('mean', ('sd', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].std())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].std())))", "masked_code": "def test_sd_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'sd')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].std()))\n    assert (out['xmax'] == '???')\n    agg = EstimateAggregator('mean', ('sd', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].std())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].std())))", "ground_truth": "(long_df['x'].mean() + long_df['x'].std())", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_952", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_sd_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_sd_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'sd')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].std()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].std()))\n    agg = EstimateAggregator('mean', ('sd', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].std())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].std())))", "masked_code": "def test_sd_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'sd')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].std()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].std()))\n    agg = EstimateAggregator('mean', ('sd', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == '???')\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].std())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].std())))", "ground_truth": "long_df['x'].mean()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_953", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_sd_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_sd_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'sd')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].std()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].std()))\n    agg = EstimateAggregator('mean', ('sd', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].std())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].std())))", "masked_code": "def test_sd_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'sd')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].std()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].std()))\n    agg = EstimateAggregator('mean', ('sd', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == '???')\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].std())))", "ground_truth": "(long_df['x'].mean() - (2 * long_df['x'].std()))", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_954", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_sd_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_sd_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'sd')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].std()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].std()))\n    agg = EstimateAggregator('mean', ('sd', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].std())))\n    assert (out['xmax'] == (long_df['x'].mean() + (2 * long_df['x'].std())))", "masked_code": "def test_sd_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'sd')\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - long_df['x'].std()))\n    assert (out['xmax'] == (long_df['x'].mean() + long_df['x'].std()))\n    agg = EstimateAggregator('mean', ('sd', 2))\n    out = agg(long_df, 'x')\n    assert (out['x'] == long_df['x'].mean())\n    assert (out['xmin'] == (long_df['x'].mean() - (2 * long_df['x'].std())))\n    assert (out['xmax'] == '???')", "ground_truth": "(long_df['x'].mean() + (2 * long_df['x'].std()))", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_955", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_pi_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_pi_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'pi')\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 2.5))\n    assert (out['ymax'] == np.percentile(long_df['y'], 97.5))\n    agg = EstimateAggregator('mean', ('pi', 50))\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 25))\n    assert (out['ymax'] == np.percentile(long_df['y'], 75))", "masked_code": "def test_pi_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'pi')\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == '???')\n    assert (out['ymax'] == np.percentile(long_df['y'], 97.5))\n    agg = EstimateAggregator('mean', ('pi', 50))\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 25))\n    assert (out['ymax'] == np.percentile(long_df['y'], 75))", "ground_truth": "np.percentile(long_df['y'], 2.5)", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_956", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_pi_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_pi_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'pi')\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 2.5))\n    assert (out['ymax'] == np.percentile(long_df['y'], 97.5))\n    agg = EstimateAggregator('mean', ('pi', 50))\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 25))\n    assert (out['ymax'] == np.percentile(long_df['y'], 75))", "masked_code": "def test_pi_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'pi')\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 2.5))\n    assert (out['ymax'] == '???')\n    agg = EstimateAggregator('mean', ('pi', 50))\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 25))\n    assert (out['ymax'] == np.percentile(long_df['y'], 75))", "ground_truth": "np.percentile(long_df['y'], 97.5)", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_957", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_pi_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_pi_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'pi')\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 2.5))\n    assert (out['ymax'] == np.percentile(long_df['y'], 97.5))\n    agg = EstimateAggregator('mean', ('pi', 50))\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 25))\n    assert (out['ymax'] == np.percentile(long_df['y'], 75))", "masked_code": "def test_pi_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'pi')\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 2.5))\n    assert (out['ymax'] == np.percentile(long_df['y'], 97.5))\n    agg = EstimateAggregator('mean', ('pi', 50))\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == '???')\n    assert (out['ymax'] == np.percentile(long_df['y'], 75))", "ground_truth": "np.percentile(long_df['y'], 25)", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_958", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_pi_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_pi_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'pi')\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 2.5))\n    assert (out['ymax'] == np.percentile(long_df['y'], 97.5))\n    agg = EstimateAggregator('mean', ('pi', 50))\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 25))\n    assert (out['ymax'] == np.percentile(long_df['y'], 75))", "masked_code": "def test_pi_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'pi')\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 2.5))\n    assert (out['ymax'] == np.percentile(long_df['y'], 97.5))\n    agg = EstimateAggregator('mean', ('pi', 50))\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == np.percentile(long_df['y'], 25))\n    assert (out['ymax'] == '???')", "ground_truth": "np.percentile(long_df['y'], 75)", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_959", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_ci_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_ci_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'ci', n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1.96))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', ('ci', 68), n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', 'ci', seed=0)\n    out_orig = agg_ref(long_df, 'y')\n    out_test = agg_ref(long_df, 'y')\n    assert_array_equal(out_orig, out_test)", "masked_code": "def test_ci_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'ci', n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1.96))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == '???')\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', ('ci', 68), n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', 'ci', seed=0)\n    out_orig = agg_ref(long_df, 'y')\n    out_test = agg_ref(long_df, 'y')\n    assert_array_equal(out_orig, out_test)", "ground_truth": "pytest.approx(out_ref['ymin'], abs=0.01)", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_960", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_ci_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_ci_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'ci', n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1.96))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', ('ci', 68), n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', 'ci', seed=0)\n    out_orig = agg_ref(long_df, 'y')\n    out_test = agg_ref(long_df, 'y')\n    assert_array_equal(out_orig, out_test)", "masked_code": "def test_ci_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'ci', n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1.96))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == '???')\n    agg = EstimateAggregator('mean', ('ci', 68), n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', 'ci', seed=0)\n    out_orig = agg_ref(long_df, 'y')\n    out_test = agg_ref(long_df, 'y')\n    assert_array_equal(out_orig, out_test)", "ground_truth": "pytest.approx(out_ref['ymax'], abs=0.01)", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_961", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_ci_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_ci_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'ci', n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1.96))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', ('ci', 68), n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', 'ci', seed=0)\n    out_orig = agg_ref(long_df, 'y')\n    out_test = agg_ref(long_df, 'y')\n    assert_array_equal(out_orig, out_test)", "masked_code": "def test_ci_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'ci', n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1.96))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', ('ci', 68), n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == '???')\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', 'ci', seed=0)\n    out_orig = agg_ref(long_df, 'y')\n    out_test = agg_ref(long_df, 'y')\n    assert_array_equal(out_orig, out_test)", "ground_truth": "pytest.approx(out_ref['ymin'], abs=0.01)", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_962", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_ci_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_ci_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'ci', n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1.96))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', ('ci', 68), n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', 'ci', seed=0)\n    out_orig = agg_ref(long_df, 'y')\n    out_test = agg_ref(long_df, 'y')\n    assert_array_equal(out_orig, out_test)", "masked_code": "def test_ci_errorbars(self, long_df):\n    agg = EstimateAggregator('mean', 'ci', n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1.96))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == pytest.approx(out_ref['ymax'], abs=0.01))\n    agg = EstimateAggregator('mean', ('ci', 68), n_boot=100000, seed=0)\n    out = agg(long_df, 'y')\n    agg_ref = EstimateAggregator('mean', ('se', 1))\n    out_ref = agg_ref(long_df, 'y')\n    assert (out['ymin'] == pytest.approx(out_ref['ymin'], abs=0.01))\n    assert (out['ymax'] == '???')\n    agg = EstimateAggregator('mean', 'ci', seed=0)\n    out_orig = agg_ref(long_df, 'y')\n    out_test = agg_ref(long_df, 'y')\n    assert_array_equal(out_orig, out_test)", "ground_truth": "pytest.approx(out_ref['ymax'], abs=0.01)", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_963", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_custom_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_custom_errorbars(self, long_df):\n    f = (lambda x: (x.min(), x.max()))\n    agg = EstimateAggregator('mean', f)\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == long_df['y'].min())\n    assert (out['ymax'] == long_df['y'].max())", "masked_code": "def test_custom_errorbars(self, long_df):\n    f = (lambda x: (x.min(), x.max()))\n    agg = EstimateAggregator('mean', f)\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == '???')\n    assert (out['ymax'] == long_df['y'].max())", "ground_truth": "long_df['y'].min()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_964", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_custom_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_custom_errorbars(self, long_df):\n    f = (lambda x: (x.min(), x.max()))\n    agg = EstimateAggregator('mean', f)\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == long_df['y'].min())\n    assert (out['ymax'] == long_df['y'].max())", "masked_code": "def test_custom_errorbars(self, long_df):\n    f = (lambda x: (x.min(), x.max()))\n    agg = EstimateAggregator('mean', f)\n    out = agg(long_df, 'y')\n    assert (out['ymin'] == long_df['y'].min())\n    assert (out['ymax'] == '???')", "ground_truth": "long_df['y'].max()", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_965", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestEstimateAggregator", "funcname": "test_singleton_errorbars", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_singleton_errorbars(self):\n    agg = EstimateAggregator('mean', 'ci')\n    val = 7\n    out = agg(pd.DataFrame(dict(y=[val])), 'y')\n    assert (out['y'] == val)\n    assert pd.isna(out['ymin'])\n    assert pd.isna(out['ymax'])", "masked_code": "def test_singleton_errorbars(self):\n    agg = EstimateAggregator('mean', 'ci')\n    val = 7\n    out = agg(pd.DataFrame(dict(y=[val])), 'y')\n    assert (out['y'] == '???')\n    assert pd.isna(out['ymin'])\n    assert pd.isna(out['ymax'])", "ground_truth": "val", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_966", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestLetterValues", "funcname": "test_median", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_median(self, x):\n    res = LetterValues(k_depth='tukey', outlier_prop=0, trust_alpha=0)(x)\n    assert (res['median'] == np.median(x))", "masked_code": "def test_median(self, x):\n    res = LetterValues(k_depth='tukey', outlier_prop=0, trust_alpha=0)(x)\n    assert (res['median'] == '???')", "ground_truth": "np.median(x)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_967", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestLetterValues", "funcname": "test_k_depth_int", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_k_depth_int(self, x):\n    res = LetterValues(k_depth=(k := 12), outlier_prop=0, trust_alpha=0)(x)\n    assert (res['k'] == k)\n    assert (len(res['levels']) == ((2 * k) - 1))", "masked_code": "def test_k_depth_int(self, x):\n    res = LetterValues(k_depth=(k := 12), outlier_prop=0, trust_alpha=0)(x)\n    assert (res['k'] == '???')\n    assert (len(res['levels']) == ((2 * k) - 1))", "ground_truth": "k", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_968", "reponame": "seaborn", "testpath": "tests/test_statistics.py", "testname": "test_statistics.py", "classname": "TestLetterValues", "funcname": "test_k_depth_int", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._statistics import KDE, Histogram, ECDF, EstimateAggregator, LetterValues, WeightedAggregator, _validate_errorbar_arg, _no_scipy"], "code": "def test_k_depth_int(self, x):\n    res = LetterValues(k_depth=(k := 12), outlier_prop=0, trust_alpha=0)(x)\n    assert (res['k'] == k)\n    assert (len(res['levels']) == ((2 * k) - 1))", "masked_code": "def test_k_depth_int(self, x):\n    res = LetterValues(k_depth=(k := 12), outlier_prop=0, trust_alpha=0)(x)\n    assert (res['k'] == k)\n    assert (len(res['levels']) == '???')", "ground_truth": "((2 * k) - 1)", "quality_analysis": {"complexity_score": 15, "left_complexity": 8, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_969", "reponame": "seaborn", "testpath": "tests/test_utils.py", "testname": "test_utils.py", "classname": null, "funcname": "test_move_legend_matplotlib_objects", "imports": ["import re", "import tempfile", "from types import ModuleType", "from urllib.request import urlopen", "from http.client import HTTPException", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from cycler import cycler", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal, assert_frame_equal", "from seaborn import utils, rcmod, scatterplot", "from seaborn.utils import get_dataset_names, get_color_cycle, remove_na, load_dataset, _assign_default_kwargs, _check_argument, _draw_figure, _deprecate_ci, _version_predates, DATASET_NAMES_URL", "from seaborn._compat import get_legend_handles"], "code": "def test_move_legend_matplotlib_objects():\n    (fig, ax) = plt.subplots()\n    colors = ('C2', 'C5')\n    labels = ('first label', 'second label')\n    title = 'the legend'\n    for (color, label) in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (ax.legend_.get_title().get_text() == title)\n    assert (ax.legend_.get_title().get_size() == new_fontsize)\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert (ax.legend_.get_title().get_text() == new_title)\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (fig.legends[0].get_title().get_text() == new_title)", "masked_code": "def test_move_legend_matplotlib_objects():\n    (fig, ax) = plt.subplots()\n    colors = ('C2', 'C5')\n    labels = ('first label', 'second label')\n    title = 'the legend'\n    for (color, label) in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (ax.legend_.get_title().get_text() == '???')\n    assert (ax.legend_.get_title().get_size() == new_fontsize)\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert (ax.legend_.get_title().get_text() == new_title)\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (fig.legends[0].get_title().get_text() == new_title)", "ground_truth": "title", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_970", "reponame": "seaborn", "testpath": "tests/test_utils.py", "testname": "test_utils.py", "classname": null, "funcname": "test_move_legend_matplotlib_objects", "imports": ["import re", "import tempfile", "from types import ModuleType", "from urllib.request import urlopen", "from http.client import HTTPException", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from cycler import cycler", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal, assert_frame_equal", "from seaborn import utils, rcmod, scatterplot", "from seaborn.utils import get_dataset_names, get_color_cycle, remove_na, load_dataset, _assign_default_kwargs, _check_argument, _draw_figure, _deprecate_ci, _version_predates, DATASET_NAMES_URL", "from seaborn._compat import get_legend_handles"], "code": "def test_move_legend_matplotlib_objects():\n    (fig, ax) = plt.subplots()\n    colors = ('C2', 'C5')\n    labels = ('first label', 'second label')\n    title = 'the legend'\n    for (color, label) in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (ax.legend_.get_title().get_text() == title)\n    assert (ax.legend_.get_title().get_size() == new_fontsize)\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert (ax.legend_.get_title().get_text() == new_title)\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (fig.legends[0].get_title().get_text() == new_title)", "masked_code": "def test_move_legend_matplotlib_objects():\n    (fig, ax) = plt.subplots()\n    colors = ('C2', 'C5')\n    labels = ('first label', 'second label')\n    title = 'the legend'\n    for (color, label) in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (ax.legend_.get_title().get_text() == title)\n    assert (ax.legend_.get_title().get_size() == '???')\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert (ax.legend_.get_title().get_text() == new_title)\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (fig.legends[0].get_title().get_text() == new_title)", "ground_truth": "new_fontsize", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_971", "reponame": "seaborn", "testpath": "tests/test_utils.py", "testname": "test_utils.py", "classname": null, "funcname": "test_move_legend_matplotlib_objects", "imports": ["import re", "import tempfile", "from types import ModuleType", "from urllib.request import urlopen", "from http.client import HTTPException", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from cycler import cycler", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal, assert_frame_equal", "from seaborn import utils, rcmod, scatterplot", "from seaborn.utils import get_dataset_names, get_color_cycle, remove_na, load_dataset, _assign_default_kwargs, _check_argument, _draw_figure, _deprecate_ci, _version_predates, DATASET_NAMES_URL", "from seaborn._compat import get_legend_handles"], "code": "def test_move_legend_matplotlib_objects():\n    (fig, ax) = plt.subplots()\n    colors = ('C2', 'C5')\n    labels = ('first label', 'second label')\n    title = 'the legend'\n    for (color, label) in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (ax.legend_.get_title().get_text() == title)\n    assert (ax.legend_.get_title().get_size() == new_fontsize)\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert (ax.legend_.get_title().get_text() == new_title)\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (fig.legends[0].get_title().get_text() == new_title)", "masked_code": "def test_move_legend_matplotlib_objects():\n    (fig, ax) = plt.subplots()\n    colors = ('C2', 'C5')\n    labels = ('first label', 'second label')\n    title = 'the legend'\n    for (color, label) in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (ax.legend_.get_title().get_text() == title)\n    assert (ax.legend_.get_title().get_size() == new_fontsize)\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert (ax.legend_.get_title().get_text() == '???')\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (fig.legends[0].get_title().get_text() == new_title)", "ground_truth": "new_title", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_972", "reponame": "seaborn", "testpath": "tests/test_utils.py", "testname": "test_utils.py", "classname": null, "funcname": "test_move_legend_matplotlib_objects", "imports": ["import re", "import tempfile", "from types import ModuleType", "from urllib.request import urlopen", "from http.client import HTTPException", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from cycler import cycler", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal, assert_frame_equal", "from seaborn import utils, rcmod, scatterplot", "from seaborn.utils import get_dataset_names, get_color_cycle, remove_na, load_dataset, _assign_default_kwargs, _check_argument, _draw_figure, _deprecate_ci, _version_predates, DATASET_NAMES_URL", "from seaborn._compat import get_legend_handles"], "code": "def test_move_legend_matplotlib_objects():\n    (fig, ax) = plt.subplots()\n    colors = ('C2', 'C5')\n    labels = ('first label', 'second label')\n    title = 'the legend'\n    for (color, label) in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (ax.legend_.get_title().get_text() == title)\n    assert (ax.legend_.get_title().get_size() == new_fontsize)\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert (ax.legend_.get_title().get_text() == new_title)\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (fig.legends[0].get_title().get_text() == new_title)", "masked_code": "def test_move_legend_matplotlib_objects():\n    (fig, ax) = plt.subplots()\n    colors = ('C2', 'C5')\n    labels = ('first label', 'second label')\n    title = 'the legend'\n    for (color, label) in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (ax.legend_.get_title().get_text() == title)\n    assert (ax.legend_.get_title().get_size() == new_fontsize)\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert (ax.legend_.get_title().get_text() == new_title)\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (fig.legends[0].get_title().get_text() == '???')", "ground_truth": "new_title", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_973", "reponame": "seaborn", "testpath": "tests/test_utils.py", "testname": "test_utils.py", "classname": null, "funcname": "test_move_legend_grid_object", "imports": ["import re", "import tempfile", "from types import ModuleType", "from urllib.request import urlopen", "from http.client import HTTPException", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from cycler import cycler", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal, assert_frame_equal", "from seaborn import utils, rcmod, scatterplot", "from seaborn.utils import get_dataset_names, get_color_cycle, remove_na, load_dataset, _assign_default_kwargs, _check_argument, _draw_figure, _deprecate_ci, _version_predates, DATASET_NAMES_URL", "from seaborn._compat import get_legend_handles"], "code": "def test_move_legend_grid_object(long_df):\n    from seaborn.axisgrid import FacetGrid\n    hue_var = 'a'\n    g = FacetGrid(long_df, hue=hue_var)\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    _draw_figure(g.figure)\n    xfm = g.figure.transFigure.inverted().transform\n    old_pos = xfm(g.legend.legendPatch.get_extents())\n    fontsize = 20\n    utils.move_legend(g, 'lower left', title_fontsize=fontsize)\n    _draw_figure(g.figure)\n    new_pos = xfm(g.legend.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (g.legend.get_title().get_text() == hue_var)\n    assert (g.legend.get_title().get_size() == fontsize)\n    assert get_legend_handles(g.legend)\n    for (i, h) in enumerate(get_legend_handles(g.legend)):\n        assert (mpl.colors.to_rgb(h.get_color()) == mpl.colors.to_rgb(f'C{i}'))", "masked_code": "def test_move_legend_grid_object(long_df):\n    from seaborn.axisgrid import FacetGrid\n    hue_var = 'a'\n    g = FacetGrid(long_df, hue=hue_var)\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    _draw_figure(g.figure)\n    xfm = g.figure.transFigure.inverted().transform\n    old_pos = xfm(g.legend.legendPatch.get_extents())\n    fontsize = 20\n    utils.move_legend(g, 'lower left', title_fontsize=fontsize)\n    _draw_figure(g.figure)\n    new_pos = xfm(g.legend.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (g.legend.get_title().get_text() == '???')\n    assert (g.legend.get_title().get_size() == fontsize)\n    assert get_legend_handles(g.legend)\n    for (i, h) in enumerate(get_legend_handles(g.legend)):\n        assert (mpl.colors.to_rgb(h.get_color()) == mpl.colors.to_rgb(f'C{i}'))", "ground_truth": "hue_var", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_974", "reponame": "seaborn", "testpath": "tests/test_utils.py", "testname": "test_utils.py", "classname": null, "funcname": "test_move_legend_grid_object", "imports": ["import re", "import tempfile", "from types import ModuleType", "from urllib.request import urlopen", "from http.client import HTTPException", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from cycler import cycler", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal, assert_frame_equal", "from seaborn import utils, rcmod, scatterplot", "from seaborn.utils import get_dataset_names, get_color_cycle, remove_na, load_dataset, _assign_default_kwargs, _check_argument, _draw_figure, _deprecate_ci, _version_predates, DATASET_NAMES_URL", "from seaborn._compat import get_legend_handles"], "code": "def test_move_legend_grid_object(long_df):\n    from seaborn.axisgrid import FacetGrid\n    hue_var = 'a'\n    g = FacetGrid(long_df, hue=hue_var)\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    _draw_figure(g.figure)\n    xfm = g.figure.transFigure.inverted().transform\n    old_pos = xfm(g.legend.legendPatch.get_extents())\n    fontsize = 20\n    utils.move_legend(g, 'lower left', title_fontsize=fontsize)\n    _draw_figure(g.figure)\n    new_pos = xfm(g.legend.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (g.legend.get_title().get_text() == hue_var)\n    assert (g.legend.get_title().get_size() == fontsize)\n    assert get_legend_handles(g.legend)\n    for (i, h) in enumerate(get_legend_handles(g.legend)):\n        assert (mpl.colors.to_rgb(h.get_color()) == mpl.colors.to_rgb(f'C{i}'))", "masked_code": "def test_move_legend_grid_object(long_df):\n    from seaborn.axisgrid import FacetGrid\n    hue_var = 'a'\n    g = FacetGrid(long_df, hue=hue_var)\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    _draw_figure(g.figure)\n    xfm = g.figure.transFigure.inverted().transform\n    old_pos = xfm(g.legend.legendPatch.get_extents())\n    fontsize = 20\n    utils.move_legend(g, 'lower left', title_fontsize=fontsize)\n    _draw_figure(g.figure)\n    new_pos = xfm(g.legend.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (g.legend.get_title().get_text() == hue_var)\n    assert (g.legend.get_title().get_size() == '???')\n    assert get_legend_handles(g.legend)\n    for (i, h) in enumerate(get_legend_handles(g.legend)):\n        assert (mpl.colors.to_rgb(h.get_color()) == mpl.colors.to_rgb(f'C{i}'))", "ground_truth": "fontsize", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_975", "reponame": "seaborn", "testpath": "tests/test_utils.py", "testname": "test_utils.py", "classname": null, "funcname": "test_move_legend_grid_object", "imports": ["import re", "import tempfile", "from types import ModuleType", "from urllib.request import urlopen", "from http.client import HTTPException", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from cycler import cycler", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal, assert_frame_equal", "from seaborn import utils, rcmod, scatterplot", "from seaborn.utils import get_dataset_names, get_color_cycle, remove_na, load_dataset, _assign_default_kwargs, _check_argument, _draw_figure, _deprecate_ci, _version_predates, DATASET_NAMES_URL", "from seaborn._compat import get_legend_handles"], "code": "def test_move_legend_grid_object(long_df):\n    from seaborn.axisgrid import FacetGrid\n    hue_var = 'a'\n    g = FacetGrid(long_df, hue=hue_var)\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    _draw_figure(g.figure)\n    xfm = g.figure.transFigure.inverted().transform\n    old_pos = xfm(g.legend.legendPatch.get_extents())\n    fontsize = 20\n    utils.move_legend(g, 'lower left', title_fontsize=fontsize)\n    _draw_figure(g.figure)\n    new_pos = xfm(g.legend.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (g.legend.get_title().get_text() == hue_var)\n    assert (g.legend.get_title().get_size() == fontsize)\n    assert get_legend_handles(g.legend)\n    for (i, h) in enumerate(get_legend_handles(g.legend)):\n        assert (mpl.colors.to_rgb(h.get_color()) == mpl.colors.to_rgb(f'C{i}'))", "masked_code": "def test_move_legend_grid_object(long_df):\n    from seaborn.axisgrid import FacetGrid\n    hue_var = 'a'\n    g = FacetGrid(long_df, hue=hue_var)\n    g.map(plt.plot, 'x', 'y')\n    g.add_legend()\n    _draw_figure(g.figure)\n    xfm = g.figure.transFigure.inverted().transform\n    old_pos = xfm(g.legend.legendPatch.get_extents())\n    fontsize = 20\n    utils.move_legend(g, 'lower left', title_fontsize=fontsize)\n    _draw_figure(g.figure)\n    new_pos = xfm(g.legend.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert (g.legend.get_title().get_text() == hue_var)\n    assert (g.legend.get_title().get_size() == fontsize)\n    assert get_legend_handles(g.legend)\n    for (i, h) in enumerate(get_legend_handles(g.legend)):\n        assert (mpl.colors.to_rgb(h.get_color()) == '???')", "ground_truth": "mpl.colors.to_rgb(f'C{i}')", "quality_analysis": {"complexity_score": 9, "left_complexity": 6, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_976", "reponame": "seaborn", "testpath": "tests/test_utils.py", "testname": "test_utils.py", "classname": null, "funcname": "test_get_color_cycle", "imports": ["import re", "import tempfile", "from types import ModuleType", "from urllib.request import urlopen", "from http.client import HTTPException", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from cycler import cycler", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal, assert_frame_equal", "from seaborn import utils, rcmod, scatterplot", "from seaborn.utils import get_dataset_names, get_color_cycle, remove_na, load_dataset, _assign_default_kwargs, _check_argument, _draw_figure, _deprecate_ci, _version_predates, DATASET_NAMES_URL", "from seaborn._compat import get_legend_handles"], "code": "@pytest.mark.parametrize('cycler,result', [(cycler(color=['y']), ['y']), (cycler(color=['k']), ['k']), (cycler(color=['k', 'y']), ['k', 'y']), (cycler(color=['y', 'k']), ['y', 'k']), (cycler(color=['b', 'r']), ['b', 'r']), (cycler(color=['r', 'b']), ['r', 'b']), (cycler(lw=[1, 2]), ['.15'])])\ndef test_get_color_cycle(cycler, result):\n    with mpl.rc_context(rc={'axes.prop_cycle': cycler}):\n        assert (get_color_cycle() == result)", "masked_code": "@pytest.mark.parametrize('cycler,result', [(cycler(color=['y']), ['y']), (cycler(color=['k']), ['k']), (cycler(color=['k', 'y']), ['k', 'y']), (cycler(color=['y', 'k']), ['y', 'k']), (cycler(color=['b', 'r']), ['b', 'r']), (cycler(color=['r', 'b']), ['r', 'b']), (cycler(lw=[1, 2]), ['.15'])])\ndef test_get_color_cycle(cycler, result):\n    with mpl.rc_context(rc={'axes.prop_cycle': cycler}):\n        assert (get_color_cycle() == '???')", "ground_truth": "result", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_977", "reponame": "seaborn", "testpath": "tests/test_utils.py", "testname": "test_utils.py", "classname": null, "funcname": "test_check_argument", "imports": ["import re", "import tempfile", "from types import ModuleType", "from urllib.request import urlopen", "from http.client import HTTPException", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from cycler import cycler", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal, assert_frame_equal", "from seaborn import utils, rcmod, scatterplot", "from seaborn.utils import get_dataset_names, get_color_cycle, remove_na, load_dataset, _assign_default_kwargs, _check_argument, _draw_figure, _deprecate_ci, _version_predates, DATASET_NAMES_URL", "from seaborn._compat import get_legend_handles"], "code": "def test_check_argument():\n    opts = ['a', 'b', None]\n    assert (_check_argument('arg', opts, 'a') == 'a')\n    assert (_check_argument('arg', opts, None) is None)\n    assert (_check_argument('arg', opts, 'aa', prefix=True) == 'aa')\n    assert (_check_argument('arg', opts, None, prefix=True) is None)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c')\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c', prefix=True)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:(- 1)], None)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:(- 1)], None, prefix=True)", "masked_code": "def test_check_argument():\n    opts = ['a', 'b', None]\n    assert (_check_argument('arg', opts, 'a') == 'a')\n    assert (_check_argument('arg', opts, None) is None)\n    assert (_check_argument('arg', opts, 'aa', prefix=True) == '???')\n    assert (_check_argument('arg', opts, None, prefix=True) is None)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c')\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c', prefix=True)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:(- 1)], None)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:(- 1)], None, prefix=True)", "ground_truth": "'aa'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_978", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_named_vectors", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_named_vectors(self, long_df, long_variables):\n    p = PlotData(long_df, long_variables)\n    assert (p.source_data is long_df)\n    assert (p.source_vars is long_variables)\n    for (key, val) in long_variables.items():\n        assert (p.names[key] == val)\n        assert_vector_equal(p.frame[key], long_df[val])", "masked_code": "def test_named_vectors(self, long_df, long_variables):\n    p = PlotData(long_df, long_variables)\n    assert (p.source_data is long_df)\n    assert (p.source_vars is long_variables)\n    for (key, val) in long_variables.items():\n        assert (p.names[key] == '???')\n        assert_vector_equal(p.frame[key], long_df[val])", "ground_truth": "val", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_979", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_named_and_given_vectors", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_named_and_given_vectors(self, long_df, long_variables):\n    long_variables['y'] = long_df['b']\n    long_variables['size'] = long_df['z'].to_numpy()\n    p = PlotData(long_df, long_variables)\n    assert_vector_equal(p.frame['color'], long_df[long_variables['color']])\n    assert_vector_equal(p.frame['y'], long_df['b'])\n    assert_vector_equal(p.frame['size'], long_df['z'])\n    assert (p.names['color'] == long_variables['color'])\n    assert (p.names['y'] == 'b')\n    assert (p.names['size'] is None)\n    assert (p.ids['color'] == long_variables['color'])\n    assert (p.ids['y'] == 'b')\n    assert (p.ids['size'] == id(long_variables['size']))", "masked_code": "def test_named_and_given_vectors(self, long_df, long_variables):\n    long_variables['y'] = long_df['b']\n    long_variables['size'] = long_df['z'].to_numpy()\n    p = PlotData(long_df, long_variables)\n    assert_vector_equal(p.frame['color'], long_df[long_variables['color']])\n    assert_vector_equal(p.frame['y'], long_df['b'])\n    assert_vector_equal(p.frame['size'], long_df['z'])\n    assert (p.names['color'] == '???')\n    assert (p.names['y'] == 'b')\n    assert (p.names['size'] is None)\n    assert (p.ids['color'] == long_variables['color'])\n    assert (p.ids['y'] == 'b')\n    assert (p.ids['size'] == id(long_variables['size']))", "ground_truth": "long_variables['color']", "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_980", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_named_and_given_vectors", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_named_and_given_vectors(self, long_df, long_variables):\n    long_variables['y'] = long_df['b']\n    long_variables['size'] = long_df['z'].to_numpy()\n    p = PlotData(long_df, long_variables)\n    assert_vector_equal(p.frame['color'], long_df[long_variables['color']])\n    assert_vector_equal(p.frame['y'], long_df['b'])\n    assert_vector_equal(p.frame['size'], long_df['z'])\n    assert (p.names['color'] == long_variables['color'])\n    assert (p.names['y'] == 'b')\n    assert (p.names['size'] is None)\n    assert (p.ids['color'] == long_variables['color'])\n    assert (p.ids['y'] == 'b')\n    assert (p.ids['size'] == id(long_variables['size']))", "masked_code": "def test_named_and_given_vectors(self, long_df, long_variables):\n    long_variables['y'] = long_df['b']\n    long_variables['size'] = long_df['z'].to_numpy()\n    p = PlotData(long_df, long_variables)\n    assert_vector_equal(p.frame['color'], long_df[long_variables['color']])\n    assert_vector_equal(p.frame['y'], long_df['b'])\n    assert_vector_equal(p.frame['size'], long_df['z'])\n    assert (p.names['color'] == long_variables['color'])\n    assert (p.names['y'] == 'b')\n    assert (p.names['size'] is None)\n    assert (p.ids['color'] == '???')\n    assert (p.ids['y'] == 'b')\n    assert (p.ids['size'] == id(long_variables['size']))", "ground_truth": "long_variables['color']", "quality_analysis": {"complexity_score": 11, "left_complexity": 6, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_981", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_named_and_given_vectors", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_named_and_given_vectors(self, long_df, long_variables):\n    long_variables['y'] = long_df['b']\n    long_variables['size'] = long_df['z'].to_numpy()\n    p = PlotData(long_df, long_variables)\n    assert_vector_equal(p.frame['color'], long_df[long_variables['color']])\n    assert_vector_equal(p.frame['y'], long_df['b'])\n    assert_vector_equal(p.frame['size'], long_df['z'])\n    assert (p.names['color'] == long_variables['color'])\n    assert (p.names['y'] == 'b')\n    assert (p.names['size'] is None)\n    assert (p.ids['color'] == long_variables['color'])\n    assert (p.ids['y'] == 'b')\n    assert (p.ids['size'] == id(long_variables['size']))", "masked_code": "def test_named_and_given_vectors(self, long_df, long_variables):\n    long_variables['y'] = long_df['b']\n    long_variables['size'] = long_df['z'].to_numpy()\n    p = PlotData(long_df, long_variables)\n    assert_vector_equal(p.frame['color'], long_df[long_variables['color']])\n    assert_vector_equal(p.frame['y'], long_df['b'])\n    assert_vector_equal(p.frame['size'], long_df['z'])\n    assert (p.names['color'] == long_variables['color'])\n    assert (p.names['y'] == 'b')\n    assert (p.names['size'] is None)\n    assert (p.ids['color'] == long_variables['color'])\n    assert (p.ids['y'] == 'b')\n    assert (p.ids['size'] == '???')", "ground_truth": "id(long_variables['size'])", "quality_analysis": {"complexity_score": 14, "left_complexity": 6, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_982", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_index_as_variable", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_index_as_variable(self, long_df, long_variables):\n    index = pd.Index(((np.arange(len(long_df)) * 2) + 10), name='i', dtype=int)\n    long_variables['x'] = 'i'\n    p = PlotData(long_df.set_index(index), long_variables)\n    assert (p.names['x'] == p.ids['x'] == 'i')\n    assert_vector_equal(p.frame['x'], pd.Series(index, index))", "masked_code": "def test_index_as_variable(self, long_df, long_variables):\n    index = pd.Index(((np.arange(len(long_df)) * 2) + 10), name='i', dtype=int)\n    long_variables['x'] = 'i'\n    p = PlotData(long_df.set_index(index), long_variables)\n    assert (p.names['x'] == '???' == 'i')\n    assert_vector_equal(p.frame['x'], pd.Series(index, index))", "ground_truth": "p.ids['x']", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_983", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_int_as_variable_key", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_int_as_variable_key(self, rng):\n    df = pd.DataFrame(rng.uniform(size=(10, 3)))\n    var = 'x'\n    key = 2\n    p = PlotData(df, {var: key})\n    assert_vector_equal(p.frame[var], df[key])\n    assert (p.names[var] == p.ids[var] == str(key))", "masked_code": "def test_int_as_variable_key(self, rng):\n    df = pd.DataFrame(rng.uniform(size=(10, 3)))\n    var = 'x'\n    key = 2\n    p = PlotData(df, {var: key})\n    assert_vector_equal(p.frame[var], df[key])\n    assert (p.names[var] == '???' == str(key))", "ground_truth": "p.ids[var]", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_984", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_int_as_variable_value", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_int_as_variable_value(self, long_df):\n    p = PlotData(long_df, {'x': 0, 'y': 'y'})\n    assert (p.frame['x'] == 0).all()\n    assert (p.names['x'] is None)\n    assert (p.ids['x'] == id(0))", "masked_code": "def test_int_as_variable_value(self, long_df):\n    p = PlotData(long_df, {'x': 0, 'y': 'y'})\n    assert (p.frame['x'] == 0).all()\n    assert (p.names['x'] is None)\n    assert (p.ids['x'] == '???')", "ground_truth": "id(0)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_985", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_tuple_as_variable_key", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_tuple_as_variable_key(self, rng):\n    cols = pd.MultiIndex.from_product([('a', 'b', 'c'), ('x', 'y')])\n    df = pd.DataFrame(rng.uniform(size=(10, 6)), columns=cols)\n    var = 'color'\n    key = ('b', 'y')\n    p = PlotData(df, {var: key})\n    assert_vector_equal(p.frame[var], df[key])\n    assert (p.names[var] == p.ids[var] == str(key))", "masked_code": "def test_tuple_as_variable_key(self, rng):\n    cols = pd.MultiIndex.from_product([('a', 'b', 'c'), ('x', 'y')])\n    df = pd.DataFrame(rng.uniform(size=(10, 6)), columns=cols)\n    var = 'color'\n    key = ('b', 'y')\n    p = PlotData(df, {var: key})\n    assert_vector_equal(p.frame[var], df[key])\n    assert (p.names[var] == '???' == str(key))", "ground_truth": "p.ids[var]", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_986", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_vectors_various_types", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_vectors_various_types(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = PlotData(None, variables)\n    assert (list(p.names) == list(long_variables))\n    if (vector_type == 'series'):\n        assert (p.source_vars is variables)\n        assert (p.names == p.ids == {key: val.name for (key, val) in variables.items()})\n    else:\n        assert (p.names == {key: None for key in variables})\n        assert (p.ids == {key: id(val) for (key, val) in variables.items()})\n    for (key, val) in long_variables.items():\n        if (vector_type == 'series'):\n            assert_vector_equal(p.frame[key], long_df[val])\n        else:\n            assert_array_equal(p.frame[key], long_df[val])", "masked_code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_vectors_various_types(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = PlotData(None, variables)\n    assert (list(p.names) == '???')\n    if (vector_type == 'series'):\n        assert (p.source_vars is variables)\n        assert (p.names == p.ids == {key: val.name for (key, val) in variables.items()})\n    else:\n        assert (p.names == {key: None for key in variables})\n        assert (p.ids == {key: id(val) for (key, val) in variables.items()})\n    for (key, val) in long_variables.items():\n        if (vector_type == 'series'):\n            assert_vector_equal(p.frame[key], long_df[val])\n        else:\n            assert_array_equal(p.frame[key], long_df[val])", "ground_truth": "list(long_variables)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_987", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_vectors_various_types", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_vectors_various_types(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = PlotData(None, variables)\n    assert (list(p.names) == list(long_variables))\n    if (vector_type == 'series'):\n        assert (p.source_vars is variables)\n        assert (p.names == p.ids == {key: val.name for (key, val) in variables.items()})\n    else:\n        assert (p.names == {key: None for key in variables})\n        assert (p.ids == {key: id(val) for (key, val) in variables.items()})\n    for (key, val) in long_variables.items():\n        if (vector_type == 'series'):\n            assert_vector_equal(p.frame[key], long_df[val])\n        else:\n            assert_array_equal(p.frame[key], long_df[val])", "masked_code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_vectors_various_types(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = PlotData(None, variables)\n    assert (list(p.names) == list(long_variables))\n    if (vector_type == 'series'):\n        assert (p.source_vars is variables)\n        assert (p.names == '???' == {key: val.name for (key, val) in variables.items()})\n    else:\n        assert (p.names == {key: None for key in variables})\n        assert (p.ids == {key: id(val) for (key, val) in variables.items()})\n    for (key, val) in long_variables.items():\n        if (vector_type == 'series'):\n            assert_vector_equal(p.frame[key], long_df[val])\n        else:\n            assert_array_equal(p.frame[key], long_df[val])", "ground_truth": "p.ids", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_988", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_vectors_various_types", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_vectors_various_types(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = PlotData(None, variables)\n    assert (list(p.names) == list(long_variables))\n    if (vector_type == 'series'):\n        assert (p.source_vars is variables)\n        assert (p.names == p.ids == {key: val.name for (key, val) in variables.items()})\n    else:\n        assert (p.names == {key: None for key in variables})\n        assert (p.ids == {key: id(val) for (key, val) in variables.items()})\n    for (key, val) in long_variables.items():\n        if (vector_type == 'series'):\n            assert_vector_equal(p.frame[key], long_df[val])\n        else:\n            assert_array_equal(p.frame[key], long_df[val])", "masked_code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_vectors_various_types(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = PlotData(None, variables)\n    assert (list(p.names) == list(long_variables))\n    if (vector_type == 'series'):\n        assert (p.source_vars is variables)\n        assert (p.names == p.ids == {key: val.name for (key, val) in variables.items()})\n    else:\n        assert (p.names == '???')\n        assert (p.ids == {key: id(val) for (key, val) in variables.items()})\n    for (key, val) in long_variables.items():\n        if (vector_type == 'series'):\n            assert_vector_equal(p.frame[key], long_df[val])\n        else:\n            assert_array_equal(p.frame[key], long_df[val])", "ground_truth": "{key: None for key in variables}", "quality_analysis": {"complexity_score": 2, "left_complexity": 2, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_989", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_vectors_various_types", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_vectors_various_types(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = PlotData(None, variables)\n    assert (list(p.names) == list(long_variables))\n    if (vector_type == 'series'):\n        assert (p.source_vars is variables)\n        assert (p.names == p.ids == {key: val.name for (key, val) in variables.items()})\n    else:\n        assert (p.names == {key: None for key in variables})\n        assert (p.ids == {key: id(val) for (key, val) in variables.items()})\n    for (key, val) in long_variables.items():\n        if (vector_type == 'series'):\n            assert_vector_equal(p.frame[key], long_df[val])\n        else:\n            assert_array_equal(p.frame[key], long_df[val])", "masked_code": "@pytest.mark.parametrize('vector_type', ['series', 'numpy', 'list'])\ndef test_vectors_various_types(self, long_df, long_variables, vector_type):\n    variables = {key: long_df[val] for (key, val) in long_variables.items()}\n    if (vector_type == 'numpy'):\n        variables = {key: val.to_numpy() for (key, val) in variables.items()}\n    elif (vector_type == 'list'):\n        variables = {key: val.to_list() for (key, val) in variables.items()}\n    p = PlotData(None, variables)\n    assert (list(p.names) == list(long_variables))\n    if (vector_type == 'series'):\n        assert (p.source_vars is variables)\n        assert (p.names == p.ids == {key: val.name for (key, val) in variables.items()})\n    else:\n        assert (p.names == {key: None for key in variables})\n        assert (p.ids == '???')\n    for (key, val) in long_variables.items():\n        if (vector_type == 'series'):\n            assert_vector_equal(p.frame[key], long_df[val])\n        else:\n            assert_array_equal(p.frame[key], long_df[val])", "ground_truth": "{key: id(val) for (key, val) in variables.items()}", "quality_analysis": {"complexity_score": 2, "left_complexity": 2, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_990", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_none_as_variable_value", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_none_as_variable_value(self, long_df):\n    p = PlotData(long_df, {'x': 'z', 'y': None})\n    assert (list(p.frame.columns) == ['x'])\n    assert (p.names == p.ids == {'x': 'z'})", "masked_code": "def test_none_as_variable_value(self, long_df):\n    p = PlotData(long_df, {'x': 'z', 'y': None})\n    assert (list(p.frame.columns) == '???')\n    assert (p.names == p.ids == {'x': 'z'})", "ground_truth": "['x']", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_991", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_none_as_variable_value", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_none_as_variable_value(self, long_df):\n    p = PlotData(long_df, {'x': 'z', 'y': None})\n    assert (list(p.frame.columns) == ['x'])\n    assert (p.names == p.ids == {'x': 'z'})", "masked_code": "def test_none_as_variable_value(self, long_df):\n    p = PlotData(long_df, {'x': 'z', 'y': None})\n    assert (list(p.frame.columns) == ['x'])\n    assert (p.names == '???' == {'x': 'z'})", "ground_truth": "p.ids", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_992", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_join_add_variable", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_join_add_variable(self, long_df):\n    v1 = {'x': 'x', 'y': 'f'}\n    v2 = {'color': 'a'}\n    p1 = PlotData(long_df, v1)\n    p2 = p1.join(None, v2)\n    for (var, key) in dict(**v1, **v2).items():\n        assert (var in p2)\n        assert (p2.names[var] == key)\n        assert_vector_equal(p2.frame[var], long_df[key])", "masked_code": "def test_join_add_variable(self, long_df):\n    v1 = {'x': 'x', 'y': 'f'}\n    v2 = {'color': 'a'}\n    p1 = PlotData(long_df, v1)\n    p2 = p1.join(None, v2)\n    for (var, key) in dict(**v1, **v2).items():\n        assert (var in p2)\n        assert (p2.names[var] == '???')\n        assert_vector_equal(p2.frame[var], long_df[key])", "ground_truth": "key", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_993", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_join_replace_variable", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_join_replace_variable(self, long_df):\n    v1 = {'x': 'x', 'y': 'y'}\n    v2 = {'y': 's'}\n    p1 = PlotData(long_df, v1)\n    p2 = p1.join(None, v2)\n    variables = v1.copy()\n    variables.update(v2)\n    for (var, key) in variables.items():\n        assert (var in p2)\n        assert (p2.names[var] == key)\n        assert_vector_equal(p2.frame[var], long_df[key])", "masked_code": "def test_join_replace_variable(self, long_df):\n    v1 = {'x': 'x', 'y': 'y'}\n    v2 = {'y': 's'}\n    p1 = PlotData(long_df, v1)\n    p2 = p1.join(None, v2)\n    variables = v1.copy()\n    variables.update(v2)\n    for (var, key) in variables.items():\n        assert (var in p2)\n        assert (p2.names[var] == '???')\n        assert_vector_equal(p2.frame[var], long_df[key])", "ground_truth": "key", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_994", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_join_all_operations", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_join_all_operations(self, long_df):\n    v1 = {'x': 'x', 'y': 'y', 'color': 'a'}\n    v2 = {'y': 's', 'size': 's', 'color': None}\n    p1 = PlotData(long_df, v1)\n    p2 = p1.join(None, v2)\n    for (var, key) in v2.items():\n        if (key is None):\n            assert (var not in p2)\n        else:\n            assert (p2.names[var] == key)\n            assert_vector_equal(p2.frame[var], long_df[key])", "masked_code": "def test_join_all_operations(self, long_df):\n    v1 = {'x': 'x', 'y': 'y', 'color': 'a'}\n    v2 = {'y': 's', 'size': 's', 'color': None}\n    p1 = PlotData(long_df, v1)\n    p2 = p1.join(None, v2)\n    for (var, key) in v2.items():\n        if (key is None):\n            assert (var not in p2)\n        else:\n            assert (p2.names[var] == '???')\n            assert_vector_equal(p2.frame[var], long_df[key])", "ground_truth": "key", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_995", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_join_all_operations_same_data", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_join_all_operations_same_data(self, long_df):\n    v1 = {'x': 'x', 'y': 'y', 'color': 'a'}\n    v2 = {'y': 's', 'size': 's', 'color': None}\n    p1 = PlotData(long_df, v1)\n    p2 = p1.join(long_df, v2)\n    for (var, key) in v2.items():\n        if (key is None):\n            assert (var not in p2)\n        else:\n            assert (p2.names[var] == key)\n            assert_vector_equal(p2.frame[var], long_df[key])", "masked_code": "def test_join_all_operations_same_data(self, long_df):\n    v1 = {'x': 'x', 'y': 'y', 'color': 'a'}\n    v2 = {'y': 's', 'size': 's', 'color': None}\n    p1 = PlotData(long_df, v1)\n    p2 = p1.join(long_df, v2)\n    for (var, key) in v2.items():\n        if (key is None):\n            assert (var not in p2)\n        else:\n            assert (p2.names[var] == '???')\n            assert_vector_equal(p2.frame[var], long_df[key])", "ground_truth": "key", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_996", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_join_add_variable_new_data", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_join_add_variable_new_data(self, long_df):\n    d1 = long_df[['x', 'y']]\n    d2 = long_df[['a', 's']]\n    v1 = {'x': 'x', 'y': 'y'}\n    v2 = {'color': 'a'}\n    p1 = PlotData(d1, v1)\n    p2 = p1.join(d2, v2)\n    for (var, key) in dict(**v1, **v2).items():\n        assert (p2.names[var] == key)\n        assert_vector_equal(p2.frame[var], long_df[key])", "masked_code": "def test_join_add_variable_new_data(self, long_df):\n    d1 = long_df[['x', 'y']]\n    d2 = long_df[['a', 's']]\n    v1 = {'x': 'x', 'y': 'y'}\n    v2 = {'color': 'a'}\n    p1 = PlotData(d1, v1)\n    p2 = p1.join(d2, v2)\n    for (var, key) in dict(**v1, **v2).items():\n        assert (p2.names[var] == '???')\n        assert_vector_equal(p2.frame[var], long_df[key])", "ground_truth": "key", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_997", "reponame": "seaborn", "testpath": "tests/_core/test_data.py", "testname": "test_data.py", "classname": "TestPlotData", "funcname": "test_join_replace_variable_new_data", "imports": ["import functools", "import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.data import PlotData"], "code": "def test_join_replace_variable_new_data(self, long_df):\n    d1 = long_df[['x', 'y']]\n    d2 = long_df[['a', 's']]\n    v1 = {'x': 'x', 'y': 'y'}\n    v2 = {'x': 'a'}\n    p1 = PlotData(d1, v1)\n    p2 = p1.join(d2, v2)\n    variables = v1.copy()\n    variables.update(v2)\n    for (var, key) in variables.items():\n        assert (p2.names[var] == key)\n        assert_vector_equal(p2.frame[var], long_df[key])", "masked_code": "def test_join_replace_variable_new_data(self, long_df):\n    d1 = long_df[['x', 'y']]\n    d2 = long_df[['a', 's']]\n    v1 = {'x': 'x', 'y': 'y'}\n    v2 = {'x': 'a'}\n    p1 = PlotData(d1, v1)\n    p2 = p1.join(d2, v2)\n    variables = v1.copy()\n    variables.update(v2)\n    for (var, key) in variables.items():\n        assert (p2.names[var] == '???')\n        assert_vector_equal(p2.frame[var], long_df[key])", "ground_truth": "key", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_998", "reponame": "seaborn", "testpath": "tests/_core/test_groupby.py", "testname": "test_groupby.py", "classname": null, "funcname": "test_init_from_list", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy"], "code": "def test_init_from_list():\n    g = GroupBy(['a', 'c', 'b'])\n    assert (g.order == {'a': None, 'c': None, 'b': None})", "masked_code": "def test_init_from_list():\n    g = GroupBy(['a', 'c', 'b'])\n    assert (g.order == '???')", "ground_truth": "{'a': None, 'c': None, 'b': None}", "quality_analysis": {"complexity_score": 11, "left_complexity": 2, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_999", "reponame": "seaborn", "testpath": "tests/_core/test_groupby.py", "testname": "test_groupby.py", "classname": null, "funcname": "test_init_from_dict", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy"], "code": "def test_init_from_dict():\n    order = {'a': [3, 2, 1], 'c': None, 'b': ['x', 'y', 'z']}\n    g = GroupBy(order)\n    assert (g.order == order)", "masked_code": "def test_init_from_dict():\n    order = {'a': [3, 2, 1], 'c': None, 'b': ['x', 'y', 'z']}\n    g = GroupBy(order)\n    assert (g.order == '???')", "ground_truth": "order", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1000", "reponame": "seaborn", "testpath": "tests/_core/test_moves.py", "testname": "test_moves.py", "classname": "TestNorm", "funcname": "test_default_no_groups", "imports": ["from itertools import product", "import numpy as np", "import pandas as pd", "from pandas.testing import assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.moves import Dodge, Jitter, Shift, Stack, Norm", "from seaborn._core.rules import categorical_order", "from seaborn._core.groupby import GroupBy", "import pytest"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_default_no_groups(self, df, orient):\n    other = {'x': 'y', 'y': 'x'}[orient]\n    gb = GroupBy(['null'])\n    res = Norm()(df, gb, orient, {})\n    assert (res[other].max() == pytest.approx(1))", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_default_no_groups(self, df, orient):\n    other = {'x': 'y', 'y': 'x'}[orient]\n    gb = GroupBy(['null'])\n    res = Norm()(df, gb, orient, {})\n    assert (res[other].max() == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1001", "reponame": "seaborn", "testpath": "tests/_core/test_moves.py", "testname": "test_moves.py", "classname": "TestNorm", "funcname": "test_default_groups", "imports": ["from itertools import product", "import numpy as np", "import pandas as pd", "from pandas.testing import assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.moves import Dodge, Jitter, Shift, Stack, Norm", "from seaborn._core.rules import categorical_order", "from seaborn._core.groupby import GroupBy", "import pytest"], "code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_default_groups(self, df, orient):\n    other = {'x': 'y', 'y': 'x'}[orient]\n    gb = GroupBy(['grp2'])\n    res = Norm()(df, gb, orient, {})\n    for (_, grp) in res.groupby('grp2'):\n        assert (grp[other].max() == pytest.approx(1))", "masked_code": "@pytest.mark.parametrize('orient', ['x', 'y'])\ndef test_default_groups(self, df, orient):\n    other = {'x': 'y', 'y': 'x'}[orient]\n    gb = GroupBy(['grp2'])\n    res = Norm()(df, gb, orient, {})\n    for (_, grp) in res.groupby('grp2'):\n        assert (grp[other].max() == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1002", "reponame": "seaborn", "testpath": "tests/_core/test_moves.py", "testname": "test_moves.py", "classname": "TestNorm", "funcname": "test_sum", "imports": ["from itertools import product", "import numpy as np", "import pandas as pd", "from pandas.testing import assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.moves import Dodge, Jitter, Shift, Stack, Norm", "from seaborn._core.rules import categorical_order", "from seaborn._core.groupby import GroupBy", "import pytest"], "code": "def test_sum(self, df):\n    gb = GroupBy(['null'])\n    res = Norm('sum')(df, gb, 'x', {})\n    assert (res['y'].sum() == pytest.approx(1))", "masked_code": "def test_sum(self, df):\n    gb = GroupBy(['null'])\n    res = Norm('sum')(df, gb, 'x', {})\n    assert (res['y'].sum() == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1003", "reponame": "seaborn", "testpath": "tests/_core/test_moves.py", "testname": "test_moves.py", "classname": "TestNorm", "funcname": "test_where", "imports": ["from itertools import product", "import numpy as np", "import pandas as pd", "from pandas.testing import assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.moves import Dodge, Jitter, Shift, Stack, Norm", "from seaborn._core.rules import categorical_order", "from seaborn._core.groupby import GroupBy", "import pytest"], "code": "def test_where(self, df):\n    gb = GroupBy(['null'])\n    res = Norm(where='x == 2')(df, gb, 'x', {})\n    assert (res.loc[((res['x'] == 2), 'y')].max() == pytest.approx(1))", "masked_code": "def test_where(self, df):\n    gb = GroupBy(['null'])\n    res = Norm(where='x == 2')(df, gb, 'x', {})\n    assert (res.loc[((res['x'] == 2), 'y')].max() == '???')", "ground_truth": "pytest.approx(1)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1004", "reponame": "seaborn", "testpath": "tests/_core/test_moves.py", "testname": "test_moves.py", "classname": "TestNorm", "funcname": "test_percent", "imports": ["from itertools import product", "import numpy as np", "import pandas as pd", "from pandas.testing import assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.moves import Dodge, Jitter, Shift, Stack, Norm", "from seaborn._core.rules import categorical_order", "from seaborn._core.groupby import GroupBy", "import pytest"], "code": "def test_percent(self, df):\n    gb = GroupBy(['null'])\n    res = Norm(percent=True)(df, gb, 'x', {})\n    assert (res['y'].max() == pytest.approx(100))", "masked_code": "def test_percent(self, df):\n    gb = GroupBy(['null'])\n    res = Norm(percent=True)(df, gb, 'x', {})\n    assert (res['y'].max() == '???')", "ground_truth": "pytest.approx(100)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1005", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestInit", "funcname": "test_empty", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_empty(self):\n    p = Plot()\n    assert (p._data.source_data is None)\n    assert (p._data.source_vars == {})", "masked_code": "def test_empty(self):\n    p = Plot()\n    assert (p._data.source_data is None)\n    assert (p._data.source_vars == '???')", "ground_truth": "{}", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1006", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestInit", "funcname": "test_data_only", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_data_only(self, long_df):\n    p = Plot(long_df)\n    assert (p._data.source_data is long_df)\n    assert (p._data.source_vars == {})", "masked_code": "def test_data_only(self, long_df):\n    p = Plot(long_df)\n    assert (p._data.source_data is long_df)\n    assert (p._data.source_vars == '???')", "ground_truth": "{}", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1007", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestInit", "funcname": "test_df_and_named_variables", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_df_and_named_variables(self, long_df):\n    variables = {'x': 'a', 'y': 'z'}\n    p = Plot(long_df, **variables)\n    for (var, col) in variables.items():\n        assert_vector_equal(p._data.frame[var], long_df[col])\n    assert (p._data.source_data is long_df)\n    assert (p._data.source_vars.keys() == variables.keys())", "masked_code": "def test_df_and_named_variables(self, long_df):\n    variables = {'x': 'a', 'y': 'z'}\n    p = Plot(long_df, **variables)\n    for (var, col) in variables.items():\n        assert_vector_equal(p._data.frame[var], long_df[col])\n    assert (p._data.source_data is long_df)\n    assert (p._data.source_vars.keys() == '???')", "ground_truth": "variables.keys()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1008", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestInit", "funcname": "test_df_and_mixed_variables", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_df_and_mixed_variables(self, long_df):\n    variables = {'x': 'a', 'y': long_df['z']}\n    p = Plot(long_df, **variables)\n    for (var, col) in variables.items():\n        if isinstance(col, str):\n            assert_vector_equal(p._data.frame[var], long_df[col])\n        else:\n            assert_vector_equal(p._data.frame[var], col)\n    assert (p._data.source_data is long_df)\n    assert (p._data.source_vars.keys() == variables.keys())", "masked_code": "def test_df_and_mixed_variables(self, long_df):\n    variables = {'x': 'a', 'y': long_df['z']}\n    p = Plot(long_df, **variables)\n    for (var, col) in variables.items():\n        if isinstance(col, str):\n            assert_vector_equal(p._data.frame[var], long_df[col])\n        else:\n            assert_vector_equal(p._data.frame[var], col)\n    assert (p._data.source_data is long_df)\n    assert (p._data.source_vars.keys() == '???')", "ground_truth": "variables.keys()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1009", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestInit", "funcname": "test_vector_variables_only", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_vector_variables_only(self, long_df):\n    variables = {'x': long_df['a'], 'y': long_df['z']}\n    p = Plot(**variables)\n    for (var, col) in variables.items():\n        assert_vector_equal(p._data.frame[var], col)\n    assert (p._data.source_data is None)\n    assert (p._data.source_vars.keys() == variables.keys())", "masked_code": "def test_vector_variables_only(self, long_df):\n    variables = {'x': long_df['a'], 'y': long_df['z']}\n    p = Plot(**variables)\n    for (var, col) in variables.items():\n        assert_vector_equal(p._data.frame[var], col)\n    assert (p._data.source_data is None)\n    assert (p._data.source_vars.keys() == '???')", "ground_truth": "variables.keys()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1010", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestInit", "funcname": "test_vector_variables_no_index", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_vector_variables_no_index(self, long_df):\n    variables = {'x': long_df['a'].to_numpy(), 'y': long_df['z'].to_list()}\n    p = Plot(**variables)\n    for (var, col) in variables.items():\n        assert_vector_equal(p._data.frame[var], pd.Series(col))\n        assert (p._data.names[var] is None)\n    assert (p._data.source_data is None)\n    assert (p._data.source_vars.keys() == variables.keys())", "masked_code": "def test_vector_variables_no_index(self, long_df):\n    variables = {'x': long_df['a'].to_numpy(), 'y': long_df['z'].to_list()}\n    p = Plot(**variables)\n    for (var, col) in variables.items():\n        assert_vector_equal(p._data.frame[var], pd.Series(col))\n        assert (p._data.names[var] is None)\n    assert (p._data.source_data is None)\n    assert (p._data.source_vars.keys() == '???')", "ground_truth": "variables.keys()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1011", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestInit", "funcname": "test_data_only_named", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_data_only_named(self, long_df):\n    p = Plot(data=long_df)\n    assert (p._data.source_data is long_df)\n    assert (p._data.source_vars == {})", "masked_code": "def test_data_only_named(self, long_df):\n    p = Plot(data=long_df)\n    assert (p._data.source_data is long_df)\n    assert (p._data.source_vars == '???')", "ground_truth": "{}", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1012", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestInit", "funcname": "test_positional_data_x_y", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_positional_data_x_y(self, long_df):\n    p = Plot(long_df, 'a', 'b')\n    assert (p._data.source_data is long_df)\n    assert (list(p._data.source_vars) == ['x', 'y'])", "masked_code": "def test_positional_data_x_y(self, long_df):\n    p = Plot(long_df, 'a', 'b')\n    assert (p._data.source_data is long_df)\n    assert (list(p._data.source_vars) == '???')", "ground_truth": "['x', 'y']", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1013", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestInit", "funcname": "test_positional_x_y", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_positional_x_y(self, long_df):\n    p = Plot(long_df['a'], long_df['b'])\n    assert (p._data.source_data is None)\n    assert (list(p._data.source_vars) == ['x', 'y'])", "masked_code": "def test_positional_x_y(self, long_df):\n    p = Plot(long_df['a'], long_df['b'])\n    assert (p._data.source_data is None)\n    assert (list(p._data.source_vars) == '???')", "ground_truth": "['x', 'y']", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1014", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestInit", "funcname": "test_positional_data_x", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_positional_data_x(self, long_df):\n    p = Plot(long_df, 'a')\n    assert (p._data.source_data is long_df)\n    assert (list(p._data.source_vars) == ['x'])", "masked_code": "def test_positional_data_x(self, long_df):\n    p = Plot(long_df, 'a')\n    assert (p._data.source_data is long_df)\n    assert (list(p._data.source_vars) == '???')", "ground_truth": "['x']", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1015", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestInit", "funcname": "test_positional_x", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_positional_x(self, long_df):\n    p = Plot(long_df['a'])\n    assert (p._data.source_data is None)\n    assert (list(p._data.source_vars) == ['x'])", "masked_code": "def test_positional_x(self, long_df):\n    p = Plot(long_df['a'])\n    assert (p._data.source_data is None)\n    assert (list(p._data.source_vars) == '???')", "ground_truth": "['x']", "quality_analysis": {"complexity_score": 8, "left_complexity": 5, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1016", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLayerAddition", "funcname": "test_with_new_variable_by_name", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_with_new_variable_by_name(self, long_df):\n    p = Plot(long_df, x='x').add(MockMark(), y='y').plot()\n    (layer,) = p._layers\n    assert (layer['data'].frame.columns.to_list() == ['x', 'y'])\n    for var in 'xy':\n        assert_vector_equal(layer['data'].frame[var], long_df[var])", "masked_code": "def test_with_new_variable_by_name(self, long_df):\n    p = Plot(long_df, x='x').add(MockMark(), y='y').plot()\n    (layer,) = p._layers\n    assert (layer['data'].frame.columns.to_list() == '???')\n    for var in 'xy':\n        assert_vector_equal(layer['data'].frame[var], long_df[var])", "ground_truth": "['x', 'y']", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1017", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLayerAddition", "funcname": "test_with_new_variable_by_vector", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_with_new_variable_by_vector(self, long_df):\n    p = Plot(long_df, x='x').add(MockMark(), y=long_df['y']).plot()\n    (layer,) = p._layers\n    assert (layer['data'].frame.columns.to_list() == ['x', 'y'])\n    for var in 'xy':\n        assert_vector_equal(layer['data'].frame[var], long_df[var])", "masked_code": "def test_with_new_variable_by_vector(self, long_df):\n    p = Plot(long_df, x='x').add(MockMark(), y=long_df['y']).plot()\n    (layer,) = p._layers\n    assert (layer['data'].frame.columns.to_list() == '???')\n    for var in 'xy':\n        assert_vector_equal(layer['data'].frame[var], long_df[var])", "ground_truth": "['x', 'y']", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1018", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLayerAddition", "funcname": "test_with_late_data_definition", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_with_late_data_definition(self, long_df):\n    p = Plot().add(MockMark(), data=long_df, x='x', y='y').plot()\n    (layer,) = p._layers\n    assert (layer['data'].frame.columns.to_list() == ['x', 'y'])\n    for var in 'xy':\n        assert_vector_equal(layer['data'].frame[var], long_df[var])", "masked_code": "def test_with_late_data_definition(self, long_df):\n    p = Plot().add(MockMark(), data=long_df, x='x', y='y').plot()\n    (layer,) = p._layers\n    assert (layer['data'].frame.columns.to_list() == '???')\n    for var in 'xy':\n        assert_vector_equal(layer['data'].frame[var], long_df[var])", "ground_truth": "['x', 'y']", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1019", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLayerAddition", "funcname": "test_with_new_data_definition", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_with_new_data_definition(self, long_df):\n    long_df_sub = long_df.sample(frac=0.5)\n    p = Plot(long_df, x='x', y='y').add(MockMark(), data=long_df_sub).plot()\n    (layer,) = p._layers\n    assert (layer['data'].frame.columns.to_list() == ['x', 'y'])\n    for var in 'xy':\n        assert_vector_equal(layer['data'].frame[var], long_df_sub[var].reindex(long_df.index))", "masked_code": "def test_with_new_data_definition(self, long_df):\n    long_df_sub = long_df.sample(frac=0.5)\n    p = Plot(long_df, x='x', y='y').add(MockMark(), data=long_df_sub).plot()\n    (layer,) = p._layers\n    assert (layer['data'].frame.columns.to_list() == '???')\n    for var in 'xy':\n        assert_vector_equal(layer['data'].frame[var], long_df_sub[var].reindex(long_df.index))", "ground_truth": "['x', 'y']", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1020", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLayerAddition", "funcname": "test_drop_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_drop_variable(self, long_df):\n    p = Plot(long_df, x='x', y='y').add(MockMark(), y=None).plot()\n    (layer,) = p._layers\n    assert (layer['data'].frame.columns.to_list() == ['x'])\n    assert_vector_equal(layer['data'].frame['x'], long_df['x'], check_dtype=False)", "masked_code": "def test_drop_variable(self, long_df):\n    p = Plot(long_df, x='x', y='y').add(MockMark(), y=None).plot()\n    (layer,) = p._layers\n    assert (layer['data'].frame.columns.to_list() == '???')\n    assert_vector_equal(layer['data'].frame['x'], long_df['x'], check_dtype=False)", "ground_truth": "['x']", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1021", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLayerAddition", "funcname": "test_orient", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "@pytest.mark.parametrize('arg,expected', [('x', 'x'), ('y', 'y'), ('v', 'x'), ('h', 'y')])\ndef test_orient(self, arg, expected):\n\n    class MockStatTrackOrient(Stat):\n\n        def __call__(self, data, groupby, orient, scales):\n            self.orient_at_call = orient\n            return data\n\n    class MockMoveTrackOrient(Move):\n\n        def __call__(self, data, groupby, orient, scales):\n            self.orient_at_call = orient\n            return data\n    s = MockStatTrackOrient()\n    m = MockMoveTrackOrient()\n    Plot(x=[1, 2, 3], y=[1, 2, 3]).add(MockMark(), s, m, orient=arg).plot()\n    assert (s.orient_at_call == expected)\n    assert (m.orient_at_call == expected)", "masked_code": "@pytest.mark.parametrize('arg,expected', [('x', 'x'), ('y', 'y'), ('v', 'x'), ('h', 'y')])\ndef test_orient(self, arg, expected):\n\n    class MockStatTrackOrient(Stat):\n\n        def __call__(self, data, groupby, orient, scales):\n            self.orient_at_call = orient\n            return data\n\n    class MockMoveTrackOrient(Move):\n\n        def __call__(self, data, groupby, orient, scales):\n            self.orient_at_call = orient\n            return data\n    s = MockStatTrackOrient()\n    m = MockMoveTrackOrient()\n    Plot(x=[1, 2, 3], y=[1, 2, 3]).add(MockMark(), s, m, orient=arg).plot()\n    assert (s.orient_at_call == '???')\n    assert (m.orient_at_call == expected)", "ground_truth": "expected", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1022", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLayerAddition", "funcname": "test_orient", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "@pytest.mark.parametrize('arg,expected', [('x', 'x'), ('y', 'y'), ('v', 'x'), ('h', 'y')])\ndef test_orient(self, arg, expected):\n\n    class MockStatTrackOrient(Stat):\n\n        def __call__(self, data, groupby, orient, scales):\n            self.orient_at_call = orient\n            return data\n\n    class MockMoveTrackOrient(Move):\n\n        def __call__(self, data, groupby, orient, scales):\n            self.orient_at_call = orient\n            return data\n    s = MockStatTrackOrient()\n    m = MockMoveTrackOrient()\n    Plot(x=[1, 2, 3], y=[1, 2, 3]).add(MockMark(), s, m, orient=arg).plot()\n    assert (s.orient_at_call == expected)\n    assert (m.orient_at_call == expected)", "masked_code": "@pytest.mark.parametrize('arg,expected', [('x', 'x'), ('y', 'y'), ('v', 'x'), ('h', 'y')])\ndef test_orient(self, arg, expected):\n\n    class MockStatTrackOrient(Stat):\n\n        def __call__(self, data, groupby, orient, scales):\n            self.orient_at_call = orient\n            return data\n\n    class MockMoveTrackOrient(Move):\n\n        def __call__(self, data, groupby, orient, scales):\n            self.orient_at_call = orient\n            return data\n    s = MockStatTrackOrient()\n    m = MockMoveTrackOrient()\n    Plot(x=[1, 2, 3], y=[1, 2, 3]).add(MockMark(), s, m, orient=arg).plot()\n    assert (s.orient_at_call == expected)\n    assert (m.orient_at_call == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1023", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLayerAddition", "funcname": "test_variable_list", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_variable_list(self, long_df):\n    p = Plot(long_df, x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df).add(MockMark(), x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df, y='x', color='a').add(MockMark(), x='y')\n    assert (p._variables == ['y', 'color', 'x'])\n    p = Plot(long_df, x='x', y='y', color='a').add(MockMark(), color=None)\n    assert (p._variables == ['x', 'y', 'color'])\n    p = Plot(long_df, x='x', y='y').add(MockMark(), color='a').add(MockMark(), alpha='s')\n    assert (p._variables == ['x', 'y', 'color', 'alpha'])\n    p = Plot(long_df, y='x').pair(x=['a', 'b'])\n    assert (p._variables == ['y', 'x0', 'x1'])", "masked_code": "def test_variable_list(self, long_df):\n    p = Plot(long_df, x='x', y='y')\n    assert (p._variables == '???')\n    p = Plot(long_df).add(MockMark(), x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df, y='x', color='a').add(MockMark(), x='y')\n    assert (p._variables == ['y', 'color', 'x'])\n    p = Plot(long_df, x='x', y='y', color='a').add(MockMark(), color=None)\n    assert (p._variables == ['x', 'y', 'color'])\n    p = Plot(long_df, x='x', y='y').add(MockMark(), color='a').add(MockMark(), alpha='s')\n    assert (p._variables == ['x', 'y', 'color', 'alpha'])\n    p = Plot(long_df, y='x').pair(x=['a', 'b'])\n    assert (p._variables == ['y', 'x0', 'x1'])", "ground_truth": "['x', 'y']", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1024", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLayerAddition", "funcname": "test_variable_list", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_variable_list(self, long_df):\n    p = Plot(long_df, x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df).add(MockMark(), x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df, y='x', color='a').add(MockMark(), x='y')\n    assert (p._variables == ['y', 'color', 'x'])\n    p = Plot(long_df, x='x', y='y', color='a').add(MockMark(), color=None)\n    assert (p._variables == ['x', 'y', 'color'])\n    p = Plot(long_df, x='x', y='y').add(MockMark(), color='a').add(MockMark(), alpha='s')\n    assert (p._variables == ['x', 'y', 'color', 'alpha'])\n    p = Plot(long_df, y='x').pair(x=['a', 'b'])\n    assert (p._variables == ['y', 'x0', 'x1'])", "masked_code": "def test_variable_list(self, long_df):\n    p = Plot(long_df, x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df).add(MockMark(), x='x', y='y')\n    assert (p._variables == '???')\n    p = Plot(long_df, y='x', color='a').add(MockMark(), x='y')\n    assert (p._variables == ['y', 'color', 'x'])\n    p = Plot(long_df, x='x', y='y', color='a').add(MockMark(), color=None)\n    assert (p._variables == ['x', 'y', 'color'])\n    p = Plot(long_df, x='x', y='y').add(MockMark(), color='a').add(MockMark(), alpha='s')\n    assert (p._variables == ['x', 'y', 'color', 'alpha'])\n    p = Plot(long_df, y='x').pair(x=['a', 'b'])\n    assert (p._variables == ['y', 'x0', 'x1'])", "ground_truth": "['x', 'y']", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1025", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLayerAddition", "funcname": "test_variable_list", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_variable_list(self, long_df):\n    p = Plot(long_df, x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df).add(MockMark(), x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df, y='x', color='a').add(MockMark(), x='y')\n    assert (p._variables == ['y', 'color', 'x'])\n    p = Plot(long_df, x='x', y='y', color='a').add(MockMark(), color=None)\n    assert (p._variables == ['x', 'y', 'color'])\n    p = Plot(long_df, x='x', y='y').add(MockMark(), color='a').add(MockMark(), alpha='s')\n    assert (p._variables == ['x', 'y', 'color', 'alpha'])\n    p = Plot(long_df, y='x').pair(x=['a', 'b'])\n    assert (p._variables == ['y', 'x0', 'x1'])", "masked_code": "def test_variable_list(self, long_df):\n    p = Plot(long_df, x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df).add(MockMark(), x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df, y='x', color='a').add(MockMark(), x='y')\n    assert (p._variables == '???')\n    p = Plot(long_df, x='x', y='y', color='a').add(MockMark(), color=None)\n    assert (p._variables == ['x', 'y', 'color'])\n    p = Plot(long_df, x='x', y='y').add(MockMark(), color='a').add(MockMark(), alpha='s')\n    assert (p._variables == ['x', 'y', 'color', 'alpha'])\n    p = Plot(long_df, y='x').pair(x=['a', 'b'])\n    assert (p._variables == ['y', 'x0', 'x1'])", "ground_truth": "['y', 'color', 'x']", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1026", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLayerAddition", "funcname": "test_variable_list", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_variable_list(self, long_df):\n    p = Plot(long_df, x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df).add(MockMark(), x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df, y='x', color='a').add(MockMark(), x='y')\n    assert (p._variables == ['y', 'color', 'x'])\n    p = Plot(long_df, x='x', y='y', color='a').add(MockMark(), color=None)\n    assert (p._variables == ['x', 'y', 'color'])\n    p = Plot(long_df, x='x', y='y').add(MockMark(), color='a').add(MockMark(), alpha='s')\n    assert (p._variables == ['x', 'y', 'color', 'alpha'])\n    p = Plot(long_df, y='x').pair(x=['a', 'b'])\n    assert (p._variables == ['y', 'x0', 'x1'])", "masked_code": "def test_variable_list(self, long_df):\n    p = Plot(long_df, x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df).add(MockMark(), x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df, y='x', color='a').add(MockMark(), x='y')\n    assert (p._variables == ['y', 'color', 'x'])\n    p = Plot(long_df, x='x', y='y', color='a').add(MockMark(), color=None)\n    assert (p._variables == '???')\n    p = Plot(long_df, x='x', y='y').add(MockMark(), color='a').add(MockMark(), alpha='s')\n    assert (p._variables == ['x', 'y', 'color', 'alpha'])\n    p = Plot(long_df, y='x').pair(x=['a', 'b'])\n    assert (p._variables == ['y', 'x0', 'x1'])", "ground_truth": "['x', 'y', 'color']", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1027", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLayerAddition", "funcname": "test_variable_list", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_variable_list(self, long_df):\n    p = Plot(long_df, x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df).add(MockMark(), x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df, y='x', color='a').add(MockMark(), x='y')\n    assert (p._variables == ['y', 'color', 'x'])\n    p = Plot(long_df, x='x', y='y', color='a').add(MockMark(), color=None)\n    assert (p._variables == ['x', 'y', 'color'])\n    p = Plot(long_df, x='x', y='y').add(MockMark(), color='a').add(MockMark(), alpha='s')\n    assert (p._variables == ['x', 'y', 'color', 'alpha'])\n    p = Plot(long_df, y='x').pair(x=['a', 'b'])\n    assert (p._variables == ['y', 'x0', 'x1'])", "masked_code": "def test_variable_list(self, long_df):\n    p = Plot(long_df, x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df).add(MockMark(), x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df, y='x', color='a').add(MockMark(), x='y')\n    assert (p._variables == ['y', 'color', 'x'])\n    p = Plot(long_df, x='x', y='y', color='a').add(MockMark(), color=None)\n    assert (p._variables == ['x', 'y', 'color'])\n    p = Plot(long_df, x='x', y='y').add(MockMark(), color='a').add(MockMark(), alpha='s')\n    assert (p._variables == '???')\n    p = Plot(long_df, y='x').pair(x=['a', 'b'])\n    assert (p._variables == ['y', 'x0', 'x1'])", "ground_truth": "['x', 'y', 'color', 'alpha']", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1028", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLayerAddition", "funcname": "test_variable_list", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_variable_list(self, long_df):\n    p = Plot(long_df, x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df).add(MockMark(), x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df, y='x', color='a').add(MockMark(), x='y')\n    assert (p._variables == ['y', 'color', 'x'])\n    p = Plot(long_df, x='x', y='y', color='a').add(MockMark(), color=None)\n    assert (p._variables == ['x', 'y', 'color'])\n    p = Plot(long_df, x='x', y='y').add(MockMark(), color='a').add(MockMark(), alpha='s')\n    assert (p._variables == ['x', 'y', 'color', 'alpha'])\n    p = Plot(long_df, y='x').pair(x=['a', 'b'])\n    assert (p._variables == ['y', 'x0', 'x1'])", "masked_code": "def test_variable_list(self, long_df):\n    p = Plot(long_df, x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df).add(MockMark(), x='x', y='y')\n    assert (p._variables == ['x', 'y'])\n    p = Plot(long_df, y='x', color='a').add(MockMark(), x='y')\n    assert (p._variables == ['y', 'color', 'x'])\n    p = Plot(long_df, x='x', y='y', color='a').add(MockMark(), color=None)\n    assert (p._variables == ['x', 'y', 'color'])\n    p = Plot(long_df, x='x', y='y').add(MockMark(), color='a').add(MockMark(), alpha='s')\n    assert (p._variables == ['x', 'y', 'color', 'alpha'])\n    p = Plot(long_df, y='x').pair(x=['a', 'b'])\n    assert (p._variables == '???')", "ground_truth": "['y', 'x0', 'x1']", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1029", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_inference", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_inference(self, long_df):\n    for (col, scale_type) in zip('zat', ['Continuous', 'Nominal', 'Temporal']):\n        p = Plot(long_df, x=col, y=col).add(MockMark()).plot()\n        for var in 'xy':\n            assert (p._scales[var].__class__.__name__ == scale_type)", "masked_code": "def test_inference(self, long_df):\n    for (col, scale_type) in zip('zat', ['Continuous', 'Nominal', 'Temporal']):\n        p = Plot(long_df, x=col, y=col).add(MockMark()).plot()\n        for var in 'xy':\n            assert (p._scales[var].__class__.__name__ == '???')", "ground_truth": "scale_type", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1030", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_log_scale_name", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "@pytest.mark.xfail(reason='Custom log scale needs log name for consistency')\ndef test_log_scale_name(self):\n    p = Plot().scale(x='log').plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xscale() == 'log')\n    assert (ax.get_yscale() == 'linear')", "masked_code": "@pytest.mark.xfail(reason='Custom log scale needs log name for consistency')\ndef test_log_scale_name(self):\n    p = Plot().scale(x='log').plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xscale() == '???')\n    assert (ax.get_yscale() == 'linear')", "ground_truth": "'log'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1031", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_log_scale_name", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "@pytest.mark.xfail(reason='Custom log scale needs log name for consistency')\ndef test_log_scale_name(self):\n    p = Plot().scale(x='log').plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xscale() == 'log')\n    assert (ax.get_yscale() == 'linear')", "masked_code": "@pytest.mark.xfail(reason='Custom log scale needs log name for consistency')\ndef test_log_scale_name(self):\n    p = Plot().scale(x='log').plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xscale() == 'log')\n    assert (ax.get_yscale() == '???')", "ground_truth": "'linear'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1032", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_facet_categories", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_facet_categories(self):\n    m = MockMark()\n    p = Plot(x=['a', 'b', 'a', 'c']).facet(col=['x', 'x', 'y', 'y']).add(m).plot()\n    (ax1, ax2) = p._figure.axes\n    assert (len(ax1.get_xticks()) == 3)\n    assert (len(ax2.get_xticks()) == 3)\n    assert_vector_equal(m.passed_data[0]['x'], pd.Series([0.0, 1.0], [0, 1]))\n    assert_vector_equal(m.passed_data[1]['x'], pd.Series([0.0, 2.0], [2, 3]))", "masked_code": "def test_facet_categories(self):\n    m = MockMark()\n    p = Plot(x=['a', 'b', 'a', 'c']).facet(col=['x', 'x', 'y', 'y']).add(m).plot()\n    (ax1, ax2) = p._figure.axes\n    assert (len(ax1.get_xticks()) == '???')\n    assert (len(ax2.get_xticks()) == 3)\n    assert_vector_equal(m.passed_data[0]['x'], pd.Series([0.0, 1.0], [0, 1]))\n    assert_vector_equal(m.passed_data[1]['x'], pd.Series([0.0, 2.0], [2, 3]))", "ground_truth": "3", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1033", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_facet_categories", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_facet_categories(self):\n    m = MockMark()\n    p = Plot(x=['a', 'b', 'a', 'c']).facet(col=['x', 'x', 'y', 'y']).add(m).plot()\n    (ax1, ax2) = p._figure.axes\n    assert (len(ax1.get_xticks()) == 3)\n    assert (len(ax2.get_xticks()) == 3)\n    assert_vector_equal(m.passed_data[0]['x'], pd.Series([0.0, 1.0], [0, 1]))\n    assert_vector_equal(m.passed_data[1]['x'], pd.Series([0.0, 2.0], [2, 3]))", "masked_code": "def test_facet_categories(self):\n    m = MockMark()\n    p = Plot(x=['a', 'b', 'a', 'c']).facet(col=['x', 'x', 'y', 'y']).add(m).plot()\n    (ax1, ax2) = p._figure.axes\n    assert (len(ax1.get_xticks()) == 3)\n    assert (len(ax2.get_xticks()) == '???')\n    assert_vector_equal(m.passed_data[0]['x'], pd.Series([0.0, 1.0], [0, 1]))\n    assert_vector_equal(m.passed_data[1]['x'], pd.Series([0.0, 2.0], [2, 3]))", "ground_truth": "3", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1034", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_facet_categories_single_dim_shared", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_facet_categories_single_dim_shared(self):\n    data = [('a', 1, 1), ('b', 1, 1), ('a', 1, 2), ('c', 1, 2), ('b', 2, 1), ('d', 2, 1), ('e', 2, 2), ('e', 2, 1)]\n    df = pd.DataFrame(data, columns=['x', 'row', 'col']).assign(y=1)\n    m = MockMark()\n    p = Plot(df, x='x').facet(row='row', col='col').add(m).share(x='row').plot()\n    axs = p._figure.axes\n    for ax in axs:\n        assert (ax.get_xticks() == [0, 1, 2])\n    assert_vector_equal(m.passed_data[0]['x'], pd.Series([0.0, 1.0], [0, 1]))\n    assert_vector_equal(m.passed_data[1]['x'], pd.Series([0.0, 2.0], [2, 3]))\n    assert_vector_equal(m.passed_data[2]['x'], pd.Series([0.0, 1.0, 2.0], [4, 5, 7]))\n    assert_vector_equal(m.passed_data[3]['x'], pd.Series([2.0], [6]))", "masked_code": "def test_facet_categories_single_dim_shared(self):\n    data = [('a', 1, 1), ('b', 1, 1), ('a', 1, 2), ('c', 1, 2), ('b', 2, 1), ('d', 2, 1), ('e', 2, 2), ('e', 2, 1)]\n    df = pd.DataFrame(data, columns=['x', 'row', 'col']).assign(y=1)\n    m = MockMark()\n    p = Plot(df, x='x').facet(row='row', col='col').add(m).share(x='row').plot()\n    axs = p._figure.axes\n    for ax in axs:\n        assert (ax.get_xticks() == '???')\n    assert_vector_equal(m.passed_data[0]['x'], pd.Series([0.0, 1.0], [0, 1]))\n    assert_vector_equal(m.passed_data[1]['x'], pd.Series([0.0, 2.0], [2, 3]))\n    assert_vector_equal(m.passed_data[2]['x'], pd.Series([0.0, 1.0, 2.0], [4, 5, 7]))\n    assert_vector_equal(m.passed_data[3]['x'], pd.Series([2.0], [6]))", "ground_truth": "[0, 1, 2]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1035", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_pair_categories", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_pair_categories(self):\n    data = [('a', 'a'), ('b', 'c')]\n    df = pd.DataFrame(data, columns=['x1', 'x2']).assign(y=1)\n    m = MockMark()\n    p = Plot(df, y='y').pair(x=['x1', 'x2']).add(m).plot()\n    (ax1, ax2) = p._figure.axes\n    assert (ax1.get_xticks() == [0, 1])\n    assert (ax2.get_xticks() == [0, 1])\n    assert_vector_equal(m.passed_data[0]['x'], pd.Series([0.0, 1.0], [0, 1]))\n    assert_vector_equal(m.passed_data[1]['x'], pd.Series([0.0, 1.0], [0, 1]))", "masked_code": "def test_pair_categories(self):\n    data = [('a', 'a'), ('b', 'c')]\n    df = pd.DataFrame(data, columns=['x1', 'x2']).assign(y=1)\n    m = MockMark()\n    p = Plot(df, y='y').pair(x=['x1', 'x2']).add(m).plot()\n    (ax1, ax2) = p._figure.axes\n    assert (ax1.get_xticks() == '???')\n    assert (ax2.get_xticks() == [0, 1])\n    assert_vector_equal(m.passed_data[0]['x'], pd.Series([0.0, 1.0], [0, 1]))\n    assert_vector_equal(m.passed_data[1]['x'], pd.Series([0.0, 1.0], [0, 1]))", "ground_truth": "[0, 1]", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1036", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_pair_categories", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_pair_categories(self):\n    data = [('a', 'a'), ('b', 'c')]\n    df = pd.DataFrame(data, columns=['x1', 'x2']).assign(y=1)\n    m = MockMark()\n    p = Plot(df, y='y').pair(x=['x1', 'x2']).add(m).plot()\n    (ax1, ax2) = p._figure.axes\n    assert (ax1.get_xticks() == [0, 1])\n    assert (ax2.get_xticks() == [0, 1])\n    assert_vector_equal(m.passed_data[0]['x'], pd.Series([0.0, 1.0], [0, 1]))\n    assert_vector_equal(m.passed_data[1]['x'], pd.Series([0.0, 1.0], [0, 1]))", "masked_code": "def test_pair_categories(self):\n    data = [('a', 'a'), ('b', 'c')]\n    df = pd.DataFrame(data, columns=['x1', 'x2']).assign(y=1)\n    m = MockMark()\n    p = Plot(df, y='y').pair(x=['x1', 'x2']).add(m).plot()\n    (ax1, ax2) = p._figure.axes\n    assert (ax1.get_xticks() == [0, 1])\n    assert (ax2.get_xticks() == '???')\n    assert_vector_equal(m.passed_data[0]['x'], pd.Series([0.0, 1.0], [0, 1]))\n    assert_vector_equal(m.passed_data[1]['x'], pd.Series([0.0, 1.0], [0, 1]))", "ground_truth": "[0, 1]", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1037", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_pair_categories_shared", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_pair_categories_shared(self):\n    data = [('a', 'a'), ('b', 'c')]\n    df = pd.DataFrame(data, columns=['x1', 'x2']).assign(y=1)\n    m = MockMark()\n    p = Plot(df, y='y').pair(x=['x1', 'x2']).add(m).share(x=True).plot()\n    for ax in p._figure.axes:\n        assert (ax.get_xticks() == [0, 1, 2])\n    print(m.passed_data)\n    assert_vector_equal(m.passed_data[0]['x'], pd.Series([0.0, 1.0], [0, 1]))\n    assert_vector_equal(m.passed_data[1]['x'], pd.Series([0.0, 2.0], [0, 1]))", "masked_code": "def test_pair_categories_shared(self):\n    data = [('a', 'a'), ('b', 'c')]\n    df = pd.DataFrame(data, columns=['x1', 'x2']).assign(y=1)\n    m = MockMark()\n    p = Plot(df, y='y').pair(x=['x1', 'x2']).add(m).share(x=True).plot()\n    for ax in p._figure.axes:\n        assert (ax.get_xticks() == '???')\n    print(m.passed_data)\n    assert_vector_equal(m.passed_data[0]['x'], pd.Series([0.0, 1.0], [0, 1]))\n    assert_vector_equal(m.passed_data[1]['x'], pd.Series([0.0, 2.0], [0, 1]))", "ground_truth": "[0, 1, 2]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1038", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_inferred_nominal_passed_to_stat", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_inferred_nominal_passed_to_stat(self):\n\n    class MockStat(Stat):\n\n        def __call__(self, data, groupby, orient, scales):\n            self.scales = scales\n            return data\n    s = MockStat()\n    y = ['a', 'a', 'b', 'c']\n    Plot(y=y).add(MockMark(), s).plot()\n    assert (s.scales['y'].__class__.__name__ == 'Nominal')", "masked_code": "def test_inferred_nominal_passed_to_stat(self):\n\n    class MockStat(Stat):\n\n        def __call__(self, data, groupby, orient, scales):\n            self.scales = scales\n            return data\n    s = MockStat()\n    y = ['a', 'a', 'b', 'c']\n    Plot(y=y).add(MockMark(), s).plot()\n    assert (s.scales['y'].__class__.__name__ == '???')", "ground_truth": "'Nominal'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1039", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_nominal_x_axis_tweaks", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_nominal_x_axis_tweaks(self):\n    p = Plot(x=['a', 'b', 'c'], y=[1, 2, 3])\n    ax1 = p.plot()._figure.axes[0]\n    assert (ax1.get_xlim() == ((- 0.5), 2.5))\n    assert (not any((x.get_visible() for x in ax1.xaxis.get_gridlines())))\n    lim = ((- 1), 2.1)\n    ax2 = p.limit(x=lim).plot()._figure.axes[0]\n    assert (ax2.get_xlim() == lim)", "masked_code": "def test_nominal_x_axis_tweaks(self):\n    p = Plot(x=['a', 'b', 'c'], y=[1, 2, 3])\n    ax1 = p.plot()._figure.axes[0]\n    assert (ax1.get_xlim() == '???')\n    assert (not any((x.get_visible() for x in ax1.xaxis.get_gridlines())))\n    lim = ((- 1), 2.1)\n    ax2 = p.limit(x=lim).plot()._figure.axes[0]\n    assert (ax2.get_xlim() == lim)", "ground_truth": "((- 0.5), 2.5)", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1040", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_nominal_x_axis_tweaks", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_nominal_x_axis_tweaks(self):\n    p = Plot(x=['a', 'b', 'c'], y=[1, 2, 3])\n    ax1 = p.plot()._figure.axes[0]\n    assert (ax1.get_xlim() == ((- 0.5), 2.5))\n    assert (not any((x.get_visible() for x in ax1.xaxis.get_gridlines())))\n    lim = ((- 1), 2.1)\n    ax2 = p.limit(x=lim).plot()._figure.axes[0]\n    assert (ax2.get_xlim() == lim)", "masked_code": "def test_nominal_x_axis_tweaks(self):\n    p = Plot(x=['a', 'b', 'c'], y=[1, 2, 3])\n    ax1 = p.plot()._figure.axes[0]\n    assert (ax1.get_xlim() == ((- 0.5), 2.5))\n    assert (not any((x.get_visible() for x in ax1.xaxis.get_gridlines())))\n    lim = ((- 1), 2.1)\n    ax2 = p.limit(x=lim).plot()._figure.axes[0]\n    assert (ax2.get_xlim() == '???')", "ground_truth": "lim", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1041", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_nominal_y_axis_tweaks", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_nominal_y_axis_tweaks(self):\n    p = Plot(x=[1, 2, 3], y=['a', 'b', 'c'])\n    ax1 = p.plot()._figure.axes[0]\n    assert (ax1.get_ylim() == (2.5, (- 0.5)))\n    assert (not any((y.get_visible() for y in ax1.yaxis.get_gridlines())))\n    lim = ((- 1), 2.1)\n    ax2 = p.limit(y=lim).plot()._figure.axes[0]\n    assert (ax2.get_ylim() == lim)", "masked_code": "def test_nominal_y_axis_tweaks(self):\n    p = Plot(x=[1, 2, 3], y=['a', 'b', 'c'])\n    ax1 = p.plot()._figure.axes[0]\n    assert (ax1.get_ylim() == '???')\n    assert (not any((y.get_visible() for y in ax1.yaxis.get_gridlines())))\n    lim = ((- 1), 2.1)\n    ax2 = p.limit(y=lim).plot()._figure.axes[0]\n    assert (ax2.get_ylim() == lim)", "ground_truth": "(2.5, (- 0.5))", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1042", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestScaling", "funcname": "test_nominal_y_axis_tweaks", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_nominal_y_axis_tweaks(self):\n    p = Plot(x=[1, 2, 3], y=['a', 'b', 'c'])\n    ax1 = p.plot()._figure.axes[0]\n    assert (ax1.get_ylim() == (2.5, (- 0.5)))\n    assert (not any((y.get_visible() for y in ax1.yaxis.get_gridlines())))\n    lim = ((- 1), 2.1)\n    ax2 = p.limit(y=lim).plot()._figure.axes[0]\n    assert (ax2.get_ylim() == lim)", "masked_code": "def test_nominal_y_axis_tweaks(self):\n    p = Plot(x=[1, 2, 3], y=['a', 'b', 'c'])\n    ax1 = p.plot()._figure.axes[0]\n    assert (ax1.get_ylim() == (2.5, (- 0.5)))\n    assert (not any((y.get_visible() for y in ax1.yaxis.get_gridlines())))\n    lim = ((- 1), 2.1)\n    ax2 = p.limit(y=lim).plot()._figure.axes[0]\n    assert (ax2.get_ylim() == '???')", "ground_truth": "lim", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1043", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_single_split_single_layer", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_split_single_layer(self, long_df):\n    m = MockMark()\n    p = Plot(long_df, x='f', y='z').add(m).plot()\n    assert (m.n_splits == 1)\n    assert (m.passed_keys[0] == {})\n    assert (m.passed_axes == [sub['ax'] for sub in p._subplots])\n    for col in p._data.frame:\n        assert_series_equal(m.passed_data[0][col], p._data.frame[col])", "masked_code": "def test_single_split_single_layer(self, long_df):\n    m = MockMark()\n    p = Plot(long_df, x='f', y='z').add(m).plot()\n    assert (m.n_splits == 1)\n    assert (m.passed_keys[0] == '???')\n    assert (m.passed_axes == [sub['ax'] for sub in p._subplots])\n    for col in p._data.frame:\n        assert_series_equal(m.passed_data[0][col], p._data.frame[col])", "ground_truth": "{}", "quality_analysis": {"complexity_score": 9, "left_complexity": 6, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1044", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_single_split_single_layer", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_split_single_layer(self, long_df):\n    m = MockMark()\n    p = Plot(long_df, x='f', y='z').add(m).plot()\n    assert (m.n_splits == 1)\n    assert (m.passed_keys[0] == {})\n    assert (m.passed_axes == [sub['ax'] for sub in p._subplots])\n    for col in p._data.frame:\n        assert_series_equal(m.passed_data[0][col], p._data.frame[col])", "masked_code": "def test_single_split_single_layer(self, long_df):\n    m = MockMark()\n    p = Plot(long_df, x='f', y='z').add(m).plot()\n    assert (m.n_splits == 1)\n    assert (m.passed_keys[0] == {})\n    assert (m.passed_axes == '???')\n    for col in p._data.frame:\n        assert_series_equal(m.passed_data[0][col], p._data.frame[col])", "ground_truth": "[sub['ax'] for sub in p._subplots]", "quality_analysis": {"complexity_score": 2, "left_complexity": 2, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1045", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_one_grouping_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "@pytest.mark.parametrize('split_var', ['color', 'group'])\ndef test_one_grouping_variable(self, long_df, split_var):\n    split_col = 'a'\n    data_vars = {'x': 'f', 'y': 'z', split_var: split_col}\n    m = MockMark()\n    p = Plot(long_df, **data_vars).add(m).plot()\n    split_keys = categorical_order(long_df[split_col])\n    (sub, *_) = p._subplots\n    assert (m.passed_axes == [sub['ax'] for _ in split_keys])\n    self.check_splits_single_var(long_df, m, data_vars, split_var, split_col, split_keys)", "masked_code": "@pytest.mark.parametrize('split_var', ['color', 'group'])\ndef test_one_grouping_variable(self, long_df, split_var):\n    split_col = 'a'\n    data_vars = {'x': 'f', 'y': 'z', split_var: split_col}\n    m = MockMark()\n    p = Plot(long_df, **data_vars).add(m).plot()\n    split_keys = categorical_order(long_df[split_col])\n    (sub, *_) = p._subplots\n    assert (m.passed_axes == '???')\n    self.check_splits_single_var(long_df, m, data_vars, split_var, split_col, split_keys)", "ground_truth": "[sub['ax'] for _ in split_keys]", "quality_analysis": {"complexity_score": 2, "left_complexity": 2, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1046", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_two_grouping_variables", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_two_grouping_variables(self, long_df):\n    split_vars = ['color', 'group']\n    split_cols = ['a', 'b']\n    data_vars = {'y': 'z', **{var: col for (var, col) in zip(split_vars, split_cols)}}\n    m = MockMark()\n    p = Plot(long_df, **data_vars).add(m).plot()\n    split_keys = [categorical_order(long_df[col]) for col in split_cols]\n    (sub, *_) = p._subplots\n    assert (m.passed_axes == [sub['ax'] for _ in itertools.product(*split_keys)])\n    self.check_splits_multi_vars(long_df, m, data_vars, split_vars, split_cols, split_keys)", "masked_code": "def test_two_grouping_variables(self, long_df):\n    split_vars = ['color', 'group']\n    split_cols = ['a', 'b']\n    data_vars = {'y': 'z', **{var: col for (var, col) in zip(split_vars, split_cols)}}\n    m = MockMark()\n    p = Plot(long_df, **data_vars).add(m).plot()\n    split_keys = [categorical_order(long_df[col]) for col in split_cols]\n    (sub, *_) = p._subplots\n    assert (m.passed_axes == '???')\n    self.check_splits_multi_vars(long_df, m, data_vars, split_vars, split_cols, split_keys)", "ground_truth": "[sub['ax'] for _ in itertools.product(*split_keys)]", "quality_analysis": {"complexity_score": 2, "left_complexity": 2, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1047", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_facets_no_subgroups", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_facets_no_subgroups(self, long_df):\n    split_var = 'col'\n    split_col = 'b'\n    data_vars = {'x': 'f', 'y': 'z'}\n    m = MockMark()\n    p = Plot(long_df, **data_vars).facet(**{split_var: split_col}).add(m).plot()\n    split_keys = categorical_order(long_df[split_col])\n    assert (m.passed_axes == list(p._figure.axes))\n    self.check_splits_single_var(long_df, m, data_vars, split_var, split_col, split_keys)", "masked_code": "def test_facets_no_subgroups(self, long_df):\n    split_var = 'col'\n    split_col = 'b'\n    data_vars = {'x': 'f', 'y': 'z'}\n    m = MockMark()\n    p = Plot(long_df, **data_vars).facet(**{split_var: split_col}).add(m).plot()\n    split_keys = categorical_order(long_df[split_col])\n    assert (m.passed_axes == '???')\n    self.check_splits_single_var(long_df, m, data_vars, split_var, split_col, split_keys)", "ground_truth": "list(p._figure.axes)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1048", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_facets_one_subgroup", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_facets_one_subgroup(self, long_df):\n    (facet_var, facet_col) = fx = ('col', 'a')\n    (group_var, group_col) = gx = ('group', 'b')\n    (split_vars, split_cols) = zip(*[fx, gx])\n    data_vars = {'x': 'f', 'y': 'z', group_var: group_col}\n    m = MockMark()\n    p = Plot(long_df, **data_vars).facet(**{facet_var: facet_col}).add(m).plot()\n    split_keys = [categorical_order(long_df[col]) for col in [facet_col, group_col]]\n    assert (m.passed_axes == [ax for ax in list(p._figure.axes) for _ in categorical_order(long_df[group_col])])\n    self.check_splits_multi_vars(long_df, m, data_vars, split_vars, split_cols, split_keys)", "masked_code": "def test_facets_one_subgroup(self, long_df):\n    (facet_var, facet_col) = fx = ('col', 'a')\n    (group_var, group_col) = gx = ('group', 'b')\n    (split_vars, split_cols) = zip(*[fx, gx])\n    data_vars = {'x': 'f', 'y': 'z', group_var: group_col}\n    m = MockMark()\n    p = Plot(long_df, **data_vars).facet(**{facet_var: facet_col}).add(m).plot()\n    split_keys = [categorical_order(long_df[col]) for col in [facet_col, group_col]]\n    assert (m.passed_axes == '???')\n    self.check_splits_multi_vars(long_df, m, data_vars, split_vars, split_cols, split_keys)", "ground_truth": "[ax for ax in list(p._figure.axes) for _ in categorical_order(long_df[group_col])]", "quality_analysis": {"complexity_score": 2, "left_complexity": 2, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1049", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_layer_specific_facet_disabling", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_layer_specific_facet_disabling(self, long_df):\n    axis_vars = {'x': 'y', 'y': 'z'}\n    row_var = 'a'\n    m = MockMark()\n    p = Plot(long_df, **axis_vars).facet(row=row_var).add(m, row=None).plot()\n    col_levels = categorical_order(long_df[row_var])\n    assert (len(p._figure.axes) == len(col_levels))\n    for data in m.passed_data:\n        for (var, col) in axis_vars.items():\n            assert_vector_equal(data[var], long_df[col])", "masked_code": "def test_layer_specific_facet_disabling(self, long_df):\n    axis_vars = {'x': 'y', 'y': 'z'}\n    row_var = 'a'\n    m = MockMark()\n    p = Plot(long_df, **axis_vars).facet(row=row_var).add(m, row=None).plot()\n    col_levels = categorical_order(long_df[row_var])\n    assert (len(p._figure.axes) == '???')\n    for data in m.passed_data:\n        for (var, col) in axis_vars.items():\n            assert_vector_equal(data[var], long_df[col])", "ground_truth": "len(col_levels)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1050", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_save", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_save(self):\n    buf = io.BytesIO()\n    p = Plot().save(buf)\n    assert isinstance(p, Plot)\n    img = Image.open(buf)\n    assert (img.format == 'PNG')\n    buf = io.StringIO()\n    Plot().save(buf, format='svg')\n    tag = xml.etree.ElementTree.fromstring(buf.getvalue()).tag\n    assert (tag == '{http://www.w3.org/2000/svg}svg')", "masked_code": "def test_save(self):\n    buf = io.BytesIO()\n    p = Plot().save(buf)\n    assert isinstance(p, Plot)\n    img = Image.open(buf)\n    assert (img.format == '???')\n    buf = io.StringIO()\n    Plot().save(buf, format='svg')\n    tag = xml.etree.ElementTree.fromstring(buf.getvalue()).tag\n    assert (tag == '{http://www.w3.org/2000/svg}svg')", "ground_truth": "'PNG'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1051", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_layout_size", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_layout_size(self):\n    size = (4, 2)\n    p = Plot().layout(size=size).plot()\n    assert (tuple(p._figure.get_size_inches()) == size)", "masked_code": "def test_layout_size(self):\n    size = (4, 2)\n    p = Plot().layout(size=size).plot()\n    assert (tuple(p._figure.get_size_inches()) == '???')", "ground_truth": "size", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1052", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_layout_extent", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='mpl<3.6 does not have get_layout_engine')\ndef test_layout_extent(self):\n    p = Plot().layout(extent=(0.1, 0.2, 0.6, 1)).plot()\n    assert (p._figure.get_layout_engine().get()['rect'] == [0.1, 0.2, 0.5, 0.8])", "masked_code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='mpl<3.6 does not have get_layout_engine')\ndef test_layout_extent(self):\n    p = Plot().layout(extent=(0.1, 0.2, 0.6, 1)).plot()\n    assert (p._figure.get_layout_engine().get()['rect'] == '???')", "ground_truth": "[0.1, 0.2, 0.5, 0.8]", "quality_analysis": {"complexity_score": 13, "left_complexity": 7, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1053", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_constrained_layout_extent", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='mpl<3.6 does not have get_layout_engine')\ndef test_constrained_layout_extent(self):\n    p = Plot().layout(engine='constrained', extent=(0.1, 0.2, 0.6, 1)).plot()\n    assert (p._figure.get_layout_engine().get()['rect'] == [0.1, 0.2, 0.5, 0.8])", "masked_code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='mpl<3.6 does not have get_layout_engine')\ndef test_constrained_layout_extent(self):\n    p = Plot().layout(engine='constrained', extent=(0.1, 0.2, 0.6, 1)).plot()\n    assert (p._figure.get_layout_engine().get()['rect'] == '???')", "ground_truth": "[0.1, 0.2, 0.5, 0.8]", "quality_analysis": {"complexity_score": 13, "left_complexity": 7, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1054", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_base_layout_extent", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_base_layout_extent(self):\n    p = Plot().layout(engine=None, extent=(0.1, 0.2, 0.6, 1)).plot()\n    assert (p._figure.subplotpars.left == 0.1)\n    assert (p._figure.subplotpars.right == 0.6)\n    assert (p._figure.subplotpars.bottom == 0.2)\n    assert (p._figure.subplotpars.top == 1)", "masked_code": "def test_base_layout_extent(self):\n    p = Plot().layout(engine=None, extent=(0.1, 0.2, 0.6, 1)).plot()\n    assert (p._figure.subplotpars.left == '???')\n    assert (p._figure.subplotpars.right == 0.6)\n    assert (p._figure.subplotpars.bottom == 0.2)\n    assert (p._figure.subplotpars.top == 1)", "ground_truth": "0.1", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1055", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_base_layout_extent", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_base_layout_extent(self):\n    p = Plot().layout(engine=None, extent=(0.1, 0.2, 0.6, 1)).plot()\n    assert (p._figure.subplotpars.left == 0.1)\n    assert (p._figure.subplotpars.right == 0.6)\n    assert (p._figure.subplotpars.bottom == 0.2)\n    assert (p._figure.subplotpars.top == 1)", "masked_code": "def test_base_layout_extent(self):\n    p = Plot().layout(engine=None, extent=(0.1, 0.2, 0.6, 1)).plot()\n    assert (p._figure.subplotpars.left == 0.1)\n    assert (p._figure.subplotpars.right == '???')\n    assert (p._figure.subplotpars.bottom == 0.2)\n    assert (p._figure.subplotpars.top == 1)", "ground_truth": "0.6", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1056", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_base_layout_extent", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_base_layout_extent(self):\n    p = Plot().layout(engine=None, extent=(0.1, 0.2, 0.6, 1)).plot()\n    assert (p._figure.subplotpars.left == 0.1)\n    assert (p._figure.subplotpars.right == 0.6)\n    assert (p._figure.subplotpars.bottom == 0.2)\n    assert (p._figure.subplotpars.top == 1)", "masked_code": "def test_base_layout_extent(self):\n    p = Plot().layout(engine=None, extent=(0.1, 0.2, 0.6, 1)).plot()\n    assert (p._figure.subplotpars.left == 0.1)\n    assert (p._figure.subplotpars.right == 0.6)\n    assert (p._figure.subplotpars.bottom == '???')\n    assert (p._figure.subplotpars.top == 1)", "ground_truth": "0.2", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1057", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_on_axes", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_on_axes(self):\n    ax = mpl.figure.Figure().subplots()\n    m = MockMark()\n    p = Plot([1], [2]).on(ax).add(m).plot()\n    assert (m.passed_axes == [ax])\n    assert (p._figure is ax.figure)", "masked_code": "def test_on_axes(self):\n    ax = mpl.figure.Figure().subplots()\n    m = MockMark()\n    p = Plot([1], [2]).on(ax).add(m).plot()\n    assert (m.passed_axes == '???')\n    assert (p._figure is ax.figure)", "ground_truth": "[ax]", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1058", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_on_figure", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "@pytest.mark.parametrize('facet', [True, False])\ndef test_on_figure(self, facet):\n    f = mpl.figure.Figure()\n    m = MockMark()\n    p = Plot([1, 2], [3, 4]).on(f).add(m)\n    if facet:\n        p = p.facet(['a', 'b'])\n    p = p.plot()\n    assert (m.passed_axes == f.axes)\n    assert (p._figure is f)", "masked_code": "@pytest.mark.parametrize('facet', [True, False])\ndef test_on_figure(self, facet):\n    f = mpl.figure.Figure()\n    m = MockMark()\n    p = Plot([1, 2], [3, 4]).on(f).add(m)\n    if facet:\n        p = p.facet(['a', 'b'])\n    p = p.plot()\n    assert (m.passed_axes == '???')\n    assert (p._figure is f)", "ground_truth": "f.axes", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1059", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_on_subfigure", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "@pytest.mark.parametrize('facet', [True, False])\ndef test_on_subfigure(self, facet):\n    (sf1, sf2) = mpl.figure.Figure().subfigures(2)\n    sf1.subplots()\n    m = MockMark()\n    p = Plot([1, 2], [3, 4]).on(sf2).add(m)\n    if facet:\n        p = p.facet(['a', 'b'])\n    p = p.plot()\n    assert (m.passed_axes == sf2.figure.axes[1:])\n    assert (p._figure is sf2.figure)", "masked_code": "@pytest.mark.parametrize('facet', [True, False])\ndef test_on_subfigure(self, facet):\n    (sf1, sf2) = mpl.figure.Figure().subfigures(2)\n    sf1.subplots()\n    m = MockMark()\n    p = Plot([1, 2], [3, 4]).on(sf2).add(m)\n    if facet:\n        p = p.facet(['a', 'b'])\n    p = p.plot()\n    assert (m.passed_axes == '???')\n    assert (p._figure is sf2.figure)", "ground_truth": "sf2.figure.axes[1:]", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1060", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_on_layout_algo_default", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Requires newer matplotlib layout engine API')\ndef test_on_layout_algo_default(self):\n\n    class MockEngine(mpl.layout_engine.ConstrainedLayoutEngine):\n        ...\n    f = mpl.figure.Figure(layout=MockEngine())\n    p = Plot().on(f).plot()\n    layout_engine = p._figure.get_layout_engine()\n    assert (layout_engine.__class__.__name__ == 'MockEngine')", "masked_code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Requires newer matplotlib layout engine API')\ndef test_on_layout_algo_default(self):\n\n    class MockEngine(mpl.layout_engine.ConstrainedLayoutEngine):\n        ...\n    f = mpl.figure.Figure(layout=MockEngine())\n    p = Plot().on(f).plot()\n    layout_engine = p._figure.get_layout_engine()\n    assert (layout_engine.__class__.__name__ == '???')", "ground_truth": "'MockEngine'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1061", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_on_layout_algo_spec", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Requires newer matplotlib layout engine API')\ndef test_on_layout_algo_spec(self):\n    f = mpl.figure.Figure(layout='constrained')\n    p = Plot().on(f).layout(engine='tight').plot()\n    layout_engine = p._figure.get_layout_engine()\n    assert (layout_engine.__class__.__name__ == 'TightLayoutEngine')", "masked_code": "@pytest.mark.skipif(_version_predates(mpl, '3.6'), reason='Requires newer matplotlib layout engine API')\ndef test_on_layout_algo_spec(self):\n    f = mpl.figure.Figure(layout='constrained')\n    p = Plot().on(f).layout(engine='tight').plot()\n    layout_engine = p._figure.get_layout_engine()\n    assert (layout_engine.__class__.__name__ == '???')", "ground_truth": "'TightLayoutEngine'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1062", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_limits", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_limits(self, long_df):\n    limit = ((- 2), 24)\n    p = Plot(long_df, x='x', y='y').limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == limit)\n    limit = (np.datetime64('2005-01-01'), np.datetime64('2008-01-01'))\n    p = Plot(long_df, x='d', y='y').limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == tuple(mpl.dates.date2num(limit)))\n    limit = ('b', 'c')\n    p = Plot(x=['a', 'b', 'c', 'd'], y=[1, 2, 3, 4]).limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == (0.5, 2.5))", "masked_code": "def test_limits(self, long_df):\n    limit = ((- 2), 24)\n    p = Plot(long_df, x='x', y='y').limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == '???')\n    limit = (np.datetime64('2005-01-01'), np.datetime64('2008-01-01'))\n    p = Plot(long_df, x='d', y='y').limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == tuple(mpl.dates.date2num(limit)))\n    limit = ('b', 'c')\n    p = Plot(x=['a', 'b', 'c', 'd'], y=[1, 2, 3, 4]).limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == (0.5, 2.5))", "ground_truth": "limit", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1063", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_limits", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_limits(self, long_df):\n    limit = ((- 2), 24)\n    p = Plot(long_df, x='x', y='y').limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == limit)\n    limit = (np.datetime64('2005-01-01'), np.datetime64('2008-01-01'))\n    p = Plot(long_df, x='d', y='y').limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == tuple(mpl.dates.date2num(limit)))\n    limit = ('b', 'c')\n    p = Plot(x=['a', 'b', 'c', 'd'], y=[1, 2, 3, 4]).limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == (0.5, 2.5))", "masked_code": "def test_limits(self, long_df):\n    limit = ((- 2), 24)\n    p = Plot(long_df, x='x', y='y').limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == limit)\n    limit = (np.datetime64('2005-01-01'), np.datetime64('2008-01-01'))\n    p = Plot(long_df, x='d', y='y').limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == '???')\n    limit = ('b', 'c')\n    p = Plot(x=['a', 'b', 'c', 'd'], y=[1, 2, 3, 4]).limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == (0.5, 2.5))", "ground_truth": "tuple(mpl.dates.date2num(limit))", "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1064", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_limits", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_limits(self, long_df):\n    limit = ((- 2), 24)\n    p = Plot(long_df, x='x', y='y').limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == limit)\n    limit = (np.datetime64('2005-01-01'), np.datetime64('2008-01-01'))\n    p = Plot(long_df, x='d', y='y').limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == tuple(mpl.dates.date2num(limit)))\n    limit = ('b', 'c')\n    p = Plot(x=['a', 'b', 'c', 'd'], y=[1, 2, 3, 4]).limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == (0.5, 2.5))", "masked_code": "def test_limits(self, long_df):\n    limit = ((- 2), 24)\n    p = Plot(long_df, x='x', y='y').limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == limit)\n    limit = (np.datetime64('2005-01-01'), np.datetime64('2008-01-01'))\n    p = Plot(long_df, x='d', y='y').limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == tuple(mpl.dates.date2num(limit)))\n    limit = ('b', 'c')\n    p = Plot(x=['a', 'b', 'c', 'd'], y=[1, 2, 3, 4]).limit(x=limit).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_xlim() == '???')", "ground_truth": "(0.5, 2.5)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1065", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_labels_axis", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_labels_axis(self, long_df):\n    label = 'Y axis'\n    p = Plot(long_df, x='x', y='y').label(y=label).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_ylabel() == label)\n    label = str.capitalize\n    p = Plot(long_df, x='x', y='y').label(y=label).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_ylabel() == 'Y')", "masked_code": "def test_labels_axis(self, long_df):\n    label = 'Y axis'\n    p = Plot(long_df, x='x', y='y').label(y=label).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_ylabel() == '???')\n    label = str.capitalize\n    p = Plot(long_df, x='x', y='y').label(y=label).plot()\n    ax = p._figure.axes[0]\n    assert (ax.get_ylabel() == 'Y')", "ground_truth": "label", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1066", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_labels_legend", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_labels_legend(self, long_df):\n    m = MockMark()\n    label = 'A'\n    p = Plot(long_df, x='x', y='y', color='a').add(m).label(color=label).plot()\n    assert (p._figure.legends[0].get_title().get_text() == label)\n    func = str.capitalize\n    p = Plot(long_df, x='x', y='y', color='a').add(m).label(color=func).plot()\n    assert (p._figure.legends[0].get_title().get_text() == label)", "masked_code": "def test_labels_legend(self, long_df):\n    m = MockMark()\n    label = 'A'\n    p = Plot(long_df, x='x', y='y', color='a').add(m).label(color=label).plot()\n    assert (p._figure.legends[0].get_title().get_text() == '???')\n    func = str.capitalize\n    p = Plot(long_df, x='x', y='y', color='a').add(m).label(color=func).plot()\n    assert (p._figure.legends[0].get_title().get_text() == label)", "ground_truth": "label", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1067", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_labels_legend", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_labels_legend(self, long_df):\n    m = MockMark()\n    label = 'A'\n    p = Plot(long_df, x='x', y='y', color='a').add(m).label(color=label).plot()\n    assert (p._figure.legends[0].get_title().get_text() == label)\n    func = str.capitalize\n    p = Plot(long_df, x='x', y='y', color='a').add(m).label(color=func).plot()\n    assert (p._figure.legends[0].get_title().get_text() == label)", "masked_code": "def test_labels_legend(self, long_df):\n    m = MockMark()\n    label = 'A'\n    p = Plot(long_df, x='x', y='y', color='a').add(m).label(color=label).plot()\n    assert (p._figure.legends[0].get_title().get_text() == label)\n    func = str.capitalize\n    p = Plot(long_df, x='x', y='y', color='a').add(m).label(color=func).plot()\n    assert (p._figure.legends[0].get_title().get_text() == '???')", "ground_truth": "label", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1068", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_labels_facets", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_labels_facets(self):\n    data = {'a': ['b', 'c'], 'x': ['y', 'z']}\n    p = Plot(data).facet('a', 'x').label(col=str.capitalize, row='$x$').plot()\n    axs = np.reshape(p._figure.axes, (2, 2))\n    for ((i, j), ax) in np.ndenumerate(axs):\n        expected = f\"A {data['a'][j]} | $x$ {data['x'][i]}\"\n        assert (ax.get_title() == expected)", "masked_code": "def test_labels_facets(self):\n    data = {'a': ['b', 'c'], 'x': ['y', 'z']}\n    p = Plot(data).facet('a', 'x').label(col=str.capitalize, row='$x$').plot()\n    axs = np.reshape(p._figure.axes, (2, 2))\n    for ((i, j), ax) in np.ndenumerate(axs):\n        expected = f\"A {data['a'][j]} | $x$ {data['x'][i]}\"\n        assert (ax.get_title() == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1069", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_title_single", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_title_single(self):\n    label = 'A'\n    p = Plot().label(title=label).plot()\n    assert (p._figure.axes[0].get_title() == label)", "masked_code": "def test_title_single(self):\n    label = 'A'\n    p = Plot().label(title=label).plot()\n    assert (p._figure.axes[0].get_title() == '???')", "ground_truth": "label", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1070", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_title_facet_function", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_title_facet_function(self):\n    titles = ['a', 'b']\n    p = Plot().facet(titles).label(title=str.capitalize).plot()\n    for (i, ax) in enumerate(p._figure.axes):\n        assert (ax.get_title() == titles[i].upper())\n    (cols, rows) = (['a', 'b'], ['x', 'y'])\n    p = Plot().facet(cols, rows).label(title=str.capitalize).plot()\n    for (i, ax) in enumerate(p._figure.axes):\n        expected = ' | '.join([cols[(i % 2)].upper(), rows[(i // 2)].upper()])\n        assert (ax.get_title() == expected)", "masked_code": "def test_title_facet_function(self):\n    titles = ['a', 'b']\n    p = Plot().facet(titles).label(title=str.capitalize).plot()\n    for (i, ax) in enumerate(p._figure.axes):\n        assert (ax.get_title() == '???')\n    (cols, rows) = (['a', 'b'], ['x', 'y'])\n    p = Plot().facet(cols, rows).label(title=str.capitalize).plot()\n    for (i, ax) in enumerate(p._figure.axes):\n        expected = ' | '.join([cols[(i % 2)].upper(), rows[(i // 2)].upper()])\n        assert (ax.get_title() == expected)", "ground_truth": "titles[i].upper()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1071", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPlotting", "funcname": "test_title_facet_function", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_title_facet_function(self):\n    titles = ['a', 'b']\n    p = Plot().facet(titles).label(title=str.capitalize).plot()\n    for (i, ax) in enumerate(p._figure.axes):\n        assert (ax.get_title() == titles[i].upper())\n    (cols, rows) = (['a', 'b'], ['x', 'y'])\n    p = Plot().facet(cols, rows).label(title=str.capitalize).plot()\n    for (i, ax) in enumerate(p._figure.axes):\n        expected = ' | '.join([cols[(i % 2)].upper(), rows[(i // 2)].upper()])\n        assert (ax.get_title() == expected)", "masked_code": "def test_title_facet_function(self):\n    titles = ['a', 'b']\n    p = Plot().facet(titles).label(title=str.capitalize).plot()\n    for (i, ax) in enumerate(p._figure.axes):\n        assert (ax.get_title() == titles[i].upper())\n    (cols, rows) = (['a', 'b'], ['x', 'y'])\n    p = Plot().facet(cols, rows).label(title=str.capitalize).plot()\n    for (i, ax) in enumerate(p._figure.axes):\n        expected = ' | '.join([cols[(i % 2)].upper(), rows[(i // 2)].upper()])\n        assert (ax.get_title() == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1072", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestExceptions", "funcname": "test_semantic_scaling", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_semantic_scaling(self):\n\n    class ErrorRaising(Continuous):\n\n        def _setup(self, data, prop, axis=None):\n\n            def f(x):\n                raise ValueError('This is a test')\n            new = super()._setup(data, prop, axis)\n            new._pipeline = [f]\n            return new\n    x = y = color = [1, 2]\n    p = Plot(x, y, color=color).add(Dot()).scale(color=ErrorRaising())\n    msg = 'Scaling operation failed for the `color` variable.'\n    with pytest.raises(PlotSpecError, match=msg) as err:\n        p.plot()\n    assert isinstance(err.value.__cause__, ValueError)\n    assert (str(err.value.__cause__) == 'This is a test')", "masked_code": "def test_semantic_scaling(self):\n\n    class ErrorRaising(Continuous):\n\n        def _setup(self, data, prop, axis=None):\n\n            def f(x):\n                raise ValueError('This is a test')\n            new = super()._setup(data, prop, axis)\n            new._pipeline = [f]\n            return new\n    x = y = color = [1, 2]\n    p = Plot(x, y, color=color).add(Dot()).scale(color=ErrorRaising())\n    msg = 'Scaling operation failed for the `color` variable.'\n    with pytest.raises(PlotSpecError, match=msg) as err:\n        p.plot()\n    assert isinstance(err.value.__cause__, ValueError)\n    assert (str(err.value.__cause__) == '???')", "ground_truth": "'This is a test'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1073", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestFacetInterface", "funcname": "test_col_wrapping", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_col_wrapping(self):\n    cols = list('abcd')\n    wrap = 3\n    p = Plot().facet(col=cols, wrap=wrap).plot()\n    assert (len(p._figure.axes) == 4)\n    assert_gridspec_shape(p._figure.axes[0], ((len(cols) // wrap) + 1), wrap)", "masked_code": "def test_col_wrapping(self):\n    cols = list('abcd')\n    wrap = 3\n    p = Plot().facet(col=cols, wrap=wrap).plot()\n    assert (len(p._figure.axes) == '???')\n    assert_gridspec_shape(p._figure.axes[0], ((len(cols) // wrap) + 1), wrap)", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1074", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestFacetInterface", "funcname": "test_row_wrapping", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_row_wrapping(self):\n    rows = list('abcd')\n    wrap = 3\n    p = Plot().facet(row=rows, wrap=wrap).plot()\n    assert_gridspec_shape(p._figure.axes[0], wrap, ((len(rows) // wrap) + 1))\n    assert (len(p._figure.axes) == 4)", "masked_code": "def test_row_wrapping(self):\n    rows = list('abcd')\n    wrap = 3\n    p = Plot().facet(row=rows, wrap=wrap).plot()\n    assert_gridspec_shape(p._figure.axes[0], wrap, ((len(rows) // wrap) + 1))\n    assert (len(p._figure.axes) == '???')", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1075", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_non_cross", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_non_cross(self, long_df):\n    x = ['x', 'y']\n    y = ['f', 'z']\n    p = Plot(long_df).pair(x, y, cross=False).plot()\n    for (i, subplot) in enumerate(p._subplots):\n        ax = subplot['ax']\n        assert (ax.get_xlabel() == x[i])\n        assert (ax.get_ylabel() == y[i])\n        assert_gridspec_shape(ax, 1, len(x))\n    (root, *other) = p._figure.axes\n    for axis in 'xy':\n        shareset = getattr(root, f'get_shared_{axis}_axes')()\n        assert (not any((shareset.joined(root, ax) for ax in other)))", "masked_code": "def test_non_cross(self, long_df):\n    x = ['x', 'y']\n    y = ['f', 'z']\n    p = Plot(long_df).pair(x, y, cross=False).plot()\n    for (i, subplot) in enumerate(p._subplots):\n        ax = subplot['ax']\n        assert (ax.get_xlabel() == '???')\n        assert (ax.get_ylabel() == y[i])\n        assert_gridspec_shape(ax, 1, len(x))\n    (root, *other) = p._figure.axes\n    for axis in 'xy':\n        shareset = getattr(root, f'get_shared_{axis}_axes')()\n        assert (not any((shareset.joined(root, ax) for ax in other)))", "ground_truth": "x[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1076", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_non_cross", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_non_cross(self, long_df):\n    x = ['x', 'y']\n    y = ['f', 'z']\n    p = Plot(long_df).pair(x, y, cross=False).plot()\n    for (i, subplot) in enumerate(p._subplots):\n        ax = subplot['ax']\n        assert (ax.get_xlabel() == x[i])\n        assert (ax.get_ylabel() == y[i])\n        assert_gridspec_shape(ax, 1, len(x))\n    (root, *other) = p._figure.axes\n    for axis in 'xy':\n        shareset = getattr(root, f'get_shared_{axis}_axes')()\n        assert (not any((shareset.joined(root, ax) for ax in other)))", "masked_code": "def test_non_cross(self, long_df):\n    x = ['x', 'y']\n    y = ['f', 'z']\n    p = Plot(long_df).pair(x, y, cross=False).plot()\n    for (i, subplot) in enumerate(p._subplots):\n        ax = subplot['ax']\n        assert (ax.get_xlabel() == x[i])\n        assert (ax.get_ylabel() == '???')\n        assert_gridspec_shape(ax, 1, len(x))\n    (root, *other) = p._figure.axes\n    for axis in 'xy':\n        shareset = getattr(root, f'get_shared_{axis}_axes')()\n        assert (not any((shareset.joined(root, ax) for ax in other)))", "ground_truth": "y[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1077", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_list_of_vectors", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_list_of_vectors(self, long_df):\n    x_vars = ['x', 'z']\n    p = Plot(long_df, y='y').pair(x=[long_df[x] for x in x_vars]).plot()\n    assert (len(p._figure.axes) == len(x_vars))\n    for (ax, x_i) in zip(p._figure.axes, x_vars):\n        assert (ax.get_xlabel() == x_i)", "masked_code": "def test_list_of_vectors(self, long_df):\n    x_vars = ['x', 'z']\n    p = Plot(long_df, y='y').pair(x=[long_df[x] for x in x_vars]).plot()\n    assert (len(p._figure.axes) == '???')\n    for (ax, x_i) in zip(p._figure.axes, x_vars):\n        assert (ax.get_xlabel() == x_i)", "ground_truth": "len(x_vars)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1078", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_list_of_vectors", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_list_of_vectors(self, long_df):\n    x_vars = ['x', 'z']\n    p = Plot(long_df, y='y').pair(x=[long_df[x] for x in x_vars]).plot()\n    assert (len(p._figure.axes) == len(x_vars))\n    for (ax, x_i) in zip(p._figure.axes, x_vars):\n        assert (ax.get_xlabel() == x_i)", "masked_code": "def test_list_of_vectors(self, long_df):\n    x_vars = ['x', 'z']\n    p = Plot(long_df, y='y').pair(x=[long_df[x] for x in x_vars]).plot()\n    assert (len(p._figure.axes) == len(x_vars))\n    for (ax, x_i) in zip(p._figure.axes, x_vars):\n        assert (ax.get_xlabel() == '???')", "ground_truth": "x_i", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1079", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_with_facets", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_with_facets(self, long_df):\n    x = 'x'\n    y = ['y', 'z']\n    col = 'a'\n    p = Plot(long_df, x=x).facet(col).pair(y=y).plot()\n    facet_levels = categorical_order(long_df[col])\n    dims = itertools.product(y, facet_levels)\n    for ((y_i, col_i), subplot) in zip(dims, p._subplots):\n        ax = subplot['ax']\n        assert (ax.get_xlabel() == x)\n        assert (ax.get_ylabel() == y_i)\n        assert (ax.get_title() == f'{col_i}')\n        assert_gridspec_shape(ax, len(y), len(facet_levels))", "masked_code": "def test_with_facets(self, long_df):\n    x = 'x'\n    y = ['y', 'z']\n    col = 'a'\n    p = Plot(long_df, x=x).facet(col).pair(y=y).plot()\n    facet_levels = categorical_order(long_df[col])\n    dims = itertools.product(y, facet_levels)\n    for ((y_i, col_i), subplot) in zip(dims, p._subplots):\n        ax = subplot['ax']\n        assert (ax.get_xlabel() == '???')\n        assert (ax.get_ylabel() == y_i)\n        assert (ax.get_title() == f'{col_i}')\n        assert_gridspec_shape(ax, len(y), len(facet_levels))", "ground_truth": "x", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1080", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_with_facets", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_with_facets(self, long_df):\n    x = 'x'\n    y = ['y', 'z']\n    col = 'a'\n    p = Plot(long_df, x=x).facet(col).pair(y=y).plot()\n    facet_levels = categorical_order(long_df[col])\n    dims = itertools.product(y, facet_levels)\n    for ((y_i, col_i), subplot) in zip(dims, p._subplots):\n        ax = subplot['ax']\n        assert (ax.get_xlabel() == x)\n        assert (ax.get_ylabel() == y_i)\n        assert (ax.get_title() == f'{col_i}')\n        assert_gridspec_shape(ax, len(y), len(facet_levels))", "masked_code": "def test_with_facets(self, long_df):\n    x = 'x'\n    y = ['y', 'z']\n    col = 'a'\n    p = Plot(long_df, x=x).facet(col).pair(y=y).plot()\n    facet_levels = categorical_order(long_df[col])\n    dims = itertools.product(y, facet_levels)\n    for ((y_i, col_i), subplot) in zip(dims, p._subplots):\n        ax = subplot['ax']\n        assert (ax.get_xlabel() == x)\n        assert (ax.get_ylabel() == '???')\n        assert (ax.get_title() == f'{col_i}')\n        assert_gridspec_shape(ax, len(y), len(facet_levels))", "ground_truth": "y_i", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1081", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_with_facets", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_with_facets(self, long_df):\n    x = 'x'\n    y = ['y', 'z']\n    col = 'a'\n    p = Plot(long_df, x=x).facet(col).pair(y=y).plot()\n    facet_levels = categorical_order(long_df[col])\n    dims = itertools.product(y, facet_levels)\n    for ((y_i, col_i), subplot) in zip(dims, p._subplots):\n        ax = subplot['ax']\n        assert (ax.get_xlabel() == x)\n        assert (ax.get_ylabel() == y_i)\n        assert (ax.get_title() == f'{col_i}')\n        assert_gridspec_shape(ax, len(y), len(facet_levels))", "masked_code": "def test_with_facets(self, long_df):\n    x = 'x'\n    y = ['y', 'z']\n    col = 'a'\n    p = Plot(long_df, x=x).facet(col).pair(y=y).plot()\n    facet_levels = categorical_order(long_df[col])\n    dims = itertools.product(y, facet_levels)\n    for ((y_i, col_i), subplot) in zip(dims, p._subplots):\n        ax = subplot['ax']\n        assert (ax.get_xlabel() == x)\n        assert (ax.get_ylabel() == y_i)\n        assert (ax.get_title() == '???')\n        assert_gridspec_shape(ax, len(y), len(facet_levels))", "ground_truth": "f'{col_i}'", "quality_analysis": {"complexity_score": 3, "left_complexity": 3, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1082", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_x_wrapping", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_x_wrapping(self, long_df):\n    x_vars = ['f', 'x', 'y', 'z']\n    wrap = 3\n    p = Plot(long_df, y='y').pair(x=x_vars, wrap=wrap).plot()\n    assert_gridspec_shape(p._figure.axes[0], ((len(x_vars) // wrap) + 1), wrap)\n    assert (len(p._figure.axes) == len(x_vars))\n    for (ax, var) in zip(p._figure.axes, x_vars):\n        label = ax.xaxis.get_label()\n        assert label.get_visible()\n        assert (label.get_text() == var)", "masked_code": "def test_x_wrapping(self, long_df):\n    x_vars = ['f', 'x', 'y', 'z']\n    wrap = 3\n    p = Plot(long_df, y='y').pair(x=x_vars, wrap=wrap).plot()\n    assert_gridspec_shape(p._figure.axes[0], ((len(x_vars) // wrap) + 1), wrap)\n    assert (len(p._figure.axes) == '???')\n    for (ax, var) in zip(p._figure.axes, x_vars):\n        label = ax.xaxis.get_label()\n        assert label.get_visible()\n        assert (label.get_text() == var)", "ground_truth": "len(x_vars)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1083", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_x_wrapping", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_x_wrapping(self, long_df):\n    x_vars = ['f', 'x', 'y', 'z']\n    wrap = 3\n    p = Plot(long_df, y='y').pair(x=x_vars, wrap=wrap).plot()\n    assert_gridspec_shape(p._figure.axes[0], ((len(x_vars) // wrap) + 1), wrap)\n    assert (len(p._figure.axes) == len(x_vars))\n    for (ax, var) in zip(p._figure.axes, x_vars):\n        label = ax.xaxis.get_label()\n        assert label.get_visible()\n        assert (label.get_text() == var)", "masked_code": "def test_x_wrapping(self, long_df):\n    x_vars = ['f', 'x', 'y', 'z']\n    wrap = 3\n    p = Plot(long_df, y='y').pair(x=x_vars, wrap=wrap).plot()\n    assert_gridspec_shape(p._figure.axes[0], ((len(x_vars) // wrap) + 1), wrap)\n    assert (len(p._figure.axes) == len(x_vars))\n    for (ax, var) in zip(p._figure.axes, x_vars):\n        label = ax.xaxis.get_label()\n        assert label.get_visible()\n        assert (label.get_text() == '???')", "ground_truth": "var", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1084", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_y_wrapping", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_y_wrapping(self, long_df):\n    y_vars = ['f', 'x', 'y', 'z']\n    wrap = 3\n    p = Plot(long_df, x='x').pair(y=y_vars, wrap=wrap).plot()\n    (n_row, n_col) = (wrap, ((len(y_vars) // wrap) + 1))\n    assert_gridspec_shape(p._figure.axes[0], n_row, n_col)\n    assert (len(p._figure.axes) == len(y_vars))\n    label_array = np.empty((n_row * n_col), object)\n    label_array[:len(y_vars)] = y_vars\n    label_array = label_array.reshape((n_row, n_col), order='F')\n    label_array = [y for y in label_array.flat if (y is not None)]\n    for (i, ax) in enumerate(p._figure.axes):\n        label = ax.yaxis.get_label()\n        assert label.get_visible()\n        assert (label.get_text() == label_array[i])", "masked_code": "def test_y_wrapping(self, long_df):\n    y_vars = ['f', 'x', 'y', 'z']\n    wrap = 3\n    p = Plot(long_df, x='x').pair(y=y_vars, wrap=wrap).plot()\n    (n_row, n_col) = (wrap, ((len(y_vars) // wrap) + 1))\n    assert_gridspec_shape(p._figure.axes[0], n_row, n_col)\n    assert (len(p._figure.axes) == '???')\n    label_array = np.empty((n_row * n_col), object)\n    label_array[:len(y_vars)] = y_vars\n    label_array = label_array.reshape((n_row, n_col), order='F')\n    label_array = [y for y in label_array.flat if (y is not None)]\n    for (i, ax) in enumerate(p._figure.axes):\n        label = ax.yaxis.get_label()\n        assert label.get_visible()\n        assert (label.get_text() == label_array[i])", "ground_truth": "len(y_vars)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1085", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_y_wrapping", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_y_wrapping(self, long_df):\n    y_vars = ['f', 'x', 'y', 'z']\n    wrap = 3\n    p = Plot(long_df, x='x').pair(y=y_vars, wrap=wrap).plot()\n    (n_row, n_col) = (wrap, ((len(y_vars) // wrap) + 1))\n    assert_gridspec_shape(p._figure.axes[0], n_row, n_col)\n    assert (len(p._figure.axes) == len(y_vars))\n    label_array = np.empty((n_row * n_col), object)\n    label_array[:len(y_vars)] = y_vars\n    label_array = label_array.reshape((n_row, n_col), order='F')\n    label_array = [y for y in label_array.flat if (y is not None)]\n    for (i, ax) in enumerate(p._figure.axes):\n        label = ax.yaxis.get_label()\n        assert label.get_visible()\n        assert (label.get_text() == label_array[i])", "masked_code": "def test_y_wrapping(self, long_df):\n    y_vars = ['f', 'x', 'y', 'z']\n    wrap = 3\n    p = Plot(long_df, x='x').pair(y=y_vars, wrap=wrap).plot()\n    (n_row, n_col) = (wrap, ((len(y_vars) // wrap) + 1))\n    assert_gridspec_shape(p._figure.axes[0], n_row, n_col)\n    assert (len(p._figure.axes) == len(y_vars))\n    label_array = np.empty((n_row * n_col), object)\n    label_array[:len(y_vars)] = y_vars\n    label_array = label_array.reshape((n_row, n_col), order='F')\n    label_array = [y for y in label_array.flat if (y is not None)]\n    for (i, ax) in enumerate(p._figure.axes):\n        label = ax.yaxis.get_label()\n        assert label.get_visible()\n        assert (label.get_text() == '???')", "ground_truth": "label_array[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1086", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_non_cross_wrapping", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_non_cross_wrapping(self, long_df):\n    x_vars = ['a', 'b', 'c', 't']\n    y_vars = ['f', 'x', 'y', 'z']\n    wrap = 3\n    p = Plot(long_df, x='x').pair(x=x_vars, y=y_vars, wrap=wrap, cross=False).plot()\n    assert_gridspec_shape(p._figure.axes[0], ((len(x_vars) // wrap) + 1), wrap)\n    assert (len(p._figure.axes) == len(x_vars))", "masked_code": "def test_non_cross_wrapping(self, long_df):\n    x_vars = ['a', 'b', 'c', 't']\n    y_vars = ['f', 'x', 'y', 'z']\n    wrap = 3\n    p = Plot(long_df, x='x').pair(x=x_vars, y=y_vars, wrap=wrap, cross=False).plot()\n    assert_gridspec_shape(p._figure.axes[0], ((len(x_vars) // wrap) + 1), wrap)\n    assert (len(p._figure.axes) == '???')", "ground_truth": "len(x_vars)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1087", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_limits", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_limits(self, long_df):\n    lims = (((- 3), 10), ((- 2), 24))\n    p = Plot(long_df, y='y').pair(x=['x', 'z']).limit(x=lims[0], x1=lims[1]).plot()\n    for (ax, lim) in zip(p._figure.axes, lims):\n        assert (ax.get_xlim() == lim)", "masked_code": "def test_limits(self, long_df):\n    lims = (((- 3), 10), ((- 2), 24))\n    p = Plot(long_df, y='y').pair(x=['x', 'z']).limit(x=lims[0], x1=lims[1]).plot()\n    for (ax, lim) in zip(p._figure.axes, lims):\n        assert (ax.get_xlim() == '???')", "ground_truth": "lim", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1088", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestPairInterface", "funcname": "test_labels", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_labels(self, long_df):\n    label = 'zed'\n    p = Plot(long_df, y='y').pair(x=['x', 'z']).label(x=str.capitalize, x1=label)\n    (ax0, ax1) = p.plot()._figure.axes\n    assert (ax0.get_xlabel() == 'X')\n    assert (ax1.get_xlabel() == label)", "masked_code": "def test_labels(self, long_df):\n    label = 'zed'\n    p = Plot(long_df, y='y').pair(x=['x', 'z']).label(x=str.capitalize, x1=label)\n    (ax0, ax1) = p.plot()._figure.axes\n    assert (ax0.get_xlabel() == 'X')\n    assert (ax1.get_xlabel() == '???')", "ground_truth": "label", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1089", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_single_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy).add(MockMark(), color=s).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == ['color'])", "masked_code": "def test_single_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy).add(MockMark(), color=s).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == '???')\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == ['color'])", "ground_truth": "(s.name, s.name)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1090", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_single_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy).add(MockMark(), color=s).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == ['color'])", "masked_code": "def test_single_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy).add(MockMark(), color=s).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == '???')\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == ['color'])", "ground_truth": "labels", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1091", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_single_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy).add(MockMark(), color=s).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == ['color'])", "masked_code": "def test_single_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy).add(MockMark(), color=s).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == '???')\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == ['color'])", "ground_truth": "len(labels)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1092", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_single_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy).add(MockMark(), color=s).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == ['color'])", "masked_code": "def test_single_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy).add(MockMark(), color=s).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == '???')\n        assert (a.variables == ['color'])", "ground_truth": "label", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1093", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_single_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy).add(MockMark(), color=s).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == ['color'])", "masked_code": "def test_single_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy).add(MockMark(), color=s).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == '???')", "ground_truth": "['color']", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1094", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_common_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_common_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "masked_code": "def test_single_layer_common_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == '???')\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "ground_truth": "(s.name, s.name)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1095", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_common_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_common_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "masked_code": "def test_single_layer_common_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == '???')\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "ground_truth": "labels", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1096", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_common_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_common_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "masked_code": "def test_single_layer_common_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == '???')\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "ground_truth": "len(labels)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1097", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_common_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_common_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "masked_code": "def test_single_layer_common_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == '???')\n        assert (a.variables == list(sem))", "ground_truth": "label", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1098", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_common_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_common_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "masked_code": "def test_single_layer_common_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = categorical_order(s)\n    assert (e[0] == (s.name, s.name))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == '???')", "ground_truth": "list(sem)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1099", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_common_unnamed_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_common_unnamed_variable(self, xy):\n    s = np.array(['a', 'b', 'a', 'c'])\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = list(np.unique(s))\n    assert (e[0] == ('', id(s)))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "masked_code": "def test_single_layer_common_unnamed_variable(self, xy):\n    s = np.array(['a', 'b', 'a', 'c'])\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = list(np.unique(s))\n    assert (e[0] == '???')\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "ground_truth": "('', id(s))", "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1100", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_common_unnamed_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_common_unnamed_variable(self, xy):\n    s = np.array(['a', 'b', 'a', 'c'])\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = list(np.unique(s))\n    assert (e[0] == ('', id(s)))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "masked_code": "def test_single_layer_common_unnamed_variable(self, xy):\n    s = np.array(['a', 'b', 'a', 'c'])\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = list(np.unique(s))\n    assert (e[0] == ('', id(s)))\n    assert (e[(- 1)] == '???')\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "ground_truth": "labels", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1101", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_common_unnamed_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_common_unnamed_variable(self, xy):\n    s = np.array(['a', 'b', 'a', 'c'])\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = list(np.unique(s))\n    assert (e[0] == ('', id(s)))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "masked_code": "def test_single_layer_common_unnamed_variable(self, xy):\n    s = np.array(['a', 'b', 'a', 'c'])\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = list(np.unique(s))\n    assert (e[0] == ('', id(s)))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == '???')\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "ground_truth": "len(labels)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1102", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_common_unnamed_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_common_unnamed_variable(self, xy):\n    s = np.array(['a', 'b', 'a', 'c'])\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = list(np.unique(s))\n    assert (e[0] == ('', id(s)))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "masked_code": "def test_single_layer_common_unnamed_variable(self, xy):\n    s = np.array(['a', 'b', 'a', 'c'])\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = list(np.unique(s))\n    assert (e[0] == ('', id(s)))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == '???')\n        assert (a.variables == list(sem))", "ground_truth": "label", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1103", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_common_unnamed_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_common_unnamed_variable(self, xy):\n    s = np.array(['a', 'b', 'a', 'c'])\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = list(np.unique(s))\n    assert (e[0] == ('', id(s)))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == list(sem))", "masked_code": "def test_single_layer_common_unnamed_variable(self, xy):\n    s = np.array(['a', 'b', 'a', 'c'])\n    sem = dict(color=s, marker=s)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e,) = p._legend_contents\n    labels = list(np.unique(s))\n    assert (e[0] == ('', id(s)))\n    assert (e[(- 1)] == labels)\n    artists = e[1]\n    assert (len(artists) == len(labels))\n    for (a, label) in zip(artists, labels):\n        assert isinstance(a, mpl.artist.Artist)\n        assert (a.value == label)\n        assert (a.variables == '???')", "ground_truth": "list(sem)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1104", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_multi_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = dict(color=s1, marker=s2)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e1, e2) = p._legend_contents\n    variables = {v.name: k for (k, v) in sem.items()}\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "masked_code": "def test_single_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = dict(color=s1, marker=s2)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e1, e2) = p._legend_contents\n    variables = {v.name: k for (k, v) in sem.items()}\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == '???')\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "ground_truth": "(s.name, s.name)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1105", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_multi_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = dict(color=s1, marker=s2)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e1, e2) = p._legend_contents\n    variables = {v.name: k for (k, v) in sem.items()}\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "masked_code": "def test_single_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = dict(color=s1, marker=s2)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e1, e2) = p._legend_contents\n    variables = {v.name: k for (k, v) in sem.items()}\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == '???')\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "ground_truth": "labels", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1106", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_multi_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = dict(color=s1, marker=s2)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e1, e2) = p._legend_contents\n    variables = {v.name: k for (k, v) in sem.items()}\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "masked_code": "def test_single_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = dict(color=s1, marker=s2)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e1, e2) = p._legend_contents\n    variables = {v.name: k for (k, v) in sem.items()}\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == '???')\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "ground_truth": "len(labels)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1107", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_multi_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = dict(color=s1, marker=s2)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e1, e2) = p._legend_contents\n    variables = {v.name: k for (k, v) in sem.items()}\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "masked_code": "def test_single_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = dict(color=s1, marker=s2)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e1, e2) = p._legend_contents\n    variables = {v.name: k for (k, v) in sem.items()}\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == '???')\n            assert (a.variables == [variables[s.name]])", "ground_truth": "label", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1108", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_single_layer_multi_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_single_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = dict(color=s1, marker=s2)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e1, e2) = p._legend_contents\n    variables = {v.name: k for (k, v) in sem.items()}\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "masked_code": "def test_single_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = dict(color=s1, marker=s2)\n    p = Plot(**xy).add(MockMark(), **sem).plot()\n    (e1, e2) = p._legend_contents\n    variables = {v.name: k for (k, v) in sem.items()}\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == '???')", "ground_truth": "[variables[s.name]]", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1109", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_multi_layer_single_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_multi_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark()).add(MockMark()).plot()\n    (e1, e2) = p._legend_contents\n    labels = categorical_order(s)\n    for e in [e1, e2]:\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == ['color'])", "masked_code": "def test_multi_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark()).add(MockMark()).plot()\n    (e1, e2) = p._legend_contents\n    labels = categorical_order(s)\n    for e in [e1, e2]:\n        assert (e[0] == '???')\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == ['color'])", "ground_truth": "(s.name, s.name)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1110", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_multi_layer_single_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_multi_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark()).add(MockMark()).plot()\n    (e1, e2) = p._legend_contents\n    labels = categorical_order(s)\n    for e in [e1, e2]:\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == ['color'])", "masked_code": "def test_multi_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark()).add(MockMark()).plot()\n    (e1, e2) = p._legend_contents\n    labels = categorical_order(s)\n    for e in [e1, e2]:\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == '???')\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == ['color'])", "ground_truth": "labels", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1111", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_multi_layer_single_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_multi_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark()).add(MockMark()).plot()\n    (e1, e2) = p._legend_contents\n    labels = categorical_order(s)\n    for e in [e1, e2]:\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == ['color'])", "masked_code": "def test_multi_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark()).add(MockMark()).plot()\n    (e1, e2) = p._legend_contents\n    labels = categorical_order(s)\n    for e in [e1, e2]:\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == '???')\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == ['color'])", "ground_truth": "len(labels)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1112", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_multi_layer_single_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_multi_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark()).add(MockMark()).plot()\n    (e1, e2) = p._legend_contents\n    labels = categorical_order(s)\n    for e in [e1, e2]:\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == ['color'])", "masked_code": "def test_multi_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark()).add(MockMark()).plot()\n    (e1, e2) = p._legend_contents\n    labels = categorical_order(s)\n    for e in [e1, e2]:\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == '???')\n            assert (a.variables == ['color'])", "ground_truth": "label", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1113", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_multi_layer_single_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_multi_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark()).add(MockMark()).plot()\n    (e1, e2) = p._legend_contents\n    labels = categorical_order(s)\n    for e in [e1, e2]:\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == ['color'])", "masked_code": "def test_multi_layer_single_variable(self, xy):\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark()).add(MockMark()).plot()\n    (e1, e2) = p._legend_contents\n    labels = categorical_order(s)\n    for e in [e1, e2]:\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == '???')", "ground_truth": "['color']", "quality_analysis": {"complexity_score": 5, "left_complexity": 2, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1114", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_multi_layer_multi_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_multi_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = (dict(color=s1), dict(marker=s2))\n    variables = {'s1': 'color', 's2': 'marker'}\n    p = Plot(**xy).add(MockMark(), **sem[0]).add(MockMark(), **sem[1]).plot()\n    (e1, e2) = p._legend_contents\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "masked_code": "def test_multi_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = (dict(color=s1), dict(marker=s2))\n    variables = {'s1': 'color', 's2': 'marker'}\n    p = Plot(**xy).add(MockMark(), **sem[0]).add(MockMark(), **sem[1]).plot()\n    (e1, e2) = p._legend_contents\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == '???')\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "ground_truth": "(s.name, s.name)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1115", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_multi_layer_multi_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_multi_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = (dict(color=s1), dict(marker=s2))\n    variables = {'s1': 'color', 's2': 'marker'}\n    p = Plot(**xy).add(MockMark(), **sem[0]).add(MockMark(), **sem[1]).plot()\n    (e1, e2) = p._legend_contents\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "masked_code": "def test_multi_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = (dict(color=s1), dict(marker=s2))\n    variables = {'s1': 'color', 's2': 'marker'}\n    p = Plot(**xy).add(MockMark(), **sem[0]).add(MockMark(), **sem[1]).plot()\n    (e1, e2) = p._legend_contents\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == '???')\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "ground_truth": "labels", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1116", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_multi_layer_multi_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_multi_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = (dict(color=s1), dict(marker=s2))\n    variables = {'s1': 'color', 's2': 'marker'}\n    p = Plot(**xy).add(MockMark(), **sem[0]).add(MockMark(), **sem[1]).plot()\n    (e1, e2) = p._legend_contents\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "masked_code": "def test_multi_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = (dict(color=s1), dict(marker=s2))\n    variables = {'s1': 'color', 's2': 'marker'}\n    p = Plot(**xy).add(MockMark(), **sem[0]).add(MockMark(), **sem[1]).plot()\n    (e1, e2) = p._legend_contents\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == '???')\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "ground_truth": "len(labels)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1117", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_multi_layer_multi_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_multi_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = (dict(color=s1), dict(marker=s2))\n    variables = {'s1': 'color', 's2': 'marker'}\n    p = Plot(**xy).add(MockMark(), **sem[0]).add(MockMark(), **sem[1]).plot()\n    (e1, e2) = p._legend_contents\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "masked_code": "def test_multi_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = (dict(color=s1), dict(marker=s2))\n    variables = {'s1': 'color', 's2': 'marker'}\n    p = Plot(**xy).add(MockMark(), **sem[0]).add(MockMark(), **sem[1]).plot()\n    (e1, e2) = p._legend_contents\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == '???')\n            assert (a.variables == [variables[s.name]])", "ground_truth": "label", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1118", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_multi_layer_multi_variable", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_multi_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = (dict(color=s1), dict(marker=s2))\n    variables = {'s1': 'color', 's2': 'marker'}\n    p = Plot(**xy).add(MockMark(), **sem[0]).add(MockMark(), **sem[1]).plot()\n    (e1, e2) = p._legend_contents\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == [variables[s.name]])", "masked_code": "def test_multi_layer_multi_variable(self, xy):\n    s1 = pd.Series(['a', 'b', 'a', 'c'], name='s1')\n    s2 = pd.Series(['m', 'm', 'p', 'm'], name='s2')\n    sem = (dict(color=s1), dict(marker=s2))\n    variables = {'s1': 'color', 's2': 'marker'}\n    p = Plot(**xy).add(MockMark(), **sem[0]).add(MockMark(), **sem[1]).plot()\n    (e1, e2) = p._legend_contents\n    for (e, s) in zip([e1, e2], [s1, s2]):\n        assert (e[0] == (s.name, s.name))\n        labels = categorical_order(s)\n        assert (e[(- 1)] == labels)\n        artists = e[1]\n        assert (len(artists) == len(labels))\n        for (a, label) in zip(artists, labels):\n            assert isinstance(a, mpl.artist.Artist)\n            assert (a.value == label)\n            assert (a.variables == '???')", "ground_truth": "[variables[s.name]]", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1119", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_multi_layer_different_artists", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_multi_layer_different_artists(self, xy):\n\n    class MockMark1(MockMark):\n\n        def _legend_artist(self, variables, value, scales):\n            return mpl.lines.Line2D([], [])\n\n    class MockMark2(MockMark):\n\n        def _legend_artist(self, variables, value, scales):\n            return mpl.patches.Patch()\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark1()).add(MockMark2()).plot()\n    (legend,) = p._figure.legends\n    names = categorical_order(s)\n    labels = [t.get_text() for t in legend.get_texts()]\n    assert (labels == names)\n    if (not _version_predates(mpl, '3.5')):\n        contents = legend.get_children()[0]\n        assert (len(contents.findobj(mpl.lines.Line2D)) == len(names))\n        assert (len(contents.findobj(mpl.patches.Patch)) == len(names))", "masked_code": "def test_multi_layer_different_artists(self, xy):\n\n    class MockMark1(MockMark):\n\n        def _legend_artist(self, variables, value, scales):\n            return mpl.lines.Line2D([], [])\n\n    class MockMark2(MockMark):\n\n        def _legend_artist(self, variables, value, scales):\n            return mpl.patches.Patch()\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark1()).add(MockMark2()).plot()\n    (legend,) = p._figure.legends\n    names = categorical_order(s)\n    labels = [t.get_text() for t in legend.get_texts()]\n    assert (labels == names)\n    if (not _version_predates(mpl, '3.5')):\n        contents = legend.get_children()[0]\n        assert (len(contents.findobj(mpl.lines.Line2D)) == '???')\n        assert (len(contents.findobj(mpl.patches.Patch)) == len(names))", "ground_truth": "len(names)", "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1120", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_multi_layer_different_artists", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_multi_layer_different_artists(self, xy):\n\n    class MockMark1(MockMark):\n\n        def _legend_artist(self, variables, value, scales):\n            return mpl.lines.Line2D([], [])\n\n    class MockMark2(MockMark):\n\n        def _legend_artist(self, variables, value, scales):\n            return mpl.patches.Patch()\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark1()).add(MockMark2()).plot()\n    (legend,) = p._figure.legends\n    names = categorical_order(s)\n    labels = [t.get_text() for t in legend.get_texts()]\n    assert (labels == names)\n    if (not _version_predates(mpl, '3.5')):\n        contents = legend.get_children()[0]\n        assert (len(contents.findobj(mpl.lines.Line2D)) == len(names))\n        assert (len(contents.findobj(mpl.patches.Patch)) == len(names))", "masked_code": "def test_multi_layer_different_artists(self, xy):\n\n    class MockMark1(MockMark):\n\n        def _legend_artist(self, variables, value, scales):\n            return mpl.lines.Line2D([], [])\n\n    class MockMark2(MockMark):\n\n        def _legend_artist(self, variables, value, scales):\n            return mpl.patches.Patch()\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s).add(MockMark1()).add(MockMark2()).plot()\n    (legend,) = p._figure.legends\n    names = categorical_order(s)\n    labels = [t.get_text() for t in legend.get_texts()]\n    assert (labels == names)\n    if (not _version_predates(mpl, '3.5')):\n        contents = legend.get_children()[0]\n        assert (len(contents.findobj(mpl.lines.Line2D)) == len(names))\n        assert (len(contents.findobj(mpl.patches.Patch)) == '???')", "ground_truth": "len(names)", "quality_analysis": {"complexity_score": 12, "left_complexity": 8, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1121", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_three_layers", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_three_layers(self, xy):\n\n    class MockMarkLine(MockMark):\n\n        def _legend_artist(self, variables, value, scales):\n            return mpl.lines.Line2D([], [])\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s)\n    for _ in range(3):\n        p = p.add(MockMarkLine())\n    p = p.plot()\n    texts = p._figure.legends[0].get_texts()\n    assert (len(texts) == len(s.unique()))", "masked_code": "def test_three_layers(self, xy):\n\n    class MockMarkLine(MockMark):\n\n        def _legend_artist(self, variables, value, scales):\n            return mpl.lines.Line2D([], [])\n    s = pd.Series(['a', 'b', 'a', 'c'], name='s')\n    p = Plot(**xy, color=s)\n    for _ in range(3):\n        p = p.add(MockMarkLine())\n    p = p.plot()\n    texts = p._figure.legends[0].get_texts()\n    assert (len(texts) == '???')", "ground_truth": "len(s.unique())", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1122", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_layer_legend", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_layer_legend(self, xy):\n    p = Plot(**xy).add(MockMark(), label='a').add(MockMark(), label='b').plot()\n    legend = p._figure.legends[0]\n    assert legend.texts\n    for (text, expected) in zip(legend.texts, 'ab'):\n        assert (text.get_text() == expected)", "masked_code": "def test_layer_legend(self, xy):\n    p = Plot(**xy).add(MockMark(), label='a').add(MockMark(), label='b').plot()\n    legend = p._figure.legends[0]\n    assert legend.texts\n    for (text, expected) in zip(legend.texts, 'ab'):\n        assert (text.get_text() == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1123", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestLegend", "funcname": "test_layer_legend_title", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_layer_legend_title(self, xy):\n    p = Plot(**xy).add(MockMark(), label='x').label(legend='layer').plot()\n    assert (p._figure.legends[0].get_title().get_text() == 'layer')", "masked_code": "def test_layer_legend_title(self, xy):\n    p = Plot(**xy).add(MockMark(), label='x').label(legend='layer').plot()\n    assert (p._figure.legends[0].get_title().get_text() == '???')", "ground_truth": "'layer'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1124", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestDefaultObject", "funcname": "test_default_repr", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_default_repr(self):\n    assert (repr(Default()) == '<default>')", "masked_code": "def test_default_repr(self):\n    assert (repr(Default()) == '???')", "ground_truth": "'<default>'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1125", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestThemeConfig", "funcname": "test_copy", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_copy(self):\n    (key, val) = ('axes.facecolor', '.95')\n    orig = Plot.config.theme[key]\n    theme = Plot.config.theme.copy()\n    theme.update({key: val})\n    assert (Plot.config.theme[key] == orig)", "masked_code": "def test_copy(self):\n    (key, val) = ('axes.facecolor', '.95')\n    orig = Plot.config.theme[key]\n    theme = Plot.config.theme.copy()\n    theme.update({key: val})\n    assert (Plot.config.theme[key] == '???')", "ground_truth": "orig", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1126", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestThemeConfig", "funcname": "test_html_repr", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_html_repr(self):\n    res = Plot.config.theme._repr_html_()\n    for tag in ['div', 'table', 'tr', 'td']:\n        assert (res.count(f'<{tag}') == res.count(f'</{tag}'))\n    for key in Plot.config.theme:\n        assert (f'<td>{key}:</td>' in res)", "masked_code": "def test_html_repr(self):\n    res = Plot.config.theme._repr_html_()\n    for tag in ['div', 'table', 'tr', 'td']:\n        assert (res.count(f'<{tag}') == '???')\n    for key in Plot.config.theme:\n        assert (f'<td>{key}:</td>' in res)", "ground_truth": "res.count(f'</{tag}')", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1127", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestDisplayConfig", "funcname": "test_png_format", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_png_format(self):\n    Plot.config.display['format'] = 'png'\n    assert (Plot()._repr_svg_() is None)\n    assert (Plot().plot()._repr_svg_() is None)\n\n    def assert_valid_png(p):\n        (data, metadata) = p._repr_png_()\n        img = Image.open(io.BytesIO(data))\n        assert (img.format == 'PNG')\n        assert (sorted(metadata) == ['height', 'width'])\n    assert_valid_png(Plot())\n    assert_valid_png(Plot().plot())", "masked_code": "def test_png_format(self):\n    Plot.config.display['format'] = 'png'\n    assert (Plot()._repr_svg_() is None)\n    assert (Plot().plot()._repr_svg_() is None)\n\n    def assert_valid_png(p):\n        (data, metadata) = p._repr_png_()\n        img = Image.open(io.BytesIO(data))\n        assert (img.format == '???')\n        assert (sorted(metadata) == ['height', 'width'])\n    assert_valid_png(Plot())\n    assert_valid_png(Plot().plot())", "ground_truth": "'PNG'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1128", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestDisplayConfig", "funcname": "test_png_format", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_png_format(self):\n    Plot.config.display['format'] = 'png'\n    assert (Plot()._repr_svg_() is None)\n    assert (Plot().plot()._repr_svg_() is None)\n\n    def assert_valid_png(p):\n        (data, metadata) = p._repr_png_()\n        img = Image.open(io.BytesIO(data))\n        assert (img.format == 'PNG')\n        assert (sorted(metadata) == ['height', 'width'])\n    assert_valid_png(Plot())\n    assert_valid_png(Plot().plot())", "masked_code": "def test_png_format(self):\n    Plot.config.display['format'] = 'png'\n    assert (Plot()._repr_svg_() is None)\n    assert (Plot().plot()._repr_svg_() is None)\n\n    def assert_valid_png(p):\n        (data, metadata) = p._repr_png_()\n        img = Image.open(io.BytesIO(data))\n        assert (img.format == 'PNG')\n        assert (sorted(metadata) == '???')\n    assert_valid_png(Plot())\n    assert_valid_png(Plot().plot())", "ground_truth": "['height', 'width']", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1129", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestDisplayConfig", "funcname": "test_svg_format", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_svg_format(self):\n    Plot.config.display['format'] = 'svg'\n    assert (Plot()._repr_png_() is None)\n    assert (Plot().plot()._repr_png_() is None)\n\n    def assert_valid_svg(p):\n        res = p._repr_svg_()\n        root = xml.etree.ElementTree.fromstring(res)\n        assert (root.tag == '{http://www.w3.org/2000/svg}svg')\n    assert_valid_svg(Plot())\n    assert_valid_svg(Plot().plot())", "masked_code": "def test_svg_format(self):\n    Plot.config.display['format'] = 'svg'\n    assert (Plot()._repr_png_() is None)\n    assert (Plot().plot()._repr_png_() is None)\n\n    def assert_valid_svg(p):\n        res = p._repr_svg_()\n        root = xml.etree.ElementTree.fromstring(res)\n        assert (root.tag == '???')\n    assert_valid_svg(Plot())\n    assert_valid_svg(Plot().plot())", "ground_truth": "'{http://www.w3.org/2000/svg}svg'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1130", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestDisplayConfig", "funcname": "test_png_scaling", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_png_scaling(self):\n    Plot.config.display['scaling'] = 1.0\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['scaling'] = 0.5\n    (res2, meta2) = Plot()._repr_png_()\n    assert ((meta1['width'] / 2) == meta2['width'])\n    assert ((meta1['height'] / 2) == meta2['height'])\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert (img1.size == img2.size)", "masked_code": "def test_png_scaling(self):\n    Plot.config.display['scaling'] = 1.0\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['scaling'] = 0.5\n    (res2, meta2) = Plot()._repr_png_()\n    assert ((meta1['width'] / 2) == '???')\n    assert ((meta1['height'] / 2) == meta2['height'])\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert (img1.size == img2.size)", "ground_truth": "meta2['width']", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1131", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestDisplayConfig", "funcname": "test_png_scaling", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_png_scaling(self):\n    Plot.config.display['scaling'] = 1.0\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['scaling'] = 0.5\n    (res2, meta2) = Plot()._repr_png_()\n    assert ((meta1['width'] / 2) == meta2['width'])\n    assert ((meta1['height'] / 2) == meta2['height'])\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert (img1.size == img2.size)", "masked_code": "def test_png_scaling(self):\n    Plot.config.display['scaling'] = 1.0\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['scaling'] = 0.5\n    (res2, meta2) = Plot()._repr_png_()\n    assert ((meta1['width'] / 2) == meta2['width'])\n    assert ((meta1['height'] / 2) == '???')\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert (img1.size == img2.size)", "ground_truth": "meta2['height']", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1132", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestDisplayConfig", "funcname": "test_png_scaling", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_png_scaling(self):\n    Plot.config.display['scaling'] = 1.0\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['scaling'] = 0.5\n    (res2, meta2) = Plot()._repr_png_()\n    assert ((meta1['width'] / 2) == meta2['width'])\n    assert ((meta1['height'] / 2) == meta2['height'])\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert (img1.size == img2.size)", "masked_code": "def test_png_scaling(self):\n    Plot.config.display['scaling'] = 1.0\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['scaling'] = 0.5\n    (res2, meta2) = Plot()._repr_png_()\n    assert ((meta1['width'] / 2) == meta2['width'])\n    assert ((meta1['height'] / 2) == meta2['height'])\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert (img1.size == '???')", "ground_truth": "img2.size", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1133", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestDisplayConfig", "funcname": "test_svg_scaling", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_svg_scaling(self):\n    Plot.config.display['format'] = 'svg'\n    Plot.config.display['scaling'] = 1.0\n    res1 = Plot()._repr_svg_()\n    Plot.config.display['scaling'] = 0.5\n    res2 = Plot()._repr_svg_()\n    root1 = xml.etree.ElementTree.fromstring(res1)\n    root2 = xml.etree.ElementTree.fromstring(res2)\n\n    def getdim(root, dim):\n        return float(root.attrib[dim][:(- 2)])\n    assert ((getdim(root1, 'width') / 2) == getdim(root2, 'width'))\n    assert ((getdim(root1, 'height') / 2) == getdim(root2, 'height'))", "masked_code": "def test_svg_scaling(self):\n    Plot.config.display['format'] = 'svg'\n    Plot.config.display['scaling'] = 1.0\n    res1 = Plot()._repr_svg_()\n    Plot.config.display['scaling'] = 0.5\n    res2 = Plot()._repr_svg_()\n    root1 = xml.etree.ElementTree.fromstring(res1)\n    root2 = xml.etree.ElementTree.fromstring(res2)\n\n    def getdim(root, dim):\n        return float(root.attrib[dim][:(- 2)])\n    assert ((getdim(root1, 'width') / 2) == '???')\n    assert ((getdim(root1, 'height') / 2) == getdim(root2, 'height'))", "ground_truth": "getdim(root2, 'width')", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1134", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestDisplayConfig", "funcname": "test_svg_scaling", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_svg_scaling(self):\n    Plot.config.display['format'] = 'svg'\n    Plot.config.display['scaling'] = 1.0\n    res1 = Plot()._repr_svg_()\n    Plot.config.display['scaling'] = 0.5\n    res2 = Plot()._repr_svg_()\n    root1 = xml.etree.ElementTree.fromstring(res1)\n    root2 = xml.etree.ElementTree.fromstring(res2)\n\n    def getdim(root, dim):\n        return float(root.attrib[dim][:(- 2)])\n    assert ((getdim(root1, 'width') / 2) == getdim(root2, 'width'))\n    assert ((getdim(root1, 'height') / 2) == getdim(root2, 'height'))", "masked_code": "def test_svg_scaling(self):\n    Plot.config.display['format'] = 'svg'\n    Plot.config.display['scaling'] = 1.0\n    res1 = Plot()._repr_svg_()\n    Plot.config.display['scaling'] = 0.5\n    res2 = Plot()._repr_svg_()\n    root1 = xml.etree.ElementTree.fromstring(res1)\n    root2 = xml.etree.ElementTree.fromstring(res2)\n\n    def getdim(root, dim):\n        return float(root.attrib[dim][:(- 2)])\n    assert ((getdim(root1, 'width') / 2) == getdim(root2, 'width'))\n    assert ((getdim(root1, 'height') / 2) == '???')", "ground_truth": "getdim(root2, 'height')", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1135", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestDisplayConfig", "funcname": "test_png_hidpi", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_png_hidpi(self):\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['hidpi'] = False\n    (res2, meta2) = Plot()._repr_png_()\n    assert (meta1['width'] == meta2['width'])\n    assert (meta1['height'] == meta2['height'])\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert ((img1.size[0] // 2) == img2.size[0])\n    assert ((img1.size[1] // 2) == img2.size[1])", "masked_code": "def test_png_hidpi(self):\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['hidpi'] = False\n    (res2, meta2) = Plot()._repr_png_()\n    assert (meta1['width'] == '???')\n    assert (meta1['height'] == meta2['height'])\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert ((img1.size[0] // 2) == img2.size[0])\n    assert ((img1.size[1] // 2) == img2.size[1])", "ground_truth": "meta2['width']", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1136", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestDisplayConfig", "funcname": "test_png_hidpi", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_png_hidpi(self):\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['hidpi'] = False\n    (res2, meta2) = Plot()._repr_png_()\n    assert (meta1['width'] == meta2['width'])\n    assert (meta1['height'] == meta2['height'])\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert ((img1.size[0] // 2) == img2.size[0])\n    assert ((img1.size[1] // 2) == img2.size[1])", "masked_code": "def test_png_hidpi(self):\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['hidpi'] = False\n    (res2, meta2) = Plot()._repr_png_()\n    assert (meta1['width'] == meta2['width'])\n    assert (meta1['height'] == '???')\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert ((img1.size[0] // 2) == img2.size[0])\n    assert ((img1.size[1] // 2) == img2.size[1])", "ground_truth": "meta2['height']", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1137", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestDisplayConfig", "funcname": "test_png_hidpi", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_png_hidpi(self):\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['hidpi'] = False\n    (res2, meta2) = Plot()._repr_png_()\n    assert (meta1['width'] == meta2['width'])\n    assert (meta1['height'] == meta2['height'])\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert ((img1.size[0] // 2) == img2.size[0])\n    assert ((img1.size[1] // 2) == img2.size[1])", "masked_code": "def test_png_hidpi(self):\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['hidpi'] = False\n    (res2, meta2) = Plot()._repr_png_()\n    assert (meta1['width'] == meta2['width'])\n    assert (meta1['height'] == meta2['height'])\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert ((img1.size[0] // 2) == '???')\n    assert ((img1.size[1] // 2) == img2.size[1])", "ground_truth": "img2.size[0]", "quality_analysis": {"complexity_score": 15, "left_complexity": 9, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1138", "reponame": "seaborn", "testpath": "tests/_core/test_plot.py", "testname": "test_plot.py", "classname": "TestDisplayConfig", "funcname": "test_png_hidpi", "imports": ["import io", "import xml", "import functools", "import itertools", "import warnings", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import matplotlib.pyplot as plt", "from PIL import Image", "import pytest", "from pandas.testing import assert_frame_equal, assert_series_equal", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot, PlotConfig, Default", "from seaborn._core.scales import Continuous, Nominal, Temporal", "from seaborn._core.moves import Move, Shift, Dodge", "from seaborn._core.rules import categorical_order", "from seaborn._core.exceptions import PlotSpecError", "from seaborn._marks.base import Mark", "from seaborn._stats.base import Stat", "from seaborn._marks.dot import Dot", "from seaborn._stats.aggregation import Agg", "from seaborn.utils import _version_predates"], "code": "def test_png_hidpi(self):\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['hidpi'] = False\n    (res2, meta2) = Plot()._repr_png_()\n    assert (meta1['width'] == meta2['width'])\n    assert (meta1['height'] == meta2['height'])\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert ((img1.size[0] // 2) == img2.size[0])\n    assert ((img1.size[1] // 2) == img2.size[1])", "masked_code": "def test_png_hidpi(self):\n    (res1, meta1) = Plot()._repr_png_()\n    Plot.config.display['hidpi'] = False\n    (res2, meta2) = Plot()._repr_png_()\n    assert (meta1['width'] == meta2['width'])\n    assert (meta1['height'] == meta2['height'])\n    img1 = Image.open(io.BytesIO(res1))\n    img2 = Image.open(io.BytesIO(res2))\n    assert ((img1.size[0] // 2) == img2.size[0])\n    assert ((img1.size[1] // 2) == '???')", "ground_truth": "img2.size[1]", "quality_analysis": {"complexity_score": 15, "left_complexity": 9, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1139", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "TestColor", "funcname": "test_inference", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "@pytest.mark.parametrize('values,data_type,scale_class', [('viridis', 'cat', Nominal), ('viridis', 'num', Continuous), ('viridis', 'bool', Boolean), ('muted', 'num', Nominal), (['r', 'g', 'b'], 'num', Nominal), ({2: 'r', 4: 'g', 8: 'b'}, 'num', Nominal), (('r', 'b'), 'num', Continuous), (('g', 'm'), 'cat', Nominal), (('c', 'y'), 'bool', Boolean), (get_colormap('inferno'), 'num', Continuous)])\ndef test_inference(self, values, data_type, scale_class, vectors):\n    scale = Color().infer_scale(values, vectors[data_type])\n    assert isinstance(scale, scale_class)\n    assert (scale.values == values)", "masked_code": "@pytest.mark.parametrize('values,data_type,scale_class', [('viridis', 'cat', Nominal), ('viridis', 'num', Continuous), ('viridis', 'bool', Boolean), ('muted', 'num', Nominal), (['r', 'g', 'b'], 'num', Nominal), ({2: 'r', 4: 'g', 8: 'b'}, 'num', Nominal), (('r', 'b'), 'num', Continuous), (('g', 'm'), 'cat', Nominal), (('c', 'y'), 'bool', Boolean), (get_colormap('inferno'), 'num', Continuous)])\ndef test_inference(self, values, data_type, scale_class, vectors):\n    scale = Color().infer_scale(values, vectors[data_type])\n    assert isinstance(scale, scale_class)\n    assert (scale.values == '???')", "ground_truth": "values", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1140", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "TestColor", "funcname": "test_standardization", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "masked_code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == '???')\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "ground_truth": "to_rgb('C3')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1141", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "TestColor", "funcname": "test_standardization", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "masked_code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == '???')\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "ground_truth": "to_rgb('dodgerblue')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1142", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "TestColor", "funcname": "test_standardization", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "masked_code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == '???')\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "ground_truth": "(0.1, 0.2, 0.3)", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1143", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "TestColor", "funcname": "test_standardization", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "masked_code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == '???')\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "ground_truth": "(0.1, 0.2, 0.3, 0.4)", "quality_analysis": {"complexity_score": 15, "left_complexity": 9, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1144", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "TestColor", "funcname": "test_standardization", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "masked_code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == '???')\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "ground_truth": "to_rgb('#123456')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1145", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "TestColor", "funcname": "test_standardization", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "masked_code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == '???')\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "ground_truth": "to_rgba('#12345678')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1146", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "TestColor", "funcname": "test_standardization", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "masked_code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == '???')\n    assert (f('#1234') == to_rgba('#1234'))", "ground_truth": "to_rgb('#123')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1147", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "TestColor", "funcname": "test_standardization", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == to_rgba('#1234'))", "masked_code": "def test_standardization(self):\n    f = Color().standardize\n    assert (f('C3') == to_rgb('C3'))\n    assert (f('dodgerblue') == to_rgb('dodgerblue'))\n    assert (f((0.1, 0.2, 0.3)) == (0.1, 0.2, 0.3))\n    assert (f((0.1, 0.2, 0.3, 0.4)) == (0.1, 0.2, 0.3, 0.4))\n    assert (f('#123456') == to_rgb('#123456'))\n    assert (f('#12345678') == to_rgba('#12345678'))\n    assert (f('#123') == to_rgb('#123'))\n    assert (f('#1234') == '???')", "ground_truth": "to_rgba('#1234')", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1148", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "ObjectPropertyBase", "funcname": "test_inference_list", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "@pytest.mark.parametrize('data_type', ['cat', 'num', 'bool'])\ndef test_inference_list(self, data_type, vectors):\n    scale = self.prop().infer_scale(self.values, vectors[data_type])\n    assert isinstance(scale, (Boolean if (data_type == 'bool') else Nominal))\n    assert (scale.values == self.values)", "masked_code": "@pytest.mark.parametrize('data_type', ['cat', 'num', 'bool'])\ndef test_inference_list(self, data_type, vectors):\n    scale = self.prop().infer_scale(self.values, vectors[data_type])\n    assert isinstance(scale, (Boolean if (data_type == 'bool') else Nominal))\n    assert (scale.values == '???')", "ground_truth": "self.values", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1149", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "ObjectPropertyBase", "funcname": "test_inference_dict", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "@pytest.mark.parametrize('data_type', ['cat', 'num', 'bool'])\ndef test_inference_dict(self, data_type, vectors):\n    x = vectors[data_type]\n    values = dict(zip(categorical_order(x), self.values))\n    scale = self.prop().infer_scale(values, x)\n    assert isinstance(scale, (Boolean if (data_type == 'bool') else Nominal))\n    assert (scale.values == values)", "masked_code": "@pytest.mark.parametrize('data_type', ['cat', 'num', 'bool'])\ndef test_inference_dict(self, data_type, vectors):\n    x = vectors[data_type]\n    values = dict(zip(categorical_order(x), self.values))\n    scale = self.prop().infer_scale(values, x)\n    assert isinstance(scale, (Boolean if (data_type == 'bool') else Nominal))\n    assert (scale.values == '???')", "ground_truth": "values", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1150", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "ObjectPropertyBase", "funcname": "test_unique_default_large_n", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "def test_unique_default_large_n(self):\n    n = 24\n    x = pd.Series(np.arange(n))\n    mapping = self.prop().get_mapping(Nominal(), x)\n    assert (len({self.unpack(x_i) for x_i in mapping(x)}) == n)", "masked_code": "def test_unique_default_large_n(self):\n    n = 24\n    x = pd.Series(np.arange(n))\n    mapping = self.prop().get_mapping(Nominal(), x)\n    assert (len({self.unpack(x_i) for x_i in mapping(x)}) == '???')", "ground_truth": "n", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1151", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "TestFill", "funcname": "test_inference_list", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "@pytest.mark.parametrize('data_type', ['cat', 'num', 'bool'])\ndef test_inference_list(self, data_type, vectors):\n    x = vectors[data_type]\n    scale = Fill().infer_scale([True, False], x)\n    assert isinstance(scale, (Boolean if (data_type == 'bool') else Nominal))\n    assert (scale.values == [True, False])", "masked_code": "@pytest.mark.parametrize('data_type', ['cat', 'num', 'bool'])\ndef test_inference_list(self, data_type, vectors):\n    x = vectors[data_type]\n    scale = Fill().infer_scale([True, False], x)\n    assert isinstance(scale, (Boolean if (data_type == 'bool') else Nominal))\n    assert (scale.values == '???')", "ground_truth": "[True, False]", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1152", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "TestFill", "funcname": "test_inference_dict", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "@pytest.mark.parametrize('data_type', ['cat', 'num', 'bool'])\ndef test_inference_dict(self, data_type, vectors):\n    x = vectors[data_type]\n    values = dict(zip(x.unique(), [True, False]))\n    scale = Fill().infer_scale(values, x)\n    assert isinstance(scale, (Boolean if (data_type == 'bool') else Nominal))\n    assert (scale.values == values)", "masked_code": "@pytest.mark.parametrize('data_type', ['cat', 'num', 'bool'])\ndef test_inference_dict(self, data_type, vectors):\n    x = vectors[data_type]\n    values = dict(zip(x.unique(), [True, False]))\n    scale = Fill().infer_scale(values, x)\n    assert isinstance(scale, (Boolean if (data_type == 'bool') else Nominal))\n    assert (scale.values == '???')", "ground_truth": "values", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1153", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "IntervalBase", "funcname": "test_inference", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "@pytest.mark.parametrize('arg,data_type,scale_class', [((1, 3), 'cat', Nominal), ((1, 3), 'num', Continuous), ((1, 3), 'bool', Boolean), ([1, 2, 3], 'cat', Nominal), ([1, 2, 3], 'num', Nominal), ([1, 3], 'bool', Boolean), ({'a': 1, 'b': 3, 'c': 2}, 'cat', Nominal), ({2: 1, 4: 3, 8: 2}, 'num', Nominal), ({True: 4, False: 2}, 'bool', Boolean)])\ndef test_inference(self, arg, data_type, scale_class, vectors):\n    x = vectors[data_type]\n    scale = self.prop().infer_scale(arg, x)\n    assert isinstance(scale, scale_class)\n    assert (scale.values == arg)", "masked_code": "@pytest.mark.parametrize('arg,data_type,scale_class', [((1, 3), 'cat', Nominal), ((1, 3), 'num', Continuous), ((1, 3), 'bool', Boolean), ([1, 2, 3], 'cat', Nominal), ([1, 2, 3], 'num', Nominal), ([1, 3], 'bool', Boolean), ({'a': 1, 'b': 3, 'c': 2}, 'cat', Nominal), ({2: 1, 4: 3, 8: 2}, 'num', Nominal), ({True: 4, False: 2}, 'bool', Boolean)])\ndef test_inference(self, arg, data_type, scale_class, vectors):\n    x = vectors[data_type]\n    scale = self.prop().infer_scale(arg, x)\n    assert isinstance(scale, scale_class)\n    assert (scale.values == '???')", "ground_truth": "arg", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1154", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "TestLineWidth", "funcname": "test_rcparam_default", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "def test_rcparam_default(self):\n    with mpl.rc_context({'lines.linewidth': 2}):\n        assert (self.prop().default_range == (1, 4))", "masked_code": "def test_rcparam_default(self):\n    with mpl.rc_context({'lines.linewidth': 2}):\n        assert (self.prop().default_range == '???')", "ground_truth": "(1, 4)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1155", "reponame": "seaborn", "testpath": "tests/_core/test_properties.py", "testname": "test_properties.py", "classname": "TestEdgeWidth", "funcname": "test_rcparam_default", "imports": ["import numpy as np", "import pandas as pd", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgb, to_rgba", "from matplotlib.markers import MarkerStyle", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.rules import categorical_order", "from seaborn._core.scales import Nominal, Continuous, Boolean", "from seaborn._core.properties import Alpha, Color, Coordinate, EdgeWidth, Fill, LineStyle, LineWidth, Marker, PointSize", "from seaborn._compat import get_colormap", "from seaborn.palettes import color_palette"], "code": "def test_rcparam_default(self):\n    with mpl.rc_context({'patch.linewidth': 2}):\n        assert (self.prop().default_range == (1, 4))", "masked_code": "def test_rcparam_default(self):\n    with mpl.rc_context({'patch.linewidth': 2}):\n        assert (self.prop().default_range == '???')", "ground_truth": "(1, 4)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1156", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == '???')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1157", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == '???')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1158", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == '???')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1159", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == '???')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1160", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == '???')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1161", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == '???')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1162", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == '???')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1163", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == '???')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1164", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == '???')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1165", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == '???')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1166", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == '???')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1167", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == '???')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'boolean'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1168", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == '???')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1169", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == '???')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1170", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == '???')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1171", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == '???')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'categorical'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1172", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == '???')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'boolean'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1173", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == '???')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'numeric'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1174", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == '???')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'boolean'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1175", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == '???')\n    assert (variable_type(s.astype(object)) == 'datetime')", "ground_truth": "'datetime'", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1176", "reponame": "seaborn", "testpath": "tests/_core/test_rules.py", "testname": "test_rules.py", "classname": null, "funcname": "test_variable_type", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from seaborn._core.rules import VarType, variable_type, categorical_order"], "code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == 'datetime')", "masked_code": "def test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s.astype(int)) == 'numeric')\n    assert (variable_type(s.astype(object)) == 'numeric')\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([np.nan, np.nan])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([pd.NA, pd.NA])\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert (variable_type(s) == 'numeric')\n    s = pd.Series(['1', '2', '3'])\n    assert (variable_type(s) == 'categorical')\n    s = pd.Series([True, False, False])\n    assert (variable_type(s) == 'numeric')\n    assert (variable_type(s, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert (variable_type(s) == 'categorical')\n    s_cat = s.astype('category')\n    assert (variable_type(s_cat, boolean_type='categorical') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='numeric') == 'categorical')\n    assert (variable_type(s_cat, boolean_type='boolean') == 'categorical')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    assert (variable_type(s, boolean_type='boolean', strict_boolean=True) == 'numeric')\n    s = pd.Series([1, 0, 0])\n    assert (variable_type(s, boolean_type='boolean') == 'boolean')\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert (variable_type(s) == 'datetime')\n    assert (variable_type(s.astype(object)) == '???')", "ground_truth": "'datetime'", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1177", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestContinuous", "funcname": "test_log_tick_upto", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_log_tick_upto(self, x):\n    n = 3\n    s = Continuous(trans='log').tick(upto=n)._setup(x, Coordinate())\n    a = PseudoAxis(s._matplotlib_scale)\n    assert (a.major.locator.numticks == n)", "masked_code": "def test_log_tick_upto(self, x):\n    n = 3\n    s = Continuous(trans='log').tick(upto=n)._setup(x, Coordinate())\n    a = PseudoAxis(s._matplotlib_scale)\n    assert (a.major.locator.numticks == '???')", "ground_truth": "n", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1178", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestContinuous", "funcname": "test_symlog_tick_default", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_symlog_tick_default(self, x):\n    s = Continuous(trans='symlog')._setup(x, Coordinate())\n    a = PseudoAxis(s._matplotlib_scale)\n    a.set_view_interval((- 1050), 1050)\n    ticks = a.major.locator()\n    assert (ticks[0] == (- ticks[(- 1)]))\n    pos_ticks = np.sort(np.unique(np.abs(ticks)))\n    assert np.allclose(np.diff(np.log10(pos_ticks[1:])), 1)\n    assert (pos_ticks[0] == 0)", "masked_code": "def test_symlog_tick_default(self, x):\n    s = Continuous(trans='symlog')._setup(x, Coordinate())\n    a = PseudoAxis(s._matplotlib_scale)\n    a.set_view_interval((- 1050), 1050)\n    ticks = a.major.locator()\n    assert (ticks[0] == '???')\n    pos_ticks = np.sort(np.unique(np.abs(ticks)))\n    assert np.allclose(np.diff(np.log10(pos_ticks[1:])), 1)\n    assert (pos_ticks[0] == 0)", "ground_truth": "(- ticks[(- 1)])", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1179", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_coordinate_axis", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_coordinate_axis(self, x):\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal()._setup(x, Coordinate(), ax.xaxis)\n    assert_array_equal(s(x), np.array([0, 1, 2, 1], float))\n    f = ax.xaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1, 2]) == ['a', 'c', 'b'])", "masked_code": "def test_coordinate_axis(self, x):\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal()._setup(x, Coordinate(), ax.xaxis)\n    assert_array_equal(s(x), np.array([0, 1, 2, 1], float))\n    f = ax.xaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1, 2]) == '???')", "ground_truth": "['a', 'c', 'b']", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1180", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_coordinate_axis_with_order", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_coordinate_axis_with_order(self, x):\n    order = ['a', 'b', 'c']\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal(order=order)._setup(x, Coordinate(), ax.xaxis)\n    assert_array_equal(s(x), np.array([0, 2, 1, 2], float))\n    f = ax.xaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1, 2]) == order)", "masked_code": "def test_coordinate_axis_with_order(self, x):\n    order = ['a', 'b', 'c']\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal(order=order)._setup(x, Coordinate(), ax.xaxis)\n    assert_array_equal(s(x), np.array([0, 2, 1, 2], float))\n    f = ax.xaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1, 2]) == '???')", "ground_truth": "order", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1181", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_coordinate_axis_with_subset_order", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_coordinate_axis_with_subset_order(self, x):\n    order = ['c', 'a']\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal(order=order)._setup(x, Coordinate(), ax.xaxis)\n    assert_array_equal(s(x), np.array([1, 0, np.nan, 0], float))\n    f = ax.xaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1, 2]) == [*order, ''])", "masked_code": "def test_coordinate_axis_with_subset_order(self, x):\n    order = ['c', 'a']\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal(order=order)._setup(x, Coordinate(), ax.xaxis)\n    assert_array_equal(s(x), np.array([1, 0, np.nan, 0], float))\n    f = ax.xaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1, 2]) == '???')", "ground_truth": "[*order, '']", "quality_analysis": {"complexity_score": 11, "left_complexity": 8, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1182", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_coordinate_axis_with_category_dtype", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_coordinate_axis_with_category_dtype(self, x):\n    order = ['b', 'a', 'd', 'c']\n    x = x.astype(pd.CategoricalDtype(order))\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal()._setup(x, Coordinate(), ax.xaxis)\n    assert_array_equal(s(x), np.array([1, 3, 0, 3], float))\n    f = ax.xaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1, 2, 3]) == order)", "masked_code": "def test_coordinate_axis_with_category_dtype(self, x):\n    order = ['b', 'a', 'd', 'c']\n    x = x.astype(pd.CategoricalDtype(order))\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal()._setup(x, Coordinate(), ax.xaxis)\n    assert_array_equal(s(x), np.array([1, 3, 0, 3], float))\n    f = ax.xaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1, 2, 3]) == '???')", "ground_truth": "order", "quality_analysis": {"complexity_score": 10, "left_complexity": 9, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1183", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_coordinate_numeric_data", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_coordinate_numeric_data(self, y):\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal()._setup(y, Coordinate(), ax.yaxis)\n    assert_array_equal(s(y), np.array([1, 0, 2, 0], float))\n    f = ax.yaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1, 2]) == ['-1.5', '1.0', '3.0'])", "masked_code": "def test_coordinate_numeric_data(self, y):\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal()._setup(y, Coordinate(), ax.yaxis)\n    assert_array_equal(s(y), np.array([1, 0, 2, 0], float))\n    f = ax.yaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1, 2]) == '???')", "ground_truth": "['-1.5', '1.0', '3.0']", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1184", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_coordinate_numeric_data_with_order", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_coordinate_numeric_data_with_order(self, y):\n    order = [1, 4, (- 1.5)]\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal(order=order)._setup(y, Coordinate(), ax.yaxis)\n    assert_array_equal(s(y), np.array([0, 2, np.nan, 2], float))\n    f = ax.yaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1, 2]) == ['1.0', '4.0', '-1.5'])", "masked_code": "def test_coordinate_numeric_data_with_order(self, y):\n    order = [1, 4, (- 1.5)]\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal(order=order)._setup(y, Coordinate(), ax.yaxis)\n    assert_array_equal(s(y), np.array([0, 2, np.nan, 2], float))\n    f = ax.yaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1, 2]) == '???')", "ground_truth": "['1.0', '4.0', '-1.5']", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1185", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_object_defaults", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_object_defaults(self, x):\n\n    class MockProperty(ObjectProperty):\n\n        def _default_values(self, n):\n            return list('xyz'[:n])\n    s = Nominal()._setup(x, MockProperty())\n    assert (s(x) == ['x', 'y', 'z', 'y'])", "masked_code": "def test_object_defaults(self, x):\n\n    class MockProperty(ObjectProperty):\n\n        def _default_values(self, n):\n            return list('xyz'[:n])\n    s = Nominal()._setup(x, MockProperty())\n    assert (s(x) == '???')", "ground_truth": "['x', 'y', 'z', 'y']", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1186", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_object_list", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_object_list(self, x):\n    vs = ['x', 'y', 'z']\n    s = Nominal(vs)._setup(x, ObjectProperty())\n    assert (s(x) == ['x', 'y', 'z', 'y'])", "masked_code": "def test_object_list(self, x):\n    vs = ['x', 'y', 'z']\n    s = Nominal(vs)._setup(x, ObjectProperty())\n    assert (s(x) == '???')", "ground_truth": "['x', 'y', 'z', 'y']", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1187", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_object_dict", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_object_dict(self, x):\n    vs = {'a': 'x', 'b': 'y', 'c': 'z'}\n    s = Nominal(vs)._setup(x, ObjectProperty())\n    assert (s(x) == ['x', 'z', 'y', 'z'])", "masked_code": "def test_object_dict(self, x):\n    vs = {'a': 'x', 'b': 'y', 'c': 'z'}\n    s = Nominal(vs)._setup(x, ObjectProperty())\n    assert (s(x) == '???')", "ground_truth": "['x', 'z', 'y', 'z']", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1188", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_object_order", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_object_order(self, x):\n    vs = ['x', 'y', 'z']\n    s = Nominal(vs, order=['c', 'a', 'b'])._setup(x, ObjectProperty())\n    assert (s(x) == ['y', 'x', 'z', 'x'])", "masked_code": "def test_object_order(self, x):\n    vs = ['x', 'y', 'z']\n    s = Nominal(vs, order=['c', 'a', 'b'])._setup(x, ObjectProperty())\n    assert (s(x) == '???')", "ground_truth": "['y', 'x', 'z', 'x']", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1189", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_object_order_subset", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_object_order_subset(self, x):\n    vs = ['x', 'y']\n    s = Nominal(vs, order=['a', 'c'])._setup(x, ObjectProperty())\n    assert (s(x) == ['x', 'y', None, 'y'])", "masked_code": "def test_object_order_subset(self, x):\n    vs = ['x', 'y']\n    s = Nominal(vs, order=['a', 'c'])._setup(x, ObjectProperty())\n    assert (s(x) == '???')", "ground_truth": "['x', 'y', None, 'y']", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1190", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_objects_that_are_weird", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_objects_that_are_weird(self, x):\n    vs = [('x', 1), (None, None, 0), {}]\n    s = Nominal(vs)._setup(x, ObjectProperty())\n    assert (s(x) == [vs[0], vs[1], vs[2], vs[1]])", "masked_code": "def test_objects_that_are_weird(self, x):\n    vs = [('x', 1), (None, None, 0), {}]\n    s = Nominal(vs)._setup(x, ObjectProperty())\n    assert (s(x) == '???')", "ground_truth": "[vs[0], vs[1], vs[2], vs[1]]", "quality_analysis": {"complexity_score": 26, "left_complexity": 4, "right_complexity": 22, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1191", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_finalize", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_finalize(self, x):\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal()._setup(x, Coordinate(), ax.yaxis)\n    s._finalize(Plot(), ax.yaxis)\n    levels = x.unique()\n    assert (ax.get_ylim() == ((len(levels) - 0.5), (- 0.5)))\n    assert_array_equal(ax.get_yticks(), list(range(len(levels))))\n    for (i, expected) in enumerate(levels):\n        assert (ax.yaxis.major.formatter(i) == expected)", "masked_code": "def test_finalize(self, x):\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal()._setup(x, Coordinate(), ax.yaxis)\n    s._finalize(Plot(), ax.yaxis)\n    levels = x.unique()\n    assert (ax.get_ylim() == '???')\n    assert_array_equal(ax.get_yticks(), list(range(len(levels))))\n    for (i, expected) in enumerate(levels):\n        assert (ax.yaxis.major.formatter(i) == expected)", "ground_truth": "((len(levels) - 0.5), (- 0.5))", "quality_analysis": {"complexity_score": 15, "left_complexity": 3, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1192", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestNominal", "funcname": "test_finalize", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_finalize(self, x):\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal()._setup(x, Coordinate(), ax.yaxis)\n    s._finalize(Plot(), ax.yaxis)\n    levels = x.unique()\n    assert (ax.get_ylim() == ((len(levels) - 0.5), (- 0.5)))\n    assert_array_equal(ax.get_yticks(), list(range(len(levels))))\n    for (i, expected) in enumerate(levels):\n        assert (ax.yaxis.major.formatter(i) == expected)", "masked_code": "def test_finalize(self, x):\n    ax = mpl.figure.Figure().subplots()\n    s = Nominal()._setup(x, Coordinate(), ax.yaxis)\n    s._finalize(Plot(), ax.yaxis)\n    levels = x.unique()\n    assert (ax.get_ylim() == ((len(levels) - 0.5), (- 0.5)))\n    assert_array_equal(ax.get_yticks(), list(range(len(levels))))\n    for (i, expected) in enumerate(levels):\n        assert (ax.yaxis.major.formatter(i) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1193", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestTemporal", "funcname": "test_tick_upto", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_tick_upto(self, t, x):\n    n = 8\n    ax = mpl.figure.Figure().subplots()\n    Temporal().tick(upto=n)._setup(t, Coordinate(), ax.xaxis)\n    locator = ax.xaxis.get_major_locator()\n    assert (set(locator.maxticks.values()) == {n})", "masked_code": "def test_tick_upto(self, t, x):\n    n = 8\n    ax = mpl.figure.Figure().subplots()\n    Temporal().tick(upto=n)._setup(t, Coordinate(), ax.xaxis)\n    locator = ax.xaxis.get_major_locator()\n    assert (set(locator.maxticks.values()) == '???')", "ground_truth": "{n}", "quality_analysis": {"complexity_score": 6, "left_complexity": 6, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1194", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestBoolean", "funcname": "test_coordinate_axis", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_coordinate_axis(self, x):\n    ax = mpl.figure.Figure().subplots()\n    s = Boolean()._setup(x, Coordinate(), ax.xaxis)\n    assert_array_equal(s(x), x.astype(float))\n    f = ax.xaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1]) == ['False', 'True'])", "masked_code": "def test_coordinate_axis(self, x):\n    ax = mpl.figure.Figure().subplots()\n    s = Boolean()._setup(x, Coordinate(), ax.xaxis)\n    assert_array_equal(s(x), x.astype(float))\n    f = ax.xaxis.get_major_formatter()\n    assert (f.format_ticks([0, 1]) == '???')", "ground_truth": "['False', 'True']", "quality_analysis": {"complexity_score": 11, "left_complexity": 7, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1195", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestBoolean", "funcname": "test_object_defaults", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_object_defaults(self, x):\n    vs = ['x', 'y', 'z']\n\n    class MockProperty(ObjectProperty):\n\n        def _default_values(self, n):\n            return vs[:n]\n    s = Boolean()._setup(x, MockProperty())\n    expected = [vs[int(x_i)] for x_i in (~ x)]\n    assert (s(x) == expected)", "masked_code": "def test_object_defaults(self, x):\n    vs = ['x', 'y', 'z']\n\n    class MockProperty(ObjectProperty):\n\n        def _default_values(self, n):\n            return vs[:n]\n    s = Boolean()._setup(x, MockProperty())\n    expected = [vs[int(x_i)] for x_i in (~ x)]\n    assert (s(x) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1196", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestBoolean", "funcname": "test_object_list", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_object_list(self, x):\n    vs = ['x', 'y']\n    s = Boolean(vs)._setup(x, ObjectProperty())\n    expected = [vs[int(x_i)] for x_i in (~ x)]\n    assert (s(x) == expected)", "masked_code": "def test_object_list(self, x):\n    vs = ['x', 'y']\n    s = Boolean(vs)._setup(x, ObjectProperty())\n    expected = [vs[int(x_i)] for x_i in (~ x)]\n    assert (s(x) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1197", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestBoolean", "funcname": "test_object_dict", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_object_dict(self, x):\n    vs = {True: 'x', False: 'y'}\n    s = Boolean(vs)._setup(x, ObjectProperty())\n    expected = [vs[x_i] for x_i in x]\n    assert (s(x) == expected)", "masked_code": "def test_object_dict(self, x):\n    vs = {True: 'x', False: 'y'}\n    s = Boolean(vs)._setup(x, ObjectProperty())\n    expected = [vs[x_i] for x_i in x]\n    assert (s(x) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1198", "reponame": "seaborn", "testpath": "tests/_core/test_scales.py", "testname": "test_scales.py", "classname": "TestBoolean", "funcname": "test_finalize", "imports": ["import re", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from pandas.testing import assert_series_equal", "from seaborn._core.plot import Plot", "from seaborn._core.scales import Nominal, Continuous, Boolean, Temporal, PseudoAxis", "from seaborn._core.properties import IntervalProperty, ObjectProperty, Coordinate, Alpha, Color, Fill", "from seaborn.palettes import color_palette", "from seaborn.utils import _version_predates"], "code": "def test_finalize(self, x):\n    ax = mpl.figure.Figure().subplots()\n    s = Boolean()._setup(x, Coordinate(), ax.xaxis)\n    s._finalize(Plot(), ax.xaxis)\n    assert (ax.get_xlim() == (1.5, (- 0.5)))\n    assert_array_equal(ax.get_xticks(), [0, 1])\n    assert (ax.xaxis.major.formatter(0) == 'False')\n    assert (ax.xaxis.major.formatter(1) == 'True')", "masked_code": "def test_finalize(self, x):\n    ax = mpl.figure.Figure().subplots()\n    s = Boolean()._setup(x, Coordinate(), ax.xaxis)\n    s._finalize(Plot(), ax.xaxis)\n    assert (ax.get_xlim() == '???')\n    assert_array_equal(ax.get_xticks(), [0, 1])\n    assert (ax.xaxis.major.formatter(0) == 'False')\n    assert (ax.xaxis.major.formatter(1) == 'True')", "ground_truth": "(1.5, (- 0.5))", "quality_analysis": {"complexity_score": 9, "left_complexity": 3, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1199", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_single_facet", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_single_facet(self):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {'col': key}, 'structure': {'col': order}}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == len(order))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_single_facet(self):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {'col': key}, 'structure': {'col': order}}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == len(order))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "len(order)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1200", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_single_facet", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_single_facet(self):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {'col': key}, 'structure': {'col': order}}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == len(order))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_single_facet(self):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {'col': key}, 'structure': {'col': order}}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "len(order)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1201", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_two_facets", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_two_facets(self):\n    col_key = 'a'\n    row_key = 'b'\n    col_order = list('xy')\n    row_order = list('xyz')\n    spec = {'variables': {'col': col_key, 'row': row_key}, 'structure': {'col': col_order, 'row': row_order}}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == (len(col_order) * len(row_order)))\n    assert (s.subplot_spec['ncols'] == len(col_order))\n    assert (s.subplot_spec['nrows'] == len(row_order))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_two_facets(self):\n    col_key = 'a'\n    row_key = 'b'\n    col_order = list('xy')\n    row_order = list('xyz')\n    spec = {'variables': {'col': col_key, 'row': row_key}, 'structure': {'col': col_order, 'row': row_order}}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == len(col_order))\n    assert (s.subplot_spec['nrows'] == len(row_order))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "(len(col_order) * len(row_order))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1202", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_two_facets", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_two_facets(self):\n    col_key = 'a'\n    row_key = 'b'\n    col_order = list('xy')\n    row_order = list('xyz')\n    spec = {'variables': {'col': col_key, 'row': row_key}, 'structure': {'col': col_order, 'row': row_order}}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == (len(col_order) * len(row_order)))\n    assert (s.subplot_spec['ncols'] == len(col_order))\n    assert (s.subplot_spec['nrows'] == len(row_order))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_two_facets(self):\n    col_key = 'a'\n    row_key = 'b'\n    col_order = list('xy')\n    row_order = list('xyz')\n    spec = {'variables': {'col': col_key, 'row': row_key}, 'structure': {'col': col_order, 'row': row_order}}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == (len(col_order) * len(row_order)))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == len(row_order))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "len(col_order)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1203", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_two_facets", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_two_facets(self):\n    col_key = 'a'\n    row_key = 'b'\n    col_order = list('xy')\n    row_order = list('xyz')\n    spec = {'variables': {'col': col_key, 'row': row_key}, 'structure': {'col': col_order, 'row': row_order}}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == (len(col_order) * len(row_order)))\n    assert (s.subplot_spec['ncols'] == len(col_order))\n    assert (s.subplot_spec['nrows'] == len(row_order))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_two_facets(self):\n    col_key = 'a'\n    row_key = 'b'\n    col_order = list('xy')\n    row_order = list('xyz')\n    spec = {'variables': {'col': col_key, 'row': row_key}, 'structure': {'col': col_order, 'row': row_order}}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == (len(col_order) * len(row_order)))\n    assert (s.subplot_spec['ncols'] == len(col_order))\n    assert (s.subplot_spec['nrows'] == '???')\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "len(row_order)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1204", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_col_facet_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_col_facet_wrapped(self):\n    key = 'b'\n    wrap = 3\n    order = list('abcde')\n    spec = {'variables': {'col': key}, 'structure': {'col': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == ((len(order) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_col_facet_wrapped(self):\n    key = 'b'\n    wrap = 3\n    order = list('abcde')\n    spec = {'variables': {'col': key}, 'structure': {'col': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == ((len(order) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "len(order)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1205", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_col_facet_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_col_facet_wrapped(self):\n    key = 'b'\n    wrap = 3\n    order = list('abcde')\n    spec = {'variables': {'col': key}, 'structure': {'col': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == ((len(order) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_col_facet_wrapped(self):\n    key = 'b'\n    wrap = 3\n    order = list('abcde')\n    spec = {'variables': {'col': key}, 'structure': {'col': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == ((len(order) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "wrap", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1206", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_col_facet_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_col_facet_wrapped(self):\n    key = 'b'\n    wrap = 3\n    order = list('abcde')\n    spec = {'variables': {'col': key}, 'structure': {'col': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == ((len(order) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_col_facet_wrapped(self):\n    key = 'b'\n    wrap = 3\n    order = list('abcde')\n    spec = {'variables': {'col': key}, 'structure': {'col': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == '???')\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "((len(order) // wrap) + 1)", "quality_analysis": {"complexity_score": 16, "left_complexity": 6, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1207", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_row_facet_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_row_facet_wrapped(self):\n    key = 'b'\n    wrap = 3\n    order = list('abcde')\n    spec = {'variables': {'row': key}, 'structure': {'row': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == ((len(order) // wrap) + 1))\n    assert (s.subplot_spec['nrows'] == wrap)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_row_facet_wrapped(self):\n    key = 'b'\n    wrap = 3\n    order = list('abcde')\n    spec = {'variables': {'row': key}, 'structure': {'row': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == ((len(order) // wrap) + 1))\n    assert (s.subplot_spec['nrows'] == wrap)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "len(order)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1208", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_row_facet_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_row_facet_wrapped(self):\n    key = 'b'\n    wrap = 3\n    order = list('abcde')\n    spec = {'variables': {'row': key}, 'structure': {'row': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == ((len(order) // wrap) + 1))\n    assert (s.subplot_spec['nrows'] == wrap)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_row_facet_wrapped(self):\n    key = 'b'\n    wrap = 3\n    order = list('abcde')\n    spec = {'variables': {'row': key}, 'structure': {'row': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == wrap)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "((len(order) // wrap) + 1)", "quality_analysis": {"complexity_score": 16, "left_complexity": 6, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1209", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_row_facet_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_row_facet_wrapped(self):\n    key = 'b'\n    wrap = 3\n    order = list('abcde')\n    spec = {'variables': {'row': key}, 'structure': {'row': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == ((len(order) // wrap) + 1))\n    assert (s.subplot_spec['nrows'] == wrap)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_row_facet_wrapped(self):\n    key = 'b'\n    wrap = 3\n    order = list('abcde')\n    spec = {'variables': {'row': key}, 'structure': {'row': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == ((len(order) // wrap) + 1))\n    assert (s.subplot_spec['nrows'] == '???')\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "wrap", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1210", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_col_facet_wrapped_single_row", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_col_facet_wrapped_single_row(self):\n    key = 'b'\n    order = list('abc')\n    wrap = (len(order) + 2)\n    spec = {'variables': {'col': key}, 'structure': {'col': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == len(order))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_col_facet_wrapped_single_row(self):\n    key = 'b'\n    order = list('abc')\n    wrap = (len(order) + 2)\n    spec = {'variables': {'col': key}, 'structure': {'col': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == len(order))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "len(order)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1211", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_col_facet_wrapped_single_row", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_col_facet_wrapped_single_row(self):\n    key = 'b'\n    order = list('abc')\n    wrap = (len(order) + 2)\n    spec = {'variables': {'col': key}, 'structure': {'col': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == len(order))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_col_facet_wrapped_single_row(self):\n    key = 'b'\n    order = list('abc')\n    wrap = (len(order) + 2)\n    spec = {'variables': {'col': key}, 'structure': {'col': order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    assert (s.n_subplots == len(order))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "len(order)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1212", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_and_y_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_and_y_paired(self):\n    x = ['x', 'y', 'z']\n    y = ['a', 'b']\n    s = Subplots({}, {}, {'structure': {'x': x, 'y': y}})\n    assert (s.n_subplots == (len(x) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] == 'row')", "masked_code": "def test_x_and_y_paired(self):\n    x = ['x', 'y', 'z']\n    y = ['a', 'b']\n    s = Subplots({}, {}, {'structure': {'x': x, 'y': y}})\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] == 'row')", "ground_truth": "(len(x) * len(y))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1213", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_and_y_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_and_y_paired(self):\n    x = ['x', 'y', 'z']\n    y = ['a', 'b']\n    s = Subplots({}, {}, {'structure': {'x': x, 'y': y}})\n    assert (s.n_subplots == (len(x) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] == 'row')", "masked_code": "def test_x_and_y_paired(self):\n    x = ['x', 'y', 'z']\n    y = ['a', 'b']\n    s = Subplots({}, {}, {'structure': {'x': x, 'y': y}})\n    assert (s.n_subplots == (len(x) * len(y)))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] == 'row')", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1214", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_and_y_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_and_y_paired(self):\n    x = ['x', 'y', 'z']\n    y = ['a', 'b']\n    s = Subplots({}, {}, {'structure': {'x': x, 'y': y}})\n    assert (s.n_subplots == (len(x) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] == 'row')", "masked_code": "def test_x_and_y_paired(self):\n    x = ['x', 'y', 'z']\n    y = ['a', 'b']\n    s = Subplots({}, {}, {'structure': {'x': x, 'y': y}})\n    assert (s.n_subplots == (len(x) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == '???')\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] == 'row')", "ground_truth": "len(y)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1215", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_and_y_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_and_y_paired(self):\n    x = ['x', 'y', 'z']\n    y = ['a', 'b']\n    s = Subplots({}, {}, {'structure': {'x': x, 'y': y}})\n    assert (s.n_subplots == (len(x) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] == 'row')", "masked_code": "def test_x_and_y_paired(self):\n    x = ['x', 'y', 'z']\n    y = ['a', 'b']\n    s = Subplots({}, {}, {'structure': {'x': x, 'y': y}})\n    assert (s.n_subplots == (len(x) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] == '???')\n    assert (s.subplot_spec['sharey'] == 'row')", "ground_truth": "'col'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1216", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_and_y_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_and_y_paired(self):\n    x = ['x', 'y', 'z']\n    y = ['a', 'b']\n    s = Subplots({}, {}, {'structure': {'x': x, 'y': y}})\n    assert (s.n_subplots == (len(x) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] == 'row')", "masked_code": "def test_x_and_y_paired(self):\n    x = ['x', 'y', 'z']\n    y = ['a', 'b']\n    s = Subplots({}, {}, {'structure': {'x': x, 'y': y}})\n    assert (s.n_subplots == (len(x) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] == '???')", "ground_truth": "'row'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1217", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_paired(self):\n    x = ['x', 'y', 'z']\n    s = Subplots({}, {}, {'structure': {'x': x}})\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_x_paired(self):\n    x = ['x', 'y', 'z']\n    s = Subplots({}, {}, {'structure': {'x': x}})\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1218", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_paired(self):\n    x = ['x', 'y', 'z']\n    s = Subplots({}, {}, {'structure': {'x': x}})\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_x_paired(self):\n    x = ['x', 'y', 'z']\n    s = Subplots({}, {}, {'structure': {'x': x}})\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1219", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_paired(self):\n    x = ['x', 'y', 'z']\n    s = Subplots({}, {}, {'structure': {'x': x}})\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_x_paired(self):\n    x = ['x', 'y', 'z']\n    s = Subplots({}, {}, {'structure': {'x': x}})\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] == '???')\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "'col'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1220", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_y_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_y_paired(self):\n    y = ['x', 'y', 'z']\n    s = Subplots({}, {}, {'structure': {'y': y}})\n    assert (s.n_subplots == len(y))\n    assert (s.subplot_spec['ncols'] == 1)\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == 'row')", "masked_code": "def test_y_paired(self):\n    y = ['x', 'y', 'z']\n    s = Subplots({}, {}, {'structure': {'y': y}})\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == 1)\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == 'row')", "ground_truth": "len(y)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1221", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_y_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_y_paired(self):\n    y = ['x', 'y', 'z']\n    s = Subplots({}, {}, {'structure': {'y': y}})\n    assert (s.n_subplots == len(y))\n    assert (s.subplot_spec['ncols'] == 1)\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == 'row')", "masked_code": "def test_y_paired(self):\n    y = ['x', 'y', 'z']\n    s = Subplots({}, {}, {'structure': {'y': y}})\n    assert (s.n_subplots == len(y))\n    assert (s.subplot_spec['ncols'] == 1)\n    assert (s.subplot_spec['nrows'] == '???')\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == 'row')", "ground_truth": "len(y)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1222", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_y_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_y_paired(self):\n    y = ['x', 'y', 'z']\n    s = Subplots({}, {}, {'structure': {'y': y}})\n    assert (s.n_subplots == len(y))\n    assert (s.subplot_spec['ncols'] == 1)\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == 'row')", "masked_code": "def test_y_paired(self):\n    y = ['x', 'y', 'z']\n    s = Subplots({}, {}, {'structure': {'y': y}})\n    assert (s.n_subplots == len(y))\n    assert (s.subplot_spec['ncols'] == 1)\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == '???')", "ground_truth": "'row'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1223", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_paired_and_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_paired_and_wrapped(self):\n    x = ['a', 'b', 'x', 'y', 'z']\n    wrap = 3\n    s = Subplots({}, {}, {'structure': {'x': x}, 'wrap': wrap})\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == ((len(x) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_x_paired_and_wrapped(self):\n    x = ['a', 'b', 'x', 'y', 'z']\n    wrap = 3\n    s = Subplots({}, {}, {'structure': {'x': x}, 'wrap': wrap})\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == ((len(x) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1224", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_paired_and_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_paired_and_wrapped(self):\n    x = ['a', 'b', 'x', 'y', 'z']\n    wrap = 3\n    s = Subplots({}, {}, {'structure': {'x': x}, 'wrap': wrap})\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == ((len(x) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_x_paired_and_wrapped(self):\n    x = ['a', 'b', 'x', 'y', 'z']\n    wrap = 3\n    s = Subplots({}, {}, {'structure': {'x': x}, 'wrap': wrap})\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == ((len(x) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "wrap", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1225", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_paired_and_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_paired_and_wrapped(self):\n    x = ['a', 'b', 'x', 'y', 'z']\n    wrap = 3\n    s = Subplots({}, {}, {'structure': {'x': x}, 'wrap': wrap})\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == ((len(x) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_x_paired_and_wrapped(self):\n    x = ['a', 'b', 'x', 'y', 'z']\n    wrap = 3\n    s = Subplots({}, {}, {'structure': {'x': x}, 'wrap': wrap})\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == '???')\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "((len(x) // wrap) + 1)", "quality_analysis": {"complexity_score": 16, "left_complexity": 6, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1226", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_y_paired_and_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_y_paired_and_wrapped(self):\n    y = ['a', 'b', 'x', 'y', 'z']\n    wrap = 2\n    s = Subplots({}, {}, {'structure': {'y': y}, 'wrap': wrap})\n    assert (s.n_subplots == len(y))\n    assert (s.subplot_spec['ncols'] == ((len(y) // wrap) + 1))\n    assert (s.subplot_spec['nrows'] == wrap)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is False)", "masked_code": "def test_y_paired_and_wrapped(self):\n    y = ['a', 'b', 'x', 'y', 'z']\n    wrap = 2\n    s = Subplots({}, {}, {'structure': {'y': y}, 'wrap': wrap})\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == ((len(y) // wrap) + 1))\n    assert (s.subplot_spec['nrows'] == wrap)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is False)", "ground_truth": "len(y)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1227", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_y_paired_and_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_y_paired_and_wrapped(self):\n    y = ['a', 'b', 'x', 'y', 'z']\n    wrap = 2\n    s = Subplots({}, {}, {'structure': {'y': y}, 'wrap': wrap})\n    assert (s.n_subplots == len(y))\n    assert (s.subplot_spec['ncols'] == ((len(y) // wrap) + 1))\n    assert (s.subplot_spec['nrows'] == wrap)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is False)", "masked_code": "def test_y_paired_and_wrapped(self):\n    y = ['a', 'b', 'x', 'y', 'z']\n    wrap = 2\n    s = Subplots({}, {}, {'structure': {'y': y}, 'wrap': wrap})\n    assert (s.n_subplots == len(y))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == wrap)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is False)", "ground_truth": "((len(y) // wrap) + 1)", "quality_analysis": {"complexity_score": 16, "left_complexity": 6, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1228", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_y_paired_and_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_y_paired_and_wrapped(self):\n    y = ['a', 'b', 'x', 'y', 'z']\n    wrap = 2\n    s = Subplots({}, {}, {'structure': {'y': y}, 'wrap': wrap})\n    assert (s.n_subplots == len(y))\n    assert (s.subplot_spec['ncols'] == ((len(y) // wrap) + 1))\n    assert (s.subplot_spec['nrows'] == wrap)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is False)", "masked_code": "def test_y_paired_and_wrapped(self):\n    y = ['a', 'b', 'x', 'y', 'z']\n    wrap = 2\n    s = Subplots({}, {}, {'structure': {'y': y}, 'wrap': wrap})\n    assert (s.n_subplots == len(y))\n    assert (s.subplot_spec['ncols'] == ((len(y) // wrap) + 1))\n    assert (s.subplot_spec['nrows'] == '???')\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is False)", "ground_truth": "wrap", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1229", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_y_paired_and_wrapped_single_row", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_y_paired_and_wrapped_single_row(self):\n    y = ['x', 'y', 'z']\n    wrap = 1\n    s = Subplots({}, {}, {'structure': {'y': y}, 'wrap': wrap})\n    assert (s.n_subplots == len(y))\n    assert (s.subplot_spec['ncols'] == len(y))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is False)", "masked_code": "def test_y_paired_and_wrapped_single_row(self):\n    y = ['x', 'y', 'z']\n    wrap = 1\n    s = Subplots({}, {}, {'structure': {'y': y}, 'wrap': wrap})\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == len(y))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is False)", "ground_truth": "len(y)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1230", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_y_paired_and_wrapped_single_row", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_y_paired_and_wrapped_single_row(self):\n    y = ['x', 'y', 'z']\n    wrap = 1\n    s = Subplots({}, {}, {'structure': {'y': y}, 'wrap': wrap})\n    assert (s.n_subplots == len(y))\n    assert (s.subplot_spec['ncols'] == len(y))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is False)", "masked_code": "def test_y_paired_and_wrapped_single_row(self):\n    y = ['x', 'y', 'z']\n    wrap = 1\n    s = Subplots({}, {}, {'structure': {'y': y}, 'wrap': wrap})\n    assert (s.n_subplots == len(y))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] is False)", "ground_truth": "len(y)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1231", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_col_faceted_y_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_col_faceted_y_paired(self):\n    y = ['x', 'y', 'z']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'col': key}, 'structure': {'col': order}}\n    pair_spec = {'structure': {'y': y}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(order))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == 'row')", "masked_code": "def test_col_faceted_y_paired(self):\n    y = ['x', 'y', 'z']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'col': key}, 'structure': {'col': order}}\n    pair_spec = {'structure': {'y': y}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == len(order))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == 'row')", "ground_truth": "(len(order) * len(y))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1232", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_col_faceted_y_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_col_faceted_y_paired(self):\n    y = ['x', 'y', 'z']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'col': key}, 'structure': {'col': order}}\n    pair_spec = {'structure': {'y': y}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(order))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == 'row')", "masked_code": "def test_col_faceted_y_paired(self):\n    y = ['x', 'y', 'z']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'col': key}, 'structure': {'col': order}}\n    pair_spec = {'structure': {'y': y}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(y)))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == 'row')", "ground_truth": "len(order)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1233", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_col_faceted_y_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_col_faceted_y_paired(self):\n    y = ['x', 'y', 'z']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'col': key}, 'structure': {'col': order}}\n    pair_spec = {'structure': {'y': y}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(order))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == 'row')", "masked_code": "def test_col_faceted_y_paired(self):\n    y = ['x', 'y', 'z']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'col': key}, 'structure': {'col': order}}\n    pair_spec = {'structure': {'y': y}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(order))\n    assert (s.subplot_spec['nrows'] == '???')\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == 'row')", "ground_truth": "len(y)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1234", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_col_faceted_y_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_col_faceted_y_paired(self):\n    y = ['x', 'y', 'z']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'col': key}, 'structure': {'col': order}}\n    pair_spec = {'structure': {'y': y}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(order))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == 'row')", "masked_code": "def test_col_faceted_y_paired(self):\n    y = ['x', 'y', 'z']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'col': key}, 'structure': {'col': order}}\n    pair_spec = {'structure': {'y': y}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(y)))\n    assert (s.subplot_spec['ncols'] == len(order))\n    assert (s.subplot_spec['nrows'] == len(y))\n    assert (s.subplot_spec['sharex'] is True)\n    assert (s.subplot_spec['sharey'] == '???')", "ground_truth": "'row'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1235", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_row_faceted_x_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_row_faceted_x_paired(self):\n    x = ['f', 's']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'row': key}, 'structure': {'row': order}}\n    pair_spec = {'structure': {'x': x}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(x)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(order))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_row_faceted_x_paired(self):\n    x = ['f', 's']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'row': key}, 'structure': {'row': order}}\n    pair_spec = {'structure': {'x': x}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(order))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "(len(order) * len(x))", "quality_analysis": {"complexity_score": 12, "left_complexity": 2, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1236", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_row_faceted_x_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_row_faceted_x_paired(self):\n    x = ['f', 's']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'row': key}, 'structure': {'row': order}}\n    pair_spec = {'structure': {'x': x}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(x)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(order))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_row_faceted_x_paired(self):\n    x = ['f', 's']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'row': key}, 'structure': {'row': order}}\n    pair_spec = {'structure': {'x': x}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(x)))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == len(order))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1237", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_row_faceted_x_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_row_faceted_x_paired(self):\n    x = ['f', 's']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'row': key}, 'structure': {'row': order}}\n    pair_spec = {'structure': {'x': x}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(x)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(order))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_row_faceted_x_paired(self):\n    x = ['f', 's']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'row': key}, 'structure': {'row': order}}\n    pair_spec = {'structure': {'x': x}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(x)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == '???')\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "len(order)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1238", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_row_faceted_x_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_row_faceted_x_paired(self):\n    x = ['f', 's']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'row': key}, 'structure': {'row': order}}\n    pair_spec = {'structure': {'x': x}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(x)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(order))\n    assert (s.subplot_spec['sharex'] == 'col')\n    assert (s.subplot_spec['sharey'] is True)", "masked_code": "def test_row_faceted_x_paired(self):\n    x = ['f', 's']\n    key = 'a'\n    order = list('abc')\n    facet_spec = {'variables': {'row': key}, 'structure': {'row': order}}\n    pair_spec = {'structure': {'x': x}}\n    s = Subplots({}, facet_spec, pair_spec)\n    assert (s.n_subplots == (len(order) * len(x)))\n    assert (s.subplot_spec['ncols'] == len(x))\n    assert (s.subplot_spec['nrows'] == len(order))\n    assert (s.subplot_spec['sharex'] == '???')\n    assert (s.subplot_spec['sharey'] is True)", "ground_truth": "'col'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1239", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_any_y_paired_non_cross", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_any_y_paired_non_cross(self):\n    x = ['a', 'b', 'c']\n    y = ['x', 'y', 'z']\n    spec = {'structure': {'x': x, 'y': y}, 'cross': False}\n    s = Subplots({}, {}, spec)\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == len(y))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is False)", "masked_code": "def test_x_any_y_paired_non_cross(self):\n    x = ['a', 'b', 'c']\n    y = ['x', 'y', 'z']\n    spec = {'structure': {'x': x, 'y': y}, 'cross': False}\n    s = Subplots({}, {}, spec)\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == len(y))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is False)", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1240", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_any_y_paired_non_cross", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_any_y_paired_non_cross(self):\n    x = ['a', 'b', 'c']\n    y = ['x', 'y', 'z']\n    spec = {'structure': {'x': x, 'y': y}, 'cross': False}\n    s = Subplots({}, {}, spec)\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == len(y))\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is False)", "masked_code": "def test_x_any_y_paired_non_cross(self):\n    x = ['a', 'b', 'c']\n    y = ['x', 'y', 'z']\n    spec = {'structure': {'x': x, 'y': y}, 'cross': False}\n    s = Subplots({}, {}, spec)\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == 1)\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is False)", "ground_truth": "len(y)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1241", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_any_y_paired_non_cross_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_any_y_paired_non_cross_wrapped(self):\n    x = ['a', 'b', 'c']\n    y = ['x', 'y', 'z']\n    wrap = 2\n    spec = {'structure': {'x': x, 'y': y}, 'cross': False, 'wrap': wrap}\n    s = Subplots({}, {}, spec)\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == ((len(x) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is False)", "masked_code": "def test_x_any_y_paired_non_cross_wrapped(self):\n    x = ['a', 'b', 'c']\n    y = ['x', 'y', 'z']\n    wrap = 2\n    spec = {'structure': {'x': x, 'y': y}, 'cross': False, 'wrap': wrap}\n    s = Subplots({}, {}, spec)\n    assert (s.n_subplots == '???')\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == ((len(x) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is False)", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1242", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_any_y_paired_non_cross_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_any_y_paired_non_cross_wrapped(self):\n    x = ['a', 'b', 'c']\n    y = ['x', 'y', 'z']\n    wrap = 2\n    spec = {'structure': {'x': x, 'y': y}, 'cross': False, 'wrap': wrap}\n    s = Subplots({}, {}, spec)\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == ((len(x) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is False)", "masked_code": "def test_x_any_y_paired_non_cross_wrapped(self):\n    x = ['a', 'b', 'c']\n    y = ['x', 'y', 'z']\n    wrap = 2\n    spec = {'structure': {'x': x, 'y': y}, 'cross': False, 'wrap': wrap}\n    s = Subplots({}, {}, spec)\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == '???')\n    assert (s.subplot_spec['nrows'] == ((len(x) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is False)", "ground_truth": "wrap", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1243", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_x_any_y_paired_non_cross_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_x_any_y_paired_non_cross_wrapped(self):\n    x = ['a', 'b', 'c']\n    y = ['x', 'y', 'z']\n    wrap = 2\n    spec = {'structure': {'x': x, 'y': y}, 'cross': False, 'wrap': wrap}\n    s = Subplots({}, {}, spec)\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == ((len(x) // wrap) + 1))\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is False)", "masked_code": "def test_x_any_y_paired_non_cross_wrapped(self):\n    x = ['a', 'b', 'c']\n    y = ['x', 'y', 'z']\n    wrap = 2\n    spec = {'structure': {'x': x, 'y': y}, 'cross': False, 'wrap': wrap}\n    s = Subplots({}, {}, spec)\n    assert (s.n_subplots == len(x))\n    assert (s.subplot_spec['ncols'] == wrap)\n    assert (s.subplot_spec['nrows'] == '???')\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] is False)", "ground_truth": "((len(x) // wrap) + 1)", "quality_analysis": {"complexity_score": 16, "left_complexity": 6, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1244", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotSpec", "funcname": "test_forced_unshared_facets", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_forced_unshared_facets(self):\n    s = Subplots({'sharex': False, 'sharey': 'row'}, {}, {})\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] == 'row')", "masked_code": "def test_forced_unshared_facets(self):\n    s = Subplots({'sharex': False, 'sharey': 'row'}, {}, {})\n    assert (s.subplot_spec['sharex'] is False)\n    assert (s.subplot_spec['sharey'] == '???')", "ground_truth": "'row'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1245", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_subplot", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_single_subplot(self):\n    s = Subplots({}, {}, {})\n    f = s.init_figure({}, {})\n    assert (len(s) == 1)\n    for (i, e) in enumerate(s):\n        for side in ['left', 'right', 'bottom', 'top']:\n            assert e[side]\n        for dim in ['col', 'row']:\n            assert (e[dim] is None)\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['ax'] == f.axes[i])", "masked_code": "def test_single_subplot(self):\n    s = Subplots({}, {}, {})\n    f = s.init_figure({}, {})\n    assert (len(s) == 1)\n    for (i, e) in enumerate(s):\n        for side in ['left', 'right', 'bottom', 'top']:\n            assert e[side]\n        for dim in ['col', 'row']:\n            assert (e[dim] is None)\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['ax'] == '???')", "ground_truth": "f.axes[i]", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1246", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_subplot", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_single_subplot(self):\n    s = Subplots({}, {}, {})\n    f = s.init_figure({}, {})\n    assert (len(s) == 1)\n    for (i, e) in enumerate(s):\n        for side in ['left', 'right', 'bottom', 'top']:\n            assert e[side]\n        for dim in ['col', 'row']:\n            assert (e[dim] is None)\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['ax'] == f.axes[i])", "masked_code": "def test_single_subplot(self):\n    s = Subplots({}, {}, {})\n    f = s.init_figure({}, {})\n    assert (len(s) == 1)\n    for (i, e) in enumerate(s):\n        for side in ['left', 'right', 'bottom', 'top']:\n            assert e[side]\n        for dim in ['col', 'row']:\n            assert (e[dim] is None)\n        for axis in 'xy':\n            assert (e[axis] == '???')\n        assert (e['ax'] == f.axes[i])", "ground_truth": "axis", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1247", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_facet_dim", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['top'] == ((dim == 'col') or (i == 0)))\n        assert (e['bottom'] == ((dim == 'col') or (i == (len(order) - 1))))\n        assert (e['left'] == ((dim == 'row') or (i == 0)))\n        assert (e['right'] == ((dim == 'row') or (i == (len(order) - 1))))", "masked_code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == '???')\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['top'] == ((dim == 'col') or (i == 0)))\n        assert (e['bottom'] == ((dim == 'col') or (i == (len(order) - 1))))\n        assert (e['left'] == ((dim == 'row') or (i == 0)))\n        assert (e['right'] == ((dim == 'row') or (i == (len(order) - 1))))", "ground_truth": "len(order)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1248", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_facet_dim", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['top'] == ((dim == 'col') or (i == 0)))\n        assert (e['bottom'] == ((dim == 'col') or (i == (len(order) - 1))))\n        assert (e['left'] == ((dim == 'row') or (i == 0)))\n        assert (e['right'] == ((dim == 'row') or (i == (len(order) - 1))))", "masked_code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == '???')\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['top'] == ((dim == 'col') or (i == 0)))\n        assert (e['bottom'] == ((dim == 'col') or (i == (len(order) - 1))))\n        assert (e['left'] == ((dim == 'row') or (i == 0)))\n        assert (e['right'] == ((dim == 'row') or (i == (len(order) - 1))))", "ground_truth": "order[i]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1249", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_facet_dim", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['top'] == ((dim == 'col') or (i == 0)))\n        assert (e['bottom'] == ((dim == 'col') or (i == (len(order) - 1))))\n        assert (e['left'] == ((dim == 'row') or (i == 0)))\n        assert (e['right'] == ((dim == 'row') or (i == (len(order) - 1))))", "masked_code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['top'] == '???')\n        assert (e['bottom'] == ((dim == 'col') or (i == (len(order) - 1))))\n        assert (e['left'] == ((dim == 'row') or (i == 0)))\n        assert (e['right'] == ((dim == 'row') or (i == (len(order) - 1))))", "ground_truth": "((dim == 'col') or (i == 0))", "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1250", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_facet_dim", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['top'] == ((dim == 'col') or (i == 0)))\n        assert (e['bottom'] == ((dim == 'col') or (i == (len(order) - 1))))\n        assert (e['left'] == ((dim == 'row') or (i == 0)))\n        assert (e['right'] == ((dim == 'row') or (i == (len(order) - 1))))", "masked_code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['top'] == ((dim == 'col') or (i == 0)))\n        assert (e['bottom'] == '???')\n        assert (e['left'] == ((dim == 'row') or (i == 0)))\n        assert (e['right'] == ((dim == 'row') or (i == (len(order) - 1))))", "ground_truth": "((dim == 'col') or (i == (len(order) - 1)))", "quality_analysis": {"complexity_score": 21, "left_complexity": 5, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1251", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_facet_dim", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['top'] == ((dim == 'col') or (i == 0)))\n        assert (e['bottom'] == ((dim == 'col') or (i == (len(order) - 1))))\n        assert (e['left'] == ((dim == 'row') or (i == 0)))\n        assert (e['right'] == ((dim == 'row') or (i == (len(order) - 1))))", "masked_code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['top'] == ((dim == 'col') or (i == 0)))\n        assert (e['bottom'] == ((dim == 'col') or (i == (len(order) - 1))))\n        assert (e['left'] == '???')\n        assert (e['right'] == ((dim == 'row') or (i == (len(order) - 1))))", "ground_truth": "((dim == 'row') or (i == 0))", "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1252", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_facet_dim", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['top'] == ((dim == 'col') or (i == 0)))\n        assert (e['bottom'] == ((dim == 'col') or (i == (len(order) - 1))))\n        assert (e['left'] == ((dim == 'row') or (i == 0)))\n        assert (e['right'] == ((dim == 'row') or (i == (len(order) - 1))))", "masked_code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['top'] == ((dim == 'col') or (i == 0)))\n        assert (e['bottom'] == ((dim == 'col') or (i == (len(order) - 1))))\n        assert (e['left'] == ((dim == 'row') or (i == 0)))\n        assert (e['right'] == '???')", "ground_truth": "((dim == 'row') or (i == (len(order) - 1)))", "quality_analysis": {"complexity_score": 21, "left_complexity": 5, "right_complexity": 16, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1253", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_facet_dim", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        assert (e['top'] == ((dim == 'col') or (i == 0)))\n        assert (e['bottom'] == ((dim == 'col') or (i == (len(order) - 1))))\n        assert (e['left'] == ((dim == 'row') or (i == 0)))\n        assert (e['right'] == ((dim == 'row') or (i == (len(order) - 1))))", "masked_code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim(self, dim):\n    key = 'a'\n    order = list('abc')\n    spec = {'variables': {dim: key}, 'structure': {dim: order}}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == '???')\n        assert (e['top'] == ((dim == 'col') or (i == 0)))\n        assert (e['bottom'] == ((dim == 'col') or (i == (len(order) - 1))))\n        assert (e['left'] == ((dim == 'row') or (i == 0)))\n        assert (e['right'] == ((dim == 'row') or (i == (len(order) - 1))))", "ground_truth": "axis", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1254", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_facet_dim_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim_wrapped(self, dim):\n    key = 'b'\n    order = list('abc')\n    wrap = (len(order) - 1)\n    spec = {'variables': {dim: key}, 'structure': {dim: order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        sides = {'col': ['top', 'bottom', 'left', 'right'], 'row': ['left', 'right', 'top', 'bottom']}\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        for (side, expected) in zip(sides[dim], tests):\n            assert (e[side] == expected)", "masked_code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim_wrapped(self, dim):\n    key = 'b'\n    order = list('abc')\n    wrap = (len(order) - 1)\n    spec = {'variables': {dim: key}, 'structure': {dim: order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == '???')\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        sides = {'col': ['top', 'bottom', 'left', 'right'], 'row': ['left', 'right', 'top', 'bottom']}\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        for (side, expected) in zip(sides[dim], tests):\n            assert (e[side] == expected)", "ground_truth": "len(order)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1255", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_facet_dim_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim_wrapped(self, dim):\n    key = 'b'\n    order = list('abc')\n    wrap = (len(order) - 1)\n    spec = {'variables': {dim: key}, 'structure': {dim: order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        sides = {'col': ['top', 'bottom', 'left', 'right'], 'row': ['left', 'right', 'top', 'bottom']}\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        for (side, expected) in zip(sides[dim], tests):\n            assert (e[side] == expected)", "masked_code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim_wrapped(self, dim):\n    key = 'b'\n    order = list('abc')\n    wrap = (len(order) - 1)\n    spec = {'variables': {dim: key}, 'structure': {dim: order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == '???')\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        sides = {'col': ['top', 'bottom', 'left', 'right'], 'row': ['left', 'right', 'top', 'bottom']}\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        for (side, expected) in zip(sides[dim], tests):\n            assert (e[side] == expected)", "ground_truth": "order[i]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1256", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_facet_dim_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim_wrapped(self, dim):\n    key = 'b'\n    order = list('abc')\n    wrap = (len(order) - 1)\n    spec = {'variables': {dim: key}, 'structure': {dim: order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        sides = {'col': ['top', 'bottom', 'left', 'right'], 'row': ['left', 'right', 'top', 'bottom']}\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        for (side, expected) in zip(sides[dim], tests):\n            assert (e[side] == expected)", "masked_code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim_wrapped(self, dim):\n    key = 'b'\n    order = list('abc')\n    wrap = (len(order) - 1)\n    spec = {'variables': {dim: key}, 'structure': {dim: order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == '???')\n        sides = {'col': ['top', 'bottom', 'left', 'right'], 'row': ['left', 'right', 'top', 'bottom']}\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        for (side, expected) in zip(sides[dim], tests):\n            assert (e[side] == expected)", "ground_truth": "axis", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1257", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_facet_dim_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim_wrapped(self, dim):\n    key = 'b'\n    order = list('abc')\n    wrap = (len(order) - 1)\n    spec = {'variables': {dim: key}, 'structure': {dim: order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        sides = {'col': ['top', 'bottom', 'left', 'right'], 'row': ['left', 'right', 'top', 'bottom']}\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        for (side, expected) in zip(sides[dim], tests):\n            assert (e[side] == expected)", "masked_code": "@pytest.mark.parametrize('dim', ['col', 'row'])\ndef test_single_facet_dim_wrapped(self, dim):\n    key = 'b'\n    order = list('abc')\n    wrap = (len(order) - 1)\n    spec = {'variables': {dim: key}, 'structure': {dim: order}, 'wrap': wrap}\n    s = Subplots({}, spec, {})\n    s.init_figure(spec, {})\n    assert (len(s) == len(order))\n    for (i, e) in enumerate(s):\n        assert (e[dim] == order[i])\n        for axis in 'xy':\n            assert (e[axis] == axis)\n        sides = {'col': ['top', 'bottom', 'left', 'right'], 'row': ['left', 'right', 'top', 'bottom']}\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        for (side, expected) in zip(sides[dim], tests):\n            assert (e[side] == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1258", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_both_facet_dims", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_both_facet_dims(self):\n    col = 'a'\n    row = 'b'\n    col_order = list('ab')\n    row_order = list('xyz')\n    facet_spec = {'variables': {'col': col, 'row': row}, 'structure': {'col': col_order, 'row': row_order}}\n    s = Subplots({}, facet_spec, {})\n    s.init_figure(facet_spec, {})\n    n_cols = len(col_order)\n    n_rows = len(row_order)\n    assert (len(s) == (n_cols * n_rows))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    for (e, (row_, col_)) in zip(es, itertools.product(row_order, col_order)):\n        assert (e['col'] == col_)\n        assert (e['row'] == row_)\n    for e in es:\n        assert (e['x'] == 'x')\n        assert (e['y'] == 'y')", "masked_code": "def test_both_facet_dims(self):\n    col = 'a'\n    row = 'b'\n    col_order = list('ab')\n    row_order = list('xyz')\n    facet_spec = {'variables': {'col': col, 'row': row}, 'structure': {'col': col_order, 'row': row_order}}\n    s = Subplots({}, facet_spec, {})\n    s.init_figure(facet_spec, {})\n    n_cols = len(col_order)\n    n_rows = len(row_order)\n    assert (len(s) == '???')\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    for (e, (row_, col_)) in zip(es, itertools.product(row_order, col_order)):\n        assert (e['col'] == col_)\n        assert (e['row'] == row_)\n    for e in es:\n        assert (e['x'] == 'x')\n        assert (e['y'] == 'y')", "ground_truth": "(n_cols * n_rows)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1259", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_both_facet_dims", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_both_facet_dims(self):\n    col = 'a'\n    row = 'b'\n    col_order = list('ab')\n    row_order = list('xyz')\n    facet_spec = {'variables': {'col': col, 'row': row}, 'structure': {'col': col_order, 'row': row_order}}\n    s = Subplots({}, facet_spec, {})\n    s.init_figure(facet_spec, {})\n    n_cols = len(col_order)\n    n_rows = len(row_order)\n    assert (len(s) == (n_cols * n_rows))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    for (e, (row_, col_)) in zip(es, itertools.product(row_order, col_order)):\n        assert (e['col'] == col_)\n        assert (e['row'] == row_)\n    for e in es:\n        assert (e['x'] == 'x')\n        assert (e['y'] == 'y')", "masked_code": "def test_both_facet_dims(self):\n    col = 'a'\n    row = 'b'\n    col_order = list('ab')\n    row_order = list('xyz')\n    facet_spec = {'variables': {'col': col, 'row': row}, 'structure': {'col': col_order, 'row': row_order}}\n    s = Subplots({}, facet_spec, {})\n    s.init_figure(facet_spec, {})\n    n_cols = len(col_order)\n    n_rows = len(row_order)\n    assert (len(s) == (n_cols * n_rows))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    for (e, (row_, col_)) in zip(es, itertools.product(row_order, col_order)):\n        assert (e['col'] == '???')\n        assert (e['row'] == row_)\n    for e in es:\n        assert (e['x'] == 'x')\n        assert (e['y'] == 'y')", "ground_truth": "col_", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1260", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_both_facet_dims", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_both_facet_dims(self):\n    col = 'a'\n    row = 'b'\n    col_order = list('ab')\n    row_order = list('xyz')\n    facet_spec = {'variables': {'col': col, 'row': row}, 'structure': {'col': col_order, 'row': row_order}}\n    s = Subplots({}, facet_spec, {})\n    s.init_figure(facet_spec, {})\n    n_cols = len(col_order)\n    n_rows = len(row_order)\n    assert (len(s) == (n_cols * n_rows))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    for (e, (row_, col_)) in zip(es, itertools.product(row_order, col_order)):\n        assert (e['col'] == col_)\n        assert (e['row'] == row_)\n    for e in es:\n        assert (e['x'] == 'x')\n        assert (e['y'] == 'y')", "masked_code": "def test_both_facet_dims(self):\n    col = 'a'\n    row = 'b'\n    col_order = list('ab')\n    row_order = list('xyz')\n    facet_spec = {'variables': {'col': col, 'row': row}, 'structure': {'col': col_order, 'row': row_order}}\n    s = Subplots({}, facet_spec, {})\n    s.init_figure(facet_spec, {})\n    n_cols = len(col_order)\n    n_rows = len(row_order)\n    assert (len(s) == (n_cols * n_rows))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    for (e, (row_, col_)) in zip(es, itertools.product(row_order, col_order)):\n        assert (e['col'] == col_)\n        assert (e['row'] == '???')\n    for e in es:\n        assert (e['x'] == 'x')\n        assert (e['y'] == 'y')", "ground_truth": "row_", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1261", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_paired_var", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z']\n    pair_spec = {'variables': {f'{var}{i}': v for (i, v) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pair_spec['structure'][var]))\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n    tests = ((i == 0), True, True, (i == (len(s) - 1)))\n    sides = {'x': ['left', 'right', 'top', 'bottom'], 'y': ['top', 'bottom', 'left', 'right']}\n    for (side, expected) in zip(sides[var], tests):\n        assert (e[side] == expected)", "masked_code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z']\n    pair_spec = {'variables': {f'{var}{i}': v for (i, v) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == '???')\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n    tests = ((i == 0), True, True, (i == (len(s) - 1)))\n    sides = {'x': ['left', 'right', 'top', 'bottom'], 'y': ['top', 'bottom', 'left', 'right']}\n    for (side, expected) in zip(sides[var], tests):\n        assert (e[side] == expected)", "ground_truth": "len(pair_spec['structure'][var])", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1262", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_paired_var", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z']\n    pair_spec = {'variables': {f'{var}{i}': v for (i, v) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pair_spec['structure'][var]))\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n    tests = ((i == 0), True, True, (i == (len(s) - 1)))\n    sides = {'x': ['left', 'right', 'top', 'bottom'], 'y': ['top', 'bottom', 'left', 'right']}\n    for (side, expected) in zip(sides[var], tests):\n        assert (e[side] == expected)", "masked_code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z']\n    pair_spec = {'variables': {f'{var}{i}': v for (i, v) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pair_spec['structure'][var]))\n    for (i, e) in enumerate(s):\n        assert (e[var] == '???')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n    tests = ((i == 0), True, True, (i == (len(s) - 1)))\n    sides = {'x': ['left', 'right', 'top', 'bottom'], 'y': ['top', 'bottom', 'left', 'right']}\n    for (side, expected) in zip(sides[var], tests):\n        assert (e[side] == expected)", "ground_truth": "f'{var}{i}'", "quality_analysis": {"complexity_score": 5, "left_complexity": 5, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1263", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_paired_var", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z']\n    pair_spec = {'variables': {f'{var}{i}': v for (i, v) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pair_spec['structure'][var]))\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n    tests = ((i == 0), True, True, (i == (len(s) - 1)))\n    sides = {'x': ['left', 'right', 'top', 'bottom'], 'y': ['top', 'bottom', 'left', 'right']}\n    for (side, expected) in zip(sides[var], tests):\n        assert (e[side] == expected)", "masked_code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z']\n    pair_spec = {'variables': {f'{var}{i}': v for (i, v) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pair_spec['structure'][var]))\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == '???')\n        assert (e['col'] is e['row'] is None)\n    tests = ((i == 0), True, True, (i == (len(s) - 1)))\n    sides = {'x': ['left', 'right', 'top', 'bottom'], 'y': ['top', 'bottom', 'left', 'right']}\n    for (side, expected) in zip(sides[var], tests):\n        assert (e[side] == expected)", "ground_truth": "other_var", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1264", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_paired_var", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z']\n    pair_spec = {'variables': {f'{var}{i}': v for (i, v) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pair_spec['structure'][var]))\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n    tests = ((i == 0), True, True, (i == (len(s) - 1)))\n    sides = {'x': ['left', 'right', 'top', 'bottom'], 'y': ['top', 'bottom', 'left', 'right']}\n    for (side, expected) in zip(sides[var], tests):\n        assert (e[side] == expected)", "masked_code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z']\n    pair_spec = {'variables': {f'{var}{i}': v for (i, v) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pair_spec['structure'][var]))\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n    tests = ((i == 0), True, True, (i == (len(s) - 1)))\n    sides = {'x': ['left', 'right', 'top', 'bottom'], 'y': ['top', 'bottom', 'left', 'right']}\n    for (side, expected) in zip(sides[var], tests):\n        assert (e[side] == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1265", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_paired_var_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var_wrapped(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z', 'a', 'b']\n    wrap = (len(pairings) - 2)\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}, 'wrap': wrap}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pairings))\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        sides = {'x': ['top', 'bottom', 'left', 'right'], 'y': ['left', 'right', 'top', 'bottom']}\n        for (side, expected) in zip(sides[var], tests):\n            assert (e[side] == expected)", "masked_code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var_wrapped(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z', 'a', 'b']\n    wrap = (len(pairings) - 2)\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}, 'wrap': wrap}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == '???')\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        sides = {'x': ['top', 'bottom', 'left', 'right'], 'y': ['left', 'right', 'top', 'bottom']}\n        for (side, expected) in zip(sides[var], tests):\n            assert (e[side] == expected)", "ground_truth": "len(pairings)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1266", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_paired_var_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var_wrapped(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z', 'a', 'b']\n    wrap = (len(pairings) - 2)\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}, 'wrap': wrap}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pairings))\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        sides = {'x': ['top', 'bottom', 'left', 'right'], 'y': ['left', 'right', 'top', 'bottom']}\n        for (side, expected) in zip(sides[var], tests):\n            assert (e[side] == expected)", "masked_code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var_wrapped(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z', 'a', 'b']\n    wrap = (len(pairings) - 2)\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}, 'wrap': wrap}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pairings))\n    for (i, e) in enumerate(s):\n        assert (e[var] == '???')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        sides = {'x': ['top', 'bottom', 'left', 'right'], 'y': ['left', 'right', 'top', 'bottom']}\n        for (side, expected) in zip(sides[var], tests):\n            assert (e[side] == expected)", "ground_truth": "f'{var}{i}'", "quality_analysis": {"complexity_score": 5, "left_complexity": 5, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1267", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_paired_var_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var_wrapped(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z', 'a', 'b']\n    wrap = (len(pairings) - 2)\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}, 'wrap': wrap}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pairings))\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        sides = {'x': ['top', 'bottom', 'left', 'right'], 'y': ['left', 'right', 'top', 'bottom']}\n        for (side, expected) in zip(sides[var], tests):\n            assert (e[side] == expected)", "masked_code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var_wrapped(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z', 'a', 'b']\n    wrap = (len(pairings) - 2)\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}, 'wrap': wrap}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pairings))\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == '???')\n        assert (e['col'] is e['row'] is None)\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        sides = {'x': ['top', 'bottom', 'left', 'right'], 'y': ['left', 'right', 'top', 'bottom']}\n        for (side, expected) in zip(sides[var], tests):\n            assert (e[side] == expected)", "ground_truth": "other_var", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1268", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_single_paired_var_wrapped", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var_wrapped(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z', 'a', 'b']\n    wrap = (len(pairings) - 2)\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}, 'wrap': wrap}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pairings))\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        sides = {'x': ['top', 'bottom', 'left', 'right'], 'y': ['left', 'right', 'top', 'bottom']}\n        for (side, expected) in zip(sides[var], tests):\n            assert (e[side] == expected)", "masked_code": "@pytest.mark.parametrize('var', ['x', 'y'])\ndef test_single_paired_var_wrapped(self, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    pairings = ['x', 'y', 'z', 'a', 'b']\n    wrap = (len(pairings) - 2)\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}, 'wrap': wrap}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    assert (len(s) == len(pairings))\n    for (i, e) in enumerate(s):\n        assert (e[var] == f'{var}{i}')\n        assert (e[other_var] == other_var)\n        assert (e['col'] is e['row'] is None)\n        tests = ((i < wrap), ((i >= wrap) or (i >= (len(s) % wrap))), ((i % wrap) == 0), (((i % wrap) == (wrap - 1)) or ((i + 1) == len(s))))\n        sides = {'x': ['top', 'bottom', 'left', 'right'], 'y': ['left', 'right', 'top', 'bottom']}\n        for (side, expected) in zip(sides[var], tests):\n            assert (e[side] == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1269", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_both_paired_variables", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_both_paired_variables(self):\n    x = ['x0', 'x1']\n    y = ['y0', 'y1', 'y2']\n    pair_spec = {'structure': {'x': x, 'y': y}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = len(x)\n    n_rows = len(y)\n    assert (len(s) == (n_cols * n_rows))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    for e in es:\n        assert (e['col'] is e['row'] is None)\n    for i in range(len(y)):\n        for j in range(len(x)):\n            e = es[((i * len(x)) + j)]\n            assert (e['x'] == f'x{j}')\n            assert (e['y'] == f'y{i}')", "masked_code": "def test_both_paired_variables(self):\n    x = ['x0', 'x1']\n    y = ['y0', 'y1', 'y2']\n    pair_spec = {'structure': {'x': x, 'y': y}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = len(x)\n    n_rows = len(y)\n    assert (len(s) == '???')\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    for e in es:\n        assert (e['col'] is e['row'] is None)\n    for i in range(len(y)):\n        for j in range(len(x)):\n            e = es[((i * len(x)) + j)]\n            assert (e['x'] == f'x{j}')\n            assert (e['y'] == f'y{i}')", "ground_truth": "(n_cols * n_rows)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1270", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_both_paired_variables", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_both_paired_variables(self):\n    x = ['x0', 'x1']\n    y = ['y0', 'y1', 'y2']\n    pair_spec = {'structure': {'x': x, 'y': y}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = len(x)\n    n_rows = len(y)\n    assert (len(s) == (n_cols * n_rows))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    for e in es:\n        assert (e['col'] is e['row'] is None)\n    for i in range(len(y)):\n        for j in range(len(x)):\n            e = es[((i * len(x)) + j)]\n            assert (e['x'] == f'x{j}')\n            assert (e['y'] == f'y{i}')", "masked_code": "def test_both_paired_variables(self):\n    x = ['x0', 'x1']\n    y = ['y0', 'y1', 'y2']\n    pair_spec = {'structure': {'x': x, 'y': y}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = len(x)\n    n_rows = len(y)\n    assert (len(s) == (n_cols * n_rows))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    for e in es:\n        assert (e['col'] is e['row'] is None)\n    for i in range(len(y)):\n        for j in range(len(x)):\n            e = es[((i * len(x)) + j)]\n            assert (e['x'] == '???')\n            assert (e['y'] == f'y{i}')", "ground_truth": "f'x{j}'", "quality_analysis": {"complexity_score": 5, "left_complexity": 5, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1271", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_both_paired_variables", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_both_paired_variables(self):\n    x = ['x0', 'x1']\n    y = ['y0', 'y1', 'y2']\n    pair_spec = {'structure': {'x': x, 'y': y}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = len(x)\n    n_rows = len(y)\n    assert (len(s) == (n_cols * n_rows))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    for e in es:\n        assert (e['col'] is e['row'] is None)\n    for i in range(len(y)):\n        for j in range(len(x)):\n            e = es[((i * len(x)) + j)]\n            assert (e['x'] == f'x{j}')\n            assert (e['y'] == f'y{i}')", "masked_code": "def test_both_paired_variables(self):\n    x = ['x0', 'x1']\n    y = ['y0', 'y1', 'y2']\n    pair_spec = {'structure': {'x': x, 'y': y}}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = len(x)\n    n_rows = len(y)\n    assert (len(s) == (n_cols * n_rows))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    for e in es:\n        assert (e['col'] is e['row'] is None)\n    for i in range(len(y)):\n        for j in range(len(x)):\n            e = es[((i * len(x)) + j)]\n            assert (e['x'] == f'x{j}')\n            assert (e['y'] == '???')", "ground_truth": "f'y{i}'", "quality_analysis": {"complexity_score": 5, "left_complexity": 5, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1272", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_both_paired_non_cross", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_both_paired_non_cross(self):\n    pair_spec = {'structure': {'x': ['x0', 'x1', 'x2'], 'y': ['y0', 'y1', 'y2']}, 'cross': False}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    for (i, e) in enumerate(s):\n        assert (e['x'] == f'x{i}')\n        assert (e['y'] == f'y{i}')\n        assert (e['col'] is e['row'] is None)\n        assert (e['left'] == (i == 0))\n        assert (e['right'] == (i == (len(s) - 1)))\n        assert e['top']\n        assert e['bottom']", "masked_code": "def test_both_paired_non_cross(self):\n    pair_spec = {'structure': {'x': ['x0', 'x1', 'x2'], 'y': ['y0', 'y1', 'y2']}, 'cross': False}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    for (i, e) in enumerate(s):\n        assert (e['x'] == '???')\n        assert (e['y'] == f'y{i}')\n        assert (e['col'] is e['row'] is None)\n        assert (e['left'] == (i == 0))\n        assert (e['right'] == (i == (len(s) - 1)))\n        assert e['top']\n        assert e['bottom']", "ground_truth": "f'x{i}'", "quality_analysis": {"complexity_score": 5, "left_complexity": 5, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1273", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_both_paired_non_cross", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_both_paired_non_cross(self):\n    pair_spec = {'structure': {'x': ['x0', 'x1', 'x2'], 'y': ['y0', 'y1', 'y2']}, 'cross': False}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    for (i, e) in enumerate(s):\n        assert (e['x'] == f'x{i}')\n        assert (e['y'] == f'y{i}')\n        assert (e['col'] is e['row'] is None)\n        assert (e['left'] == (i == 0))\n        assert (e['right'] == (i == (len(s) - 1)))\n        assert e['top']\n        assert e['bottom']", "masked_code": "def test_both_paired_non_cross(self):\n    pair_spec = {'structure': {'x': ['x0', 'x1', 'x2'], 'y': ['y0', 'y1', 'y2']}, 'cross': False}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    for (i, e) in enumerate(s):\n        assert (e['x'] == f'x{i}')\n        assert (e['y'] == '???')\n        assert (e['col'] is e['row'] is None)\n        assert (e['left'] == (i == 0))\n        assert (e['right'] == (i == (len(s) - 1)))\n        assert e['top']\n        assert e['bottom']", "ground_truth": "f'y{i}'", "quality_analysis": {"complexity_score": 5, "left_complexity": 5, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1274", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_both_paired_non_cross", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_both_paired_non_cross(self):\n    pair_spec = {'structure': {'x': ['x0', 'x1', 'x2'], 'y': ['y0', 'y1', 'y2']}, 'cross': False}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    for (i, e) in enumerate(s):\n        assert (e['x'] == f'x{i}')\n        assert (e['y'] == f'y{i}')\n        assert (e['col'] is e['row'] is None)\n        assert (e['left'] == (i == 0))\n        assert (e['right'] == (i == (len(s) - 1)))\n        assert e['top']\n        assert e['bottom']", "masked_code": "def test_both_paired_non_cross(self):\n    pair_spec = {'structure': {'x': ['x0', 'x1', 'x2'], 'y': ['y0', 'y1', 'y2']}, 'cross': False}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    for (i, e) in enumerate(s):\n        assert (e['x'] == f'x{i}')\n        assert (e['y'] == f'y{i}')\n        assert (e['col'] is e['row'] is None)\n        assert (e['left'] == '???')\n        assert (e['right'] == (i == (len(s) - 1)))\n        assert e['top']\n        assert e['bottom']", "ground_truth": "(i == 0)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1275", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_both_paired_non_cross", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "def test_both_paired_non_cross(self):\n    pair_spec = {'structure': {'x': ['x0', 'x1', 'x2'], 'y': ['y0', 'y1', 'y2']}, 'cross': False}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    for (i, e) in enumerate(s):\n        assert (e['x'] == f'x{i}')\n        assert (e['y'] == f'y{i}')\n        assert (e['col'] is e['row'] is None)\n        assert (e['left'] == (i == 0))\n        assert (e['right'] == (i == (len(s) - 1)))\n        assert e['top']\n        assert e['bottom']", "masked_code": "def test_both_paired_non_cross(self):\n    pair_spec = {'structure': {'x': ['x0', 'x1', 'x2'], 'y': ['y0', 'y1', 'y2']}, 'cross': False}\n    s = Subplots({}, {}, pair_spec)\n    s.init_figure(pair_spec)\n    for (i, e) in enumerate(s):\n        assert (e['x'] == f'x{i}')\n        assert (e['y'] == f'y{i}')\n        assert (e['col'] is e['row'] is None)\n        assert (e['left'] == (i == 0))\n        assert (e['right'] == '???')\n        assert e['top']\n        assert e['bottom']", "ground_truth": "(i == (len(s) - 1))", "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1276", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_one_facet_one_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim,var', [('col', 'y'), ('row', 'x')])\ndef test_one_facet_one_paired(self, dim, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    other_dim = {'col': 'row', 'row': 'col'}[dim]\n    order = list('abc')\n    facet_spec = {'variables': {dim: 's'}, 'structure': {dim: order}}\n    pairings = ['x', 'y', 't']\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, facet_spec, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = (len(order) if (dim == 'col') else len(pairings))\n    n_rows = (len(order) if (dim == 'row') else len(pairings))\n    assert (len(s) == (len(order) * len(pairings)))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    if (dim == 'row'):\n        es = np.reshape(es, (n_rows, n_cols)).T.ravel()\n    for (i, e) in enumerate(es):\n        assert (e[dim] == order[(i % len(pairings))])\n        assert (e[other_dim] is None)\n        assert (e[var] == f'{var}{(i // len(order))}')\n        assert (e[other_var] == other_var)", "masked_code": "@pytest.mark.parametrize('dim,var', [('col', 'y'), ('row', 'x')])\ndef test_one_facet_one_paired(self, dim, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    other_dim = {'col': 'row', 'row': 'col'}[dim]\n    order = list('abc')\n    facet_spec = {'variables': {dim: 's'}, 'structure': {dim: order}}\n    pairings = ['x', 'y', 't']\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, facet_spec, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = (len(order) if (dim == 'col') else len(pairings))\n    n_rows = (len(order) if (dim == 'row') else len(pairings))\n    assert (len(s) == '???')\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    if (dim == 'row'):\n        es = np.reshape(es, (n_rows, n_cols)).T.ravel()\n    for (i, e) in enumerate(es):\n        assert (e[dim] == order[(i % len(pairings))])\n        assert (e[other_dim] is None)\n        assert (e[var] == f'{var}{(i // len(order))}')\n        assert (e[other_var] == other_var)", "ground_truth": "(len(order) * len(pairings))", "quality_analysis": {"complexity_score": 14, "left_complexity": 4, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1277", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_one_facet_one_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim,var', [('col', 'y'), ('row', 'x')])\ndef test_one_facet_one_paired(self, dim, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    other_dim = {'col': 'row', 'row': 'col'}[dim]\n    order = list('abc')\n    facet_spec = {'variables': {dim: 's'}, 'structure': {dim: order}}\n    pairings = ['x', 'y', 't']\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, facet_spec, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = (len(order) if (dim == 'col') else len(pairings))\n    n_rows = (len(order) if (dim == 'row') else len(pairings))\n    assert (len(s) == (len(order) * len(pairings)))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    if (dim == 'row'):\n        es = np.reshape(es, (n_rows, n_cols)).T.ravel()\n    for (i, e) in enumerate(es):\n        assert (e[dim] == order[(i % len(pairings))])\n        assert (e[other_dim] is None)\n        assert (e[var] == f'{var}{(i // len(order))}')\n        assert (e[other_var] == other_var)", "masked_code": "@pytest.mark.parametrize('dim,var', [('col', 'y'), ('row', 'x')])\ndef test_one_facet_one_paired(self, dim, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    other_dim = {'col': 'row', 'row': 'col'}[dim]\n    order = list('abc')\n    facet_spec = {'variables': {dim: 's'}, 'structure': {dim: order}}\n    pairings = ['x', 'y', 't']\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, facet_spec, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = (len(order) if (dim == 'col') else len(pairings))\n    n_rows = (len(order) if (dim == 'row') else len(pairings))\n    assert (len(s) == (len(order) * len(pairings)))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    if (dim == 'row'):\n        es = np.reshape(es, (n_rows, n_cols)).T.ravel()\n    for (i, e) in enumerate(es):\n        assert (e[dim] == '???')\n        assert (e[other_dim] is None)\n        assert (e[var] == f'{var}{(i // len(order))}')\n        assert (e[other_var] == other_var)", "ground_truth": "order[(i % len(pairings))]", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1278", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_one_facet_one_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim,var', [('col', 'y'), ('row', 'x')])\ndef test_one_facet_one_paired(self, dim, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    other_dim = {'col': 'row', 'row': 'col'}[dim]\n    order = list('abc')\n    facet_spec = {'variables': {dim: 's'}, 'structure': {dim: order}}\n    pairings = ['x', 'y', 't']\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, facet_spec, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = (len(order) if (dim == 'col') else len(pairings))\n    n_rows = (len(order) if (dim == 'row') else len(pairings))\n    assert (len(s) == (len(order) * len(pairings)))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    if (dim == 'row'):\n        es = np.reshape(es, (n_rows, n_cols)).T.ravel()\n    for (i, e) in enumerate(es):\n        assert (e[dim] == order[(i % len(pairings))])\n        assert (e[other_dim] is None)\n        assert (e[var] == f'{var}{(i // len(order))}')\n        assert (e[other_var] == other_var)", "masked_code": "@pytest.mark.parametrize('dim,var', [('col', 'y'), ('row', 'x')])\ndef test_one_facet_one_paired(self, dim, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    other_dim = {'col': 'row', 'row': 'col'}[dim]\n    order = list('abc')\n    facet_spec = {'variables': {dim: 's'}, 'structure': {dim: order}}\n    pairings = ['x', 'y', 't']\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, facet_spec, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = (len(order) if (dim == 'col') else len(pairings))\n    n_rows = (len(order) if (dim == 'row') else len(pairings))\n    assert (len(s) == (len(order) * len(pairings)))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    if (dim == 'row'):\n        es = np.reshape(es, (n_rows, n_cols)).T.ravel()\n    for (i, e) in enumerate(es):\n        assert (e[dim] == order[(i % len(pairings))])\n        assert (e[other_dim] is None)\n        assert (e[var] == '???')\n        assert (e[other_var] == other_var)", "ground_truth": "f'{var}{(i // len(order))}'", "quality_analysis": {"complexity_score": 5, "left_complexity": 5, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1279", "reponame": "seaborn", "testpath": "tests/_core/test_subplots.py", "testname": "test_subplots.py", "classname": "TestSubplotElements", "funcname": "test_one_facet_one_paired", "imports": ["import itertools", "import numpy as np", "import pytest", "from seaborn._core.subplots import Subplots"], "code": "@pytest.mark.parametrize('dim,var', [('col', 'y'), ('row', 'x')])\ndef test_one_facet_one_paired(self, dim, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    other_dim = {'col': 'row', 'row': 'col'}[dim]\n    order = list('abc')\n    facet_spec = {'variables': {dim: 's'}, 'structure': {dim: order}}\n    pairings = ['x', 'y', 't']\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, facet_spec, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = (len(order) if (dim == 'col') else len(pairings))\n    n_rows = (len(order) if (dim == 'row') else len(pairings))\n    assert (len(s) == (len(order) * len(pairings)))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    if (dim == 'row'):\n        es = np.reshape(es, (n_rows, n_cols)).T.ravel()\n    for (i, e) in enumerate(es):\n        assert (e[dim] == order[(i % len(pairings))])\n        assert (e[other_dim] is None)\n        assert (e[var] == f'{var}{(i // len(order))}')\n        assert (e[other_var] == other_var)", "masked_code": "@pytest.mark.parametrize('dim,var', [('col', 'y'), ('row', 'x')])\ndef test_one_facet_one_paired(self, dim, var):\n    other_var = {'x': 'y', 'y': 'x'}[var]\n    other_dim = {'col': 'row', 'row': 'col'}[dim]\n    order = list('abc')\n    facet_spec = {'variables': {dim: 's'}, 'structure': {dim: order}}\n    pairings = ['x', 'y', 't']\n    pair_spec = {'variables': {f'{var}{i}': val for (i, val) in enumerate(pairings)}, 'structure': {var: [f'{var}{i}' for (i, _) in enumerate(pairings)]}}\n    s = Subplots({}, facet_spec, pair_spec)\n    s.init_figure(pair_spec)\n    n_cols = (len(order) if (dim == 'col') else len(pairings))\n    n_rows = (len(order) if (dim == 'row') else len(pairings))\n    assert (len(s) == (len(order) * len(pairings)))\n    es = list(s)\n    for e in es[:n_cols]:\n        assert e['top']\n    for e in es[::n_cols]:\n        assert e['left']\n    for e in es[(n_cols - 1)::n_cols]:\n        assert e['right']\n    for e in es[(- n_cols):]:\n        assert e['bottom']\n    if (dim == 'row'):\n        es = np.reshape(es, (n_rows, n_cols)).T.ravel()\n    for (i, e) in enumerate(es):\n        assert (e[dim] == order[(i % len(pairings))])\n        assert (e[other_dim] is None)\n        assert (e[var] == f'{var}{(i // len(order))}')\n        assert (e[other_var] == '???')", "ground_truth": "other_var", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1280", "reponame": "seaborn", "testpath": "tests/_marks/test_area.py", "testname": "test_area.py", "classname": "TestArea", "funcname": "test_unfilled", "imports": ["import matplotlib as mpl", "from matplotlib.colors import to_rgba, to_rgba_array", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.area import Area, Band"], "code": "def test_unfilled(self):\n    (x, y) = ([1, 2, 3], [1, 2, 1])\n    c = '.5'\n    p = Plot(x=x, y=y).add(Area(fill=False, color=c)).plot()\n    ax = p._figure.axes[0]\n    poly = ax.patches[0]\n    assert (poly.get_facecolor() == to_rgba(c, 0))", "masked_code": "def test_unfilled(self):\n    (x, y) = ([1, 2, 3], [1, 2, 1])\n    c = '.5'\n    p = Plot(x=x, y=y).add(Area(fill=False, color=c)).plot()\n    ax = p._figure.axes[0]\n    poly = ax.patches[0]\n    assert (poly.get_facecolor() == '???')", "ground_truth": "to_rgba(c, 0)", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1281", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBar", "funcname": "test_set_properties", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_set_properties(self):\n    x = ['a', 'b', 'c']\n    y = [1, 3, 2]\n    mark = Bar(color='.8', alpha=0.5, edgecolor='.3', edgealpha=0.9, edgestyle=(2, 1), edgewidth=1.5)\n    p = Plot(x, y).add(mark).plot()\n    ax = p._figure.axes[0]\n    for bar in ax.patches:\n        assert (bar.get_facecolor() == to_rgba(mark.color, mark.alpha))\n        assert (bar.get_edgecolor() == to_rgba(mark.edgecolor, mark.edgealpha))\n        assert (bar.get_linewidth() == (mark.edgewidth * 2))\n        expected_dashes = ((mark.edgestyle[0] / 2), (mark.edgestyle[1] / 2))\n        assert (bar.get_linestyle() == (0, expected_dashes))", "masked_code": "def test_set_properties(self):\n    x = ['a', 'b', 'c']\n    y = [1, 3, 2]\n    mark = Bar(color='.8', alpha=0.5, edgecolor='.3', edgealpha=0.9, edgestyle=(2, 1), edgewidth=1.5)\n    p = Plot(x, y).add(mark).plot()\n    ax = p._figure.axes[0]\n    for bar in ax.patches:\n        assert (bar.get_facecolor() == '???')\n        assert (bar.get_edgecolor() == to_rgba(mark.edgecolor, mark.edgealpha))\n        assert (bar.get_linewidth() == (mark.edgewidth * 2))\n        expected_dashes = ((mark.edgestyle[0] / 2), (mark.edgestyle[1] / 2))\n        assert (bar.get_linestyle() == (0, expected_dashes))", "ground_truth": "to_rgba(mark.color, mark.alpha)", "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1282", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBar", "funcname": "test_set_properties", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_set_properties(self):\n    x = ['a', 'b', 'c']\n    y = [1, 3, 2]\n    mark = Bar(color='.8', alpha=0.5, edgecolor='.3', edgealpha=0.9, edgestyle=(2, 1), edgewidth=1.5)\n    p = Plot(x, y).add(mark).plot()\n    ax = p._figure.axes[0]\n    for bar in ax.patches:\n        assert (bar.get_facecolor() == to_rgba(mark.color, mark.alpha))\n        assert (bar.get_edgecolor() == to_rgba(mark.edgecolor, mark.edgealpha))\n        assert (bar.get_linewidth() == (mark.edgewidth * 2))\n        expected_dashes = ((mark.edgestyle[0] / 2), (mark.edgestyle[1] / 2))\n        assert (bar.get_linestyle() == (0, expected_dashes))", "masked_code": "def test_set_properties(self):\n    x = ['a', 'b', 'c']\n    y = [1, 3, 2]\n    mark = Bar(color='.8', alpha=0.5, edgecolor='.3', edgealpha=0.9, edgestyle=(2, 1), edgewidth=1.5)\n    p = Plot(x, y).add(mark).plot()\n    ax = p._figure.axes[0]\n    for bar in ax.patches:\n        assert (bar.get_facecolor() == to_rgba(mark.color, mark.alpha))\n        assert (bar.get_edgecolor() == '???')\n        assert (bar.get_linewidth() == (mark.edgewidth * 2))\n        expected_dashes = ((mark.edgestyle[0] / 2), (mark.edgestyle[1] / 2))\n        assert (bar.get_linestyle() == (0, expected_dashes))", "ground_truth": "to_rgba(mark.edgecolor, mark.edgealpha)", "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1283", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBar", "funcname": "test_set_properties", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_set_properties(self):\n    x = ['a', 'b', 'c']\n    y = [1, 3, 2]\n    mark = Bar(color='.8', alpha=0.5, edgecolor='.3', edgealpha=0.9, edgestyle=(2, 1), edgewidth=1.5)\n    p = Plot(x, y).add(mark).plot()\n    ax = p._figure.axes[0]\n    for bar in ax.patches:\n        assert (bar.get_facecolor() == to_rgba(mark.color, mark.alpha))\n        assert (bar.get_edgecolor() == to_rgba(mark.edgecolor, mark.edgealpha))\n        assert (bar.get_linewidth() == (mark.edgewidth * 2))\n        expected_dashes = ((mark.edgestyle[0] / 2), (mark.edgestyle[1] / 2))\n        assert (bar.get_linestyle() == (0, expected_dashes))", "masked_code": "def test_set_properties(self):\n    x = ['a', 'b', 'c']\n    y = [1, 3, 2]\n    mark = Bar(color='.8', alpha=0.5, edgecolor='.3', edgealpha=0.9, edgestyle=(2, 1), edgewidth=1.5)\n    p = Plot(x, y).add(mark).plot()\n    ax = p._figure.axes[0]\n    for bar in ax.patches:\n        assert (bar.get_facecolor() == to_rgba(mark.color, mark.alpha))\n        assert (bar.get_edgecolor() == to_rgba(mark.edgecolor, mark.edgealpha))\n        assert (bar.get_linewidth() == '???')\n        expected_dashes = ((mark.edgestyle[0] / 2), (mark.edgestyle[1] / 2))\n        assert (bar.get_linestyle() == (0, expected_dashes))", "ground_truth": "(mark.edgewidth * 2)", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1284", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBar", "funcname": "test_set_properties", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_set_properties(self):\n    x = ['a', 'b', 'c']\n    y = [1, 3, 2]\n    mark = Bar(color='.8', alpha=0.5, edgecolor='.3', edgealpha=0.9, edgestyle=(2, 1), edgewidth=1.5)\n    p = Plot(x, y).add(mark).plot()\n    ax = p._figure.axes[0]\n    for bar in ax.patches:\n        assert (bar.get_facecolor() == to_rgba(mark.color, mark.alpha))\n        assert (bar.get_edgecolor() == to_rgba(mark.edgecolor, mark.edgealpha))\n        assert (bar.get_linewidth() == (mark.edgewidth * 2))\n        expected_dashes = ((mark.edgestyle[0] / 2), (mark.edgestyle[1] / 2))\n        assert (bar.get_linestyle() == (0, expected_dashes))", "masked_code": "def test_set_properties(self):\n    x = ['a', 'b', 'c']\n    y = [1, 3, 2]\n    mark = Bar(color='.8', alpha=0.5, edgecolor='.3', edgealpha=0.9, edgestyle=(2, 1), edgewidth=1.5)\n    p = Plot(x, y).add(mark).plot()\n    ax = p._figure.axes[0]\n    for bar in ax.patches:\n        assert (bar.get_facecolor() == to_rgba(mark.color, mark.alpha))\n        assert (bar.get_edgecolor() == to_rgba(mark.edgecolor, mark.edgealpha))\n        assert (bar.get_linewidth() == (mark.edgewidth * 2))\n        expected_dashes = ((mark.edgestyle[0] / 2), (mark.edgestyle[1] / 2))\n        assert (bar.get_linestyle() == '???')", "ground_truth": "(0, expected_dashes)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1285", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBar", "funcname": "test_mapped_properties", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_mapped_properties(self):\n    x = ['a', 'b']\n    y = [1, 2]\n    mark = Bar(alpha=0.2)\n    p = Plot(x, y, color=x, edgewidth=y).add(mark).plot()\n    ax = p._figure.axes[0]\n    colors = p._theme['axes.prop_cycle'].by_key()['color']\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_facecolor() == to_rgba(colors[i], mark.alpha))\n        assert (bar.get_edgecolor() == to_rgba(colors[i], 1))\n    assert (ax.patches[0].get_linewidth() < ax.patches[1].get_linewidth())", "masked_code": "def test_mapped_properties(self):\n    x = ['a', 'b']\n    y = [1, 2]\n    mark = Bar(alpha=0.2)\n    p = Plot(x, y, color=x, edgewidth=y).add(mark).plot()\n    ax = p._figure.axes[0]\n    colors = p._theme['axes.prop_cycle'].by_key()['color']\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_facecolor() == '???')\n        assert (bar.get_edgecolor() == to_rgba(colors[i], 1))\n    assert (ax.patches[0].get_linewidth() < ax.patches[1].get_linewidth())", "ground_truth": "to_rgba(colors[i], mark.alpha)", "quality_analysis": {"complexity_score": 13, "left_complexity": 3, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1286", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBar", "funcname": "test_mapped_properties", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_mapped_properties(self):\n    x = ['a', 'b']\n    y = [1, 2]\n    mark = Bar(alpha=0.2)\n    p = Plot(x, y, color=x, edgewidth=y).add(mark).plot()\n    ax = p._figure.axes[0]\n    colors = p._theme['axes.prop_cycle'].by_key()['color']\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_facecolor() == to_rgba(colors[i], mark.alpha))\n        assert (bar.get_edgecolor() == to_rgba(colors[i], 1))\n    assert (ax.patches[0].get_linewidth() < ax.patches[1].get_linewidth())", "masked_code": "def test_mapped_properties(self):\n    x = ['a', 'b']\n    y = [1, 2]\n    mark = Bar(alpha=0.2)\n    p = Plot(x, y, color=x, edgewidth=y).add(mark).plot()\n    ax = p._figure.axes[0]\n    colors = p._theme['axes.prop_cycle'].by_key()['color']\n    for (i, bar) in enumerate(ax.patches):\n        assert (bar.get_facecolor() == to_rgba(colors[i], mark.alpha))\n        assert (bar.get_edgecolor() == '???')\n    assert (ax.patches[0].get_linewidth() < ax.patches[1].get_linewidth())", "ground_truth": "to_rgba(colors[i], 1)", "quality_analysis": {"complexity_score": 12, "left_complexity": 3, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1287", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBars", "funcname": "test_positions", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_positions(self, x, y):\n    p = Plot(x, y).add(Bars()).plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 0)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(1, 0)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 1)] == 0)\n        assert (verts[(3, 1)] == y[i])", "masked_code": "def test_positions(self, x, y):\n    p = Plot(x, y).add(Bars()).plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == '???')\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 0)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(1, 0)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 1)] == 0)\n        assert (verts[(3, 1)] == y[i])", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1288", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBars", "funcname": "test_positions", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_positions(self, x, y):\n    p = Plot(x, y).add(Bars()).plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 0)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(1, 0)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 1)] == 0)\n        assert (verts[(3, 1)] == y[i])", "masked_code": "def test_positions(self, x, y):\n    p = Plot(x, y).add(Bars()).plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 0)] == '???')\n        assert (verts[(1, 0)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 1)] == 0)\n        assert (verts[(3, 1)] == y[i])", "ground_truth": "pytest.approx((x[i] - 0.5))", "quality_analysis": {"complexity_score": 19, "left_complexity": 8, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1289", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBars", "funcname": "test_positions", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_positions(self, x, y):\n    p = Plot(x, y).add(Bars()).plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 0)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(1, 0)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 1)] == 0)\n        assert (verts[(3, 1)] == y[i])", "masked_code": "def test_positions(self, x, y):\n    p = Plot(x, y).add(Bars()).plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 0)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(1, 0)] == '???')\n        assert (verts[(0, 1)] == 0)\n        assert (verts[(3, 1)] == y[i])", "ground_truth": "pytest.approx((x[i] + 0.5))", "quality_analysis": {"complexity_score": 19, "left_complexity": 8, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1290", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBars", "funcname": "test_positions", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_positions(self, x, y):\n    p = Plot(x, y).add(Bars()).plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 0)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(1, 0)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 1)] == 0)\n        assert (verts[(3, 1)] == y[i])", "masked_code": "def test_positions(self, x, y):\n    p = Plot(x, y).add(Bars()).plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 0)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(1, 0)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 1)] == 0)\n        assert (verts[(3, 1)] == '???')", "ground_truth": "y[i]", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1291", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBars", "funcname": "test_positions_horizontal", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_positions_horizontal(self, x, y):\n    p = Plot(x=y, y=x).add(Bars(), orient='h').plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 1)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(3, 1)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 0)] == 0)\n        assert (verts[(1, 0)] == y[i])", "masked_code": "def test_positions_horizontal(self, x, y):\n    p = Plot(x=y, y=x).add(Bars(), orient='h').plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == '???')\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 1)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(3, 1)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 0)] == 0)\n        assert (verts[(1, 0)] == y[i])", "ground_truth": "len(x)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1292", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBars", "funcname": "test_positions_horizontal", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_positions_horizontal(self, x, y):\n    p = Plot(x=y, y=x).add(Bars(), orient='h').plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 1)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(3, 1)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 0)] == 0)\n        assert (verts[(1, 0)] == y[i])", "masked_code": "def test_positions_horizontal(self, x, y):\n    p = Plot(x=y, y=x).add(Bars(), orient='h').plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 1)] == '???')\n        assert (verts[(3, 1)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 0)] == 0)\n        assert (verts[(1, 0)] == y[i])", "ground_truth": "pytest.approx((x[i] - 0.5))", "quality_analysis": {"complexity_score": 19, "left_complexity": 8, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1293", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBars", "funcname": "test_positions_horizontal", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_positions_horizontal(self, x, y):\n    p = Plot(x=y, y=x).add(Bars(), orient='h').plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 1)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(3, 1)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 0)] == 0)\n        assert (verts[(1, 0)] == y[i])", "masked_code": "def test_positions_horizontal(self, x, y):\n    p = Plot(x=y, y=x).add(Bars(), orient='h').plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 1)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(3, 1)] == '???')\n        assert (verts[(0, 0)] == 0)\n        assert (verts[(1, 0)] == y[i])", "ground_truth": "pytest.approx((x[i] + 0.5))", "quality_analysis": {"complexity_score": 19, "left_complexity": 8, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1294", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBars", "funcname": "test_positions_horizontal", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_positions_horizontal(self, x, y):\n    p = Plot(x=y, y=x).add(Bars(), orient='h').plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 1)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(3, 1)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 0)] == 0)\n        assert (verts[(1, 0)] == y[i])", "masked_code": "def test_positions_horizontal(self, x, y):\n    p = Plot(x=y, y=x).add(Bars(), orient='h').plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    assert (len(paths) == len(x))\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 1)] == pytest.approx((x[i] - 0.5)))\n        assert (verts[(3, 1)] == pytest.approx((x[i] + 0.5)))\n        assert (verts[(0, 0)] == 0)\n        assert (verts[(1, 0)] == '???')", "ground_truth": "y[i]", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1295", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBars", "funcname": "test_width", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_width(self, x, y):\n    p = Plot(x, y).add(Bars(width=0.4)).plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 0)] == pytest.approx((x[i] - 0.2)))\n        assert (verts[(1, 0)] == pytest.approx((x[i] + 0.2)))", "masked_code": "def test_width(self, x, y):\n    p = Plot(x, y).add(Bars(width=0.4)).plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 0)] == '???')\n        assert (verts[(1, 0)] == pytest.approx((x[i] + 0.2)))", "ground_truth": "pytest.approx((x[i] - 0.2))", "quality_analysis": {"complexity_score": 19, "left_complexity": 8, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1296", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBars", "funcname": "test_width", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_width(self, x, y):\n    p = Plot(x, y).add(Bars(width=0.4)).plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 0)] == pytest.approx((x[i] - 0.2)))\n        assert (verts[(1, 0)] == pytest.approx((x[i] + 0.2)))", "masked_code": "def test_width(self, x, y):\n    p = Plot(x, y).add(Bars(width=0.4)).plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    for (i, path) in enumerate(paths):\n        verts = path.vertices\n        assert (verts[(0, 0)] == pytest.approx((x[i] - 0.2)))\n        assert (verts[(1, 0)] == '???')", "ground_truth": "pytest.approx((x[i] + 0.2))", "quality_analysis": {"complexity_score": 19, "left_complexity": 8, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1297", "reponame": "seaborn", "testpath": "tests/_marks/test_bar.py", "testname": "test_bar.py", "classname": "TestBars", "funcname": "test_log_scale", "imports": ["import numpy as np", "import pandas as pd", "from matplotlib.colors import to_rgba, to_rgba_array", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.bar import Bar, Bars"], "code": "def test_log_scale(self):\n    x = y = [1, 10, 100, 1000]\n    p = Plot(x, y).add(Bars()).scale(x='log').plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    for (a, b) in zip(paths, paths[1:]):\n        assert (a.vertices[(1, 0)] == pytest.approx(b.vertices[(0, 0)]))", "masked_code": "def test_log_scale(self):\n    x = y = [1, 10, 100, 1000]\n    p = Plot(x, y).add(Bars()).scale(x='log').plot()\n    ax = p._figure.axes[0]\n    paths = ax.collections[0].get_paths()\n    for (a, b) in zip(paths, paths[1:]):\n        assert (a.vertices[(1, 0)] == '???')", "ground_truth": "pytest.approx(b.vertices[(0, 0)])", "quality_analysis": {"complexity_score": 21, "left_complexity": 9, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1298", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_repr", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_repr(self):\n    assert (str(Mappable(0.5)) == '<0.5>')\n    assert (str(Mappable('CO')) == \"<'CO'>\")\n    assert (str(Mappable(rc='lines.linewidth')) == '<rc:lines.linewidth>')\n    assert (str(Mappable(depend='color')) == '<depend:color>')\n    assert (str(Mappable(auto=True)) == '<auto>')", "masked_code": "def test_repr(self):\n    assert (str(Mappable(0.5)) == '???')\n    assert (str(Mappable('CO')) == \"<'CO'>\")\n    assert (str(Mappable(rc='lines.linewidth')) == '<rc:lines.linewidth>')\n    assert (str(Mappable(depend='color')) == '<depend:color>')\n    assert (str(Mappable(auto=True)) == '<auto>')", "ground_truth": "'<0.5>'", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1299", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_repr", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_repr(self):\n    assert (str(Mappable(0.5)) == '<0.5>')\n    assert (str(Mappable('CO')) == \"<'CO'>\")\n    assert (str(Mappable(rc='lines.linewidth')) == '<rc:lines.linewidth>')\n    assert (str(Mappable(depend='color')) == '<depend:color>')\n    assert (str(Mappable(auto=True)) == '<auto>')", "masked_code": "def test_repr(self):\n    assert (str(Mappable(0.5)) == '<0.5>')\n    assert (str(Mappable('CO')) == '???')\n    assert (str(Mappable(rc='lines.linewidth')) == '<rc:lines.linewidth>')\n    assert (str(Mappable(depend='color')) == '<depend:color>')\n    assert (str(Mappable(auto=True)) == '<auto>')", "ground_truth": "\"<'CO'>\"", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1300", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_repr", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_repr(self):\n    assert (str(Mappable(0.5)) == '<0.5>')\n    assert (str(Mappable('CO')) == \"<'CO'>\")\n    assert (str(Mappable(rc='lines.linewidth')) == '<rc:lines.linewidth>')\n    assert (str(Mappable(depend='color')) == '<depend:color>')\n    assert (str(Mappable(auto=True)) == '<auto>')", "masked_code": "def test_repr(self):\n    assert (str(Mappable(0.5)) == '<0.5>')\n    assert (str(Mappable('CO')) == \"<'CO'>\")\n    assert (str(Mappable(rc='lines.linewidth')) == '???')\n    assert (str(Mappable(depend='color')) == '<depend:color>')\n    assert (str(Mappable(auto=True)) == '<auto>')", "ground_truth": "'<rc:lines.linewidth>'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1301", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_repr", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_repr(self):\n    assert (str(Mappable(0.5)) == '<0.5>')\n    assert (str(Mappable('CO')) == \"<'CO'>\")\n    assert (str(Mappable(rc='lines.linewidth')) == '<rc:lines.linewidth>')\n    assert (str(Mappable(depend='color')) == '<depend:color>')\n    assert (str(Mappable(auto=True)) == '<auto>')", "masked_code": "def test_repr(self):\n    assert (str(Mappable(0.5)) == '<0.5>')\n    assert (str(Mappable('CO')) == \"<'CO'>\")\n    assert (str(Mappable(rc='lines.linewidth')) == '<rc:lines.linewidth>')\n    assert (str(Mappable(depend='color')) == '???')\n    assert (str(Mappable(auto=True)) == '<auto>')", "ground_truth": "'<depend:color>'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1302", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_repr", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_repr(self):\n    assert (str(Mappable(0.5)) == '<0.5>')\n    assert (str(Mappable('CO')) == \"<'CO'>\")\n    assert (str(Mappable(rc='lines.linewidth')) == '<rc:lines.linewidth>')\n    assert (str(Mappable(depend='color')) == '<depend:color>')\n    assert (str(Mappable(auto=True)) == '<auto>')", "masked_code": "def test_repr(self):\n    assert (str(Mappable(0.5)) == '<0.5>')\n    assert (str(Mappable('CO')) == \"<'CO'>\")\n    assert (str(Mappable(rc='lines.linewidth')) == '<rc:lines.linewidth>')\n    assert (str(Mappable(depend='color')) == '<depend:color>')\n    assert (str(Mappable(auto=True)) == '???')", "ground_truth": "'<auto>'", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1303", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_value", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_value(self):\n    val = 3\n    m = self.mark(linewidth=val)\n    assert (m._resolve({}, 'linewidth') == val)\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), val))", "masked_code": "def test_value(self):\n    val = 3\n    m = self.mark(linewidth=val)\n    assert (m._resolve({}, 'linewidth') == '???')\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), val))", "ground_truth": "val", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1304", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_default", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_default(self):\n    val = 3\n    m = self.mark(linewidth=Mappable(val))\n    assert (m._resolve({}, 'linewidth') == val)\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), val))", "masked_code": "def test_default(self):\n    val = 3\n    m = self.mark(linewidth=Mappable(val))\n    assert (m._resolve({}, 'linewidth') == '???')\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), val))", "ground_truth": "val", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1305", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_rcparam", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_rcparam(self):\n    param = 'lines.linewidth'\n    val = mpl.rcParams[param]\n    m = self.mark(linewidth=Mappable(rc=param))\n    assert (m._resolve({}, 'linewidth') == val)\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), val))", "masked_code": "def test_rcparam(self):\n    param = 'lines.linewidth'\n    val = mpl.rcParams[param]\n    m = self.mark(linewidth=Mappable(rc=param))\n    assert (m._resolve({}, 'linewidth') == '???')\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), val))", "ground_truth": "val", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1306", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_depends", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_depends(self):\n    val = 2\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    m = self.mark(pointsize=Mappable(val), linewidth=Mappable(depend='pointsize'))\n    assert (m._resolve({}, 'linewidth') == val)\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), val))\n    m = self.mark(pointsize=(val * 2), linewidth=Mappable(depend='pointsize'))\n    assert (m._resolve({}, 'linewidth') == (val * 2))\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), (val * 2)))", "masked_code": "def test_depends(self):\n    val = 2\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    m = self.mark(pointsize=Mappable(val), linewidth=Mappable(depend='pointsize'))\n    assert (m._resolve({}, 'linewidth') == '???')\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), val))\n    m = self.mark(pointsize=(val * 2), linewidth=Mappable(depend='pointsize'))\n    assert (m._resolve({}, 'linewidth') == (val * 2))\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), (val * 2)))", "ground_truth": "val", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1307", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_depends", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_depends(self):\n    val = 2\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    m = self.mark(pointsize=Mappable(val), linewidth=Mappable(depend='pointsize'))\n    assert (m._resolve({}, 'linewidth') == val)\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), val))\n    m = self.mark(pointsize=(val * 2), linewidth=Mappable(depend='pointsize'))\n    assert (m._resolve({}, 'linewidth') == (val * 2))\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), (val * 2)))", "masked_code": "def test_depends(self):\n    val = 2\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    m = self.mark(pointsize=Mappable(val), linewidth=Mappable(depend='pointsize'))\n    assert (m._resolve({}, 'linewidth') == val)\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), val))\n    m = self.mark(pointsize=(val * 2), linewidth=Mappable(depend='pointsize'))\n    assert (m._resolve({}, 'linewidth') == '???')\n    assert_array_equal(m._resolve(df, 'linewidth'), np.full(len(df), (val * 2)))", "ground_truth": "(val * 2)", "quality_analysis": {"complexity_score": 11, "left_complexity": 7, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1308", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_mapped", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_mapped(self):\n    values = {'a': 1, 'b': 2, 'c': 3}\n\n    def f(x):\n        return np.array([values[x_i] for x_i in x])\n    m = self.mark(linewidth=Mappable(2))\n    scales = {'linewidth': f}\n    assert (m._resolve({'linewidth': 'c'}, 'linewidth', scales) == 3)\n    df = pd.DataFrame({'linewidth': ['a', 'b', 'c']})\n    expected = np.array([1, 2, 3], float)\n    assert_array_equal(m._resolve(df, 'linewidth', scales), expected)", "masked_code": "def test_mapped(self):\n    values = {'a': 1, 'b': 2, 'c': 3}\n\n    def f(x):\n        return np.array([values[x_i] for x_i in x])\n    m = self.mark(linewidth=Mappable(2))\n    scales = {'linewidth': f}\n    assert (m._resolve({'linewidth': 'c'}, 'linewidth', scales) == '???')\n    df = pd.DataFrame({'linewidth': ['a', 'b', 'c']})\n    expected = np.array([1, 2, 3], float)\n    assert_array_equal(m._resolve(df, 'linewidth', scales), expected)", "ground_truth": "3", "quality_analysis": {"complexity_score": 11, "left_complexity": 10, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1309", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_color", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_color(self):\n    (c, a) = ('C1', 0.5)\n    m = self.mark(color=c, alpha=a)\n    assert (resolve_color(m, {}) == mpl.colors.to_rgba(c, a))\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    cs = ([c] * len(df))\n    assert_array_equal(resolve_color(m, df), mpl.colors.to_rgba_array(cs, a))", "masked_code": "def test_color(self):\n    (c, a) = ('C1', 0.5)\n    m = self.mark(color=c, alpha=a)\n    assert (resolve_color(m, {}) == '???')\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    cs = ([c] * len(df))\n    assert_array_equal(resolve_color(m, df), mpl.colors.to_rgba_array(cs, a))", "ground_truth": "mpl.colors.to_rgba(c, a)", "quality_analysis": {"complexity_score": 12, "left_complexity": 7, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1310", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_color_mapped_alpha", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_color_mapped_alpha(self):\n    c = 'r'\n    values = {'a': 0.2, 'b': 0.5, 'c': 0.8}\n    m = self.mark(color=c, alpha=Mappable(1))\n    scales = {'alpha': (lambda s: np.array([values[s_i] for s_i in s]))}\n    assert (resolve_color(m, {'alpha': 'b'}, '', scales) == mpl.colors.to_rgba(c, 0.5))\n    df = pd.DataFrame({'alpha': list(values.keys())})\n    expected = mpl.colors.to_rgba_array(([c] * len(df)))\n    expected[(:, 3)] = list(values.values())\n    assert_array_equal(resolve_color(m, df, '', scales), expected)", "masked_code": "def test_color_mapped_alpha(self):\n    c = 'r'\n    values = {'a': 0.2, 'b': 0.5, 'c': 0.8}\n    m = self.mark(color=c, alpha=Mappable(1))\n    scales = {'alpha': (lambda s: np.array([values[s_i] for s_i in s]))}\n    assert (resolve_color(m, {'alpha': 'b'}, '', scales) == '???')\n    df = pd.DataFrame({'alpha': list(values.keys())})\n    expected = mpl.colors.to_rgba_array(([c] * len(df)))\n    expected[(:, 3)] = list(values.values())\n    assert_array_equal(resolve_color(m, df, '', scales), expected)", "ground_truth": "mpl.colors.to_rgba(c, 0.5)", "quality_analysis": {"complexity_score": 16, "left_complexity": 11, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1311", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_fillcolor", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_fillcolor(self):\n    (c, a) = ('green', 0.8)\n    fa = 0.2\n    m = self.mark(color=c, alpha=a, fillcolor=Mappable(depend='color'), fillalpha=Mappable(fa))\n    assert (resolve_color(m, {}) == mpl.colors.to_rgba(c, a))\n    assert (resolve_color(m, {}, 'fill') == mpl.colors.to_rgba(c, fa))\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    cs = ([c] * len(df))\n    assert_array_equal(resolve_color(m, df), mpl.colors.to_rgba_array(cs, a))\n    assert_array_equal(resolve_color(m, df, 'fill'), mpl.colors.to_rgba_array(cs, fa))", "masked_code": "def test_fillcolor(self):\n    (c, a) = ('green', 0.8)\n    fa = 0.2\n    m = self.mark(color=c, alpha=a, fillcolor=Mappable(depend='color'), fillalpha=Mappable(fa))\n    assert (resolve_color(m, {}) == '???')\n    assert (resolve_color(m, {}, 'fill') == mpl.colors.to_rgba(c, fa))\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    cs = ([c] * len(df))\n    assert_array_equal(resolve_color(m, df), mpl.colors.to_rgba_array(cs, a))\n    assert_array_equal(resolve_color(m, df, 'fill'), mpl.colors.to_rgba_array(cs, fa))", "ground_truth": "mpl.colors.to_rgba(c, a)", "quality_analysis": {"complexity_score": 12, "left_complexity": 7, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1312", "reponame": "seaborn", "testpath": "tests/_marks/test_base.py", "testname": "test_base.py", "classname": "TestMappable", "funcname": "test_fillcolor", "imports": ["from dataclasses import dataclass", "import numpy as np", "import pandas as pd", "import matplotlib as mpl", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._marks.base import Mark, Mappable, resolve_color"], "code": "def test_fillcolor(self):\n    (c, a) = ('green', 0.8)\n    fa = 0.2\n    m = self.mark(color=c, alpha=a, fillcolor=Mappable(depend='color'), fillalpha=Mappable(fa))\n    assert (resolve_color(m, {}) == mpl.colors.to_rgba(c, a))\n    assert (resolve_color(m, {}, 'fill') == mpl.colors.to_rgba(c, fa))\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    cs = ([c] * len(df))\n    assert_array_equal(resolve_color(m, df), mpl.colors.to_rgba_array(cs, a))\n    assert_array_equal(resolve_color(m, df, 'fill'), mpl.colors.to_rgba_array(cs, fa))", "masked_code": "def test_fillcolor(self):\n    (c, a) = ('green', 0.8)\n    fa = 0.2\n    m = self.mark(color=c, alpha=a, fillcolor=Mappable(depend='color'), fillalpha=Mappable(fa))\n    assert (resolve_color(m, {}) == mpl.colors.to_rgba(c, a))\n    assert (resolve_color(m, {}, 'fill') == '???')\n    df = pd.DataFrame(index=pd.RangeIndex(10))\n    cs = ([c] * len(df))\n    assert_array_equal(resolve_color(m, df), mpl.colors.to_rgba_array(cs, a))\n    assert_array_equal(resolve_color(m, df, 'fill'), mpl.colors.to_rgba_array(cs, fa))", "ground_truth": "mpl.colors.to_rgba(c, fa)", "quality_analysis": {"complexity_score": 13, "left_complexity": 8, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1313", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestPath", "funcname": "test_other_props_direct", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_other_props_direct(self):\n    x = y = [1, 2, 3]\n    m = Path(marker='s', linestyle='--', linewidth=3, pointsize=10, edgewidth=1)\n    p = Plot(x=x, y=y).add(m).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_marker() == m.marker)\n    assert (line.get_linestyle() == m.linestyle)\n    assert (line.get_linewidth() == m.linewidth)\n    assert (line.get_markersize() == m.pointsize)\n    assert (line.get_markeredgewidth() == m.edgewidth)", "masked_code": "def test_other_props_direct(self):\n    x = y = [1, 2, 3]\n    m = Path(marker='s', linestyle='--', linewidth=3, pointsize=10, edgewidth=1)\n    p = Plot(x=x, y=y).add(m).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_marker() == '???')\n    assert (line.get_linestyle() == m.linestyle)\n    assert (line.get_linewidth() == m.linewidth)\n    assert (line.get_markersize() == m.pointsize)\n    assert (line.get_markeredgewidth() == m.edgewidth)", "ground_truth": "m.marker", "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1314", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestPath", "funcname": "test_other_props_direct", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_other_props_direct(self):\n    x = y = [1, 2, 3]\n    m = Path(marker='s', linestyle='--', linewidth=3, pointsize=10, edgewidth=1)\n    p = Plot(x=x, y=y).add(m).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_marker() == m.marker)\n    assert (line.get_linestyle() == m.linestyle)\n    assert (line.get_linewidth() == m.linewidth)\n    assert (line.get_markersize() == m.pointsize)\n    assert (line.get_markeredgewidth() == m.edgewidth)", "masked_code": "def test_other_props_direct(self):\n    x = y = [1, 2, 3]\n    m = Path(marker='s', linestyle='--', linewidth=3, pointsize=10, edgewidth=1)\n    p = Plot(x=x, y=y).add(m).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_marker() == m.marker)\n    assert (line.get_linestyle() == '???')\n    assert (line.get_linewidth() == m.linewidth)\n    assert (line.get_markersize() == m.pointsize)\n    assert (line.get_markeredgewidth() == m.edgewidth)", "ground_truth": "m.linestyle", "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1315", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestPath", "funcname": "test_other_props_direct", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_other_props_direct(self):\n    x = y = [1, 2, 3]\n    m = Path(marker='s', linestyle='--', linewidth=3, pointsize=10, edgewidth=1)\n    p = Plot(x=x, y=y).add(m).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_marker() == m.marker)\n    assert (line.get_linestyle() == m.linestyle)\n    assert (line.get_linewidth() == m.linewidth)\n    assert (line.get_markersize() == m.pointsize)\n    assert (line.get_markeredgewidth() == m.edgewidth)", "masked_code": "def test_other_props_direct(self):\n    x = y = [1, 2, 3]\n    m = Path(marker='s', linestyle='--', linewidth=3, pointsize=10, edgewidth=1)\n    p = Plot(x=x, y=y).add(m).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_marker() == m.marker)\n    assert (line.get_linestyle() == m.linestyle)\n    assert (line.get_linewidth() == '???')\n    assert (line.get_markersize() == m.pointsize)\n    assert (line.get_markeredgewidth() == m.edgewidth)", "ground_truth": "m.linewidth", "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1316", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestPath", "funcname": "test_other_props_direct", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_other_props_direct(self):\n    x = y = [1, 2, 3]\n    m = Path(marker='s', linestyle='--', linewidth=3, pointsize=10, edgewidth=1)\n    p = Plot(x=x, y=y).add(m).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_marker() == m.marker)\n    assert (line.get_linestyle() == m.linestyle)\n    assert (line.get_linewidth() == m.linewidth)\n    assert (line.get_markersize() == m.pointsize)\n    assert (line.get_markeredgewidth() == m.edgewidth)", "masked_code": "def test_other_props_direct(self):\n    x = y = [1, 2, 3]\n    m = Path(marker='s', linestyle='--', linewidth=3, pointsize=10, edgewidth=1)\n    p = Plot(x=x, y=y).add(m).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_marker() == m.marker)\n    assert (line.get_linestyle() == m.linestyle)\n    assert (line.get_linewidth() == m.linewidth)\n    assert (line.get_markersize() == '???')\n    assert (line.get_markeredgewidth() == m.edgewidth)", "ground_truth": "m.pointsize", "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1317", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestPath", "funcname": "test_other_props_direct", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_other_props_direct(self):\n    x = y = [1, 2, 3]\n    m = Path(marker='s', linestyle='--', linewidth=3, pointsize=10, edgewidth=1)\n    p = Plot(x=x, y=y).add(m).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_marker() == m.marker)\n    assert (line.get_linestyle() == m.linestyle)\n    assert (line.get_linewidth() == m.linewidth)\n    assert (line.get_markersize() == m.pointsize)\n    assert (line.get_markeredgewidth() == m.edgewidth)", "masked_code": "def test_other_props_direct(self):\n    x = y = [1, 2, 3]\n    m = Path(marker='s', linestyle='--', linewidth=3, pointsize=10, edgewidth=1)\n    p = Plot(x=x, y=y).add(m).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_marker() == m.marker)\n    assert (line.get_linestyle() == m.linestyle)\n    assert (line.get_linewidth() == m.linewidth)\n    assert (line.get_markersize() == m.pointsize)\n    assert (line.get_markeredgewidth() == '???')", "ground_truth": "m.edgewidth", "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1318", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestPath", "funcname": "test_capstyle", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_capstyle(self):\n    x = y = [1, 2]\n    rc = {'lines.solid_capstyle': 'projecting', 'lines.dash_capstyle': 'round'}\n    p = Plot(x, y).add(Path()).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_dash_capstyle() == 'projecting')\n    p = Plot(x, y).add(Path(linestyle='--')).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_dash_capstyle() == 'round')\n    p = Plot(x, y).add(Path({'solid_capstyle': 'butt'})).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_solid_capstyle() == 'butt')", "masked_code": "def test_capstyle(self):\n    x = y = [1, 2]\n    rc = {'lines.solid_capstyle': 'projecting', 'lines.dash_capstyle': 'round'}\n    p = Plot(x, y).add(Path()).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_dash_capstyle() == '???')\n    p = Plot(x, y).add(Path(linestyle='--')).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_dash_capstyle() == 'round')\n    p = Plot(x, y).add(Path({'solid_capstyle': 'butt'})).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_solid_capstyle() == 'butt')", "ground_truth": "'projecting'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1319", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestPath", "funcname": "test_capstyle", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_capstyle(self):\n    x = y = [1, 2]\n    rc = {'lines.solid_capstyle': 'projecting', 'lines.dash_capstyle': 'round'}\n    p = Plot(x, y).add(Path()).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_dash_capstyle() == 'projecting')\n    p = Plot(x, y).add(Path(linestyle='--')).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_dash_capstyle() == 'round')\n    p = Plot(x, y).add(Path({'solid_capstyle': 'butt'})).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_solid_capstyle() == 'butt')", "masked_code": "def test_capstyle(self):\n    x = y = [1, 2]\n    rc = {'lines.solid_capstyle': 'projecting', 'lines.dash_capstyle': 'round'}\n    p = Plot(x, y).add(Path()).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_dash_capstyle() == 'projecting')\n    p = Plot(x, y).add(Path(linestyle='--')).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_dash_capstyle() == '???')\n    p = Plot(x, y).add(Path({'solid_capstyle': 'butt'})).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_solid_capstyle() == 'butt')", "ground_truth": "'round'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1320", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestPath", "funcname": "test_capstyle", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_capstyle(self):\n    x = y = [1, 2]\n    rc = {'lines.solid_capstyle': 'projecting', 'lines.dash_capstyle': 'round'}\n    p = Plot(x, y).add(Path()).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_dash_capstyle() == 'projecting')\n    p = Plot(x, y).add(Path(linestyle='--')).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_dash_capstyle() == 'round')\n    p = Plot(x, y).add(Path({'solid_capstyle': 'butt'})).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_solid_capstyle() == 'butt')", "masked_code": "def test_capstyle(self):\n    x = y = [1, 2]\n    rc = {'lines.solid_capstyle': 'projecting', 'lines.dash_capstyle': 'round'}\n    p = Plot(x, y).add(Path()).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_dash_capstyle() == 'projecting')\n    p = Plot(x, y).add(Path(linestyle='--')).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_dash_capstyle() == 'round')\n    p = Plot(x, y).add(Path({'solid_capstyle': 'butt'})).theme(rc).plot()\n    (line,) = p._figure.axes[0].get_lines()\n    assert (line.get_solid_capstyle() == '???')", "ground_truth": "'butt'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1321", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestPaths", "funcname": "test_set_properties", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_set_properties(self):\n    x = y = [1, 2, 3]\n    m = Paths(color='.737', linewidth=1, linestyle=(3, 1))\n    p = Plot(x=x, y=y).add(m).plot()\n    (lines,) = p._figure.axes[0].collections\n    assert same_color(lines.get_color().squeeze(), m.color)\n    assert (lines.get_linewidth().item() == m.linewidth)\n    assert (lines.get_dashes()[0] == (0, list(m.linestyle)))", "masked_code": "def test_set_properties(self):\n    x = y = [1, 2, 3]\n    m = Paths(color='.737', linewidth=1, linestyle=(3, 1))\n    p = Plot(x=x, y=y).add(m).plot()\n    (lines,) = p._figure.axes[0].collections\n    assert same_color(lines.get_color().squeeze(), m.color)\n    assert (lines.get_linewidth().item() == '???')\n    assert (lines.get_dashes()[0] == (0, list(m.linestyle)))", "ground_truth": "m.linewidth", "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1322", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestPaths", "funcname": "test_set_properties", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_set_properties(self):\n    x = y = [1, 2, 3]\n    m = Paths(color='.737', linewidth=1, linestyle=(3, 1))\n    p = Plot(x=x, y=y).add(m).plot()\n    (lines,) = p._figure.axes[0].collections\n    assert same_color(lines.get_color().squeeze(), m.color)\n    assert (lines.get_linewidth().item() == m.linewidth)\n    assert (lines.get_dashes()[0] == (0, list(m.linestyle)))", "masked_code": "def test_set_properties(self):\n    x = y = [1, 2, 3]\n    m = Paths(color='.737', linewidth=1, linestyle=(3, 1))\n    p = Plot(x=x, y=y).add(m).plot()\n    (lines,) = p._figure.axes[0].collections\n    assert same_color(lines.get_color().squeeze(), m.color)\n    assert (lines.get_linewidth().item() == m.linewidth)\n    assert (lines.get_dashes()[0] == '???')", "ground_truth": "(0, list(m.linestyle))", "quality_analysis": {"complexity_score": 15, "left_complexity": 7, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1323", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestPaths", "funcname": "test_capstyle", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_capstyle(self):\n    x = y = [1, 2]\n    rc = {'lines.solid_capstyle': 'projecting'}\n    with mpl.rc_context(rc):\n        p = Plot(x, y).add(Paths()).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'projecting')\n        p = Plot(x, y).add(Paths(linestyle='--')).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'projecting')\n        p = Plot(x, y).add(Paths({'capstyle': 'butt'})).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'butt')", "masked_code": "def test_capstyle(self):\n    x = y = [1, 2]\n    rc = {'lines.solid_capstyle': 'projecting'}\n    with mpl.rc_context(rc):\n        p = Plot(x, y).add(Paths()).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == '???')\n        p = Plot(x, y).add(Paths(linestyle='--')).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'projecting')\n        p = Plot(x, y).add(Paths({'capstyle': 'butt'})).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'butt')", "ground_truth": "'projecting'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1324", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestPaths", "funcname": "test_capstyle", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_capstyle(self):\n    x = y = [1, 2]\n    rc = {'lines.solid_capstyle': 'projecting'}\n    with mpl.rc_context(rc):\n        p = Plot(x, y).add(Paths()).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'projecting')\n        p = Plot(x, y).add(Paths(linestyle='--')).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'projecting')\n        p = Plot(x, y).add(Paths({'capstyle': 'butt'})).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'butt')", "masked_code": "def test_capstyle(self):\n    x = y = [1, 2]\n    rc = {'lines.solid_capstyle': 'projecting'}\n    with mpl.rc_context(rc):\n        p = Plot(x, y).add(Paths()).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'projecting')\n        p = Plot(x, y).add(Paths(linestyle='--')).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == '???')\n        p = Plot(x, y).add(Paths({'capstyle': 'butt'})).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'butt')", "ground_truth": "'projecting'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1325", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestPaths", "funcname": "test_capstyle", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_capstyle(self):\n    x = y = [1, 2]\n    rc = {'lines.solid_capstyle': 'projecting'}\n    with mpl.rc_context(rc):\n        p = Plot(x, y).add(Paths()).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'projecting')\n        p = Plot(x, y).add(Paths(linestyle='--')).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'projecting')\n        p = Plot(x, y).add(Paths({'capstyle': 'butt'})).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'butt')", "masked_code": "def test_capstyle(self):\n    x = y = [1, 2]\n    rc = {'lines.solid_capstyle': 'projecting'}\n    with mpl.rc_context(rc):\n        p = Plot(x, y).add(Paths()).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'projecting')\n        p = Plot(x, y).add(Paths(linestyle='--')).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == 'projecting')\n        p = Plot(x, y).add(Paths({'capstyle': 'butt'})).plot()\n        lines = p._figure.axes[0].collections[0]\n        assert (lines.get_capstyle() == '???')", "ground_truth": "'butt'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1326", "reponame": "seaborn", "testpath": "tests/_marks/test_line.py", "testname": "test_line.py", "classname": "TestRange", "funcname": "test_direct_properties", "imports": ["import numpy as np", "import matplotlib as mpl", "from matplotlib.colors import same_color, to_rgba", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._core.moves import Dodge", "from seaborn._marks.line import Dash, Line, Path, Lines, Paths, Range"], "code": "def test_direct_properties(self):\n    x = [1, 2]\n    ymin = [1, 4]\n    ymax = [2, 3]\n    m = Range(color='.654', linewidth=4)\n    p = Plot(x=x, ymin=ymin, ymax=ymax).add(m).plot()\n    (lines,) = p._figure.axes[0].collections\n    for (i, path) in enumerate(lines.get_paths()):\n        assert same_color(lines.get_colors()[i], m.color)\n        assert (lines.get_linewidths()[i] == m.linewidth)", "masked_code": "def test_direct_properties(self):\n    x = [1, 2]\n    ymin = [1, 4]\n    ymax = [2, 3]\n    m = Range(color='.654', linewidth=4)\n    p = Plot(x=x, ymin=ymin, ymax=ymax).add(m).plot()\n    (lines,) = p._figure.axes[0].collections\n    for (i, path) in enumerate(lines.get_paths()):\n        assert same_color(lines.get_colors()[i], m.color)\n        assert (lines.get_linewidths()[i] == '???')", "ground_truth": "m.linewidth", "quality_analysis": {"complexity_score": 9, "left_complexity": 7, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1327", "reponame": "seaborn", "testpath": "tests/_marks/test_text.py", "testname": "test_text.py", "classname": "TestText", "funcname": "test_simple", "imports": ["import numpy as np", "from matplotlib.colors import to_rgba", "from matplotlib.text import Text as MPLText", "from numpy.testing import assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.text import Text"], "code": "def test_simple(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    p = Plot(x, y, text=s).add(Text()).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        (x_, y_) = text.get_position()\n        assert (x_ == x[i])\n        assert (y_ == y[i])\n        assert (text.get_text() == s[i])\n        assert (text.get_horizontalalignment() == 'center')\n        assert (text.get_verticalalignment() == 'center_baseline')", "masked_code": "def test_simple(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    p = Plot(x, y, text=s).add(Text()).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        (x_, y_) = text.get_position()\n        assert (x_ == x[i])\n        assert (y_ == y[i])\n        assert (text.get_text() == '???')\n        assert (text.get_horizontalalignment() == 'center')\n        assert (text.get_verticalalignment() == 'center_baseline')", "ground_truth": "s[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1328", "reponame": "seaborn", "testpath": "tests/_marks/test_text.py", "testname": "test_text.py", "classname": "TestText", "funcname": "test_simple", "imports": ["import numpy as np", "from matplotlib.colors import to_rgba", "from matplotlib.text import Text as MPLText", "from numpy.testing import assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.text import Text"], "code": "def test_simple(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    p = Plot(x, y, text=s).add(Text()).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        (x_, y_) = text.get_position()\n        assert (x_ == x[i])\n        assert (y_ == y[i])\n        assert (text.get_text() == s[i])\n        assert (text.get_horizontalalignment() == 'center')\n        assert (text.get_verticalalignment() == 'center_baseline')", "masked_code": "def test_simple(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    p = Plot(x, y, text=s).add(Text()).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        (x_, y_) = text.get_position()\n        assert (x_ == x[i])\n        assert (y_ == y[i])\n        assert (text.get_text() == s[i])\n        assert (text.get_horizontalalignment() == '???')\n        assert (text.get_verticalalignment() == 'center_baseline')", "ground_truth": "'center'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1329", "reponame": "seaborn", "testpath": "tests/_marks/test_text.py", "testname": "test_text.py", "classname": "TestText", "funcname": "test_simple", "imports": ["import numpy as np", "from matplotlib.colors import to_rgba", "from matplotlib.text import Text as MPLText", "from numpy.testing import assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.text import Text"], "code": "def test_simple(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    p = Plot(x, y, text=s).add(Text()).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        (x_, y_) = text.get_position()\n        assert (x_ == x[i])\n        assert (y_ == y[i])\n        assert (text.get_text() == s[i])\n        assert (text.get_horizontalalignment() == 'center')\n        assert (text.get_verticalalignment() == 'center_baseline')", "masked_code": "def test_simple(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    p = Plot(x, y, text=s).add(Text()).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        (x_, y_) = text.get_position()\n        assert (x_ == x[i])\n        assert (y_ == y[i])\n        assert (text.get_text() == s[i])\n        assert (text.get_horizontalalignment() == 'center')\n        assert (text.get_verticalalignment() == '???')", "ground_truth": "'center_baseline'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1330", "reponame": "seaborn", "testpath": "tests/_marks/test_text.py", "testname": "test_text.py", "classname": "TestText", "funcname": "test_set_properties", "imports": ["import numpy as np", "from matplotlib.colors import to_rgba", "from matplotlib.text import Text as MPLText", "from numpy.testing import assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.text import Text"], "code": "def test_set_properties(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    color = 'red'\n    alpha = 0.6\n    fontsize = 6\n    valign = 'bottom'\n    m = Text(color=color, alpha=alpha, fontsize=fontsize, valign=valign)\n    p = Plot(x, y, text=s).add(m).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        assert (text.get_text() == s[i])\n        assert (text.get_color() == to_rgba(m.color, m.alpha))\n        assert (text.get_fontsize() == m.fontsize)\n        assert (text.get_verticalalignment() == m.valign)", "masked_code": "def test_set_properties(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    color = 'red'\n    alpha = 0.6\n    fontsize = 6\n    valign = 'bottom'\n    m = Text(color=color, alpha=alpha, fontsize=fontsize, valign=valign)\n    p = Plot(x, y, text=s).add(m).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        assert (text.get_text() == '???')\n        assert (text.get_color() == to_rgba(m.color, m.alpha))\n        assert (text.get_fontsize() == m.fontsize)\n        assert (text.get_verticalalignment() == m.valign)", "ground_truth": "s[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1331", "reponame": "seaborn", "testpath": "tests/_marks/test_text.py", "testname": "test_text.py", "classname": "TestText", "funcname": "test_set_properties", "imports": ["import numpy as np", "from matplotlib.colors import to_rgba", "from matplotlib.text import Text as MPLText", "from numpy.testing import assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.text import Text"], "code": "def test_set_properties(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    color = 'red'\n    alpha = 0.6\n    fontsize = 6\n    valign = 'bottom'\n    m = Text(color=color, alpha=alpha, fontsize=fontsize, valign=valign)\n    p = Plot(x, y, text=s).add(m).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        assert (text.get_text() == s[i])\n        assert (text.get_color() == to_rgba(m.color, m.alpha))\n        assert (text.get_fontsize() == m.fontsize)\n        assert (text.get_verticalalignment() == m.valign)", "masked_code": "def test_set_properties(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    color = 'red'\n    alpha = 0.6\n    fontsize = 6\n    valign = 'bottom'\n    m = Text(color=color, alpha=alpha, fontsize=fontsize, valign=valign)\n    p = Plot(x, y, text=s).add(m).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        assert (text.get_text() == s[i])\n        assert (text.get_color() == '???')\n        assert (text.get_fontsize() == m.fontsize)\n        assert (text.get_verticalalignment() == m.valign)", "ground_truth": "to_rgba(m.color, m.alpha)", "quality_analysis": {"complexity_score": 10, "left_complexity": 3, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1332", "reponame": "seaborn", "testpath": "tests/_marks/test_text.py", "testname": "test_text.py", "classname": "TestText", "funcname": "test_set_properties", "imports": ["import numpy as np", "from matplotlib.colors import to_rgba", "from matplotlib.text import Text as MPLText", "from numpy.testing import assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.text import Text"], "code": "def test_set_properties(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    color = 'red'\n    alpha = 0.6\n    fontsize = 6\n    valign = 'bottom'\n    m = Text(color=color, alpha=alpha, fontsize=fontsize, valign=valign)\n    p = Plot(x, y, text=s).add(m).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        assert (text.get_text() == s[i])\n        assert (text.get_color() == to_rgba(m.color, m.alpha))\n        assert (text.get_fontsize() == m.fontsize)\n        assert (text.get_verticalalignment() == m.valign)", "masked_code": "def test_set_properties(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    color = 'red'\n    alpha = 0.6\n    fontsize = 6\n    valign = 'bottom'\n    m = Text(color=color, alpha=alpha, fontsize=fontsize, valign=valign)\n    p = Plot(x, y, text=s).add(m).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        assert (text.get_text() == s[i])\n        assert (text.get_color() == to_rgba(m.color, m.alpha))\n        assert (text.get_fontsize() == '???')\n        assert (text.get_verticalalignment() == m.valign)", "ground_truth": "m.fontsize", "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1333", "reponame": "seaborn", "testpath": "tests/_marks/test_text.py", "testname": "test_text.py", "classname": "TestText", "funcname": "test_set_properties", "imports": ["import numpy as np", "from matplotlib.colors import to_rgba", "from matplotlib.text import Text as MPLText", "from numpy.testing import assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.text import Text"], "code": "def test_set_properties(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    color = 'red'\n    alpha = 0.6\n    fontsize = 6\n    valign = 'bottom'\n    m = Text(color=color, alpha=alpha, fontsize=fontsize, valign=valign)\n    p = Plot(x, y, text=s).add(m).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        assert (text.get_text() == s[i])\n        assert (text.get_color() == to_rgba(m.color, m.alpha))\n        assert (text.get_fontsize() == m.fontsize)\n        assert (text.get_verticalalignment() == m.valign)", "masked_code": "def test_set_properties(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    color = 'red'\n    alpha = 0.6\n    fontsize = 6\n    valign = 'bottom'\n    m = Text(color=color, alpha=alpha, fontsize=fontsize, valign=valign)\n    p = Plot(x, y, text=s).add(m).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        assert (text.get_text() == s[i])\n        assert (text.get_color() == to_rgba(m.color, m.alpha))\n        assert (text.get_fontsize() == m.fontsize)\n        assert (text.get_verticalalignment() == '???')", "ground_truth": "m.valign", "quality_analysis": {"complexity_score": 5, "left_complexity": 3, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1334", "reponame": "seaborn", "testpath": "tests/_marks/test_text.py", "testname": "test_text.py", "classname": "TestText", "funcname": "test_mapped_properties", "imports": ["import numpy as np", "from matplotlib.colors import to_rgba", "from matplotlib.text import Text as MPLText", "from numpy.testing import assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.text import Text"], "code": "def test_mapped_properties(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    color = list('aab')\n    fontsize = [1, 2, 4]\n    p = Plot(x, y, color=color, fontsize=fontsize, text=s).add(Text()).plot()\n    ax = p._figure.axes[0]\n    texts = self.get_texts(ax)\n    assert (texts[0].get_color() == texts[1].get_color())\n    assert (texts[0].get_color() != texts[2].get_color())\n    assert (texts[0].get_fontsize() < texts[1].get_fontsize() < texts[2].get_fontsize())", "masked_code": "def test_mapped_properties(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    color = list('aab')\n    fontsize = [1, 2, 4]\n    p = Plot(x, y, color=color, fontsize=fontsize, text=s).add(Text()).plot()\n    ax = p._figure.axes[0]\n    texts = self.get_texts(ax)\n    assert (texts[0].get_color() == '???')\n    assert (texts[0].get_color() != texts[2].get_color())\n    assert (texts[0].get_fontsize() < texts[1].get_fontsize() < texts[2].get_fontsize())", "ground_truth": "texts[1].get_color()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1335", "reponame": "seaborn", "testpath": "tests/_marks/test_text.py", "testname": "test_text.py", "classname": "TestText", "funcname": "test_mapped_alignment", "imports": ["import numpy as np", "from matplotlib.colors import to_rgba", "from matplotlib.text import Text as MPLText", "from numpy.testing import assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.text import Text"], "code": "def test_mapped_alignment(self):\n    x = [1, 2]\n    p = Plot(x=x, y=x, halign=x, valign=x, text=x).add(Text()).plot()\n    ax = p._figure.axes[0]\n    (t1, t2) = self.get_texts(ax)\n    assert (t1.get_horizontalalignment() == 'left')\n    assert (t2.get_horizontalalignment() == 'right')\n    assert (t1.get_verticalalignment() == 'top')\n    assert (t2.get_verticalalignment() == 'bottom')", "masked_code": "def test_mapped_alignment(self):\n    x = [1, 2]\n    p = Plot(x=x, y=x, halign=x, valign=x, text=x).add(Text()).plot()\n    ax = p._figure.axes[0]\n    (t1, t2) = self.get_texts(ax)\n    assert (t1.get_horizontalalignment() == '???')\n    assert (t2.get_horizontalalignment() == 'right')\n    assert (t1.get_verticalalignment() == 'top')\n    assert (t2.get_verticalalignment() == 'bottom')", "ground_truth": "'left'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1336", "reponame": "seaborn", "testpath": "tests/_marks/test_text.py", "testname": "test_text.py", "classname": "TestText", "funcname": "test_mapped_alignment", "imports": ["import numpy as np", "from matplotlib.colors import to_rgba", "from matplotlib.text import Text as MPLText", "from numpy.testing import assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.text import Text"], "code": "def test_mapped_alignment(self):\n    x = [1, 2]\n    p = Plot(x=x, y=x, halign=x, valign=x, text=x).add(Text()).plot()\n    ax = p._figure.axes[0]\n    (t1, t2) = self.get_texts(ax)\n    assert (t1.get_horizontalalignment() == 'left')\n    assert (t2.get_horizontalalignment() == 'right')\n    assert (t1.get_verticalalignment() == 'top')\n    assert (t2.get_verticalalignment() == 'bottom')", "masked_code": "def test_mapped_alignment(self):\n    x = [1, 2]\n    p = Plot(x=x, y=x, halign=x, valign=x, text=x).add(Text()).plot()\n    ax = p._figure.axes[0]\n    (t1, t2) = self.get_texts(ax)\n    assert (t1.get_horizontalalignment() == 'left')\n    assert (t2.get_horizontalalignment() == '???')\n    assert (t1.get_verticalalignment() == 'top')\n    assert (t2.get_verticalalignment() == 'bottom')", "ground_truth": "'right'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1337", "reponame": "seaborn", "testpath": "tests/_marks/test_text.py", "testname": "test_text.py", "classname": "TestText", "funcname": "test_mapped_alignment", "imports": ["import numpy as np", "from matplotlib.colors import to_rgba", "from matplotlib.text import Text as MPLText", "from numpy.testing import assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.text import Text"], "code": "def test_mapped_alignment(self):\n    x = [1, 2]\n    p = Plot(x=x, y=x, halign=x, valign=x, text=x).add(Text()).plot()\n    ax = p._figure.axes[0]\n    (t1, t2) = self.get_texts(ax)\n    assert (t1.get_horizontalalignment() == 'left')\n    assert (t2.get_horizontalalignment() == 'right')\n    assert (t1.get_verticalalignment() == 'top')\n    assert (t2.get_verticalalignment() == 'bottom')", "masked_code": "def test_mapped_alignment(self):\n    x = [1, 2]\n    p = Plot(x=x, y=x, halign=x, valign=x, text=x).add(Text()).plot()\n    ax = p._figure.axes[0]\n    (t1, t2) = self.get_texts(ax)\n    assert (t1.get_horizontalalignment() == 'left')\n    assert (t2.get_horizontalalignment() == 'right')\n    assert (t1.get_verticalalignment() == '???')\n    assert (t2.get_verticalalignment() == 'bottom')", "ground_truth": "'top'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1338", "reponame": "seaborn", "testpath": "tests/_marks/test_text.py", "testname": "test_text.py", "classname": "TestText", "funcname": "test_mapped_alignment", "imports": ["import numpy as np", "from matplotlib.colors import to_rgba", "from matplotlib.text import Text as MPLText", "from numpy.testing import assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.text import Text"], "code": "def test_mapped_alignment(self):\n    x = [1, 2]\n    p = Plot(x=x, y=x, halign=x, valign=x, text=x).add(Text()).plot()\n    ax = p._figure.axes[0]\n    (t1, t2) = self.get_texts(ax)\n    assert (t1.get_horizontalalignment() == 'left')\n    assert (t2.get_horizontalalignment() == 'right')\n    assert (t1.get_verticalalignment() == 'top')\n    assert (t2.get_verticalalignment() == 'bottom')", "masked_code": "def test_mapped_alignment(self):\n    x = [1, 2]\n    p = Plot(x=x, y=x, halign=x, valign=x, text=x).add(Text()).plot()\n    ax = p._figure.axes[0]\n    (t1, t2) = self.get_texts(ax)\n    assert (t1.get_horizontalalignment() == 'left')\n    assert (t2.get_horizontalalignment() == 'right')\n    assert (t1.get_verticalalignment() == 'top')\n    assert (t2.get_verticalalignment() == '???')", "ground_truth": "'bottom'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1339", "reponame": "seaborn", "testpath": "tests/_marks/test_text.py", "testname": "test_text.py", "classname": "TestText", "funcname": "test_identity_fontsize", "imports": ["import numpy as np", "from matplotlib.colors import to_rgba", "from matplotlib.text import Text as MPLText", "from numpy.testing import assert_array_almost_equal", "from seaborn._core.plot import Plot", "from seaborn._marks.text import Text"], "code": "def test_identity_fontsize(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    fs = [5, 8, 12]\n    p = Plot(x, y, text=s, fontsize=fs).add(Text()).scale(fontsize=None).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        assert (text.get_fontsize() == fs[i])", "masked_code": "def test_identity_fontsize(self):\n    x = y = [1, 2, 3]\n    s = list('abc')\n    fs = [5, 8, 12]\n    p = Plot(x, y, text=s, fontsize=fs).add(Text()).scale(fontsize=None).plot()\n    ax = p._figure.axes[0]\n    for (i, text) in enumerate(self.get_texts(ax)):\n        assert (text.get_fontsize() == '???')", "ground_truth": "fs[i]", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1340", "reponame": "seaborn", "testpath": "tests/_stats/test_aggregation.py", "testname": "test_aggregation.py", "classname": "TestEst", "funcname": "test_weighted_mean", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from pandas.testing import assert_frame_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.aggregation import Agg, Est"], "code": "def test_weighted_mean(self, df, rng):\n    weights = rng.uniform(0, 5, len(df))\n    gb = self.get_groupby(df[['x', 'y']], 'x')\n    df = df.assign(weight=weights)\n    res = Est('mean')(df, gb, 'x', {})\n    for (_, res_row) in res.iterrows():\n        rows = df[(df['x'] == res_row['x'])]\n        expected = np.average(rows['y'], weights=rows['weight'])\n        assert (res_row['y'] == expected)", "masked_code": "def test_weighted_mean(self, df, rng):\n    weights = rng.uniform(0, 5, len(df))\n    gb = self.get_groupby(df[['x', 'y']], 'x')\n    df = df.assign(weight=weights)\n    res = Est('mean')(df, gb, 'x', {})\n    for (_, res_row) in res.iterrows():\n        rows = df[(df['x'] == res_row['x'])]\n        expected = np.average(rows['y'], weights=rows['weight'])\n        assert (res_row['y'] == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1341", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_string_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_string_bins(self, long_df):\n    h = Hist(bins='sqrt')\n    bin_kws = h._define_bin_params(long_df, 'x', 'continuous')\n    assert (bin_kws['range'] == (long_df['x'].min(), long_df['x'].max()))\n    assert (bin_kws['bins'] == int(np.sqrt(len(long_df))))", "masked_code": "def test_string_bins(self, long_df):\n    h = Hist(bins='sqrt')\n    bin_kws = h._define_bin_params(long_df, 'x', 'continuous')\n    assert (bin_kws['range'] == '???')\n    assert (bin_kws['bins'] == int(np.sqrt(len(long_df))))", "ground_truth": "(long_df['x'].min(), long_df['x'].max())", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1342", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_string_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_string_bins(self, long_df):\n    h = Hist(bins='sqrt')\n    bin_kws = h._define_bin_params(long_df, 'x', 'continuous')\n    assert (bin_kws['range'] == (long_df['x'].min(), long_df['x'].max()))\n    assert (bin_kws['bins'] == int(np.sqrt(len(long_df))))", "masked_code": "def test_string_bins(self, long_df):\n    h = Hist(bins='sqrt')\n    bin_kws = h._define_bin_params(long_df, 'x', 'continuous')\n    assert (bin_kws['range'] == (long_df['x'].min(), long_df['x'].max()))\n    assert (bin_kws['bins'] == '???')", "ground_truth": "int(np.sqrt(len(long_df)))", "quality_analysis": {"complexity_score": 15, "left_complexity": 5, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1343", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_int_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_int_bins(self, long_df):\n    n = 24\n    h = Hist(bins=n)\n    bin_kws = h._define_bin_params(long_df, 'x', 'continuous')\n    assert (bin_kws['range'] == (long_df['x'].min(), long_df['x'].max()))\n    assert (bin_kws['bins'] == n)", "masked_code": "def test_int_bins(self, long_df):\n    n = 24\n    h = Hist(bins=n)\n    bin_kws = h._define_bin_params(long_df, 'x', 'continuous')\n    assert (bin_kws['range'] == '???')\n    assert (bin_kws['bins'] == n)", "ground_truth": "(long_df['x'].min(), long_df['x'].max())", "quality_analysis": {"complexity_score": 13, "left_complexity": 5, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1344", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_int_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_int_bins(self, long_df):\n    n = 24\n    h = Hist(bins=n)\n    bin_kws = h._define_bin_params(long_df, 'x', 'continuous')\n    assert (bin_kws['range'] == (long_df['x'].min(), long_df['x'].max()))\n    assert (bin_kws['bins'] == n)", "masked_code": "def test_int_bins(self, long_df):\n    n = 24\n    h = Hist(bins=n)\n    bin_kws = h._define_bin_params(long_df, 'x', 'continuous')\n    assert (bin_kws['range'] == (long_df['x'].min(), long_df['x'].max()))\n    assert (bin_kws['bins'] == '???')", "ground_truth": "n", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1345", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_binwidth", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_binwidth(self, long_df):\n    binwidth = 0.5\n    h = Hist(binwidth=binwidth)\n    bin_kws = h._define_bin_params(long_df, 'x', 'continuous')\n    n_bins = bin_kws['bins']\n    (left, right) = bin_kws['range']\n    assert (((right - left) / n_bins) == pytest.approx(binwidth))", "masked_code": "def test_binwidth(self, long_df):\n    binwidth = 0.5\n    h = Hist(binwidth=binwidth)\n    bin_kws = h._define_bin_params(long_df, 'x', 'continuous')\n    n_bins = bin_kws['bins']\n    (left, right) = bin_kws['range']\n    assert (((right - left) / n_bins) == '???')", "ground_truth": "pytest.approx(binwidth)", "quality_analysis": {"complexity_score": 11, "left_complexity": 7, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1346", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_binrange", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_binrange(self, long_df):\n    binrange = ((- 4), 4)\n    h = Hist(binrange=binrange)\n    bin_kws = h._define_bin_params(long_df, 'x', 'continuous')\n    assert (bin_kws['range'] == binrange)", "masked_code": "def test_binrange(self, long_df):\n    binrange = ((- 4), 4)\n    h = Hist(binrange=binrange)\n    bin_kws = h._define_bin_params(long_df, 'x', 'continuous')\n    assert (bin_kws['range'] == '???')", "ground_truth": "binrange", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1347", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_discrete_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_discrete_bins(self, long_df):\n    h = Hist(discrete=True)\n    x = long_df['x'].astype(int)\n    bin_kws = h._define_bin_params(long_df.assign(x=x), 'x', 'continuous')\n    assert (bin_kws['range'] == ((x.min() - 0.5), (x.max() + 0.5)))\n    assert (bin_kws['bins'] == ((x.max() - x.min()) + 1))", "masked_code": "def test_discrete_bins(self, long_df):\n    h = Hist(discrete=True)\n    x = long_df['x'].astype(int)\n    bin_kws = h._define_bin_params(long_df.assign(x=x), 'x', 'continuous')\n    assert (bin_kws['range'] == '???')\n    assert (bin_kws['bins'] == ((x.max() - x.min()) + 1))", "ground_truth": "((x.min() - 0.5), (x.max() + 0.5))", "quality_analysis": {"complexity_score": 19, "left_complexity": 5, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1348", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_discrete_bins", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_discrete_bins(self, long_df):\n    h = Hist(discrete=True)\n    x = long_df['x'].astype(int)\n    bin_kws = h._define_bin_params(long_df.assign(x=x), 'x', 'continuous')\n    assert (bin_kws['range'] == ((x.min() - 0.5), (x.max() + 0.5)))\n    assert (bin_kws['bins'] == ((x.max() - x.min()) + 1))", "masked_code": "def test_discrete_bins(self, long_df):\n    h = Hist(discrete=True)\n    x = long_df['x'].astype(int)\n    bin_kws = h._define_bin_params(long_df.assign(x=x), 'x', 'continuous')\n    assert (bin_kws['range'] == ((x.min() - 0.5), (x.max() + 0.5)))\n    assert (bin_kws['bins'] == '???')", "ground_truth": "((x.max() - x.min()) + 1)", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1349", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_discrete_bins_from_nominal_scale", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_discrete_bins_from_nominal_scale(self, rng):\n    h = Hist()\n    x = rng.randint(0, 5, 10)\n    df = pd.DataFrame({'x': x})\n    bin_kws = h._define_bin_params(df, 'x', 'nominal')\n    assert (bin_kws['range'] == ((x.min() - 0.5), (x.max() + 0.5)))\n    assert (bin_kws['bins'] == ((x.max() - x.min()) + 1))", "masked_code": "def test_discrete_bins_from_nominal_scale(self, rng):\n    h = Hist()\n    x = rng.randint(0, 5, 10)\n    df = pd.DataFrame({'x': x})\n    bin_kws = h._define_bin_params(df, 'x', 'nominal')\n    assert (bin_kws['range'] == '???')\n    assert (bin_kws['bins'] == ((x.max() - x.min()) + 1))", "ground_truth": "((x.min() - 0.5), (x.max() + 0.5))", "quality_analysis": {"complexity_score": 19, "left_complexity": 5, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1350", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_discrete_bins_from_nominal_scale", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_discrete_bins_from_nominal_scale(self, rng):\n    h = Hist()\n    x = rng.randint(0, 5, 10)\n    df = pd.DataFrame({'x': x})\n    bin_kws = h._define_bin_params(df, 'x', 'nominal')\n    assert (bin_kws['range'] == ((x.min() - 0.5), (x.max() + 0.5)))\n    assert (bin_kws['bins'] == ((x.max() - x.min()) + 1))", "masked_code": "def test_discrete_bins_from_nominal_scale(self, rng):\n    h = Hist()\n    x = rng.randint(0, 5, 10)\n    df = pd.DataFrame({'x': x})\n    bin_kws = h._define_bin_params(df, 'x', 'nominal')\n    assert (bin_kws['range'] == ((x.min() - 0.5), (x.max() + 0.5)))\n    assert (bin_kws['bins'] == '???')", "ground_truth": "((x.max() - x.min()) + 1)", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1351", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_count_stat", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_count_stat(self, long_df, single_args):\n    h = Hist(stat='count')\n    out = h(long_df, *single_args)\n    assert (out['y'].sum() == len(long_df))", "masked_code": "def test_count_stat(self, long_df, single_args):\n    h = Hist(stat='count')\n    out = h(long_df, *single_args)\n    assert (out['y'].sum() == '???')", "ground_truth": "len(long_df)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1352", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_percent_stat", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_percent_stat(self, long_df, single_args):\n    h = Hist(stat='percent')\n    out = h(long_df, *single_args)\n    assert (out['y'].sum() == 100)", "masked_code": "def test_percent_stat(self, long_df, single_args):\n    h = Hist(stat='percent')\n    out = h(long_df, *single_args)\n    assert (out['y'].sum() == '???')", "ground_truth": "100", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1353", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_frequency_stat", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_frequency_stat(self, long_df, single_args):\n    h = Hist(stat='frequency')\n    out = h(long_df, *single_args)\n    assert ((out['y'] * out['space']).sum() == len(long_df))", "masked_code": "def test_frequency_stat(self, long_df, single_args):\n    h = Hist(stat='frequency')\n    out = h(long_df, *single_args)\n    assert ((out['y'] * out['space']).sum() == '???')", "ground_truth": "len(long_df)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1354", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_cumulative_count", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_cumulative_count(self, long_df, single_args):\n    h = Hist(stat='count', cumulative=True)\n    out = h(long_df, *single_args)\n    assert (out['y'].max() == len(long_df))", "masked_code": "def test_cumulative_count(self, long_df, single_args):\n    h = Hist(stat='count', cumulative=True)\n    out = h(long_df, *single_args)\n    assert (out['y'].max() == '???')", "ground_truth": "len(long_df)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1355", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_common_norm_default", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_common_norm_default(self, long_df, triple_args):\n    h = Hist(stat='percent')\n    out = h(long_df, *triple_args)\n    assert (out['y'].sum() == pytest.approx(100))", "masked_code": "def test_common_norm_default(self, long_df, triple_args):\n    h = Hist(stat='percent')\n    out = h(long_df, *triple_args)\n    assert (out['y'].sum() == '???')", "ground_truth": "pytest.approx(100)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1356", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_common_norm_false", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_common_norm_false(self, long_df, triple_args):\n    h = Hist(stat='percent', common_norm=False)\n    out = h(long_df, *triple_args)\n    for (_, out_part) in out.groupby(['a', 's']):\n        assert (out_part['y'].sum() == pytest.approx(100))", "masked_code": "def test_common_norm_false(self, long_df, triple_args):\n    h = Hist(stat='percent', common_norm=False)\n    out = h(long_df, *triple_args)\n    for (_, out_part) in out.groupby(['a', 's']):\n        assert (out_part['y'].sum() == '???')", "ground_truth": "pytest.approx(100)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1357", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_common_norm_subset", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_common_norm_subset(self, long_df, triple_args):\n    h = Hist(stat='percent', common_norm=['a'])\n    out = h(long_df, *triple_args)\n    for (_, out_part) in out.groupby('a'):\n        assert (out_part['y'].sum() == pytest.approx(100))", "masked_code": "def test_common_norm_subset(self, long_df, triple_args):\n    h = Hist(stat='percent', common_norm=['a'])\n    out = h(long_df, *triple_args)\n    for (_, out_part) in out.groupby('a'):\n        assert (out_part['y'].sum() == '???')", "ground_truth": "pytest.approx(100)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1358", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_common_bins_false", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_common_bins_false(self, long_df, triple_args):\n    h = Hist(common_bins=False)\n    out = h(long_df, *triple_args)\n    bins = []\n    for (_, out_part) in out.groupby(['a', 's']):\n        bins.append(tuple(out_part['x']))\n    assert (len(set(bins)) == len(out.groupby(['a', 's'])))", "masked_code": "def test_common_bins_false(self, long_df, triple_args):\n    h = Hist(common_bins=False)\n    out = h(long_df, *triple_args)\n    bins = []\n    for (_, out_part) in out.groupby(['a', 's']):\n        bins.append(tuple(out_part['x']))\n    assert (len(set(bins)) == '???')", "ground_truth": "len(out.groupby(['a', 's']))", "quality_analysis": {"complexity_score": 17, "left_complexity": 7, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1359", "reponame": "seaborn", "testpath": "tests/_stats/test_counting.py", "testname": "test_counting.py", "classname": "TestHist", "funcname": "test_common_bins_subset", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.counting import Hist, Count"], "code": "def test_common_bins_subset(self, long_df, triple_args):\n    h = Hist(common_bins=False)\n    out = h(long_df, *triple_args)\n    bins = []\n    for (_, out_part) in out.groupby('a'):\n        bins.append(tuple(out_part['x']))\n    assert (len(set(bins)) == out['a'].nunique())", "masked_code": "def test_common_bins_subset(self, long_df, triple_args):\n    h = Hist(common_bins=False)\n    out = h(long_df, *triple_args)\n    bins = []\n    for (_, out_part) in out.groupby('a'):\n        bins.append(tuple(out_part['x']))\n    assert (len(set(bins)) == '???')", "ground_truth": "out['a'].nunique()", "quality_analysis": {"complexity_score": 10, "left_complexity": 7, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1360", "reponame": "seaborn", "testpath": "tests/_stats/test_density.py", "testname": "test_density.py", "classname": "TestKDE", "funcname": "test_columns", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.density import KDE, _no_scipy", "from seaborn._compat import groupby_apply_include_groups"], "code": "@pytest.mark.parametrize('ori', ['x', 'y'])\ndef test_columns(self, df, ori):\n    df = df[[ori, 'alpha']]\n    gb = self.get_groupby(df, ori)\n    res = KDE()(df, gb, ori, {})\n    other = {'x': 'y', 'y': 'x'}[ori]\n    expected = [ori, 'alpha', 'density', other]\n    assert (list(res.columns) == expected)", "masked_code": "@pytest.mark.parametrize('ori', ['x', 'y'])\ndef test_columns(self, df, ori):\n    df = df[[ori, 'alpha']]\n    gb = self.get_groupby(df, ori)\n    res = KDE()(df, gb, ori, {})\n    other = {'x': 'y', 'y': 'x'}[ori]\n    expected = [ori, 'alpha', 'density', other]\n    assert (list(res.columns) == '???')", "ground_truth": "expected", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1361", "reponame": "seaborn", "testpath": "tests/_stats/test_density.py", "testname": "test_density.py", "classname": "TestKDE", "funcname": "test_gridsize", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.density import KDE, _no_scipy", "from seaborn._compat import groupby_apply_include_groups"], "code": "@pytest.mark.parametrize('gridsize', [20, 30, None])\ndef test_gridsize(self, df, gridsize):\n    ori = 'y'\n    df = df[[ori]]\n    gb = self.get_groupby(df, ori)\n    res = KDE(gridsize=gridsize)(df, gb, ori, {})\n    if (gridsize is None):\n        assert_array_equal(res[ori], df[ori])\n    else:\n        assert (len(res) == gridsize)", "masked_code": "@pytest.mark.parametrize('gridsize', [20, 30, None])\ndef test_gridsize(self, df, gridsize):\n    ori = 'y'\n    df = df[[ori]]\n    gb = self.get_groupby(df, ori)\n    res = KDE(gridsize=gridsize)(df, gb, ori, {})\n    if (gridsize is None):\n        assert_array_equal(res[ori], df[ori])\n    else:\n        assert (len(res) == '???')", "ground_truth": "gridsize", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1362", "reponame": "seaborn", "testpath": "tests/_stats/test_density.py", "testname": "test_density.py", "classname": "TestKDE", "funcname": "test_cut", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.density import KDE, _no_scipy", "from seaborn._compat import groupby_apply_include_groups"], "code": "@pytest.mark.parametrize('cut', [1, 2])\ndef test_cut(self, df, cut):\n    ori = 'y'\n    df = df[[ori]]\n    gb = self.get_groupby(df, ori)\n    res = KDE(cut=cut, bw_method=1)(df, gb, ori, {})\n    vals = df[ori]\n    bw = vals.std()\n    assert (res[ori].min() == pytest.approx((vals.min() - (bw * cut)), abs=0.01))\n    assert (res[ori].max() == pytest.approx((vals.max() + (bw * cut)), abs=0.01))", "masked_code": "@pytest.mark.parametrize('cut', [1, 2])\ndef test_cut(self, df, cut):\n    ori = 'y'\n    df = df[[ori]]\n    gb = self.get_groupby(df, ori)\n    res = KDE(cut=cut, bw_method=1)(df, gb, ori, {})\n    vals = df[ori]\n    bw = vals.std()\n    assert (res[ori].min() == '???')\n    assert (res[ori].max() == pytest.approx((vals.max() + (bw * cut)), abs=0.01))", "ground_truth": "pytest.approx((vals.min() - (bw * cut)), abs=0.01)", "quality_analysis": {"complexity_score": 15, "left_complexity": 3, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1363", "reponame": "seaborn", "testpath": "tests/_stats/test_density.py", "testname": "test_density.py", "classname": "TestKDE", "funcname": "test_cut", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.density import KDE, _no_scipy", "from seaborn._compat import groupby_apply_include_groups"], "code": "@pytest.mark.parametrize('cut', [1, 2])\ndef test_cut(self, df, cut):\n    ori = 'y'\n    df = df[[ori]]\n    gb = self.get_groupby(df, ori)\n    res = KDE(cut=cut, bw_method=1)(df, gb, ori, {})\n    vals = df[ori]\n    bw = vals.std()\n    assert (res[ori].min() == pytest.approx((vals.min() - (bw * cut)), abs=0.01))\n    assert (res[ori].max() == pytest.approx((vals.max() + (bw * cut)), abs=0.01))", "masked_code": "@pytest.mark.parametrize('cut', [1, 2])\ndef test_cut(self, df, cut):\n    ori = 'y'\n    df = df[[ori]]\n    gb = self.get_groupby(df, ori)\n    res = KDE(cut=cut, bw_method=1)(df, gb, ori, {})\n    vals = df[ori]\n    bw = vals.std()\n    assert (res[ori].min() == pytest.approx((vals.min() - (bw * cut)), abs=0.01))\n    assert (res[ori].max() == '???')", "ground_truth": "pytest.approx((vals.max() + (bw * cut)), abs=0.01)", "quality_analysis": {"complexity_score": 15, "left_complexity": 3, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1364", "reponame": "seaborn", "testpath": "tests/_stats/test_density.py", "testname": "test_density.py", "classname": "TestKDE", "funcname": "test_common_norm", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.density import KDE, _no_scipy", "from seaborn._compat import groupby_apply_include_groups"], "code": "@pytest.mark.parametrize('common_norm', [True, False])\ndef test_common_norm(self, df, common_norm):\n    ori = 'y'\n    df = df[[ori, 'alpha']]\n    gb = self.get_groupby(df, ori)\n    res = KDE(common_norm=common_norm)(df, gb, ori, {})\n    areas = res.groupby('alpha').apply((lambda x: self.integrate(x['density'], x[ori])), **groupby_apply_include_groups(False))\n    if common_norm:\n        assert (areas.sum() == pytest.approx(1, abs=0.001))\n    else:\n        assert_array_almost_equal(areas, [1, 1], decimal=3)", "masked_code": "@pytest.mark.parametrize('common_norm', [True, False])\ndef test_common_norm(self, df, common_norm):\n    ori = 'y'\n    df = df[[ori, 'alpha']]\n    gb = self.get_groupby(df, ori)\n    res = KDE(common_norm=common_norm)(df, gb, ori, {})\n    areas = res.groupby('alpha').apply((lambda x: self.integrate(x['density'], x[ori])), **groupby_apply_include_groups(False))\n    if common_norm:\n        assert (areas.sum() == '???')\n    else:\n        assert_array_almost_equal(areas, [1, 1], decimal=3)", "ground_truth": "pytest.approx(1, abs=0.001)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1365", "reponame": "seaborn", "testpath": "tests/_stats/test_density.py", "testname": "test_density.py", "classname": "TestKDE", "funcname": "test_cumulative", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.density import KDE, _no_scipy", "from seaborn._compat import groupby_apply_include_groups"], "code": "@pytest.mark.skipif(_no_scipy, reason='KDE.cumulative requires scipy')\n@pytest.mark.parametrize('common_norm', [True, False])\ndef test_cumulative(self, df, common_norm):\n    ori = 'y'\n    df = df[[ori, 'alpha']]\n    gb = self.get_groupby(df, ori)\n    res = KDE(cumulative=True, common_norm=common_norm)(df, gb, ori, {})\n    for (_, group_res) in res.groupby('alpha'):\n        assert (group_res['density'].diff().dropna() >= 0).all()\n        if (not common_norm):\n            assert (group_res['density'].max() == pytest.approx(1, abs=0.001))", "masked_code": "@pytest.mark.skipif(_no_scipy, reason='KDE.cumulative requires scipy')\n@pytest.mark.parametrize('common_norm', [True, False])\ndef test_cumulative(self, df, common_norm):\n    ori = 'y'\n    df = df[[ori, 'alpha']]\n    gb = self.get_groupby(df, ori)\n    res = KDE(cumulative=True, common_norm=common_norm)(df, gb, ori, {})\n    for (_, group_res) in res.groupby('alpha'):\n        assert (group_res['density'].diff().dropna() >= 0).all()\n        if (not common_norm):\n            assert (group_res['density'].max() == '???')", "ground_truth": "pytest.approx(1, abs=0.001)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1366", "reponame": "seaborn", "testpath": "tests/_stats/test_density.py", "testname": "test_density.py", "classname": "TestKDE", "funcname": "test_singular", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.density import KDE, _no_scipy", "from seaborn._compat import groupby_apply_include_groups"], "code": "@pytest.mark.parametrize('vals', [[], [1], ([1] * 5), ([1929245168.06679] * 18)])\ndef test_singular(self, df, vals):\n    df1 = pd.DataFrame({'y': vals, 'alpha': (['z'] * len(vals))})\n    gb = self.get_groupby(df1, 'y')\n    res = KDE()(df1, gb, 'y', {})\n    assert res.empty\n    df2 = pd.concat([df[['y', 'alpha']], df1], ignore_index=True)\n    gb = self.get_groupby(df2, 'y')\n    res = KDE()(df2, gb, 'y', {})\n    assert (set(res['alpha']) == set(df['alpha']))", "masked_code": "@pytest.mark.parametrize('vals', [[], [1], ([1] * 5), ([1929245168.06679] * 18)])\ndef test_singular(self, df, vals):\n    df1 = pd.DataFrame({'y': vals, 'alpha': (['z'] * len(vals))})\n    gb = self.get_groupby(df1, 'y')\n    res = KDE()(df1, gb, 'y', {})\n    assert res.empty\n    df2 = pd.concat([df[['y', 'alpha']], df1], ignore_index=True)\n    gb = self.get_groupby(df2, 'y')\n    res = KDE()(df2, gb, 'y', {})\n    assert (set(res['alpha']) == '???')", "ground_truth": "set(df['alpha'])", "quality_analysis": {"complexity_score": 16, "left_complexity": 8, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1367", "reponame": "seaborn", "testpath": "tests/_stats/test_density.py", "testname": "test_density.py", "classname": "TestKDE", "funcname": "test_missing", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.density import KDE, _no_scipy", "from seaborn._compat import groupby_apply_include_groups"], "code": "@pytest.mark.parametrize('col', ['y', 'weight'])\ndef test_missing(self, df, col):\n    (val, ori) = 'xy'\n    df['weight'] = 1\n    df = df[[ori, 'weight']].astype(float)\n    df.loc[(:4, col)] = np.nan\n    gb = self.get_groupby(df, ori)\n    res = KDE()(df, gb, ori, {})\n    assert (self.integrate(res[val], res[ori]) == pytest.approx(1, abs=0.001))", "masked_code": "@pytest.mark.parametrize('col', ['y', 'weight'])\ndef test_missing(self, df, col):\n    (val, ori) = 'xy'\n    df['weight'] = 1\n    df = df[[ori, 'weight']].astype(float)\n    df.loc[(:4, col)] = np.nan\n    gb = self.get_groupby(df, ori)\n    res = KDE()(df, gb, ori, {})\n    assert (self.integrate(res[val], res[ori]) == '???')", "ground_truth": "pytest.approx(1, abs=0.001)", "quality_analysis": {"complexity_score": 17, "left_complexity": 13, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "seaborn_1368", "reponame": "seaborn", "testpath": "tests/_stats/test_regression.py", "testname": "test_regression.py", "classname": "TestPolyFit", "funcname": "test_one_grouper", "imports": ["import numpy as np", "import pandas as pd", "import pytest", "from numpy.testing import assert_array_equal, assert_array_almost_equal", "from pandas.testing import assert_frame_equal", "from seaborn._core.groupby import GroupBy", "from seaborn._stats.regression import PolyFit"], "code": "def test_one_grouper(self, df):\n    groupby = GroupBy(['group'])\n    gridsize = 50\n    res = PolyFit(gridsize=gridsize)(df, groupby, 'x', {})\n    assert (res.columns.to_list() == ['x', 'y', 'group'])\n    ngroups = df['group'].nunique()\n    assert_array_equal(res.index, np.arange((ngroups * gridsize)))\n    for (_, part) in res.groupby('group'):\n        grid = np.linspace(part['x'].min(), part['x'].max(), gridsize)\n        assert_array_equal(part['x'], grid)\n        assert part['y'].diff().diff().dropna().abs().gt(0).all()", "masked_code": "def test_one_grouper(self, df):\n    groupby = GroupBy(['group'])\n    gridsize = 50\n    res = PolyFit(gridsize=gridsize)(df, groupby, 'x', {})\n    assert (res.columns.to_list() == '???')\n    ngroups = df['group'].nunique()\n    assert_array_equal(res.index, np.arange((ngroups * gridsize)))\n    for (_, part) in res.groupby('group'):\n        grid = np.linspace(part['x'].min(), part['x'].max(), gridsize)\n        assert_array_equal(part['x'], grid)\n        assert part['y'].diff().diff().dropna().abs().gt(0).all()", "ground_truth": "['x', 'y', 'group']", "quality_analysis": {"complexity_score": 8, "left_complexity": 3, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
