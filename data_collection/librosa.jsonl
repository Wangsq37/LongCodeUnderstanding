{"task_id": "librosa_0", "reponame": "librosa", "testpath": "tests/test_beat.py", "testname": "test_beat.py", "classname": null, "funcname": "test_beat_no_onsets", "imports": ["import os", "import pytest", "from contextlib import nullcontext as dnr", "import numpy as np", "import scipy.stats", "import librosa", "from test_core import files, load"], "code": "def test_beat_no_onsets():\n    sr = 22050\n    hop_length = 512\n    duration = 30\n    onsets = np.zeros(((duration * sr) // hop_length))\n    (tempo, beats) = librosa.beat.beat_track(onset_envelope=onsets, sr=sr, hop_length=hop_length, sparse=True)\n    assert np.allclose(tempo, 0)\n    assert (len(beats) == 0)\n    (tempo, beats) = librosa.beat.beat_track(onset_envelope=onsets, sr=sr, hop_length=hop_length, sparse=False)\n    assert np.allclose(tempo, 0)\n    assert (beats.shape == onsets.shape)\n    assert (not np.any(beats))", "masked_code": "def test_beat_no_onsets():\n    sr = 22050\n    hop_length = 512\n    duration = 30\n    onsets = np.zeros(((duration * sr) // hop_length))\n    (tempo, beats) = librosa.beat.beat_track(onset_envelope=onsets, sr=sr, hop_length=hop_length, sparse=True)\n    assert np.allclose(tempo, 0)\n    assert (len(beats) == 0)\n    (tempo, beats) = librosa.beat.beat_track(onset_envelope=onsets, sr=sr, hop_length=hop_length, sparse=False)\n    assert np.allclose(tempo, 0)\n    assert (beats.shape == '???')\n    assert (not np.any(beats))", "ground_truth": "onsets.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_1", "reponame": "librosa", "testpath": "tests/test_beat.py", "testname": "test_beat.py", "classname": null, "funcname": "test_plp", "imports": ["import os", "import pytest", "from contextlib import nullcontext as dnr", "import numpy as np", "import scipy.stats", "import librosa", "from test_core import files, load"], "code": "@pytest.mark.parametrize('hop_length', [256, 512])\n@pytest.mark.parametrize('win_length', [192, 384])\n@pytest.mark.parametrize('use_onset', [False, True])\n@pytest.mark.parametrize('tempo_min,tempo_max,ctx', [(30, 300, dnr()), (None, 240, dnr()), (60, None, dnr()), (120, 80, pytest.raises(librosa.ParameterError))])\n@pytest.mark.parametrize('prior', [None, scipy.stats.lognorm(s=1, loc=np.log(120), scale=120)])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\ndef test_plp(ysr, hop_length, win_length, tempo_min, tempo_max, use_onset, prior, ctx):\n    (y, sr) = ysr\n    oenv = librosa.onset.onset_strength(y=y, sr=sr, hop_length=hop_length)\n    with ctx:\n        if use_onset:\n            pulse = librosa.beat.plp(y=y, sr=sr, onset_envelope=oenv, hop_length=hop_length, win_length=win_length, tempo_min=tempo_min, tempo_max=tempo_max, prior=prior)\n        else:\n            pulse = librosa.beat.plp(y=y, sr=sr, hop_length=hop_length, win_length=win_length, tempo_min=tempo_min, tempo_max=tempo_max, prior=prior)\n        assert (len(pulse) == len(oenv))\n        assert np.all((pulse >= 0))\n        assert np.all((pulse <= 1))", "masked_code": "@pytest.mark.parametrize('hop_length', [256, 512])\n@pytest.mark.parametrize('win_length', [192, 384])\n@pytest.mark.parametrize('use_onset', [False, True])\n@pytest.mark.parametrize('tempo_min,tempo_max,ctx', [(30, 300, dnr()), (None, 240, dnr()), (60, None, dnr()), (120, 80, pytest.raises(librosa.ParameterError))])\n@pytest.mark.parametrize('prior', [None, scipy.stats.lognorm(s=1, loc=np.log(120), scale=120)])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\ndef test_plp(ysr, hop_length, win_length, tempo_min, tempo_max, use_onset, prior, ctx):\n    (y, sr) = ysr\n    oenv = librosa.onset.onset_strength(y=y, sr=sr, hop_length=hop_length)\n    with ctx:\n        if use_onset:\n            pulse = librosa.beat.plp(y=y, sr=sr, onset_envelope=oenv, hop_length=hop_length, win_length=win_length, tempo_min=tempo_min, tempo_max=tempo_max, prior=prior)\n        else:\n            pulse = librosa.beat.plp(y=y, sr=sr, hop_length=hop_length, win_length=win_length, tempo_min=tempo_min, tempo_max=tempo_max, prior=prior)\n        assert (len(pulse) == '???')\n        assert np.all((pulse >= 0))\n        assert np.all((pulse <= 1))", "ground_truth": "len(oenv)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_2", "reponame": "librosa", "testpath": "tests/test_constantq.py", "testname": "test_constantq.py", "classname": null, "funcname": "test_cqt", "imports": ["from __future__ import division", "import warnings", "import os", "from typing import Optional", "import librosa", "import numpy as np", "import scipy.stats", "import pytest", "from test_core import srand"], "code": "@pytest.mark.parametrize('fmin', [None, librosa.note_to_hz('C2')])\n@pytest.mark.parametrize('n_bins', [1, 12, 24, 76])\n@pytest.mark.parametrize('bins_per_octave', [12, 24])\n@pytest.mark.parametrize('tuning', [None, 0, 0.25])\n@pytest.mark.parametrize('filter_scale', [1])\n@pytest.mark.parametrize('norm', [1])\n@pytest.mark.parametrize('res_type', ['polyphase'])\n@pytest.mark.parametrize('hop_length', [512, 2000])\n@pytest.mark.parametrize('sparsity', [0.01])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\n@pytest.mark.filterwarnings('ignore:Trying to estimate tuning')\ndef test_cqt(y_cqt_110, sr_cqt, hop_length, fmin, n_bins, bins_per_octave, tuning, filter_scale, norm, res_type, sparsity):\n    C = librosa.cqt(y=y_cqt_110, sr=sr_cqt, hop_length=hop_length, fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave, tuning=tuning, filter_scale=filter_scale, norm=norm, sparsity=sparsity, res_type=res_type)\n    assert np.iscomplexobj(C)\n    assert (C.shape[0] == n_bins)\n    if (fmin is None):\n        fmin = librosa.note_to_hz('C1')\n    if (110 <= (fmin * (2 ** (n_bins / bins_per_octave)))):\n        peaks = np.argmax(np.abs(C), axis=0)\n        common_peak = np.argmax(np.bincount(peaks))\n        peak_frequency = (fmin * (2 ** (common_peak / bins_per_octave)))\n        assert np.isclose(peak_frequency, 110)", "masked_code": "@pytest.mark.parametrize('fmin', [None, librosa.note_to_hz('C2')])\n@pytest.mark.parametrize('n_bins', [1, 12, 24, 76])\n@pytest.mark.parametrize('bins_per_octave', [12, 24])\n@pytest.mark.parametrize('tuning', [None, 0, 0.25])\n@pytest.mark.parametrize('filter_scale', [1])\n@pytest.mark.parametrize('norm', [1])\n@pytest.mark.parametrize('res_type', ['polyphase'])\n@pytest.mark.parametrize('hop_length', [512, 2000])\n@pytest.mark.parametrize('sparsity', [0.01])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\n@pytest.mark.filterwarnings('ignore:Trying to estimate tuning')\ndef test_cqt(y_cqt_110, sr_cqt, hop_length, fmin, n_bins, bins_per_octave, tuning, filter_scale, norm, res_type, sparsity):\n    C = librosa.cqt(y=y_cqt_110, sr=sr_cqt, hop_length=hop_length, fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave, tuning=tuning, filter_scale=filter_scale, norm=norm, sparsity=sparsity, res_type=res_type)\n    assert np.iscomplexobj(C)\n    assert (C.shape[0] == '???')\n    if (fmin is None):\n        fmin = librosa.note_to_hz('C1')\n    if (110 <= (fmin * (2 ** (n_bins / bins_per_octave)))):\n        peaks = np.argmax(np.abs(C), axis=0)\n        common_peak = np.argmax(np.bincount(peaks))\n        peak_frequency = (fmin * (2 ** (common_peak / bins_per_octave)))\n        assert np.isclose(peak_frequency, 110)", "ground_truth": "n_bins", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_3", "reponame": "librosa", "testpath": "tests/test_constantq.py", "testname": "test_constantq.py", "classname": null, "funcname": "test_cqt_early_downsample", "imports": ["from __future__ import division", "import warnings", "import os", "from typing import Optional", "import librosa", "import numpy as np", "import scipy.stats", "import pytest", "from test_core import srand"], "code": "@pytest.mark.parametrize('fmin', [librosa.note_to_hz('C1')])\n@pytest.mark.parametrize('bins_per_octave', [12])\n@pytest.mark.parametrize('n_bins', [88])\ndef test_cqt_early_downsample(y_cqt_110, sr_cqt, n_bins, fmin, bins_per_octave):\n    with pytest.warns(FutureWarning, match='Support for VQT with res_type=None'):\n        C = librosa.cqt(y=y_cqt_110, sr=sr_cqt, fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave, res_type=None)\n    assert np.iscomplexobj(C)\n    assert (C.shape[0] == n_bins)\n    if (fmin is None):\n        fmin = librosa.note_to_hz('C1')\n    if (110 <= (fmin * (2 ** (n_bins / bins_per_octave)))):\n        peaks = np.argmax(np.abs(C), axis=0)\n        common_peak = np.argmax(np.bincount(peaks))\n        peak_frequency = (fmin * (2 ** (common_peak / bins_per_octave)))\n        assert np.isclose(peak_frequency, 110)", "masked_code": "@pytest.mark.parametrize('fmin', [librosa.note_to_hz('C1')])\n@pytest.mark.parametrize('bins_per_octave', [12])\n@pytest.mark.parametrize('n_bins', [88])\ndef test_cqt_early_downsample(y_cqt_110, sr_cqt, n_bins, fmin, bins_per_octave):\n    with pytest.warns(FutureWarning, match='Support for VQT with res_type=None'):\n        C = librosa.cqt(y=y_cqt_110, sr=sr_cqt, fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave, res_type=None)\n    assert np.iscomplexobj(C)\n    assert (C.shape[0] == '???')\n    if (fmin is None):\n        fmin = librosa.note_to_hz('C1')\n    if (110 <= (fmin * (2 ** (n_bins / bins_per_octave)))):\n        peaks = np.argmax(np.abs(C), axis=0)\n        common_peak = np.argmax(np.bincount(peaks))\n        peak_frequency = (fmin * (2 ** (common_peak / bins_per_octave)))\n        assert np.isclose(peak_frequency, 110)", "ground_truth": "n_bins", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_4", "reponame": "librosa", "testpath": "tests/test_constantq.py", "testname": "test_constantq.py", "classname": null, "funcname": "test_cqt_frame_rate", "imports": ["from __future__ import division", "import warnings", "import os", "from typing import Optional", "import librosa", "import numpy as np", "import scipy.stats", "import pytest", "from test_core import srand"], "code": "@pytest.mark.parametrize('hop_length', [256, 512])\ndef test_cqt_frame_rate(y_cqt_110, sr_cqt, hop_length):\n    C = librosa.cqt(y=y_cqt_110, sr=sr_cqt, hop_length=hop_length, res_type='polyphase')\n    if (hop_length == 256):\n        assert (C.shape[1] == 33)\n    elif (hop_length == 512):\n        assert (C.shape[1] == 17)\n    else:\n        assert False", "masked_code": "@pytest.mark.parametrize('hop_length', [256, 512])\ndef test_cqt_frame_rate(y_cqt_110, sr_cqt, hop_length):\n    C = librosa.cqt(y=y_cqt_110, sr=sr_cqt, hop_length=hop_length, res_type='polyphase')\n    if (hop_length == 256):\n        assert (C.shape[1] == '???')\n    elif (hop_length == 512):\n        assert (C.shape[1] == 17)\n    else:\n        assert False", "ground_truth": "33", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_5", "reponame": "librosa", "testpath": "tests/test_constantq.py", "testname": "test_constantq.py", "classname": null, "funcname": "test_cqt_frame_rate", "imports": ["from __future__ import division", "import warnings", "import os", "from typing import Optional", "import librosa", "import numpy as np", "import scipy.stats", "import pytest", "from test_core import srand"], "code": "@pytest.mark.parametrize('hop_length', [256, 512])\ndef test_cqt_frame_rate(y_cqt_110, sr_cqt, hop_length):\n    C = librosa.cqt(y=y_cqt_110, sr=sr_cqt, hop_length=hop_length, res_type='polyphase')\n    if (hop_length == 256):\n        assert (C.shape[1] == 33)\n    elif (hop_length == 512):\n        assert (C.shape[1] == 17)\n    else:\n        assert False", "masked_code": "@pytest.mark.parametrize('hop_length', [256, 512])\ndef test_cqt_frame_rate(y_cqt_110, sr_cqt, hop_length):\n    C = librosa.cqt(y=y_cqt_110, sr=sr_cqt, hop_length=hop_length, res_type='polyphase')\n    if (hop_length == 256):\n        assert (C.shape[1] == 33)\n    elif (hop_length == 512):\n        assert (C.shape[1] == '???')\n    else:\n        assert False", "ground_truth": "17", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_6", "reponame": "librosa", "testpath": "tests/test_constantq.py", "testname": "test_constantq.py", "classname": null, "funcname": "test_vqt", "imports": ["from __future__ import division", "import warnings", "import os", "from typing import Optional", "import librosa", "import numpy as np", "import scipy.stats", "import pytest", "from test_core import srand"], "code": "@pytest.mark.parametrize('fmin', [None, librosa.note_to_hz('C2')])\n@pytest.mark.parametrize('n_bins', [1, 12, 24])\n@pytest.mark.parametrize('gamma', [None, 0, 2.5])\n@pytest.mark.parametrize('bins_per_octave', [12, 24])\n@pytest.mark.parametrize('tuning', [0])\n@pytest.mark.parametrize('filter_scale', [1])\n@pytest.mark.parametrize('norm', [1])\n@pytest.mark.parametrize('res_type', ['polyphase'])\n@pytest.mark.parametrize('sparsity', [0.01])\n@pytest.mark.parametrize('hop_length', [512])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\ndef test_vqt(y_cqt_110, sr_cqt, hop_length, fmin, n_bins, gamma, bins_per_octave, tuning, filter_scale, norm, res_type, sparsity):\n    C = librosa.vqt(y=y_cqt_110, sr=sr_cqt, hop_length=hop_length, fmin=fmin, n_bins=n_bins, gamma=gamma, bins_per_octave=bins_per_octave, tuning=tuning, filter_scale=filter_scale, norm=norm, sparsity=sparsity, res_type=res_type)\n    assert np.iscomplexobj(C)\n    assert (C.shape[0] == n_bins)\n    if (fmin is None):\n        fmin = librosa.note_to_hz('C1')\n    if (110 <= (fmin * (2 ** (n_bins / bins_per_octave)))):\n        peaks = np.argmax(np.abs(C), axis=0)\n        common_peak = np.argmax(np.bincount(peaks))\n        peak_frequency = (fmin * (2 ** (common_peak / bins_per_octave)))\n        assert np.isclose(peak_frequency, 110)", "masked_code": "@pytest.mark.parametrize('fmin', [None, librosa.note_to_hz('C2')])\n@pytest.mark.parametrize('n_bins', [1, 12, 24])\n@pytest.mark.parametrize('gamma', [None, 0, 2.5])\n@pytest.mark.parametrize('bins_per_octave', [12, 24])\n@pytest.mark.parametrize('tuning', [0])\n@pytest.mark.parametrize('filter_scale', [1])\n@pytest.mark.parametrize('norm', [1])\n@pytest.mark.parametrize('res_type', ['polyphase'])\n@pytest.mark.parametrize('sparsity', [0.01])\n@pytest.mark.parametrize('hop_length', [512])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\ndef test_vqt(y_cqt_110, sr_cqt, hop_length, fmin, n_bins, gamma, bins_per_octave, tuning, filter_scale, norm, res_type, sparsity):\n    C = librosa.vqt(y=y_cqt_110, sr=sr_cqt, hop_length=hop_length, fmin=fmin, n_bins=n_bins, gamma=gamma, bins_per_octave=bins_per_octave, tuning=tuning, filter_scale=filter_scale, norm=norm, sparsity=sparsity, res_type=res_type)\n    assert np.iscomplexobj(C)\n    assert (C.shape[0] == '???')\n    if (fmin is None):\n        fmin = librosa.note_to_hz('C1')\n    if (110 <= (fmin * (2 ** (n_bins / bins_per_octave)))):\n        peaks = np.argmax(np.abs(C), axis=0)\n        common_peak = np.argmax(np.bincount(peaks))\n        peak_frequency = (fmin * (2 ** (common_peak / bins_per_octave)))\n        assert np.isclose(peak_frequency, 110)", "ground_truth": "n_bins", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_7", "reponame": "librosa", "testpath": "tests/test_constantq.py", "testname": "test_constantq.py", "classname": null, "funcname": "test_hybrid_cqt", "imports": ["from __future__ import division", "import warnings", "import os", "from typing import Optional", "import librosa", "import numpy as np", "import scipy.stats", "import pytest", "from test_core import srand"], "code": "@pytest.mark.parametrize('sr', [11025])\n@pytest.mark.parametrize('hop_length', [512, 2000])\n@pytest.mark.parametrize('sparsity', [0.01])\n@pytest.mark.parametrize('fmin', [None, librosa.note_to_hz('C2')])\n@pytest.mark.parametrize('n_bins', [1, 12, 24, 48, 72, 74, 76])\n@pytest.mark.parametrize('bins_per_octave', [12, 24])\n@pytest.mark.parametrize('tuning', [None, 0, 0.25])\n@pytest.mark.parametrize('resolution', [1])\n@pytest.mark.parametrize('norm', [1])\n@pytest.mark.parametrize('res_type', ['polyphase'])\ndef test_hybrid_cqt(y_hybrid, sr, hop_length, fmin, n_bins, bins_per_octave, tuning, resolution, norm, sparsity, res_type):\n    C2 = librosa.hybrid_cqt(y_hybrid, sr=sr, hop_length=hop_length, fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave, tuning=tuning, filter_scale=resolution, norm=norm, sparsity=sparsity, res_type=res_type)\n    C1 = np.abs(librosa.cqt(y_hybrid, sr=sr, hop_length=hop_length, fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave, tuning=tuning, filter_scale=resolution, norm=norm, sparsity=sparsity, res_type=res_type))\n    assert (C1.shape == C2.shape)\n    idx1 = (C1 > (0.0001 * C1.max()))\n    idx2 = (C2 > (0.0001 * C2.max()))\n    perc = 0.99\n    thresh = 0.001\n    idx = (idx1 | idx2)\n    assert (np.percentile(np.abs((C1[idx] - C2[idx])), perc) < (thresh * max(C1.max(), C2.max())))", "masked_code": "@pytest.mark.parametrize('sr', [11025])\n@pytest.mark.parametrize('hop_length', [512, 2000])\n@pytest.mark.parametrize('sparsity', [0.01])\n@pytest.mark.parametrize('fmin', [None, librosa.note_to_hz('C2')])\n@pytest.mark.parametrize('n_bins', [1, 12, 24, 48, 72, 74, 76])\n@pytest.mark.parametrize('bins_per_octave', [12, 24])\n@pytest.mark.parametrize('tuning', [None, 0, 0.25])\n@pytest.mark.parametrize('resolution', [1])\n@pytest.mark.parametrize('norm', [1])\n@pytest.mark.parametrize('res_type', ['polyphase'])\ndef test_hybrid_cqt(y_hybrid, sr, hop_length, fmin, n_bins, bins_per_octave, tuning, resolution, norm, sparsity, res_type):\n    C2 = librosa.hybrid_cqt(y_hybrid, sr=sr, hop_length=hop_length, fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave, tuning=tuning, filter_scale=resolution, norm=norm, sparsity=sparsity, res_type=res_type)\n    C1 = np.abs(librosa.cqt(y_hybrid, sr=sr, hop_length=hop_length, fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave, tuning=tuning, filter_scale=resolution, norm=norm, sparsity=sparsity, res_type=res_type))\n    assert (C1.shape == '???')\n    idx1 = (C1 > (0.0001 * C1.max()))\n    idx2 = (C2 > (0.0001 * C2.max()))\n    perc = 0.99\n    thresh = 0.001\n    idx = (idx1 | idx2)\n    assert (np.percentile(np.abs((C1[idx] - C2[idx])), perc) < (thresh * max(C1.max(), C2.max())))", "ground_truth": "C2.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_8", "reponame": "librosa", "testpath": "tests/test_constantq.py", "testname": "test_constantq.py", "classname": null, "funcname": "test_icqt", "imports": ["from __future__ import division", "import warnings", "import os", "from typing import Optional", "import librosa", "import numpy as np", "import scipy.stats", "import pytest", "from test_core import srand"], "code": "@pytest.mark.parametrize('over_sample', [1, 3])\n@pytest.mark.parametrize('scale', [False, True])\n@pytest.mark.parametrize('hop_length', [384, 512])\n@pytest.mark.parametrize('length', [None, True])\n@pytest.mark.parametrize('res_type', ['soxr_hq', 'polyphase'])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\ndef test_icqt(y_icqt, sr_icqt, scale, hop_length, over_sample, length, res_type, dtype):\n    bins_per_octave = (over_sample * 12)\n    n_bins = (7 * bins_per_octave)\n    C = librosa.cqt(y_icqt, sr=sr_icqt, n_bins=n_bins, bins_per_octave=bins_per_octave, scale=scale, hop_length=hop_length)\n    if length:\n        _len = len(y_icqt)\n    else:\n        _len = None\n    yinv = librosa.icqt(C, sr=sr_icqt, scale=scale, hop_length=hop_length, bins_per_octave=bins_per_octave, length=_len, res_type=res_type, dtype=dtype)\n    assert (yinv.dtype == dtype)\n    if length:\n        assert (len(y_icqt) == len(yinv))\n    else:\n        yinv = librosa.util.fix_length(yinv, size=len(y_icqt))\n    y_icqt = y_icqt[(sr_icqt // 2):((- sr_icqt) // 2)]\n    yinv = yinv[(sr_icqt // 2):((- sr_icqt) // 2)]\n    residual = np.abs((y_icqt - yinv))\n    resnorm = np.sqrt(np.mean((residual ** 2)))\n    assert (resnorm <= 0.1), resnorm", "masked_code": "@pytest.mark.parametrize('over_sample', [1, 3])\n@pytest.mark.parametrize('scale', [False, True])\n@pytest.mark.parametrize('hop_length', [384, 512])\n@pytest.mark.parametrize('length', [None, True])\n@pytest.mark.parametrize('res_type', ['soxr_hq', 'polyphase'])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\ndef test_icqt(y_icqt, sr_icqt, scale, hop_length, over_sample, length, res_type, dtype):\n    bins_per_octave = (over_sample * 12)\n    n_bins = (7 * bins_per_octave)\n    C = librosa.cqt(y_icqt, sr=sr_icqt, n_bins=n_bins, bins_per_octave=bins_per_octave, scale=scale, hop_length=hop_length)\n    if length:\n        _len = len(y_icqt)\n    else:\n        _len = None\n    yinv = librosa.icqt(C, sr=sr_icqt, scale=scale, hop_length=hop_length, bins_per_octave=bins_per_octave, length=_len, res_type=res_type, dtype=dtype)\n    assert (yinv.dtype == '???')\n    if length:\n        assert (len(y_icqt) == len(yinv))\n    else:\n        yinv = librosa.util.fix_length(yinv, size=len(y_icqt))\n    y_icqt = y_icqt[(sr_icqt // 2):((- sr_icqt) // 2)]\n    yinv = yinv[(sr_icqt // 2):((- sr_icqt) // 2)]\n    residual = np.abs((y_icqt - yinv))\n    resnorm = np.sqrt(np.mean((residual ** 2)))\n    assert (resnorm <= 0.1), resnorm", "ground_truth": "dtype", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_9", "reponame": "librosa", "testpath": "tests/test_constantq.py", "testname": "test_constantq.py", "classname": null, "funcname": "test_icqt", "imports": ["from __future__ import division", "import warnings", "import os", "from typing import Optional", "import librosa", "import numpy as np", "import scipy.stats", "import pytest", "from test_core import srand"], "code": "@pytest.mark.parametrize('over_sample', [1, 3])\n@pytest.mark.parametrize('scale', [False, True])\n@pytest.mark.parametrize('hop_length', [384, 512])\n@pytest.mark.parametrize('length', [None, True])\n@pytest.mark.parametrize('res_type', ['soxr_hq', 'polyphase'])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\ndef test_icqt(y_icqt, sr_icqt, scale, hop_length, over_sample, length, res_type, dtype):\n    bins_per_octave = (over_sample * 12)\n    n_bins = (7 * bins_per_octave)\n    C = librosa.cqt(y_icqt, sr=sr_icqt, n_bins=n_bins, bins_per_octave=bins_per_octave, scale=scale, hop_length=hop_length)\n    if length:\n        _len = len(y_icqt)\n    else:\n        _len = None\n    yinv = librosa.icqt(C, sr=sr_icqt, scale=scale, hop_length=hop_length, bins_per_octave=bins_per_octave, length=_len, res_type=res_type, dtype=dtype)\n    assert (yinv.dtype == dtype)\n    if length:\n        assert (len(y_icqt) == len(yinv))\n    else:\n        yinv = librosa.util.fix_length(yinv, size=len(y_icqt))\n    y_icqt = y_icqt[(sr_icqt // 2):((- sr_icqt) // 2)]\n    yinv = yinv[(sr_icqt // 2):((- sr_icqt) // 2)]\n    residual = np.abs((y_icqt - yinv))\n    resnorm = np.sqrt(np.mean((residual ** 2)))\n    assert (resnorm <= 0.1), resnorm", "masked_code": "@pytest.mark.parametrize('over_sample', [1, 3])\n@pytest.mark.parametrize('scale', [False, True])\n@pytest.mark.parametrize('hop_length', [384, 512])\n@pytest.mark.parametrize('length', [None, True])\n@pytest.mark.parametrize('res_type', ['soxr_hq', 'polyphase'])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\ndef test_icqt(y_icqt, sr_icqt, scale, hop_length, over_sample, length, res_type, dtype):\n    bins_per_octave = (over_sample * 12)\n    n_bins = (7 * bins_per_octave)\n    C = librosa.cqt(y_icqt, sr=sr_icqt, n_bins=n_bins, bins_per_octave=bins_per_octave, scale=scale, hop_length=hop_length)\n    if length:\n        _len = len(y_icqt)\n    else:\n        _len = None\n    yinv = librosa.icqt(C, sr=sr_icqt, scale=scale, hop_length=hop_length, bins_per_octave=bins_per_octave, length=_len, res_type=res_type, dtype=dtype)\n    assert (yinv.dtype == dtype)\n    if length:\n        assert (len(y_icqt) == '???')\n    else:\n        yinv = librosa.util.fix_length(yinv, size=len(y_icqt))\n    y_icqt = y_icqt[(sr_icqt // 2):((- sr_icqt) // 2)]\n    yinv = yinv[(sr_icqt // 2):((- sr_icqt) // 2)]\n    residual = np.abs((y_icqt - yinv))\n    resnorm = np.sqrt(np.mean((residual ** 2)))\n    assert (resnorm <= 0.1), resnorm", "ground_truth": "len(yinv)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_10", "reponame": "librosa", "testpath": "tests/test_constantq.py", "testname": "test_constantq.py", "classname": null, "funcname": "test_griffinlim_cqt", "imports": ["from __future__ import division", "import warnings", "import os", "from typing import Optional", "import librosa", "import numpy as np", "import scipy.stats", "import pytest", "from test_core import srand"], "code": "@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('window', ['hann', 'hamming'])\n@pytest.mark.parametrize('use_length', [False, True])\n@pytest.mark.parametrize('over_sample', [1, 3])\n@pytest.mark.parametrize('res_type', ['polyphase'])\n@pytest.mark.parametrize('pad_mode', ['reflect'])\n@pytest.mark.parametrize('scale', [False, True])\n@pytest.mark.parametrize('momentum', [0.99])\n@pytest.mark.parametrize('random_state', [0])\n@pytest.mark.parametrize('fmin', [40.0])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('init', [None])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\ndef test_griffinlim_cqt(y_chirp, hop_length, window, use_length, over_sample, fmin, res_type, pad_mode, scale, momentum, init, random_state, dtype):\n    if use_length:\n        length = len(y_chirp)\n    else:\n        length = None\n    sr = 22050\n    bins_per_octave = (12 * over_sample)\n    n_bins = (6 * bins_per_octave)\n    C = librosa.cqt(y_chirp, sr=sr, hop_length=hop_length, window=window, fmin=fmin, bins_per_octave=bins_per_octave, n_bins=n_bins, scale=scale, pad_mode=pad_mode, res_type=res_type)\n    Cmag = np.abs(C)\n    y_rec = librosa.griffinlim_cqt(Cmag, hop_length=hop_length, window=window, sr=sr, fmin=fmin, bins_per_octave=bins_per_octave, scale=scale, pad_mode=pad_mode, n_iter=2, momentum=momentum, random_state=random_state, length=length, res_type=res_type, init=init, dtype=dtype)\n    y_inv = librosa.icqt(Cmag, sr=sr, fmin=fmin, hop_length=hop_length, window=window, bins_per_octave=bins_per_octave, scale=scale, length=length, res_type=res_type)\n    if use_length:\n        assert (len(y_rec) == length)\n    assert (y_rec.dtype == dtype)\n    assert np.all(np.isfinite(y_rec))", "masked_code": "@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('window', ['hann', 'hamming'])\n@pytest.mark.parametrize('use_length', [False, True])\n@pytest.mark.parametrize('over_sample', [1, 3])\n@pytest.mark.parametrize('res_type', ['polyphase'])\n@pytest.mark.parametrize('pad_mode', ['reflect'])\n@pytest.mark.parametrize('scale', [False, True])\n@pytest.mark.parametrize('momentum', [0.99])\n@pytest.mark.parametrize('random_state', [0])\n@pytest.mark.parametrize('fmin', [40.0])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('init', [None])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\ndef test_griffinlim_cqt(y_chirp, hop_length, window, use_length, over_sample, fmin, res_type, pad_mode, scale, momentum, init, random_state, dtype):\n    if use_length:\n        length = len(y_chirp)\n    else:\n        length = None\n    sr = 22050\n    bins_per_octave = (12 * over_sample)\n    n_bins = (6 * bins_per_octave)\n    C = librosa.cqt(y_chirp, sr=sr, hop_length=hop_length, window=window, fmin=fmin, bins_per_octave=bins_per_octave, n_bins=n_bins, scale=scale, pad_mode=pad_mode, res_type=res_type)\n    Cmag = np.abs(C)\n    y_rec = librosa.griffinlim_cqt(Cmag, hop_length=hop_length, window=window, sr=sr, fmin=fmin, bins_per_octave=bins_per_octave, scale=scale, pad_mode=pad_mode, n_iter=2, momentum=momentum, random_state=random_state, length=length, res_type=res_type, init=init, dtype=dtype)\n    y_inv = librosa.icqt(Cmag, sr=sr, fmin=fmin, hop_length=hop_length, window=window, bins_per_octave=bins_per_octave, scale=scale, length=length, res_type=res_type)\n    if use_length:\n        assert (len(y_rec) == length)\n    assert (y_rec.dtype == '???')\n    assert np.all(np.isfinite(y_rec))", "ground_truth": "dtype", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_11", "reponame": "librosa", "testpath": "tests/test_constantq.py", "testname": "test_constantq.py", "classname": null, "funcname": "test_griffinlim_cqt", "imports": ["from __future__ import division", "import warnings", "import os", "from typing import Optional", "import librosa", "import numpy as np", "import scipy.stats", "import pytest", "from test_core import srand"], "code": "@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('window', ['hann', 'hamming'])\n@pytest.mark.parametrize('use_length', [False, True])\n@pytest.mark.parametrize('over_sample', [1, 3])\n@pytest.mark.parametrize('res_type', ['polyphase'])\n@pytest.mark.parametrize('pad_mode', ['reflect'])\n@pytest.mark.parametrize('scale', [False, True])\n@pytest.mark.parametrize('momentum', [0.99])\n@pytest.mark.parametrize('random_state', [0])\n@pytest.mark.parametrize('fmin', [40.0])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('init', [None])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\ndef test_griffinlim_cqt(y_chirp, hop_length, window, use_length, over_sample, fmin, res_type, pad_mode, scale, momentum, init, random_state, dtype):\n    if use_length:\n        length = len(y_chirp)\n    else:\n        length = None\n    sr = 22050\n    bins_per_octave = (12 * over_sample)\n    n_bins = (6 * bins_per_octave)\n    C = librosa.cqt(y_chirp, sr=sr, hop_length=hop_length, window=window, fmin=fmin, bins_per_octave=bins_per_octave, n_bins=n_bins, scale=scale, pad_mode=pad_mode, res_type=res_type)\n    Cmag = np.abs(C)\n    y_rec = librosa.griffinlim_cqt(Cmag, hop_length=hop_length, window=window, sr=sr, fmin=fmin, bins_per_octave=bins_per_octave, scale=scale, pad_mode=pad_mode, n_iter=2, momentum=momentum, random_state=random_state, length=length, res_type=res_type, init=init, dtype=dtype)\n    y_inv = librosa.icqt(Cmag, sr=sr, fmin=fmin, hop_length=hop_length, window=window, bins_per_octave=bins_per_octave, scale=scale, length=length, res_type=res_type)\n    if use_length:\n        assert (len(y_rec) == length)\n    assert (y_rec.dtype == dtype)\n    assert np.all(np.isfinite(y_rec))", "masked_code": "@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('window', ['hann', 'hamming'])\n@pytest.mark.parametrize('use_length', [False, True])\n@pytest.mark.parametrize('over_sample', [1, 3])\n@pytest.mark.parametrize('res_type', ['polyphase'])\n@pytest.mark.parametrize('pad_mode', ['reflect'])\n@pytest.mark.parametrize('scale', [False, True])\n@pytest.mark.parametrize('momentum', [0.99])\n@pytest.mark.parametrize('random_state', [0])\n@pytest.mark.parametrize('fmin', [40.0])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('init', [None])\n@pytest.mark.filterwarnings('ignore:n_fft=.*is too large')\ndef test_griffinlim_cqt(y_chirp, hop_length, window, use_length, over_sample, fmin, res_type, pad_mode, scale, momentum, init, random_state, dtype):\n    if use_length:\n        length = len(y_chirp)\n    else:\n        length = None\n    sr = 22050\n    bins_per_octave = (12 * over_sample)\n    n_bins = (6 * bins_per_octave)\n    C = librosa.cqt(y_chirp, sr=sr, hop_length=hop_length, window=window, fmin=fmin, bins_per_octave=bins_per_octave, n_bins=n_bins, scale=scale, pad_mode=pad_mode, res_type=res_type)\n    Cmag = np.abs(C)\n    y_rec = librosa.griffinlim_cqt(Cmag, hop_length=hop_length, window=window, sr=sr, fmin=fmin, bins_per_octave=bins_per_octave, scale=scale, pad_mode=pad_mode, n_iter=2, momentum=momentum, random_state=random_state, length=length, res_type=res_type, init=init, dtype=dtype)\n    y_inv = librosa.icqt(Cmag, sr=sr, fmin=fmin, hop_length=hop_length, window=window, bins_per_octave=bins_per_octave, scale=scale, length=length, res_type=res_type)\n    if use_length:\n        assert (len(y_rec) == '???')\n    assert (y_rec.dtype == dtype)\n    assert np.all(np.isfinite(y_rec))", "ground_truth": "length", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_12", "reponame": "librosa", "testpath": "tests/test_constantq.py", "testname": "test_constantq.py", "classname": null, "funcname": "test_cqt_precision", "imports": ["from __future__ import division", "import warnings", "import os", "from typing import Optional", "import librosa", "import numpy as np", "import scipy.stats", "import pytest", "from test_core import srand"], "code": "@pytest.mark.parametrize('dtype', [np.complex64, np.complex128])\ndef test_cqt_precision(y_cqt, sr_cqt, dtype):\n    C = librosa.cqt(y=y_cqt, sr=sr_cqt, dtype=dtype)\n    assert (np.dtype(C.dtype) == np.dtype(dtype))", "masked_code": "@pytest.mark.parametrize('dtype', [np.complex64, np.complex128])\ndef test_cqt_precision(y_cqt, sr_cqt, dtype):\n    C = librosa.cqt(y=y_cqt, sr=sr_cqt, dtype=dtype)\n    assert (np.dtype(C.dtype) == '???')", "ground_truth": "np.dtype(dtype)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_13", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_frames_to_samples", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('frames', [100, np.arange(10.0), np.ones((3, 3))], ids=['0d', '1d', '2d'])\n@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('n_fft', [None, 1024])\ndef test_frames_to_samples(frames, hop_length, n_fft):\n    samples = librosa.frames_to_samples(frames, hop_length=hop_length, n_fft=n_fft)\n    frames = np.asanyarray(frames)\n    assert (frames.shape == samples.shape)\n    assert (frames.ndim == samples.ndim)\n    if (n_fft is None):\n        assert np.allclose(samples, (frames * hop_length))\n    else:\n        assert np.allclose(((samples - (n_fft // 2)) // hop_length), frames)", "masked_code": "@pytest.mark.parametrize('frames', [100, np.arange(10.0), np.ones((3, 3))], ids=['0d', '1d', '2d'])\n@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('n_fft', [None, 1024])\ndef test_frames_to_samples(frames, hop_length, n_fft):\n    samples = librosa.frames_to_samples(frames, hop_length=hop_length, n_fft=n_fft)\n    frames = np.asanyarray(frames)\n    assert (frames.shape == '???')\n    assert (frames.ndim == samples.ndim)\n    if (n_fft is None):\n        assert np.allclose(samples, (frames * hop_length))\n    else:\n        assert np.allclose(((samples - (n_fft // 2)) // hop_length), frames)", "ground_truth": "samples.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_14", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_frames_to_samples", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('frames', [100, np.arange(10.0), np.ones((3, 3))], ids=['0d', '1d', '2d'])\n@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('n_fft', [None, 1024])\ndef test_frames_to_samples(frames, hop_length, n_fft):\n    samples = librosa.frames_to_samples(frames, hop_length=hop_length, n_fft=n_fft)\n    frames = np.asanyarray(frames)\n    assert (frames.shape == samples.shape)\n    assert (frames.ndim == samples.ndim)\n    if (n_fft is None):\n        assert np.allclose(samples, (frames * hop_length))\n    else:\n        assert np.allclose(((samples - (n_fft // 2)) // hop_length), frames)", "masked_code": "@pytest.mark.parametrize('frames', [100, np.arange(10.0), np.ones((3, 3))], ids=['0d', '1d', '2d'])\n@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('n_fft', [None, 1024])\ndef test_frames_to_samples(frames, hop_length, n_fft):\n    samples = librosa.frames_to_samples(frames, hop_length=hop_length, n_fft=n_fft)\n    frames = np.asanyarray(frames)\n    assert (frames.shape == samples.shape)\n    assert (frames.ndim == '???')\n    if (n_fft is None):\n        assert np.allclose(samples, (frames * hop_length))\n    else:\n        assert np.allclose(((samples - (n_fft // 2)) // hop_length), frames)", "ground_truth": "samples.ndim", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_15", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_samples_to_frames", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('samples', [(1024 * 100), (1024 * np.arange(10.0)), (1024 * np.ones((3, 3)))], ids=['0d', '1d', '2d'])\n@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('n_fft', [None, 1024])\ndef test_samples_to_frames(samples, hop_length, n_fft):\n    frames = librosa.samples_to_frames(samples, hop_length=hop_length, n_fft=n_fft)\n    samples = np.asanyarray(samples)\n    assert (frames.shape == samples.shape)\n    assert (frames.ndim == samples.ndim)\n    if (n_fft is None):\n        assert np.allclose(samples, (frames * hop_length))\n    else:\n        assert np.allclose(((samples - (n_fft // 2)) // hop_length), frames)", "masked_code": "@pytest.mark.parametrize('samples', [(1024 * 100), (1024 * np.arange(10.0)), (1024 * np.ones((3, 3)))], ids=['0d', '1d', '2d'])\n@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('n_fft', [None, 1024])\ndef test_samples_to_frames(samples, hop_length, n_fft):\n    frames = librosa.samples_to_frames(samples, hop_length=hop_length, n_fft=n_fft)\n    samples = np.asanyarray(samples)\n    assert (frames.shape == '???')\n    assert (frames.ndim == samples.ndim)\n    if (n_fft is None):\n        assert np.allclose(samples, (frames * hop_length))\n    else:\n        assert np.allclose(((samples - (n_fft // 2)) // hop_length), frames)", "ground_truth": "samples.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_16", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_samples_to_frames", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('samples', [(1024 * 100), (1024 * np.arange(10.0)), (1024 * np.ones((3, 3)))], ids=['0d', '1d', '2d'])\n@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('n_fft', [None, 1024])\ndef test_samples_to_frames(samples, hop_length, n_fft):\n    frames = librosa.samples_to_frames(samples, hop_length=hop_length, n_fft=n_fft)\n    samples = np.asanyarray(samples)\n    assert (frames.shape == samples.shape)\n    assert (frames.ndim == samples.ndim)\n    if (n_fft is None):\n        assert np.allclose(samples, (frames * hop_length))\n    else:\n        assert np.allclose(((samples - (n_fft // 2)) // hop_length), frames)", "masked_code": "@pytest.mark.parametrize('samples', [(1024 * 100), (1024 * np.arange(10.0)), (1024 * np.ones((3, 3)))], ids=['0d', '1d', '2d'])\n@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('n_fft', [None, 1024])\ndef test_samples_to_frames(samples, hop_length, n_fft):\n    frames = librosa.samples_to_frames(samples, hop_length=hop_length, n_fft=n_fft)\n    samples = np.asanyarray(samples)\n    assert (frames.shape == samples.shape)\n    assert (frames.ndim == '???')\n    if (n_fft is None):\n        assert np.allclose(samples, (frames * hop_length))\n    else:\n        assert np.allclose(((samples - (n_fft // 2)) // hop_length), frames)", "ground_truth": "samples.ndim", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_17", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_note_to_midi", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('tuning,octave', [(None, None), (None, 1), (None, 2), (None, 3), ((- 25), 1), ((- 25), 2), ((- 25), 3), (0, 1), (0, 2), (0, 3)])\n@pytest.mark.parametrize('accidental', ['', '#', 'b', '!'])\n@pytest.mark.parametrize('round_midi', [False, True])\ndef test_note_to_midi(tuning, accidental, octave, round_midi: bool):\n    note = 'C{:s}'.format(accidental)\n    if (octave is not None):\n        note = '{:s}{:d}'.format(note, octave)\n    else:\n        octave = 0\n    if (tuning is not None):\n        note = '{:s}{:+d}'.format(note, tuning)\n    else:\n        tuning = 0\n    midi_true = ((12 * (octave + 1)) + (tuning * 0.01))\n    if (accidental == '#'):\n        midi_true += 1\n    elif (accidental in list('b!')):\n        midi_true -= 1\n    midi = librosa.note_to_midi(note, round_midi=round_midi)\n    if round_midi:\n        midi_true = np.round(midi_true)\n    assert (midi == midi_true)\n    midi = librosa.note_to_midi([note], round_midi=round_midi)\n    assert (midi[0] == midi_true)", "masked_code": "@pytest.mark.parametrize('tuning,octave', [(None, None), (None, 1), (None, 2), (None, 3), ((- 25), 1), ((- 25), 2), ((- 25), 3), (0, 1), (0, 2), (0, 3)])\n@pytest.mark.parametrize('accidental', ['', '#', 'b', '!'])\n@pytest.mark.parametrize('round_midi', [False, True])\ndef test_note_to_midi(tuning, accidental, octave, round_midi: bool):\n    note = 'C{:s}'.format(accidental)\n    if (octave is not None):\n        note = '{:s}{:d}'.format(note, octave)\n    else:\n        octave = 0\n    if (tuning is not None):\n        note = '{:s}{:+d}'.format(note, tuning)\n    else:\n        tuning = 0\n    midi_true = ((12 * (octave + 1)) + (tuning * 0.01))\n    if (accidental == '#'):\n        midi_true += 1\n    elif (accidental in list('b!')):\n        midi_true -= 1\n    midi = librosa.note_to_midi(note, round_midi=round_midi)\n    if round_midi:\n        midi_true = np.round(midi_true)\n    assert (midi == midi_true)\n    midi = librosa.note_to_midi([note], round_midi=round_midi)\n    assert (midi[0] == '???')", "ground_truth": "midi_true", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_18", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_fft_frequencies", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('sr', [8000, 22050])\n@pytest.mark.parametrize('n_fft', [1024, 2048])\ndef test_fft_frequencies(sr, n_fft):\n    freqs = librosa.fft_frequencies(sr=sr, n_fft=n_fft)\n    assert (freqs[0] == 0)\n    assert (freqs[(- 1)] == (sr / 2.0))\n    dels = np.diff(freqs)\n    assert np.allclose(dels, dels[0])", "masked_code": "@pytest.mark.parametrize('sr', [8000, 22050])\n@pytest.mark.parametrize('n_fft', [1024, 2048])\ndef test_fft_frequencies(sr, n_fft):\n    freqs = librosa.fft_frequencies(sr=sr, n_fft=n_fft)\n    assert (freqs[0] == 0)\n    assert (freqs[(- 1)] == '???')\n    dels = np.diff(freqs)\n    assert np.allclose(dels, dels[0])", "ground_truth": "(sr / 2.0)", "quality_analysis": {"complexity_score": 11, "left_complexity": 7, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_19", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_cqt_frequencies", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('n_bins', [12, 24, 36])\n@pytest.mark.parametrize('fmin', [440.0])\n@pytest.mark.parametrize('bins_per_octave', [12, 24, 36])\n@pytest.mark.parametrize('tuning', [(- 0.25), 0.0, 0.25])\ndef test_cqt_frequencies(n_bins, fmin, bins_per_octave, tuning):\n    freqs = librosa.cqt_frequencies(n_bins, fmin=fmin, bins_per_octave=bins_per_octave, tuning=tuning)\n    assert (len(freqs) == n_bins)\n    assert np.allclose(freqs[0], (fmin * (2.0 ** (float(tuning) / bins_per_octave))))\n    Q = np.diff(np.log2(freqs))\n    assert np.allclose(Q, (1.0 / bins_per_octave))", "masked_code": "@pytest.mark.parametrize('n_bins', [12, 24, 36])\n@pytest.mark.parametrize('fmin', [440.0])\n@pytest.mark.parametrize('bins_per_octave', [12, 24, 36])\n@pytest.mark.parametrize('tuning', [(- 0.25), 0.0, 0.25])\ndef test_cqt_frequencies(n_bins, fmin, bins_per_octave, tuning):\n    freqs = librosa.cqt_frequencies(n_bins, fmin=fmin, bins_per_octave=bins_per_octave, tuning=tuning)\n    assert (len(freqs) == '???')\n    assert np.allclose(freqs[0], (fmin * (2.0 ** (float(tuning) / bins_per_octave))))\n    Q = np.diff(np.log2(freqs))\n    assert np.allclose(Q, (1.0 / bins_per_octave))", "ground_truth": "n_bins", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_20", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_tempo_frequencies", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('n_bins', [1, 16, 128])\n@pytest.mark.parametrize('hop_length', [256, 512])\n@pytest.mark.parametrize('sr', [11025, 22050])\ndef test_tempo_frequencies(n_bins, hop_length, sr):\n    freqs = librosa.tempo_frequencies(n_bins, hop_length=hop_length, sr=sr)\n    assert (len(freqs) == n_bins)\n    assert (not np.isfinite(freqs[0]))\n    if (n_bins > 1):\n        invdiff = ((freqs[1:] ** (- 1)) * (60.0 * sr))\n        assert np.allclose(invdiff[0], hop_length)\n        assert np.allclose(np.diff(invdiff), np.asarray(hop_length)), np.diff(invdiff)", "masked_code": "@pytest.mark.parametrize('n_bins', [1, 16, 128])\n@pytest.mark.parametrize('hop_length', [256, 512])\n@pytest.mark.parametrize('sr', [11025, 22050])\ndef test_tempo_frequencies(n_bins, hop_length, sr):\n    freqs = librosa.tempo_frequencies(n_bins, hop_length=hop_length, sr=sr)\n    assert (len(freqs) == '???')\n    assert (not np.isfinite(freqs[0]))\n    if (n_bins > 1):\n        invdiff = ((freqs[1:] ** (- 1)) * (60.0 * sr))\n        assert np.allclose(invdiff[0], hop_length)\n        assert np.allclose(np.diff(invdiff), np.asarray(hop_length)), np.diff(invdiff)", "ground_truth": "n_bins", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_21", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_fourier_tempo_frequencies", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('sr', [8000, 22050])\n@pytest.mark.parametrize('hop_length', [256, 512])\n@pytest.mark.parametrize('win_length', [192, 384])\ndef test_fourier_tempo_frequencies(sr, hop_length, win_length):\n    freqs = librosa.fourier_tempo_frequencies(sr=sr, hop_length=hop_length, win_length=win_length)\n    assert (freqs[0] == 0)\n    assert (freqs[(- 1)] == (((sr * 60) / 2.0) / hop_length))\n    dels = np.diff(freqs)\n    assert np.allclose(dels, dels[0])", "masked_code": "@pytest.mark.parametrize('sr', [8000, 22050])\n@pytest.mark.parametrize('hop_length', [256, 512])\n@pytest.mark.parametrize('win_length', [192, 384])\ndef test_fourier_tempo_frequencies(sr, hop_length, win_length):\n    freqs = librosa.fourier_tempo_frequencies(sr=sr, hop_length=hop_length, win_length=win_length)\n    assert (freqs[0] == 0)\n    assert (freqs[(- 1)] == '???')\n    dels = np.diff(freqs)\n    assert np.allclose(dels, dels[0])", "ground_truth": "(((sr * 60) / 2.0) / hop_length)", "quality_analysis": {"complexity_score": 17, "left_complexity": 7, "right_complexity": 10, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_22", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_blocks_to_frames", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('blocks', [0, 1, [10, 20]])\n@pytest.mark.parametrize('block_length', [1, 4, 8])\ndef test_blocks_to_frames(blocks, block_length):\n    frames = librosa.blocks_to_frames(blocks, block_length=block_length)\n    assert (frames.ndim == np.asarray(blocks).ndim)\n    assert (frames.size == np.asarray(blocks).size)\n    assert np.allclose(frames, (block_length * np.asanyarray(blocks)))\n    assert np.issubdtype(frames.dtype, int)", "masked_code": "@pytest.mark.parametrize('blocks', [0, 1, [10, 20]])\n@pytest.mark.parametrize('block_length', [1, 4, 8])\ndef test_blocks_to_frames(blocks, block_length):\n    frames = librosa.blocks_to_frames(blocks, block_length=block_length)\n    assert (frames.ndim == '???')\n    assert (frames.size == np.asarray(blocks).size)\n    assert np.allclose(frames, (block_length * np.asanyarray(blocks)))\n    assert np.issubdtype(frames.dtype, int)", "ground_truth": "np.asarray(blocks).ndim", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_23", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_blocks_to_frames", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('blocks', [0, 1, [10, 20]])\n@pytest.mark.parametrize('block_length', [1, 4, 8])\ndef test_blocks_to_frames(blocks, block_length):\n    frames = librosa.blocks_to_frames(blocks, block_length=block_length)\n    assert (frames.ndim == np.asarray(blocks).ndim)\n    assert (frames.size == np.asarray(blocks).size)\n    assert np.allclose(frames, (block_length * np.asanyarray(blocks)))\n    assert np.issubdtype(frames.dtype, int)", "masked_code": "@pytest.mark.parametrize('blocks', [0, 1, [10, 20]])\n@pytest.mark.parametrize('block_length', [1, 4, 8])\ndef test_blocks_to_frames(blocks, block_length):\n    frames = librosa.blocks_to_frames(blocks, block_length=block_length)\n    assert (frames.ndim == np.asarray(blocks).ndim)\n    assert (frames.size == '???')\n    assert np.allclose(frames, (block_length * np.asanyarray(blocks)))\n    assert np.issubdtype(frames.dtype, int)", "ground_truth": "np.asarray(blocks).size", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_24", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_blocks_to_samples", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('blocks', [0, 1, [10, 20]])\n@pytest.mark.parametrize('block_length', [1, 4, 8])\n@pytest.mark.parametrize('hop_length', [1, 512])\ndef test_blocks_to_samples(blocks, block_length, hop_length):\n    samples = librosa.blocks_to_samples(blocks, block_length=block_length, hop_length=hop_length)\n    assert (samples.ndim == np.asarray(blocks).ndim)\n    assert (samples.size == np.asarray(blocks).size)\n    assert np.allclose(samples, ((np.asanyarray(blocks) * hop_length) * block_length))\n    assert np.issubdtype(samples.dtype, int)", "masked_code": "@pytest.mark.parametrize('blocks', [0, 1, [10, 20]])\n@pytest.mark.parametrize('block_length', [1, 4, 8])\n@pytest.mark.parametrize('hop_length', [1, 512])\ndef test_blocks_to_samples(blocks, block_length, hop_length):\n    samples = librosa.blocks_to_samples(blocks, block_length=block_length, hop_length=hop_length)\n    assert (samples.ndim == '???')\n    assert (samples.size == np.asarray(blocks).size)\n    assert np.allclose(samples, ((np.asanyarray(blocks) * hop_length) * block_length))\n    assert np.issubdtype(samples.dtype, int)", "ground_truth": "np.asarray(blocks).ndim", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_25", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_blocks_to_samples", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('blocks', [0, 1, [10, 20]])\n@pytest.mark.parametrize('block_length', [1, 4, 8])\n@pytest.mark.parametrize('hop_length', [1, 512])\ndef test_blocks_to_samples(blocks, block_length, hop_length):\n    samples = librosa.blocks_to_samples(blocks, block_length=block_length, hop_length=hop_length)\n    assert (samples.ndim == np.asarray(blocks).ndim)\n    assert (samples.size == np.asarray(blocks).size)\n    assert np.allclose(samples, ((np.asanyarray(blocks) * hop_length) * block_length))\n    assert np.issubdtype(samples.dtype, int)", "masked_code": "@pytest.mark.parametrize('blocks', [0, 1, [10, 20]])\n@pytest.mark.parametrize('block_length', [1, 4, 8])\n@pytest.mark.parametrize('hop_length', [1, 512])\ndef test_blocks_to_samples(blocks, block_length, hop_length):\n    samples = librosa.blocks_to_samples(blocks, block_length=block_length, hop_length=hop_length)\n    assert (samples.ndim == np.asarray(blocks).ndim)\n    assert (samples.size == '???')\n    assert np.allclose(samples, ((np.asanyarray(blocks) * hop_length) * block_length))\n    assert np.issubdtype(samples.dtype, int)", "ground_truth": "np.asarray(blocks).size", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_26", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_blocks_to_time", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('blocks', [0, 1, [10, 20]])\n@pytest.mark.parametrize('block_length', [1, 4, 8])\n@pytest.mark.parametrize('hop_length', [1, 512])\n@pytest.mark.parametrize('sr', [22050, 44100])\ndef test_blocks_to_time(blocks, block_length, hop_length, sr):\n    times = librosa.blocks_to_time(blocks, block_length=block_length, hop_length=hop_length, sr=sr)\n    assert (times.ndim == np.asarray(blocks).ndim)\n    assert (times.size == np.asarray(blocks).size)\n    assert np.allclose(times, (((np.asanyarray(blocks) * hop_length) * block_length) / float(sr)))\n    assert np.issubdtype(times.dtype, float)", "masked_code": "@pytest.mark.parametrize('blocks', [0, 1, [10, 20]])\n@pytest.mark.parametrize('block_length', [1, 4, 8])\n@pytest.mark.parametrize('hop_length', [1, 512])\n@pytest.mark.parametrize('sr', [22050, 44100])\ndef test_blocks_to_time(blocks, block_length, hop_length, sr):\n    times = librosa.blocks_to_time(blocks, block_length=block_length, hop_length=hop_length, sr=sr)\n    assert (times.ndim == '???')\n    assert (times.size == np.asarray(blocks).size)\n    assert np.allclose(times, (((np.asanyarray(blocks) * hop_length) * block_length) / float(sr)))\n    assert np.issubdtype(times.dtype, float)", "ground_truth": "np.asarray(blocks).ndim", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_27", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_blocks_to_time", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('blocks', [0, 1, [10, 20]])\n@pytest.mark.parametrize('block_length', [1, 4, 8])\n@pytest.mark.parametrize('hop_length', [1, 512])\n@pytest.mark.parametrize('sr', [22050, 44100])\ndef test_blocks_to_time(blocks, block_length, hop_length, sr):\n    times = librosa.blocks_to_time(blocks, block_length=block_length, hop_length=hop_length, sr=sr)\n    assert (times.ndim == np.asarray(blocks).ndim)\n    assert (times.size == np.asarray(blocks).size)\n    assert np.allclose(times, (((np.asanyarray(blocks) * hop_length) * block_length) / float(sr)))\n    assert np.issubdtype(times.dtype, float)", "masked_code": "@pytest.mark.parametrize('blocks', [0, 1, [10, 20]])\n@pytest.mark.parametrize('block_length', [1, 4, 8])\n@pytest.mark.parametrize('hop_length', [1, 512])\n@pytest.mark.parametrize('sr', [22050, 44100])\ndef test_blocks_to_time(blocks, block_length, hop_length, sr):\n    times = librosa.blocks_to_time(blocks, block_length=block_length, hop_length=hop_length, sr=sr)\n    assert (times.ndim == np.asarray(blocks).ndim)\n    assert (times.size == '???')\n    assert np.allclose(times, (((np.asanyarray(blocks) * hop_length) * block_length) / float(sr)))\n    assert np.issubdtype(times.dtype, float)", "ground_truth": "np.asarray(blocks).size", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_28", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_midi_to_svara_h", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('abbr', [False, True])\n@pytest.mark.parametrize('octave', [False, True])\n@pytest.mark.parametrize('unicode', [False, True])\n@pytest.mark.parametrize('midi', [list(range(36))])\n@pytest.mark.parametrize('Sa', [12])\ndef test_midi_to_svara_h(midi, Sa, abbr, octave, unicode):\n    svara = librosa.midi_to_svara_h(midi, Sa=Sa, abbr=abbr, octave=octave, unicode=unicode)\n    svara = np.asarray(svara)\n    assert (len(svara) == len(midi))\n    if abbr:\n        assert (svara[Sa] == 'S')\n    else:\n        assert (svara[Sa] == 'Sa')\n    if (sys.version >= '3.7'):\n        if (not unicode):\n            for s in svara:\n                assert s.isascii()\n    if (not abbr):\n        for s in svara:\n            assert (0 < len(s) < 5)\n    else:\n        for s in svara:\n            assert (0 < len(s) < 3)\n    if octave:\n        assert (not np.all((svara[:12] == svara[12:24])))\n        assert (not np.all((svara[12:24] == svara[24:])))\n    else:\n        assert np.all((svara[:12] == svara[12:24]))\n        assert np.all((svara[:12] == svara[24:]))", "masked_code": "@pytest.mark.parametrize('abbr', [False, True])\n@pytest.mark.parametrize('octave', [False, True])\n@pytest.mark.parametrize('unicode', [False, True])\n@pytest.mark.parametrize('midi', [list(range(36))])\n@pytest.mark.parametrize('Sa', [12])\ndef test_midi_to_svara_h(midi, Sa, abbr, octave, unicode):\n    svara = librosa.midi_to_svara_h(midi, Sa=Sa, abbr=abbr, octave=octave, unicode=unicode)\n    svara = np.asarray(svara)\n    assert (len(svara) == '???')\n    if abbr:\n        assert (svara[Sa] == 'S')\n    else:\n        assert (svara[Sa] == 'Sa')\n    if (sys.version >= '3.7'):\n        if (not unicode):\n            for s in svara:\n                assert s.isascii()\n    if (not abbr):\n        for s in svara:\n            assert (0 < len(s) < 5)\n    else:\n        for s in svara:\n            assert (0 < len(s) < 3)\n    if octave:\n        assert (not np.all((svara[:12] == svara[12:24])))\n        assert (not np.all((svara[12:24] == svara[24:])))\n    else:\n        assert np.all((svara[:12] == svara[12:24]))\n        assert np.all((svara[:12] == svara[24:]))", "ground_truth": "len(midi)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_29", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_midi_to_svara_h", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('abbr', [False, True])\n@pytest.mark.parametrize('octave', [False, True])\n@pytest.mark.parametrize('unicode', [False, True])\n@pytest.mark.parametrize('midi', [list(range(36))])\n@pytest.mark.parametrize('Sa', [12])\ndef test_midi_to_svara_h(midi, Sa, abbr, octave, unicode):\n    svara = librosa.midi_to_svara_h(midi, Sa=Sa, abbr=abbr, octave=octave, unicode=unicode)\n    svara = np.asarray(svara)\n    assert (len(svara) == len(midi))\n    if abbr:\n        assert (svara[Sa] == 'S')\n    else:\n        assert (svara[Sa] == 'Sa')\n    if (sys.version >= '3.7'):\n        if (not unicode):\n            for s in svara:\n                assert s.isascii()\n    if (not abbr):\n        for s in svara:\n            assert (0 < len(s) < 5)\n    else:\n        for s in svara:\n            assert (0 < len(s) < 3)\n    if octave:\n        assert (not np.all((svara[:12] == svara[12:24])))\n        assert (not np.all((svara[12:24] == svara[24:])))\n    else:\n        assert np.all((svara[:12] == svara[12:24]))\n        assert np.all((svara[:12] == svara[24:]))", "masked_code": "@pytest.mark.parametrize('abbr', [False, True])\n@pytest.mark.parametrize('octave', [False, True])\n@pytest.mark.parametrize('unicode', [False, True])\n@pytest.mark.parametrize('midi', [list(range(36))])\n@pytest.mark.parametrize('Sa', [12])\ndef test_midi_to_svara_h(midi, Sa, abbr, octave, unicode):\n    svara = librosa.midi_to_svara_h(midi, Sa=Sa, abbr=abbr, octave=octave, unicode=unicode)\n    svara = np.asarray(svara)\n    assert (len(svara) == len(midi))\n    if abbr:\n        assert (svara[Sa] == 'S')\n    else:\n        assert (svara[Sa] == '???')\n    if (sys.version >= '3.7'):\n        if (not unicode):\n            for s in svara:\n                assert s.isascii()\n    if (not abbr):\n        for s in svara:\n            assert (0 < len(s) < 5)\n    else:\n        for s in svara:\n            assert (0 < len(s) < 3)\n    if octave:\n        assert (not np.all((svara[:12] == svara[12:24])))\n        assert (not np.all((svara[12:24] == svara[24:])))\n    else:\n        assert np.all((svara[:12] == svara[12:24]))\n        assert np.all((svara[:12] == svara[24:]))", "ground_truth": "'Sa'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_30", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_midi_to_svara_c", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('abbr', [False, True])\n@pytest.mark.parametrize('octave', [False, True])\n@pytest.mark.parametrize('unicode', [False, True])\n@pytest.mark.parametrize('midi', [list(range(36))])\n@pytest.mark.parametrize('Sa', [12])\n@pytest.mark.parametrize('mela', range(1, 72, 7))\ndef test_midi_to_svara_c(midi, Sa, mela, abbr, octave, unicode):\n    svara = librosa.midi_to_svara_c(midi, Sa=Sa, mela=mela, abbr=abbr, octave=octave, unicode=unicode)\n    svara = np.asarray(svara)\n    assert (len(svara) == len(midi))\n    if abbr:\n        assert (svara[Sa] == 'S')\n    else:\n        assert (svara[Sa] == 'Sa')\n    if (sys.version >= '3.7'):\n        if (not unicode):\n            for s in svara:\n                assert s.isascii()\n    if (not abbr):\n        for s in svara:\n            assert (0 < len(s) < 6)\n    else:\n        for s in svara:\n            assert (0 < len(s) < 4)\n    if octave:\n        assert (not np.all((svara[:12] == svara[12:24])))\n        assert (not np.all((svara[12:24] == svara[24:])))\n    else:\n        assert np.all((svara[:12] == svara[12:24]))\n        assert np.all((svara[:12] == svara[24:]))", "masked_code": "@pytest.mark.parametrize('abbr', [False, True])\n@pytest.mark.parametrize('octave', [False, True])\n@pytest.mark.parametrize('unicode', [False, True])\n@pytest.mark.parametrize('midi', [list(range(36))])\n@pytest.mark.parametrize('Sa', [12])\n@pytest.mark.parametrize('mela', range(1, 72, 7))\ndef test_midi_to_svara_c(midi, Sa, mela, abbr, octave, unicode):\n    svara = librosa.midi_to_svara_c(midi, Sa=Sa, mela=mela, abbr=abbr, octave=octave, unicode=unicode)\n    svara = np.asarray(svara)\n    assert (len(svara) == '???')\n    if abbr:\n        assert (svara[Sa] == 'S')\n    else:\n        assert (svara[Sa] == 'Sa')\n    if (sys.version >= '3.7'):\n        if (not unicode):\n            for s in svara:\n                assert s.isascii()\n    if (not abbr):\n        for s in svara:\n            assert (0 < len(s) < 6)\n    else:\n        for s in svara:\n            assert (0 < len(s) < 4)\n    if octave:\n        assert (not np.all((svara[:12] == svara[12:24])))\n        assert (not np.all((svara[12:24] == svara[24:])))\n    else:\n        assert np.all((svara[:12] == svara[12:24]))\n        assert np.all((svara[:12] == svara[24:]))", "ground_truth": "len(midi)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_31", "reponame": "librosa", "testpath": "tests/test_convert.py", "testname": "test_convert.py", "classname": null, "funcname": "test_midi_to_svara_c", "imports": ["import os", "import sys", "import warnings", "import librosa", "import numpy as np", "import pytest"], "code": "@pytest.mark.parametrize('abbr', [False, True])\n@pytest.mark.parametrize('octave', [False, True])\n@pytest.mark.parametrize('unicode', [False, True])\n@pytest.mark.parametrize('midi', [list(range(36))])\n@pytest.mark.parametrize('Sa', [12])\n@pytest.mark.parametrize('mela', range(1, 72, 7))\ndef test_midi_to_svara_c(midi, Sa, mela, abbr, octave, unicode):\n    svara = librosa.midi_to_svara_c(midi, Sa=Sa, mela=mela, abbr=abbr, octave=octave, unicode=unicode)\n    svara = np.asarray(svara)\n    assert (len(svara) == len(midi))\n    if abbr:\n        assert (svara[Sa] == 'S')\n    else:\n        assert (svara[Sa] == 'Sa')\n    if (sys.version >= '3.7'):\n        if (not unicode):\n            for s in svara:\n                assert s.isascii()\n    if (not abbr):\n        for s in svara:\n            assert (0 < len(s) < 6)\n    else:\n        for s in svara:\n            assert (0 < len(s) < 4)\n    if octave:\n        assert (not np.all((svara[:12] == svara[12:24])))\n        assert (not np.all((svara[12:24] == svara[24:])))\n    else:\n        assert np.all((svara[:12] == svara[12:24]))\n        assert np.all((svara[:12] == svara[24:]))", "masked_code": "@pytest.mark.parametrize('abbr', [False, True])\n@pytest.mark.parametrize('octave', [False, True])\n@pytest.mark.parametrize('unicode', [False, True])\n@pytest.mark.parametrize('midi', [list(range(36))])\n@pytest.mark.parametrize('Sa', [12])\n@pytest.mark.parametrize('mela', range(1, 72, 7))\ndef test_midi_to_svara_c(midi, Sa, mela, abbr, octave, unicode):\n    svara = librosa.midi_to_svara_c(midi, Sa=Sa, mela=mela, abbr=abbr, octave=octave, unicode=unicode)\n    svara = np.asarray(svara)\n    assert (len(svara) == len(midi))\n    if abbr:\n        assert (svara[Sa] == 'S')\n    else:\n        assert (svara[Sa] == '???')\n    if (sys.version >= '3.7'):\n        if (not unicode):\n            for s in svara:\n                assert s.isascii()\n    if (not abbr):\n        for s in svara:\n            assert (0 < len(s) < 6)\n    else:\n        for s in svara:\n            assert (0 < len(s) < 4)\n    if octave:\n        assert (not np.all((svara[:12] == svara[12:24])))\n        assert (not np.all((svara[12:24] == svara[24:])))\n    else:\n        assert np.all((svara[:12] == svara[12:24]))\n        assert np.all((svara[:12] == svara[24:]))", "ground_truth": "'Sa'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_32", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_segment_load", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_segment_load():\n    sample_len = 2003\n    fs = 44100\n    test_file = os.path.join('tests', 'data', 'test1_44100.wav')\n    (y, sr) = librosa.load(test_file, sr=None, mono=False, offset=0.0, duration=(sample_len / float(fs)))\n    assert (y.shape[(- 1)] == sample_len)\n    (y2, sr) = librosa.load(test_file, sr=None, mono=False)\n    assert np.allclose(y, y2[(:, :sample_len)])\n    sample_offset = 2048\n    (y, sr) = librosa.load(test_file, sr=None, mono=False, offset=(sample_offset / float(fs)), duration=1.0)\n    assert (y.shape[(- 1)] == fs)\n    (y2, sr) = librosa.load(test_file, sr=None, mono=False)\n    assert np.allclose(y, y2[(:, sample_offset:(sample_offset + fs))])", "masked_code": "def test_segment_load():\n    sample_len = 2003\n    fs = 44100\n    test_file = os.path.join('tests', 'data', 'test1_44100.wav')\n    (y, sr) = librosa.load(test_file, sr=None, mono=False, offset=0.0, duration=(sample_len / float(fs)))\n    assert (y.shape[(- 1)] == '???')\n    (y2, sr) = librosa.load(test_file, sr=None, mono=False)\n    assert np.allclose(y, y2[(:, :sample_len)])\n    sample_offset = 2048\n    (y, sr) = librosa.load(test_file, sr=None, mono=False, offset=(sample_offset / float(fs)), duration=1.0)\n    assert (y.shape[(- 1)] == fs)\n    (y2, sr) = librosa.load(test_file, sr=None, mono=False)\n    assert np.allclose(y, y2[(:, sample_offset:(sample_offset + fs))])", "ground_truth": "sample_len", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_33", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_segment_load", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_segment_load():\n    sample_len = 2003\n    fs = 44100\n    test_file = os.path.join('tests', 'data', 'test1_44100.wav')\n    (y, sr) = librosa.load(test_file, sr=None, mono=False, offset=0.0, duration=(sample_len / float(fs)))\n    assert (y.shape[(- 1)] == sample_len)\n    (y2, sr) = librosa.load(test_file, sr=None, mono=False)\n    assert np.allclose(y, y2[(:, :sample_len)])\n    sample_offset = 2048\n    (y, sr) = librosa.load(test_file, sr=None, mono=False, offset=(sample_offset / float(fs)), duration=1.0)\n    assert (y.shape[(- 1)] == fs)\n    (y2, sr) = librosa.load(test_file, sr=None, mono=False)\n    assert np.allclose(y, y2[(:, sample_offset:(sample_offset + fs))])", "masked_code": "def test_segment_load():\n    sample_len = 2003\n    fs = 44100\n    test_file = os.path.join('tests', 'data', 'test1_44100.wav')\n    (y, sr) = librosa.load(test_file, sr=None, mono=False, offset=0.0, duration=(sample_len / float(fs)))\n    assert (y.shape[(- 1)] == sample_len)\n    (y2, sr) = librosa.load(test_file, sr=None, mono=False)\n    assert np.allclose(y, y2[(:, :sample_len)])\n    sample_offset = 2048\n    (y, sr) = librosa.load(test_file, sr=None, mono=False, offset=(sample_offset / float(fs)), duration=1.0)\n    assert (y.shape[(- 1)] == '???')\n    (y2, sr) = librosa.load(test_file, sr=None, mono=False)\n    assert np.allclose(y, y2[(:, sample_offset:(sample_offset + fs))])", "ground_truth": "fs", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_34", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_resample_mono", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('sr_out', [8000, 22050])\n@pytest.mark.parametrize('res_type', ['kaiser_best', 'kaiser_fast', 'scipy', 'fft', 'polyphase', 'linear', 'sinc_best', 'sinc_fastest', 'sinc_medium', 'zero_order_hold', 'soxr_qq', 'soxr_lq', 'soxr_mq', 'soxr_hq', 'soxr_vhq'])\n@pytest.mark.parametrize('fix', [False, True])\ndef test_resample_mono(resample_mono, sr_out, res_type, fix):\n    (y, sr_in) = resample_mono\n    y = librosa.to_mono(y)\n    y2 = librosa.resample(y, orig_sr=sr_in, target_sr=sr_out, res_type=res_type, fix=fix)\n    librosa.util.valid_audio(y2)\n    if (sr_out == sr_in):\n        assert np.allclose(y, y2)\n    assert (y2.flags['C_CONTIGUOUS'] == y.flags['C_CONTIGUOUS'])\n    assert (y2.flags['F_CONTIGUOUS'] == y.flags['F_CONTIGUOUS'])\n    target_length = ((y.shape[(- 1)] * sr_out) // sr_in)\n    assert (np.abs((y2.shape[(- 1)] - target_length)) <= 1)", "masked_code": "@pytest.mark.parametrize('sr_out', [8000, 22050])\n@pytest.mark.parametrize('res_type', ['kaiser_best', 'kaiser_fast', 'scipy', 'fft', 'polyphase', 'linear', 'sinc_best', 'sinc_fastest', 'sinc_medium', 'zero_order_hold', 'soxr_qq', 'soxr_lq', 'soxr_mq', 'soxr_hq', 'soxr_vhq'])\n@pytest.mark.parametrize('fix', [False, True])\ndef test_resample_mono(resample_mono, sr_out, res_type, fix):\n    (y, sr_in) = resample_mono\n    y = librosa.to_mono(y)\n    y2 = librosa.resample(y, orig_sr=sr_in, target_sr=sr_out, res_type=res_type, fix=fix)\n    librosa.util.valid_audio(y2)\n    if (sr_out == sr_in):\n        assert np.allclose(y, y2)\n    assert (y2.flags['C_CONTIGUOUS'] == '???')\n    assert (y2.flags['F_CONTIGUOUS'] == y.flags['F_CONTIGUOUS'])\n    target_length = ((y.shape[(- 1)] * sr_out) // sr_in)\n    assert (np.abs((y2.shape[(- 1)] - target_length)) <= 1)", "ground_truth": "y.flags['C_CONTIGUOUS']", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_35", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_resample_mono", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('sr_out', [8000, 22050])\n@pytest.mark.parametrize('res_type', ['kaiser_best', 'kaiser_fast', 'scipy', 'fft', 'polyphase', 'linear', 'sinc_best', 'sinc_fastest', 'sinc_medium', 'zero_order_hold', 'soxr_qq', 'soxr_lq', 'soxr_mq', 'soxr_hq', 'soxr_vhq'])\n@pytest.mark.parametrize('fix', [False, True])\ndef test_resample_mono(resample_mono, sr_out, res_type, fix):\n    (y, sr_in) = resample_mono\n    y = librosa.to_mono(y)\n    y2 = librosa.resample(y, orig_sr=sr_in, target_sr=sr_out, res_type=res_type, fix=fix)\n    librosa.util.valid_audio(y2)\n    if (sr_out == sr_in):\n        assert np.allclose(y, y2)\n    assert (y2.flags['C_CONTIGUOUS'] == y.flags['C_CONTIGUOUS'])\n    assert (y2.flags['F_CONTIGUOUS'] == y.flags['F_CONTIGUOUS'])\n    target_length = ((y.shape[(- 1)] * sr_out) // sr_in)\n    assert (np.abs((y2.shape[(- 1)] - target_length)) <= 1)", "masked_code": "@pytest.mark.parametrize('sr_out', [8000, 22050])\n@pytest.mark.parametrize('res_type', ['kaiser_best', 'kaiser_fast', 'scipy', 'fft', 'polyphase', 'linear', 'sinc_best', 'sinc_fastest', 'sinc_medium', 'zero_order_hold', 'soxr_qq', 'soxr_lq', 'soxr_mq', 'soxr_hq', 'soxr_vhq'])\n@pytest.mark.parametrize('fix', [False, True])\ndef test_resample_mono(resample_mono, sr_out, res_type, fix):\n    (y, sr_in) = resample_mono\n    y = librosa.to_mono(y)\n    y2 = librosa.resample(y, orig_sr=sr_in, target_sr=sr_out, res_type=res_type, fix=fix)\n    librosa.util.valid_audio(y2)\n    if (sr_out == sr_in):\n        assert np.allclose(y, y2)\n    assert (y2.flags['C_CONTIGUOUS'] == y.flags['C_CONTIGUOUS'])\n    assert (y2.flags['F_CONTIGUOUS'] == '???')\n    target_length = ((y.shape[(- 1)] * sr_out) // sr_in)\n    assert (np.abs((y2.shape[(- 1)] - target_length)) <= 1)", "ground_truth": "y.flags['F_CONTIGUOUS']", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_36", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_resample_stereo", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('sr_out', [8000, 22050])\n@pytest.mark.parametrize('res_type', ['kaiser_best', 'kaiser_fast', 'scipy', 'fft', 'polyphase', 'linear', 'sinc_best', 'sinc_fastest', 'sinc_medium', 'zero_order_hold', 'soxr_qq', 'soxr_lq', 'soxr_mq', 'soxr_hq', 'soxr_vhq'])\n@pytest.mark.parametrize('fix', [False, True])\ndef test_resample_stereo(resample_audio, sr_out, res_type, fix):\n    (y, sr_in) = resample_audio\n    y2 = librosa.resample(y, orig_sr=sr_in, target_sr=sr_out, res_type=res_type, fix=fix)\n    librosa.util.valid_audio(y2)\n    assert (y2.ndim == y.ndim)\n    if (sr_out == sr_in):\n        assert np.allclose(y, y2)\n    target_length = ((y.shape[(- 1)] * sr_out) // sr_in)\n    assert (np.abs((y2.shape[(- 1)] - target_length)) <= 1)", "masked_code": "@pytest.mark.parametrize('sr_out', [8000, 22050])\n@pytest.mark.parametrize('res_type', ['kaiser_best', 'kaiser_fast', 'scipy', 'fft', 'polyphase', 'linear', 'sinc_best', 'sinc_fastest', 'sinc_medium', 'zero_order_hold', 'soxr_qq', 'soxr_lq', 'soxr_mq', 'soxr_hq', 'soxr_vhq'])\n@pytest.mark.parametrize('fix', [False, True])\ndef test_resample_stereo(resample_audio, sr_out, res_type, fix):\n    (y, sr_in) = resample_audio\n    y2 = librosa.resample(y, orig_sr=sr_in, target_sr=sr_out, res_type=res_type, fix=fix)\n    librosa.util.valid_audio(y2)\n    assert (y2.ndim == '???')\n    if (sr_out == sr_in):\n        assert np.allclose(y, y2)\n    target_length = ((y.shape[(- 1)] * sr_out) // sr_in)\n    assert (np.abs((y2.shape[(- 1)] - target_length)) <= 1)", "ground_truth": "y.ndim", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_37", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_reassigned_spectrogram_clip", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('clip', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_clip(mock_reassign_frequencies, mock_reassign_times, clip):\n    mock_freqs = np.ones((5, 17))\n    mock_freqs[(0, 0)] = (- 1)\n    mock_freqs[(0, 1)] = 33\n    mock_times = np.ones((5, 17))\n    mock_times[(1, 0)] = (- 1)\n    mock_times[(1, 1)] = 3\n    mock_mags = np.ones((5, 17))\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, clip=clip)\n    if clip:\n        assert (freqs[(0, 0)] == 0)\n        assert (freqs[(0, 1)] == 32)\n        assert (times[(1, 0)] == 0)\n        assert (times[(1, 1)] == 2)\n    else:\n        assert (freqs[(0, 0)] == (- 1))\n        assert (freqs[(0, 1)] == 33)\n        assert (times[(1, 0)] == (- 1))\n        assert (times[(1, 1)] == 3)\n    assert (freqs[(2, 0)] == 1)\n    assert (times[(2, 1)] == 1)", "masked_code": "@pytest.mark.parametrize('clip', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_clip(mock_reassign_frequencies, mock_reassign_times, clip):\n    mock_freqs = np.ones((5, 17))\n    mock_freqs[(0, 0)] = (- 1)\n    mock_freqs[(0, 1)] = 33\n    mock_times = np.ones((5, 17))\n    mock_times[(1, 0)] = (- 1)\n    mock_times[(1, 1)] = 3\n    mock_mags = np.ones((5, 17))\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, clip=clip)\n    if clip:\n        assert (freqs[(0, 0)] == 0)\n        assert (freqs[(0, 1)] == '???')\n        assert (times[(1, 0)] == 0)\n        assert (times[(1, 1)] == 2)\n    else:\n        assert (freqs[(0, 0)] == (- 1))\n        assert (freqs[(0, 1)] == 33)\n        assert (times[(1, 0)] == (- 1))\n        assert (times[(1, 1)] == 3)\n    assert (freqs[(2, 0)] == 1)\n    assert (times[(2, 1)] == 1)", "ground_truth": "32", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_38", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_reassigned_spectrogram_clip", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('clip', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_clip(mock_reassign_frequencies, mock_reassign_times, clip):\n    mock_freqs = np.ones((5, 17))\n    mock_freqs[(0, 0)] = (- 1)\n    mock_freqs[(0, 1)] = 33\n    mock_times = np.ones((5, 17))\n    mock_times[(1, 0)] = (- 1)\n    mock_times[(1, 1)] = 3\n    mock_mags = np.ones((5, 17))\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, clip=clip)\n    if clip:\n        assert (freqs[(0, 0)] == 0)\n        assert (freqs[(0, 1)] == 32)\n        assert (times[(1, 0)] == 0)\n        assert (times[(1, 1)] == 2)\n    else:\n        assert (freqs[(0, 0)] == (- 1))\n        assert (freqs[(0, 1)] == 33)\n        assert (times[(1, 0)] == (- 1))\n        assert (times[(1, 1)] == 3)\n    assert (freqs[(2, 0)] == 1)\n    assert (times[(2, 1)] == 1)", "masked_code": "@pytest.mark.parametrize('clip', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_clip(mock_reassign_frequencies, mock_reassign_times, clip):\n    mock_freqs = np.ones((5, 17))\n    mock_freqs[(0, 0)] = (- 1)\n    mock_freqs[(0, 1)] = 33\n    mock_times = np.ones((5, 17))\n    mock_times[(1, 0)] = (- 1)\n    mock_times[(1, 1)] = 3\n    mock_mags = np.ones((5, 17))\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, clip=clip)\n    if clip:\n        assert (freqs[(0, 0)] == 0)\n        assert (freqs[(0, 1)] == 32)\n        assert (times[(1, 0)] == 0)\n        assert (times[(1, 1)] == 2)\n    else:\n        assert (freqs[(0, 0)] == '???')\n        assert (freqs[(0, 1)] == 33)\n        assert (times[(1, 0)] == (- 1))\n        assert (times[(1, 1)] == 3)\n    assert (freqs[(2, 0)] == 1)\n    assert (times[(2, 1)] == 1)", "ground_truth": "(- 1)", "quality_analysis": {"complexity_score": 11, "left_complexity": 8, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_39", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_reassigned_spectrogram_clip", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('clip', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_clip(mock_reassign_frequencies, mock_reassign_times, clip):\n    mock_freqs = np.ones((5, 17))\n    mock_freqs[(0, 0)] = (- 1)\n    mock_freqs[(0, 1)] = 33\n    mock_times = np.ones((5, 17))\n    mock_times[(1, 0)] = (- 1)\n    mock_times[(1, 1)] = 3\n    mock_mags = np.ones((5, 17))\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, clip=clip)\n    if clip:\n        assert (freqs[(0, 0)] == 0)\n        assert (freqs[(0, 1)] == 32)\n        assert (times[(1, 0)] == 0)\n        assert (times[(1, 1)] == 2)\n    else:\n        assert (freqs[(0, 0)] == (- 1))\n        assert (freqs[(0, 1)] == 33)\n        assert (times[(1, 0)] == (- 1))\n        assert (times[(1, 1)] == 3)\n    assert (freqs[(2, 0)] == 1)\n    assert (times[(2, 1)] == 1)", "masked_code": "@pytest.mark.parametrize('clip', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_clip(mock_reassign_frequencies, mock_reassign_times, clip):\n    mock_freqs = np.ones((5, 17))\n    mock_freqs[(0, 0)] = (- 1)\n    mock_freqs[(0, 1)] = 33\n    mock_times = np.ones((5, 17))\n    mock_times[(1, 0)] = (- 1)\n    mock_times[(1, 1)] = 3\n    mock_mags = np.ones((5, 17))\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, clip=clip)\n    if clip:\n        assert (freqs[(0, 0)] == 0)\n        assert (freqs[(0, 1)] == 32)\n        assert (times[(1, 0)] == 0)\n        assert (times[(1, 1)] == 2)\n    else:\n        assert (freqs[(0, 0)] == (- 1))\n        assert (freqs[(0, 1)] == '???')\n        assert (times[(1, 0)] == (- 1))\n        assert (times[(1, 1)] == 3)\n    assert (freqs[(2, 0)] == 1)\n    assert (times[(2, 1)] == 1)", "ground_truth": "33", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_40", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_reassigned_spectrogram_clip", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('clip', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_clip(mock_reassign_frequencies, mock_reassign_times, clip):\n    mock_freqs = np.ones((5, 17))\n    mock_freqs[(0, 0)] = (- 1)\n    mock_freqs[(0, 1)] = 33\n    mock_times = np.ones((5, 17))\n    mock_times[(1, 0)] = (- 1)\n    mock_times[(1, 1)] = 3\n    mock_mags = np.ones((5, 17))\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, clip=clip)\n    if clip:\n        assert (freqs[(0, 0)] == 0)\n        assert (freqs[(0, 1)] == 32)\n        assert (times[(1, 0)] == 0)\n        assert (times[(1, 1)] == 2)\n    else:\n        assert (freqs[(0, 0)] == (- 1))\n        assert (freqs[(0, 1)] == 33)\n        assert (times[(1, 0)] == (- 1))\n        assert (times[(1, 1)] == 3)\n    assert (freqs[(2, 0)] == 1)\n    assert (times[(2, 1)] == 1)", "masked_code": "@pytest.mark.parametrize('clip', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_clip(mock_reassign_frequencies, mock_reassign_times, clip):\n    mock_freqs = np.ones((5, 17))\n    mock_freqs[(0, 0)] = (- 1)\n    mock_freqs[(0, 1)] = 33\n    mock_times = np.ones((5, 17))\n    mock_times[(1, 0)] = (- 1)\n    mock_times[(1, 1)] = 3\n    mock_mags = np.ones((5, 17))\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, clip=clip)\n    if clip:\n        assert (freqs[(0, 0)] == 0)\n        assert (freqs[(0, 1)] == 32)\n        assert (times[(1, 0)] == 0)\n        assert (times[(1, 1)] == 2)\n    else:\n        assert (freqs[(0, 0)] == (- 1))\n        assert (freqs[(0, 1)] == 33)\n        assert (times[(1, 0)] == '???')\n        assert (times[(1, 1)] == 3)\n    assert (freqs[(2, 0)] == 1)\n    assert (times[(2, 1)] == 1)", "ground_truth": "(- 1)", "quality_analysis": {"complexity_score": 11, "left_complexity": 8, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_41", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_reassigned_spectrogram_clip", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('clip', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_clip(mock_reassign_frequencies, mock_reassign_times, clip):\n    mock_freqs = np.ones((5, 17))\n    mock_freqs[(0, 0)] = (- 1)\n    mock_freqs[(0, 1)] = 33\n    mock_times = np.ones((5, 17))\n    mock_times[(1, 0)] = (- 1)\n    mock_times[(1, 1)] = 3\n    mock_mags = np.ones((5, 17))\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, clip=clip)\n    if clip:\n        assert (freqs[(0, 0)] == 0)\n        assert (freqs[(0, 1)] == 32)\n        assert (times[(1, 0)] == 0)\n        assert (times[(1, 1)] == 2)\n    else:\n        assert (freqs[(0, 0)] == (- 1))\n        assert (freqs[(0, 1)] == 33)\n        assert (times[(1, 0)] == (- 1))\n        assert (times[(1, 1)] == 3)\n    assert (freqs[(2, 0)] == 1)\n    assert (times[(2, 1)] == 1)", "masked_code": "@pytest.mark.parametrize('clip', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_clip(mock_reassign_frequencies, mock_reassign_times, clip):\n    mock_freqs = np.ones((5, 17))\n    mock_freqs[(0, 0)] = (- 1)\n    mock_freqs[(0, 1)] = 33\n    mock_times = np.ones((5, 17))\n    mock_times[(1, 0)] = (- 1)\n    mock_times[(1, 1)] = 3\n    mock_mags = np.ones((5, 17))\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, clip=clip)\n    if clip:\n        assert (freqs[(0, 0)] == 0)\n        assert (freqs[(0, 1)] == 32)\n        assert (times[(1, 0)] == 0)\n        assert (times[(1, 1)] == 2)\n    else:\n        assert (freqs[(0, 0)] == (- 1))\n        assert (freqs[(0, 1)] == 33)\n        assert (times[(1, 0)] == (- 1))\n        assert (times[(1, 1)] == '???')\n    assert (freqs[(2, 0)] == 1)\n    assert (times[(2, 1)] == 1)", "ground_truth": "3", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_42", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_reassigned_spectrogram_fill_nan", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('fill_nan', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_fill_nan(mock_reassign_frequencies, mock_reassign_times, fill_nan):\n    mock_freqs = np.ones((5, 17))\n    mock_times = np.ones((5, 17))\n    mock_freqs[(3, 0)] = np.nan\n    mock_times[(3, 0)] = np.nan\n    mock_mags = np.ones((5, 17))\n    mock_mags[(3, 1)] = 0\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, center=False, fill_nan=fill_nan)\n    if fill_nan:\n        assert (freqs[(3, 0)] == 24)\n        assert (times[(3, 0)] == 0.0625)\n        assert (freqs[(3, 1)] == 24)\n        assert (times[(3, 1)] == 0.1875)\n    else:\n        assert np.isnan(freqs[(3, 0)])\n        assert np.isnan(times[(3, 0)])\n        assert np.isnan(freqs[(3, 1)])\n        assert np.isnan(times[(3, 1)])\n    assert (mags[(3, 1)] == 0)\n    assert (freqs[(3, 2)] == 1)\n    assert (times[(3, 2)] == 1)", "masked_code": "@pytest.mark.parametrize('fill_nan', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_fill_nan(mock_reassign_frequencies, mock_reassign_times, fill_nan):\n    mock_freqs = np.ones((5, 17))\n    mock_times = np.ones((5, 17))\n    mock_freqs[(3, 0)] = np.nan\n    mock_times[(3, 0)] = np.nan\n    mock_mags = np.ones((5, 17))\n    mock_mags[(3, 1)] = 0\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, center=False, fill_nan=fill_nan)\n    if fill_nan:\n        assert (freqs[(3, 0)] == '???')\n        assert (times[(3, 0)] == 0.0625)\n        assert (freqs[(3, 1)] == 24)\n        assert (times[(3, 1)] == 0.1875)\n    else:\n        assert np.isnan(freqs[(3, 0)])\n        assert np.isnan(times[(3, 0)])\n        assert np.isnan(freqs[(3, 1)])\n        assert np.isnan(times[(3, 1)])\n    assert (mags[(3, 1)] == 0)\n    assert (freqs[(3, 2)] == 1)\n    assert (times[(3, 2)] == 1)", "ground_truth": "24", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_43", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_reassigned_spectrogram_fill_nan", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('fill_nan', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_fill_nan(mock_reassign_frequencies, mock_reassign_times, fill_nan):\n    mock_freqs = np.ones((5, 17))\n    mock_times = np.ones((5, 17))\n    mock_freqs[(3, 0)] = np.nan\n    mock_times[(3, 0)] = np.nan\n    mock_mags = np.ones((5, 17))\n    mock_mags[(3, 1)] = 0\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, center=False, fill_nan=fill_nan)\n    if fill_nan:\n        assert (freqs[(3, 0)] == 24)\n        assert (times[(3, 0)] == 0.0625)\n        assert (freqs[(3, 1)] == 24)\n        assert (times[(3, 1)] == 0.1875)\n    else:\n        assert np.isnan(freqs[(3, 0)])\n        assert np.isnan(times[(3, 0)])\n        assert np.isnan(freqs[(3, 1)])\n        assert np.isnan(times[(3, 1)])\n    assert (mags[(3, 1)] == 0)\n    assert (freqs[(3, 2)] == 1)\n    assert (times[(3, 2)] == 1)", "masked_code": "@pytest.mark.parametrize('fill_nan', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_fill_nan(mock_reassign_frequencies, mock_reassign_times, fill_nan):\n    mock_freqs = np.ones((5, 17))\n    mock_times = np.ones((5, 17))\n    mock_freqs[(3, 0)] = np.nan\n    mock_times[(3, 0)] = np.nan\n    mock_mags = np.ones((5, 17))\n    mock_mags[(3, 1)] = 0\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, center=False, fill_nan=fill_nan)\n    if fill_nan:\n        assert (freqs[(3, 0)] == 24)\n        assert (times[(3, 0)] == '???')\n        assert (freqs[(3, 1)] == 24)\n        assert (times[(3, 1)] == 0.1875)\n    else:\n        assert np.isnan(freqs[(3, 0)])\n        assert np.isnan(times[(3, 0)])\n        assert np.isnan(freqs[(3, 1)])\n        assert np.isnan(times[(3, 1)])\n    assert (mags[(3, 1)] == 0)\n    assert (freqs[(3, 2)] == 1)\n    assert (times[(3, 2)] == 1)", "ground_truth": "0.0625", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_44", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_reassigned_spectrogram_fill_nan", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('fill_nan', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_fill_nan(mock_reassign_frequencies, mock_reassign_times, fill_nan):\n    mock_freqs = np.ones((5, 17))\n    mock_times = np.ones((5, 17))\n    mock_freqs[(3, 0)] = np.nan\n    mock_times[(3, 0)] = np.nan\n    mock_mags = np.ones((5, 17))\n    mock_mags[(3, 1)] = 0\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, center=False, fill_nan=fill_nan)\n    if fill_nan:\n        assert (freqs[(3, 0)] == 24)\n        assert (times[(3, 0)] == 0.0625)\n        assert (freqs[(3, 1)] == 24)\n        assert (times[(3, 1)] == 0.1875)\n    else:\n        assert np.isnan(freqs[(3, 0)])\n        assert np.isnan(times[(3, 0)])\n        assert np.isnan(freqs[(3, 1)])\n        assert np.isnan(times[(3, 1)])\n    assert (mags[(3, 1)] == 0)\n    assert (freqs[(3, 2)] == 1)\n    assert (times[(3, 2)] == 1)", "masked_code": "@pytest.mark.parametrize('fill_nan', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_fill_nan(mock_reassign_frequencies, mock_reassign_times, fill_nan):\n    mock_freqs = np.ones((5, 17))\n    mock_times = np.ones((5, 17))\n    mock_freqs[(3, 0)] = np.nan\n    mock_times[(3, 0)] = np.nan\n    mock_mags = np.ones((5, 17))\n    mock_mags[(3, 1)] = 0\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, center=False, fill_nan=fill_nan)\n    if fill_nan:\n        assert (freqs[(3, 0)] == 24)\n        assert (times[(3, 0)] == 0.0625)\n        assert (freqs[(3, 1)] == '???')\n        assert (times[(3, 1)] == 0.1875)\n    else:\n        assert np.isnan(freqs[(3, 0)])\n        assert np.isnan(times[(3, 0)])\n        assert np.isnan(freqs[(3, 1)])\n        assert np.isnan(times[(3, 1)])\n    assert (mags[(3, 1)] == 0)\n    assert (freqs[(3, 2)] == 1)\n    assert (times[(3, 2)] == 1)", "ground_truth": "24", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_45", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_reassigned_spectrogram_fill_nan", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('fill_nan', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_fill_nan(mock_reassign_frequencies, mock_reassign_times, fill_nan):\n    mock_freqs = np.ones((5, 17))\n    mock_times = np.ones((5, 17))\n    mock_freqs[(3, 0)] = np.nan\n    mock_times[(3, 0)] = np.nan\n    mock_mags = np.ones((5, 17))\n    mock_mags[(3, 1)] = 0\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, center=False, fill_nan=fill_nan)\n    if fill_nan:\n        assert (freqs[(3, 0)] == 24)\n        assert (times[(3, 0)] == 0.0625)\n        assert (freqs[(3, 1)] == 24)\n        assert (times[(3, 1)] == 0.1875)\n    else:\n        assert np.isnan(freqs[(3, 0)])\n        assert np.isnan(times[(3, 0)])\n        assert np.isnan(freqs[(3, 1)])\n        assert np.isnan(times[(3, 1)])\n    assert (mags[(3, 1)] == 0)\n    assert (freqs[(3, 2)] == 1)\n    assert (times[(3, 2)] == 1)", "masked_code": "@pytest.mark.parametrize('fill_nan', [False, True])\n@mock.patch('librosa.core.spectrum.__reassign_times')\n@mock.patch('librosa.core.spectrum.__reassign_frequencies')\ndef test_reassigned_spectrogram_fill_nan(mock_reassign_frequencies, mock_reassign_times, fill_nan):\n    mock_freqs = np.ones((5, 17))\n    mock_times = np.ones((5, 17))\n    mock_freqs[(3, 0)] = np.nan\n    mock_times[(3, 0)] = np.nan\n    mock_mags = np.ones((5, 17))\n    mock_mags[(3, 1)] = 0\n    mock_reassign_frequencies.return_value = (mock_freqs, mock_mags)\n    mock_reassign_times.return_value = (mock_times, mock_mags)\n    (freqs, times, mags) = librosa.reassigned_spectrogram(y=np.zeros(128), sr=64, n_fft=8, hop_length=8, center=False, fill_nan=fill_nan)\n    if fill_nan:\n        assert (freqs[(3, 0)] == 24)\n        assert (times[(3, 0)] == 0.0625)\n        assert (freqs[(3, 1)] == 24)\n        assert (times[(3, 1)] == '???')\n    else:\n        assert np.isnan(freqs[(3, 0)])\n        assert np.isnan(times[(3, 0)])\n        assert np.isnan(freqs[(3, 1)])\n        assert np.isnan(times[(3, 1)])\n    assert (mags[(3, 1)] == 0)\n    assert (freqs[(3, 2)] == 1)\n    assert (times[(3, 2)] == 1)", "ground_truth": "0.1875", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_46", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_to_mono", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('y', [np.arange(5.0), np.zeros((2, 5), dtype=float)], ids=['mono', 'stereo'])\ndef test_to_mono(y):\n    y_mono = librosa.to_mono(y)\n    assert (y_mono.ndim == 1)\n    assert (len(y_mono) == y.shape[(- 1)])\n    if (y.ndim == 1):\n        assert np.allclose(y, y_mono)", "masked_code": "@pytest.mark.parametrize('y', [np.arange(5.0), np.zeros((2, 5), dtype=float)], ids=['mono', 'stereo'])\ndef test_to_mono(y):\n    y_mono = librosa.to_mono(y)\n    assert (y_mono.ndim == 1)\n    assert (len(y_mono) == '???')\n    if (y.ndim == 1):\n        assert np.allclose(y, y_mono)", "ground_truth": "y.shape[(- 1)]", "quality_analysis": {"complexity_score": 12, "left_complexity": 4, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_47", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_to_mono_multi", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('y', [np.ones((2, 10)), np.ones((2, 3, 10)), np.ones((2, 3, 4, 10))])\ndef test_to_mono_multi(y):\n    y_mono = librosa.to_mono(y)\n    assert (y_mono.ndim == 1)\n    assert (len(y_mono) == y.shape[(- 1)])", "masked_code": "@pytest.mark.parametrize('y', [np.ones((2, 10)), np.ones((2, 3, 10)), np.ones((2, 3, 4, 10))])\ndef test_to_mono_multi(y):\n    y_mono = librosa.to_mono(y)\n    assert (y_mono.ndim == 1)\n    assert (len(y_mono) == '???')", "ground_truth": "y.shape[(- 1)]", "quality_analysis": {"complexity_score": 12, "left_complexity": 4, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_48", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_piptrack_properties", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('fmin', [0, 100])\n@pytest.mark.parametrize('fmax', [4000, 8000, 11025])\n@pytest.mark.parametrize('threshold', [0.1, 0.2, 0.5])\n@pytest.mark.parametrize('ref', [None, 1.0, np.max])\ndef test_piptrack_properties(pip_spec, pip_nfft, pip_hop, fmin, fmax, threshold, ref):\n    n_fft = pip_nfft\n    hop_length = pip_hop\n    S = pip_spec\n    (pitches, mags) = librosa.core.piptrack(S=S, n_fft=n_fft, hop_length=hop_length, fmin=fmin, fmax=fmax, threshold=threshold, ref=ref)\n    assert (S.shape == pitches.shape)\n    assert (S.shape == mags.shape)\n    assert np.all((mags >= 0))\n    idx = (mags > 0)\n    assert np.all((pitches[idx] >= fmin))\n    assert np.all((pitches[idx] <= fmax))\n    assert np.all((pitches[(~ idx)] == 0))", "masked_code": "@pytest.mark.parametrize('fmin', [0, 100])\n@pytest.mark.parametrize('fmax', [4000, 8000, 11025])\n@pytest.mark.parametrize('threshold', [0.1, 0.2, 0.5])\n@pytest.mark.parametrize('ref', [None, 1.0, np.max])\ndef test_piptrack_properties(pip_spec, pip_nfft, pip_hop, fmin, fmax, threshold, ref):\n    n_fft = pip_nfft\n    hop_length = pip_hop\n    S = pip_spec\n    (pitches, mags) = librosa.core.piptrack(S=S, n_fft=n_fft, hop_length=hop_length, fmin=fmin, fmax=fmax, threshold=threshold, ref=ref)\n    assert (S.shape == '???')\n    assert (S.shape == mags.shape)\n    assert np.all((mags >= 0))\n    idx = (mags > 0)\n    assert np.all((pitches[idx] >= fmin))\n    assert np.all((pitches[idx] <= fmax))\n    assert np.all((pitches[(~ idx)] == 0))", "ground_truth": "pitches.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_49", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_piptrack_properties", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('fmin', [0, 100])\n@pytest.mark.parametrize('fmax', [4000, 8000, 11025])\n@pytest.mark.parametrize('threshold', [0.1, 0.2, 0.5])\n@pytest.mark.parametrize('ref', [None, 1.0, np.max])\ndef test_piptrack_properties(pip_spec, pip_nfft, pip_hop, fmin, fmax, threshold, ref):\n    n_fft = pip_nfft\n    hop_length = pip_hop\n    S = pip_spec\n    (pitches, mags) = librosa.core.piptrack(S=S, n_fft=n_fft, hop_length=hop_length, fmin=fmin, fmax=fmax, threshold=threshold, ref=ref)\n    assert (S.shape == pitches.shape)\n    assert (S.shape == mags.shape)\n    assert np.all((mags >= 0))\n    idx = (mags > 0)\n    assert np.all((pitches[idx] >= fmin))\n    assert np.all((pitches[idx] <= fmax))\n    assert np.all((pitches[(~ idx)] == 0))", "masked_code": "@pytest.mark.parametrize('fmin', [0, 100])\n@pytest.mark.parametrize('fmax', [4000, 8000, 11025])\n@pytest.mark.parametrize('threshold', [0.1, 0.2, 0.5])\n@pytest.mark.parametrize('ref', [None, 1.0, np.max])\ndef test_piptrack_properties(pip_spec, pip_nfft, pip_hop, fmin, fmax, threshold, ref):\n    n_fft = pip_nfft\n    hop_length = pip_hop\n    S = pip_spec\n    (pitches, mags) = librosa.core.piptrack(S=S, n_fft=n_fft, hop_length=hop_length, fmin=fmin, fmax=fmax, threshold=threshold, ref=ref)\n    assert (S.shape == pitches.shape)\n    assert (S.shape == '???')\n    assert np.all((mags >= 0))\n    idx = (mags > 0)\n    assert np.all((pitches[idx] >= fmin))\n    assert np.all((pitches[idx] <= fmax))\n    assert np.all((pitches[(~ idx)] == 0))", "ground_truth": "mags.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_50", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_power_to_db", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('x', [np.linspace(0, 200000.0, num=10), (np.linspace(0, 200000.0, num=10) * np.exp(1j))])\n@pytest.mark.parametrize('ref', [1.0, np.max])\n@pytest.mark.parametrize('amin', [1e-10, 1000.0])\n@pytest.mark.parametrize('top_db', [None, 0, 40, 80])\ndef test_power_to_db(x, ref, amin, top_db):\n    if np.iscomplexobj(x):\n        with pytest.warns(UserWarning, match='power_to_db was called on complex input'):\n            y = librosa.power_to_db(x, ref=ref, amin=amin, top_db=top_db)\n    else:\n        y = librosa.power_to_db(x, ref=ref, amin=amin, top_db=top_db)\n    assert np.isrealobj(y)\n    assert (y.shape == x.shape)\n    if (top_db is not None):\n        assert (y.min() >= (y.max() - top_db))", "masked_code": "@pytest.mark.parametrize('x', [np.linspace(0, 200000.0, num=10), (np.linspace(0, 200000.0, num=10) * np.exp(1j))])\n@pytest.mark.parametrize('ref', [1.0, np.max])\n@pytest.mark.parametrize('amin', [1e-10, 1000.0])\n@pytest.mark.parametrize('top_db', [None, 0, 40, 80])\ndef test_power_to_db(x, ref, amin, top_db):\n    if np.iscomplexobj(x):\n        with pytest.warns(UserWarning, match='power_to_db was called on complex input'):\n            y = librosa.power_to_db(x, ref=ref, amin=amin, top_db=top_db)\n    else:\n        y = librosa.power_to_db(x, ref=ref, amin=amin, top_db=top_db)\n    assert np.isrealobj(y)\n    assert (y.shape == '???')\n    if (top_db is not None):\n        assert (y.min() >= (y.max() - top_db))", "ground_truth": "x.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_51", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_clicks", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('times', [np.linspace(0, 10.0, num=5)])\n@pytest.mark.parametrize('sr', [11025, 22050])\n@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('click', [None, np.ones(1000)])\n@pytest.mark.parametrize('use_frames', [False, True])\n@pytest.mark.parametrize('click_freq', [1000])\n@pytest.mark.parametrize('click_duration', [0.1])\n@pytest.mark.parametrize('length', [None, (5 * 22050)])\ndef test_clicks(times, sr, hop_length, click_freq, click_duration, click, length, use_frames):\n    if use_frames:\n        frames = librosa.time_to_frames(times, sr=sr, hop_length=hop_length)\n        times = None\n    else:\n        frames = None\n    y = librosa.clicks(times=times, frames=frames, sr=sr, hop_length=hop_length, click_freq=click_freq, click_duration=click_duration, click=click, length=length)\n    if (times is not None):\n        nmax = librosa.time_to_samples(times, sr=sr).max()\n    else:\n        assert (frames is not None)\n        nmax = librosa.frames_to_samples(frames, hop_length=hop_length).max()\n    if (length is not None):\n        assert (len(y) == length)\n    elif (click is not None):\n        assert (len(y) == (nmax + len(click)))", "masked_code": "@pytest.mark.parametrize('times', [np.linspace(0, 10.0, num=5)])\n@pytest.mark.parametrize('sr', [11025, 22050])\n@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('click', [None, np.ones(1000)])\n@pytest.mark.parametrize('use_frames', [False, True])\n@pytest.mark.parametrize('click_freq', [1000])\n@pytest.mark.parametrize('click_duration', [0.1])\n@pytest.mark.parametrize('length', [None, (5 * 22050)])\ndef test_clicks(times, sr, hop_length, click_freq, click_duration, click, length, use_frames):\n    if use_frames:\n        frames = librosa.time_to_frames(times, sr=sr, hop_length=hop_length)\n        times = None\n    else:\n        frames = None\n    y = librosa.clicks(times=times, frames=frames, sr=sr, hop_length=hop_length, click_freq=click_freq, click_duration=click_duration, click=click, length=length)\n    if (times is not None):\n        nmax = librosa.time_to_samples(times, sr=sr).max()\n    else:\n        assert (frames is not None)\n        nmax = librosa.frames_to_samples(frames, hop_length=hop_length).max()\n    if (length is not None):\n        assert (len(y) == '???')\n    elif (click is not None):\n        assert (len(y) == (nmax + len(click)))", "ground_truth": "length", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_52", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_clicks", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('times', [np.linspace(0, 10.0, num=5)])\n@pytest.mark.parametrize('sr', [11025, 22050])\n@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('click', [None, np.ones(1000)])\n@pytest.mark.parametrize('use_frames', [False, True])\n@pytest.mark.parametrize('click_freq', [1000])\n@pytest.mark.parametrize('click_duration', [0.1])\n@pytest.mark.parametrize('length', [None, (5 * 22050)])\ndef test_clicks(times, sr, hop_length, click_freq, click_duration, click, length, use_frames):\n    if use_frames:\n        frames = librosa.time_to_frames(times, sr=sr, hop_length=hop_length)\n        times = None\n    else:\n        frames = None\n    y = librosa.clicks(times=times, frames=frames, sr=sr, hop_length=hop_length, click_freq=click_freq, click_duration=click_duration, click=click, length=length)\n    if (times is not None):\n        nmax = librosa.time_to_samples(times, sr=sr).max()\n    else:\n        assert (frames is not None)\n        nmax = librosa.frames_to_samples(frames, hop_length=hop_length).max()\n    if (length is not None):\n        assert (len(y) == length)\n    elif (click is not None):\n        assert (len(y) == (nmax + len(click)))", "masked_code": "@pytest.mark.parametrize('times', [np.linspace(0, 10.0, num=5)])\n@pytest.mark.parametrize('sr', [11025, 22050])\n@pytest.mark.parametrize('hop_length', [512, 1024])\n@pytest.mark.parametrize('click', [None, np.ones(1000)])\n@pytest.mark.parametrize('use_frames', [False, True])\n@pytest.mark.parametrize('click_freq', [1000])\n@pytest.mark.parametrize('click_duration', [0.1])\n@pytest.mark.parametrize('length', [None, (5 * 22050)])\ndef test_clicks(times, sr, hop_length, click_freq, click_duration, click, length, use_frames):\n    if use_frames:\n        frames = librosa.time_to_frames(times, sr=sr, hop_length=hop_length)\n        times = None\n    else:\n        frames = None\n    y = librosa.clicks(times=times, frames=frames, sr=sr, hop_length=hop_length, click_freq=click_freq, click_duration=click_duration, click=click, length=length)\n    if (times is not None):\n        nmax = librosa.time_to_samples(times, sr=sr).max()\n    else:\n        assert (frames is not None)\n        nmax = librosa.frames_to_samples(frames, hop_length=hop_length).max()\n    if (length is not None):\n        assert (len(y) == length)\n    elif (click is not None):\n        assert (len(y) == '???')", "ground_truth": "(nmax + len(click))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_53", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_tone", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('frequency', [440])\n@pytest.mark.parametrize('sr', [11025, 22050, 44100])\n@pytest.mark.parametrize('length,duration', [(None, 0.5), (1740, None), (22050, None), (1740, 0.5)])\n@pytest.mark.parametrize('phi', [None, np.pi])\ndef test_tone(frequency, sr, length, duration, phi):\n    y = librosa.tone(frequency=frequency, sr=sr, length=length, duration=duration, phi=phi)\n    if (length is not None):\n        assert (len(y) == length)\n    else:\n        assert (len(y) == int((duration * sr)))", "masked_code": "@pytest.mark.parametrize('frequency', [440])\n@pytest.mark.parametrize('sr', [11025, 22050, 44100])\n@pytest.mark.parametrize('length,duration', [(None, 0.5), (1740, None), (22050, None), (1740, 0.5)])\n@pytest.mark.parametrize('phi', [None, np.pi])\ndef test_tone(frequency, sr, length, duration, phi):\n    y = librosa.tone(frequency=frequency, sr=sr, length=length, duration=duration, phi=phi)\n    if (length is not None):\n        assert (len(y) == '???')\n    else:\n        assert (len(y) == int((duration * sr)))", "ground_truth": "length", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_54", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_tone", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('frequency', [440])\n@pytest.mark.parametrize('sr', [11025, 22050, 44100])\n@pytest.mark.parametrize('length,duration', [(None, 0.5), (1740, None), (22050, None), (1740, 0.5)])\n@pytest.mark.parametrize('phi', [None, np.pi])\ndef test_tone(frequency, sr, length, duration, phi):\n    y = librosa.tone(frequency=frequency, sr=sr, length=length, duration=duration, phi=phi)\n    if (length is not None):\n        assert (len(y) == length)\n    else:\n        assert (len(y) == int((duration * sr)))", "masked_code": "@pytest.mark.parametrize('frequency', [440])\n@pytest.mark.parametrize('sr', [11025, 22050, 44100])\n@pytest.mark.parametrize('length,duration', [(None, 0.5), (1740, None), (22050, None), (1740, 0.5)])\n@pytest.mark.parametrize('phi', [None, np.pi])\ndef test_tone(frequency, sr, length, duration, phi):\n    y = librosa.tone(frequency=frequency, sr=sr, length=length, duration=duration, phi=phi)\n    if (length is not None):\n        assert (len(y) == length)\n    else:\n        assert (len(y) == '???')", "ground_truth": "int((duration * sr))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_55", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_chirp", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('fmin,fmax', [(440, 880), (880, 440)])\n@pytest.mark.parametrize('sr', [11025, 22050])\n@pytest.mark.parametrize('length,duration', [(None, 0.5), (11025, None), (11025, 0.5)])\n@pytest.mark.parametrize('phi', [None, (np.pi / 2)])\n@pytest.mark.parametrize('linear', [False, True])\ndef test_chirp(fmin, fmax, sr, length, duration, linear, phi):\n    y = librosa.chirp(fmin=fmin, fmax=fmax, sr=sr, length=length, duration=duration, linear=linear, phi=phi)\n    if (length is not None):\n        assert (len(y) == length)\n    else:\n        assert (len(y) == int((duration * sr)))", "masked_code": "@pytest.mark.parametrize('fmin,fmax', [(440, 880), (880, 440)])\n@pytest.mark.parametrize('sr', [11025, 22050])\n@pytest.mark.parametrize('length,duration', [(None, 0.5), (11025, None), (11025, 0.5)])\n@pytest.mark.parametrize('phi', [None, (np.pi / 2)])\n@pytest.mark.parametrize('linear', [False, True])\ndef test_chirp(fmin, fmax, sr, length, duration, linear, phi):\n    y = librosa.chirp(fmin=fmin, fmax=fmax, sr=sr, length=length, duration=duration, linear=linear, phi=phi)\n    if (length is not None):\n        assert (len(y) == '???')\n    else:\n        assert (len(y) == int((duration * sr)))", "ground_truth": "length", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_56", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_chirp", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('fmin,fmax', [(440, 880), (880, 440)])\n@pytest.mark.parametrize('sr', [11025, 22050])\n@pytest.mark.parametrize('length,duration', [(None, 0.5), (11025, None), (11025, 0.5)])\n@pytest.mark.parametrize('phi', [None, (np.pi / 2)])\n@pytest.mark.parametrize('linear', [False, True])\ndef test_chirp(fmin, fmax, sr, length, duration, linear, phi):\n    y = librosa.chirp(fmin=fmin, fmax=fmax, sr=sr, length=length, duration=duration, linear=linear, phi=phi)\n    if (length is not None):\n        assert (len(y) == length)\n    else:\n        assert (len(y) == int((duration * sr)))", "masked_code": "@pytest.mark.parametrize('fmin,fmax', [(440, 880), (880, 440)])\n@pytest.mark.parametrize('sr', [11025, 22050])\n@pytest.mark.parametrize('length,duration', [(None, 0.5), (11025, None), (11025, 0.5)])\n@pytest.mark.parametrize('phi', [None, (np.pi / 2)])\n@pytest.mark.parametrize('linear', [False, True])\ndef test_chirp(fmin, fmax, sr, length, duration, linear, phi):\n    y = librosa.chirp(fmin=fmin, fmax=fmax, sr=sr, length=length, duration=duration, linear=linear, phi=phi)\n    if (length is not None):\n        assert (len(y) == length)\n    else:\n        assert (len(y) == '???')", "ground_truth": "int((duration * sr))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_57", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_harmonics_1d", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_harmonics_1d():\n    x = np.arange(16)\n    y = (np.linspace((- 8), 8, num=len(x), endpoint=False) ** 2)\n    h = [0.25, 0.5, 1, 2, 4]\n    yh = librosa.interp_harmonics(y, freqs=x, harmonics=h, axis=0)\n    assert (yh.shape[1:] == y.shape)\n    assert (yh.shape[0] == len(h))\n    for i in range(len(h)):\n        if (h[i] <= 1):\n            step = int((1.0 / h[i]))\n            vals = yh[(i, ::step)]\n            assert np.allclose(vals, y[:len(vals)])\n        else:\n            step = cast(int, h[i])\n            vals = y[::step]\n            assert np.allclose(vals, yh[(i, :len(vals))])", "masked_code": "def test_harmonics_1d():\n    x = np.arange(16)\n    y = (np.linspace((- 8), 8, num=len(x), endpoint=False) ** 2)\n    h = [0.25, 0.5, 1, 2, 4]\n    yh = librosa.interp_harmonics(y, freqs=x, harmonics=h, axis=0)\n    assert (yh.shape[1:] == '???')\n    assert (yh.shape[0] == len(h))\n    for i in range(len(h)):\n        if (h[i] <= 1):\n            step = int((1.0 / h[i]))\n            vals = yh[(i, ::step)]\n            assert np.allclose(vals, y[:len(vals)])\n        else:\n            step = cast(int, h[i])\n            vals = y[::step]\n            assert np.allclose(vals, yh[(i, :len(vals))])", "ground_truth": "y.shape", "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_58", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_harmonics_1d", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_harmonics_1d():\n    x = np.arange(16)\n    y = (np.linspace((- 8), 8, num=len(x), endpoint=False) ** 2)\n    h = [0.25, 0.5, 1, 2, 4]\n    yh = librosa.interp_harmonics(y, freqs=x, harmonics=h, axis=0)\n    assert (yh.shape[1:] == y.shape)\n    assert (yh.shape[0] == len(h))\n    for i in range(len(h)):\n        if (h[i] <= 1):\n            step = int((1.0 / h[i]))\n            vals = yh[(i, ::step)]\n            assert np.allclose(vals, y[:len(vals)])\n        else:\n            step = cast(int, h[i])\n            vals = y[::step]\n            assert np.allclose(vals, yh[(i, :len(vals))])", "masked_code": "def test_harmonics_1d():\n    x = np.arange(16)\n    y = (np.linspace((- 8), 8, num=len(x), endpoint=False) ** 2)\n    h = [0.25, 0.5, 1, 2, 4]\n    yh = librosa.interp_harmonics(y, freqs=x, harmonics=h, axis=0)\n    assert (yh.shape[1:] == y.shape)\n    assert (yh.shape[0] == '???')\n    for i in range(len(h)):\n        if (h[i] <= 1):\n            step = int((1.0 / h[i]))\n            vals = yh[(i, ::step)]\n            assert np.allclose(vals, y[:len(vals)])\n        else:\n            step = cast(int, h[i])\n            vals = y[::step]\n            assert np.allclose(vals, yh[(i, :len(vals))])", "ground_truth": "len(h)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_59", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_harmonics_2d", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_harmonics_2d():\n    x = np.arange(16)\n    y = (np.linspace((- 8), 8, num=len(x), endpoint=False) ** 2)\n    y = np.tile(y, (5, 1)).T\n    h = [0.25, 0.5, 1, 2, 4]\n    yh = librosa.interp_harmonics(y, freqs=x, harmonics=h, axis=0)\n    assert (yh.shape[1:] == y.shape)\n    assert (yh.shape[0] == len(h))\n    for i in range(len(h)):\n        if (h[i] <= 1):\n            step = int((1.0 / h[i]))\n            vals = yh[(i, ::step)]\n            assert np.allclose(vals, y[:len(vals)])\n        else:\n            step = cast(int, h[i])\n            vals = y[::step]\n            assert np.allclose(vals, yh[(i, :len(vals))])", "masked_code": "def test_harmonics_2d():\n    x = np.arange(16)\n    y = (np.linspace((- 8), 8, num=len(x), endpoint=False) ** 2)\n    y = np.tile(y, (5, 1)).T\n    h = [0.25, 0.5, 1, 2, 4]\n    yh = librosa.interp_harmonics(y, freqs=x, harmonics=h, axis=0)\n    assert (yh.shape[1:] == '???')\n    assert (yh.shape[0] == len(h))\n    for i in range(len(h)):\n        if (h[i] <= 1):\n            step = int((1.0 / h[i]))\n            vals = yh[(i, ::step)]\n            assert np.allclose(vals, y[:len(vals)])\n        else:\n            step = cast(int, h[i])\n            vals = y[::step]\n            assert np.allclose(vals, yh[(i, :len(vals))])", "ground_truth": "y.shape", "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_60", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_harmonics_2d", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_harmonics_2d():\n    x = np.arange(16)\n    y = (np.linspace((- 8), 8, num=len(x), endpoint=False) ** 2)\n    y = np.tile(y, (5, 1)).T\n    h = [0.25, 0.5, 1, 2, 4]\n    yh = librosa.interp_harmonics(y, freqs=x, harmonics=h, axis=0)\n    assert (yh.shape[1:] == y.shape)\n    assert (yh.shape[0] == len(h))\n    for i in range(len(h)):\n        if (h[i] <= 1):\n            step = int((1.0 / h[i]))\n            vals = yh[(i, ::step)]\n            assert np.allclose(vals, y[:len(vals)])\n        else:\n            step = cast(int, h[i])\n            vals = y[::step]\n            assert np.allclose(vals, yh[(i, :len(vals))])", "masked_code": "def test_harmonics_2d():\n    x = np.arange(16)\n    y = (np.linspace((- 8), 8, num=len(x), endpoint=False) ** 2)\n    y = np.tile(y, (5, 1)).T\n    h = [0.25, 0.5, 1, 2, 4]\n    yh = librosa.interp_harmonics(y, freqs=x, harmonics=h, axis=0)\n    assert (yh.shape[1:] == y.shape)\n    assert (yh.shape[0] == '???')\n    for i in range(len(h)):\n        if (h[i] <= 1):\n            step = int((1.0 / h[i]))\n            vals = yh[(i, ::step)]\n            assert np.allclose(vals, y[:len(vals)])\n        else:\n            step = cast(int, h[i])\n            vals = y[::step]\n            assert np.allclose(vals, yh[(i, :len(vals))])", "ground_truth": "len(h)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_61", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_harmonics_2d_varying", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_harmonics_2d_varying():\n    x = np.arange(16)\n    y = (np.linspace((- 8), 8, num=len(x), endpoint=False) ** 2)\n    x = np.tile(x, (5, 1)).T\n    y = np.tile(y, (5, 1)).T\n    h = [0.25, 0.5, 1, 2, 4]\n    yh = librosa.interp_harmonics(y, freqs=x, harmonics=h, axis=(- 2))\n    assert (yh.shape[1:] == y.shape)\n    assert (yh.shape[0] == len(h))\n    for i in range(len(h)):\n        if (h[i] <= 1):\n            step = int((1.0 / h[i]))\n            vals = yh[(i, ::step)]\n            assert np.allclose(vals, y[:len(vals)])\n        else:\n            step = cast(int, h[i])\n            vals = y[::step]\n            assert np.allclose(vals, yh[(i, :len(vals))])", "masked_code": "def test_harmonics_2d_varying():\n    x = np.arange(16)\n    y = (np.linspace((- 8), 8, num=len(x), endpoint=False) ** 2)\n    x = np.tile(x, (5, 1)).T\n    y = np.tile(y, (5, 1)).T\n    h = [0.25, 0.5, 1, 2, 4]\n    yh = librosa.interp_harmonics(y, freqs=x, harmonics=h, axis=(- 2))\n    assert (yh.shape[1:] == '???')\n    assert (yh.shape[0] == len(h))\n    for i in range(len(h)):\n        if (h[i] <= 1):\n            step = int((1.0 / h[i]))\n            vals = yh[(i, ::step)]\n            assert np.allclose(vals, y[:len(vals)])\n        else:\n            step = cast(int, h[i])\n            vals = y[::step]\n            assert np.allclose(vals, yh[(i, :len(vals))])", "ground_truth": "y.shape", "quality_analysis": {"complexity_score": 7, "left_complexity": 5, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_62", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_harmonics_2d_varying", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_harmonics_2d_varying():\n    x = np.arange(16)\n    y = (np.linspace((- 8), 8, num=len(x), endpoint=False) ** 2)\n    x = np.tile(x, (5, 1)).T\n    y = np.tile(y, (5, 1)).T\n    h = [0.25, 0.5, 1, 2, 4]\n    yh = librosa.interp_harmonics(y, freqs=x, harmonics=h, axis=(- 2))\n    assert (yh.shape[1:] == y.shape)\n    assert (yh.shape[0] == len(h))\n    for i in range(len(h)):\n        if (h[i] <= 1):\n            step = int((1.0 / h[i]))\n            vals = yh[(i, ::step)]\n            assert np.allclose(vals, y[:len(vals)])\n        else:\n            step = cast(int, h[i])\n            vals = y[::step]\n            assert np.allclose(vals, yh[(i, :len(vals))])", "masked_code": "def test_harmonics_2d_varying():\n    x = np.arange(16)\n    y = (np.linspace((- 8), 8, num=len(x), endpoint=False) ** 2)\n    x = np.tile(x, (5, 1)).T\n    y = np.tile(y, (5, 1)).T\n    h = [0.25, 0.5, 1, 2, 4]\n    yh = librosa.interp_harmonics(y, freqs=x, harmonics=h, axis=(- 2))\n    assert (yh.shape[1:] == y.shape)\n    assert (yh.shape[0] == '???')\n    for i in range(len(h)):\n        if (h[i] <= 1):\n            step = int((1.0 / h[i]))\n            vals = yh[(i, ::step)]\n            assert np.allclose(vals, y[:len(vals)])\n        else:\n            step = cast(int, h[i])\n            vals = y[::step]\n            assert np.allclose(vals, yh[(i, :len(vals))])", "ground_truth": "len(h)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_63", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_iirt_peaks", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_iirt_peaks():\n    Fs = 4000\n    length = 180\n    click_times = [10, 50, 90, 130, 170]\n    x = np.zeros((length * Fs))\n    for click in click_times:\n        x[(click * Fs)] = 1\n    win_length = 200\n    hop_length = 50\n    center_freqs = librosa.midi_to_hz(np.arange(40, 95))\n    sample_rates = np.asarray((((len(np.arange(40, 46)) * [1000.0]) + (len(np.arange(46, 80)) * [1750.0])) + (len(np.arange(80, 95)) * [4000.0])))\n    X = librosa.iirt(x, center_freqs=center_freqs, sample_rates=sample_rates, win_length=win_length, hop_length=hop_length)\n    for cur_band in X:\n        cur_peaks = scipy.signal.find_peaks(cur_band, height=np.mean(cur_band), distance=1000)[0]\n        assert (len(cur_peaks) == 5)\n        cur_peak_times = ((cur_peaks * hop_length) / Fs)\n        assert all((abs((cur_peak_times - click_times)) < ((2 * win_length) / Fs)))", "masked_code": "def test_iirt_peaks():\n    Fs = 4000\n    length = 180\n    click_times = [10, 50, 90, 130, 170]\n    x = np.zeros((length * Fs))\n    for click in click_times:\n        x[(click * Fs)] = 1\n    win_length = 200\n    hop_length = 50\n    center_freqs = librosa.midi_to_hz(np.arange(40, 95))\n    sample_rates = np.asarray((((len(np.arange(40, 46)) * [1000.0]) + (len(np.arange(46, 80)) * [1750.0])) + (len(np.arange(80, 95)) * [4000.0])))\n    X = librosa.iirt(x, center_freqs=center_freqs, sample_rates=sample_rates, win_length=win_length, hop_length=hop_length)\n    for cur_band in X:\n        cur_peaks = scipy.signal.find_peaks(cur_band, height=np.mean(cur_band), distance=1000)[0]\n        assert (len(cur_peaks) == '???')\n        cur_peak_times = ((cur_peaks * hop_length) / Fs)\n        assert all((abs((cur_peak_times - click_times)) < ((2 * win_length) / Fs)))", "ground_truth": "5", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_64", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_pcen_complex", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_pcen_complex():\n    S = np.ones((9, 30), dtype=complex)\n    Pexp = np.ones((9, 30))\n    with warnings.catch_warnings(record=True) as out:\n        P = librosa.pcen(S, gain=1, bias=0, power=1, time_constant=0.5, eps=1e-20, b=1, max_size=1)\n        if np.issubdtype(S.dtype, np.complexfloating):\n            assert (len(out) > 0)\n            assert ('complex' in str(out[0].message).lower())\n    assert (P.shape == S.shape)\n    assert np.all((P >= 0))\n    assert np.all(np.isfinite(P))\n    if (Pexp is not None):\n        assert np.allclose(P, Pexp)", "masked_code": "def test_pcen_complex():\n    S = np.ones((9, 30), dtype=complex)\n    Pexp = np.ones((9, 30))\n    with warnings.catch_warnings(record=True) as out:\n        P = librosa.pcen(S, gain=1, bias=0, power=1, time_constant=0.5, eps=1e-20, b=1, max_size=1)\n        if np.issubdtype(S.dtype, np.complexfloating):\n            assert (len(out) > 0)\n            assert ('complex' in str(out[0].message).lower())\n    assert (P.shape == '???')\n    assert np.all((P >= 0))\n    assert np.all(np.isfinite(P))\n    if (Pexp is not None):\n        assert np.allclose(P, Pexp)", "ground_truth": "S.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_65", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_set_fftlib", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_set_fftlib():\n    with pytest.warns(FutureWarning):\n        librosa.set_fftlib('foo')\n    assert (librosa.get_fftlib() == 'foo')\n    with pytest.warns(FutureWarning):\n        librosa.set_fftlib()", "masked_code": "def test_set_fftlib():\n    with pytest.warns(FutureWarning):\n        librosa.set_fftlib('foo')\n    assert (librosa.get_fftlib() == '???')\n    with pytest.warns(FutureWarning):\n        librosa.set_fftlib()", "ground_truth": "'foo'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_66", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_griffinlim", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('hop_length', [None, 1024])\n@pytest.mark.parametrize('win_length', [None, 1024])\n@pytest.mark.parametrize('n_fft', [2048, 2049])\n@pytest.mark.parametrize('window', ['hann', 'rect'])\n@pytest.mark.parametrize('center', [False, True])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('use_length', [False, True])\n@pytest.mark.parametrize('pad_mode', ['constant', 'reflect'])\n@pytest.mark.parametrize('momentum', [0, 0.99])\n@pytest.mark.parametrize('random_state', [None, 0, np.random.RandomState()])\n@pytest.mark.parametrize('init', [None, 'random'])\ndef test_griffinlim(y_chirp, hop_length, win_length, n_fft, window, center, dtype, use_length, pad_mode, momentum, init, random_state):\n    if use_length:\n        length = len(y_chirp)\n    else:\n        length = None\n    D = librosa.stft(y_chirp, hop_length=hop_length, win_length=win_length, n_fft=n_fft, window=window, center=center, pad_mode=pad_mode)\n    S = np.abs(D)\n    y_rec = librosa.griffinlim(S, hop_length=hop_length, win_length=win_length, n_fft=n_fft, window=window, center=center, dtype=dtype, length=length, pad_mode=pad_mode, n_iter=3, momentum=momentum, init=init, random_state=random_state)\n    if use_length:\n        assert (len(y_rec) == length)\n    assert (y_rec.dtype == dtype)", "masked_code": "@pytest.mark.parametrize('hop_length', [None, 1024])\n@pytest.mark.parametrize('win_length', [None, 1024])\n@pytest.mark.parametrize('n_fft', [2048, 2049])\n@pytest.mark.parametrize('window', ['hann', 'rect'])\n@pytest.mark.parametrize('center', [False, True])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('use_length', [False, True])\n@pytest.mark.parametrize('pad_mode', ['constant', 'reflect'])\n@pytest.mark.parametrize('momentum', [0, 0.99])\n@pytest.mark.parametrize('random_state', [None, 0, np.random.RandomState()])\n@pytest.mark.parametrize('init', [None, 'random'])\ndef test_griffinlim(y_chirp, hop_length, win_length, n_fft, window, center, dtype, use_length, pad_mode, momentum, init, random_state):\n    if use_length:\n        length = len(y_chirp)\n    else:\n        length = None\n    D = librosa.stft(y_chirp, hop_length=hop_length, win_length=win_length, n_fft=n_fft, window=window, center=center, pad_mode=pad_mode)\n    S = np.abs(D)\n    y_rec = librosa.griffinlim(S, hop_length=hop_length, win_length=win_length, n_fft=n_fft, window=window, center=center, dtype=dtype, length=length, pad_mode=pad_mode, n_iter=3, momentum=momentum, init=init, random_state=random_state)\n    if use_length:\n        assert (len(y_rec) == length)\n    assert (y_rec.dtype == '???')", "ground_truth": "dtype", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_67", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_griffinlim", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('hop_length', [None, 1024])\n@pytest.mark.parametrize('win_length', [None, 1024])\n@pytest.mark.parametrize('n_fft', [2048, 2049])\n@pytest.mark.parametrize('window', ['hann', 'rect'])\n@pytest.mark.parametrize('center', [False, True])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('use_length', [False, True])\n@pytest.mark.parametrize('pad_mode', ['constant', 'reflect'])\n@pytest.mark.parametrize('momentum', [0, 0.99])\n@pytest.mark.parametrize('random_state', [None, 0, np.random.RandomState()])\n@pytest.mark.parametrize('init', [None, 'random'])\ndef test_griffinlim(y_chirp, hop_length, win_length, n_fft, window, center, dtype, use_length, pad_mode, momentum, init, random_state):\n    if use_length:\n        length = len(y_chirp)\n    else:\n        length = None\n    D = librosa.stft(y_chirp, hop_length=hop_length, win_length=win_length, n_fft=n_fft, window=window, center=center, pad_mode=pad_mode)\n    S = np.abs(D)\n    y_rec = librosa.griffinlim(S, hop_length=hop_length, win_length=win_length, n_fft=n_fft, window=window, center=center, dtype=dtype, length=length, pad_mode=pad_mode, n_iter=3, momentum=momentum, init=init, random_state=random_state)\n    if use_length:\n        assert (len(y_rec) == length)\n    assert (y_rec.dtype == dtype)", "masked_code": "@pytest.mark.parametrize('hop_length', [None, 1024])\n@pytest.mark.parametrize('win_length', [None, 1024])\n@pytest.mark.parametrize('n_fft', [2048, 2049])\n@pytest.mark.parametrize('window', ['hann', 'rect'])\n@pytest.mark.parametrize('center', [False, True])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('use_length', [False, True])\n@pytest.mark.parametrize('pad_mode', ['constant', 'reflect'])\n@pytest.mark.parametrize('momentum', [0, 0.99])\n@pytest.mark.parametrize('random_state', [None, 0, np.random.RandomState()])\n@pytest.mark.parametrize('init', [None, 'random'])\ndef test_griffinlim(y_chirp, hop_length, win_length, n_fft, window, center, dtype, use_length, pad_mode, momentum, init, random_state):\n    if use_length:\n        length = len(y_chirp)\n    else:\n        length = None\n    D = librosa.stft(y_chirp, hop_length=hop_length, win_length=win_length, n_fft=n_fft, window=window, center=center, pad_mode=pad_mode)\n    S = np.abs(D)\n    y_rec = librosa.griffinlim(S, hop_length=hop_length, win_length=win_length, n_fft=n_fft, window=window, center=center, dtype=dtype, length=length, pad_mode=pad_mode, n_iter=3, momentum=momentum, init=init, random_state=random_state)\n    if use_length:\n        assert (len(y_rec) == '???')\n    assert (y_rec.dtype == dtype)", "ground_truth": "length", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_68", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_stream", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('block_length', [10, np.int64(30)])\n@pytest.mark.parametrize('frame_length', [1024, np.int64(2048)])\n@pytest.mark.parametrize('hop_length', [512, np.int64(1024)])\n@pytest.mark.parametrize('mono', [False, True])\n@pytest.mark.parametrize('offset', [0.0, 2.0])\n@pytest.mark.parametrize('duration', [None, 1.0])\n@pytest.mark.parametrize('fill_value', [None, 999.0])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\ndef test_stream(path, block_length, frame_length, hop_length, mono, offset, duration, fill_value, dtype):\n    stream = librosa.stream(path, block_length=block_length, frame_length=frame_length, hop_length=hop_length, dtype=dtype, mono=mono, offset=offset, duration=duration, fill_value=fill_value)\n    y_frame_stream = []\n    target_length = (frame_length + ((block_length - 1) * hop_length))\n    for y_block in stream:\n        assert (y_block.dtype == dtype)\n        if mono:\n            assert (y_block.ndim == 1)\n        else:\n            assert (y_block.ndim == 2)\n            assert (y_block.shape[0] == 2)\n        if (fill_value is None):\n            assert (y_block.shape[(- 1)] <= target_length)\n        else:\n            assert (y_block.shape[(- 1)] == target_length)\n        y_b_mono = librosa.to_mono(y_block)\n        if (len(y_b_mono) >= frame_length):\n            y_b_frame = librosa.util.frame(y_b_mono, frame_length=frame_length, hop_length=hop_length)\n            y_frame_stream.append(y_b_frame)\n    y_frame_stream = np.concatenate(y_frame_stream, axis=1)\n    if hasattr(path, 'seek'):\n        path.seek(0)\n    (y_full, sr) = librosa.load(path, sr=None, dtype=dtype, mono=True, offset=offset, duration=duration)\n    y_frame = librosa.util.frame(y_full, frame_length=frame_length, hop_length=hop_length)\n    n = y_frame.shape[1]\n    assert np.allclose(y_frame[(:, :n)], y_frame_stream[(:, :n)])", "masked_code": "@pytest.mark.parametrize('block_length', [10, np.int64(30)])\n@pytest.mark.parametrize('frame_length', [1024, np.int64(2048)])\n@pytest.mark.parametrize('hop_length', [512, np.int64(1024)])\n@pytest.mark.parametrize('mono', [False, True])\n@pytest.mark.parametrize('offset', [0.0, 2.0])\n@pytest.mark.parametrize('duration', [None, 1.0])\n@pytest.mark.parametrize('fill_value', [None, 999.0])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\ndef test_stream(path, block_length, frame_length, hop_length, mono, offset, duration, fill_value, dtype):\n    stream = librosa.stream(path, block_length=block_length, frame_length=frame_length, hop_length=hop_length, dtype=dtype, mono=mono, offset=offset, duration=duration, fill_value=fill_value)\n    y_frame_stream = []\n    target_length = (frame_length + ((block_length - 1) * hop_length))\n    for y_block in stream:\n        assert (y_block.dtype == '???')\n        if mono:\n            assert (y_block.ndim == 1)\n        else:\n            assert (y_block.ndim == 2)\n            assert (y_block.shape[0] == 2)\n        if (fill_value is None):\n            assert (y_block.shape[(- 1)] <= target_length)\n        else:\n            assert (y_block.shape[(- 1)] == target_length)\n        y_b_mono = librosa.to_mono(y_block)\n        if (len(y_b_mono) >= frame_length):\n            y_b_frame = librosa.util.frame(y_b_mono, frame_length=frame_length, hop_length=hop_length)\n            y_frame_stream.append(y_b_frame)\n    y_frame_stream = np.concatenate(y_frame_stream, axis=1)\n    if hasattr(path, 'seek'):\n        path.seek(0)\n    (y_full, sr) = librosa.load(path, sr=None, dtype=dtype, mono=True, offset=offset, duration=duration)\n    y_frame = librosa.util.frame(y_full, frame_length=frame_length, hop_length=hop_length)\n    n = y_frame.shape[1]\n    assert np.allclose(y_frame[(:, :n)], y_frame_stream[(:, :n)])", "ground_truth": "dtype", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_69", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_stream", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "@pytest.mark.parametrize('block_length', [10, np.int64(30)])\n@pytest.mark.parametrize('frame_length', [1024, np.int64(2048)])\n@pytest.mark.parametrize('hop_length', [512, np.int64(1024)])\n@pytest.mark.parametrize('mono', [False, True])\n@pytest.mark.parametrize('offset', [0.0, 2.0])\n@pytest.mark.parametrize('duration', [None, 1.0])\n@pytest.mark.parametrize('fill_value', [None, 999.0])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\ndef test_stream(path, block_length, frame_length, hop_length, mono, offset, duration, fill_value, dtype):\n    stream = librosa.stream(path, block_length=block_length, frame_length=frame_length, hop_length=hop_length, dtype=dtype, mono=mono, offset=offset, duration=duration, fill_value=fill_value)\n    y_frame_stream = []\n    target_length = (frame_length + ((block_length - 1) * hop_length))\n    for y_block in stream:\n        assert (y_block.dtype == dtype)\n        if mono:\n            assert (y_block.ndim == 1)\n        else:\n            assert (y_block.ndim == 2)\n            assert (y_block.shape[0] == 2)\n        if (fill_value is None):\n            assert (y_block.shape[(- 1)] <= target_length)\n        else:\n            assert (y_block.shape[(- 1)] == target_length)\n        y_b_mono = librosa.to_mono(y_block)\n        if (len(y_b_mono) >= frame_length):\n            y_b_frame = librosa.util.frame(y_b_mono, frame_length=frame_length, hop_length=hop_length)\n            y_frame_stream.append(y_b_frame)\n    y_frame_stream = np.concatenate(y_frame_stream, axis=1)\n    if hasattr(path, 'seek'):\n        path.seek(0)\n    (y_full, sr) = librosa.load(path, sr=None, dtype=dtype, mono=True, offset=offset, duration=duration)\n    y_frame = librosa.util.frame(y_full, frame_length=frame_length, hop_length=hop_length)\n    n = y_frame.shape[1]\n    assert np.allclose(y_frame[(:, :n)], y_frame_stream[(:, :n)])", "masked_code": "@pytest.mark.parametrize('block_length', [10, np.int64(30)])\n@pytest.mark.parametrize('frame_length', [1024, np.int64(2048)])\n@pytest.mark.parametrize('hop_length', [512, np.int64(1024)])\n@pytest.mark.parametrize('mono', [False, True])\n@pytest.mark.parametrize('offset', [0.0, 2.0])\n@pytest.mark.parametrize('duration', [None, 1.0])\n@pytest.mark.parametrize('fill_value', [None, 999.0])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\ndef test_stream(path, block_length, frame_length, hop_length, mono, offset, duration, fill_value, dtype):\n    stream = librosa.stream(path, block_length=block_length, frame_length=frame_length, hop_length=hop_length, dtype=dtype, mono=mono, offset=offset, duration=duration, fill_value=fill_value)\n    y_frame_stream = []\n    target_length = (frame_length + ((block_length - 1) * hop_length))\n    for y_block in stream:\n        assert (y_block.dtype == dtype)\n        if mono:\n            assert (y_block.ndim == 1)\n        else:\n            assert (y_block.ndim == 2)\n            assert (y_block.shape[0] == 2)\n        if (fill_value is None):\n            assert (y_block.shape[(- 1)] <= target_length)\n        else:\n            assert (y_block.shape[(- 1)] == '???')\n        y_b_mono = librosa.to_mono(y_block)\n        if (len(y_b_mono) >= frame_length):\n            y_b_frame = librosa.util.frame(y_b_mono, frame_length=frame_length, hop_length=hop_length)\n            y_frame_stream.append(y_b_frame)\n    y_frame_stream = np.concatenate(y_frame_stream, axis=1)\n    if hasattr(path, 'seek'):\n        path.seek(0)\n    (y_full, sr) = librosa.load(path, sr=None, dtype=dtype, mono=True, offset=offset, duration=duration)\n    y_frame = librosa.util.frame(y_full, frame_length=frame_length, hop_length=hop_length)\n    n = y_frame.shape[1]\n    assert np.allclose(y_frame[(:, :n)], y_frame_stream[(:, :n)])", "ground_truth": "target_length", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_70", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_f0_harmonics_static", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_f0_harmonics_static():\n    freqs = np.arange(8)\n    data = np.multiply.outer(freqs, np.arange(2, 5))\n    f0 = np.array([1, 2, 0])\n    harmonics = [0.5, 1, 3]\n    yh = librosa.f0_harmonics(data, f0=f0, freqs=freqs, harmonics=harmonics)\n    assert (yh.shape[0] == len(harmonics))\n    assert (yh.shape[1:] == data.shape[1:])\n    assert np.allclose(yh[(:, 0)], [1, 2, 6])\n    assert np.allclose(yh[(:, 1)], [3, 6, 18])\n    assert np.allclose(yh[(:, 2)], [0, 0, 0])", "masked_code": "def test_f0_harmonics_static():\n    freqs = np.arange(8)\n    data = np.multiply.outer(freqs, np.arange(2, 5))\n    f0 = np.array([1, 2, 0])\n    harmonics = [0.5, 1, 3]\n    yh = librosa.f0_harmonics(data, f0=f0, freqs=freqs, harmonics=harmonics)\n    assert (yh.shape[0] == '???')\n    assert (yh.shape[1:] == data.shape[1:])\n    assert np.allclose(yh[(:, 0)], [1, 2, 6])\n    assert np.allclose(yh[(:, 1)], [3, 6, 18])\n    assert np.allclose(yh[(:, 2)], [0, 0, 0])", "ground_truth": "len(harmonics)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_71", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_f0_harmonics_static", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_f0_harmonics_static():\n    freqs = np.arange(8)\n    data = np.multiply.outer(freqs, np.arange(2, 5))\n    f0 = np.array([1, 2, 0])\n    harmonics = [0.5, 1, 3]\n    yh = librosa.f0_harmonics(data, f0=f0, freqs=freqs, harmonics=harmonics)\n    assert (yh.shape[0] == len(harmonics))\n    assert (yh.shape[1:] == data.shape[1:])\n    assert np.allclose(yh[(:, 0)], [1, 2, 6])\n    assert np.allclose(yh[(:, 1)], [3, 6, 18])\n    assert np.allclose(yh[(:, 2)], [0, 0, 0])", "masked_code": "def test_f0_harmonics_static():\n    freqs = np.arange(8)\n    data = np.multiply.outer(freqs, np.arange(2, 5))\n    f0 = np.array([1, 2, 0])\n    harmonics = [0.5, 1, 3]\n    yh = librosa.f0_harmonics(data, f0=f0, freqs=freqs, harmonics=harmonics)\n    assert (yh.shape[0] == len(harmonics))\n    assert (yh.shape[1:] == '???')\n    assert np.allclose(yh[(:, 0)], [1, 2, 6])\n    assert np.allclose(yh[(:, 1)], [3, 6, 18])\n    assert np.allclose(yh[(:, 2)], [0, 0, 0])", "ground_truth": "data.shape[1:]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_72", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_f0_harmonics_dynamic", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_f0_harmonics_dynamic():\n    freqs = np.add.outer(np.arange(8), np.arange(3))\n    data = (freqs * np.arange(2, 5))\n    f0 = np.array([2, 4, 5])\n    harmonics = [0.5, 1, 2]\n    yh = librosa.f0_harmonics(data, f0=f0, freqs=freqs, harmonics=harmonics)\n    assert (yh.shape[0] == len(harmonics))\n    assert (yh.shape[1:] == data.shape[1:])\n    assert np.allclose(yh[(:, 0)], [2, 4, 8])\n    assert np.allclose(yh[(:, 1)], [6, 12, 24])\n    assert np.allclose(yh[(:, 2)], [10, 20, 0])", "masked_code": "def test_f0_harmonics_dynamic():\n    freqs = np.add.outer(np.arange(8), np.arange(3))\n    data = (freqs * np.arange(2, 5))\n    f0 = np.array([2, 4, 5])\n    harmonics = [0.5, 1, 2]\n    yh = librosa.f0_harmonics(data, f0=f0, freqs=freqs, harmonics=harmonics)\n    assert (yh.shape[0] == '???')\n    assert (yh.shape[1:] == data.shape[1:])\n    assert np.allclose(yh[(:, 0)], [2, 4, 8])\n    assert np.allclose(yh[(:, 1)], [6, 12, 24])\n    assert np.allclose(yh[(:, 2)], [10, 20, 0])", "ground_truth": "len(harmonics)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_73", "reponame": "librosa", "testpath": "tests/test_core.py", "testname": "test_core.py", "classname": null, "funcname": "test_f0_harmonics_dynamic", "imports": ["from __future__ import print_function", "import os", "import sys", "import soundfile", "import audioread.rawread", "import librosa", "import librosa.core", "import librosa.core.spectrum", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "import pytest", "import warnings", "from unittest import mock", "from typing import Any, Callable, Union, cast"], "code": "def test_f0_harmonics_dynamic():\n    freqs = np.add.outer(np.arange(8), np.arange(3))\n    data = (freqs * np.arange(2, 5))\n    f0 = np.array([2, 4, 5])\n    harmonics = [0.5, 1, 2]\n    yh = librosa.f0_harmonics(data, f0=f0, freqs=freqs, harmonics=harmonics)\n    assert (yh.shape[0] == len(harmonics))\n    assert (yh.shape[1:] == data.shape[1:])\n    assert np.allclose(yh[(:, 0)], [2, 4, 8])\n    assert np.allclose(yh[(:, 1)], [6, 12, 24])\n    assert np.allclose(yh[(:, 2)], [10, 20, 0])", "masked_code": "def test_f0_harmonics_dynamic():\n    freqs = np.add.outer(np.arange(8), np.arange(3))\n    data = (freqs * np.arange(2, 5))\n    f0 = np.array([2, 4, 5])\n    harmonics = [0.5, 1, 2]\n    yh = librosa.f0_harmonics(data, f0=f0, freqs=freqs, harmonics=harmonics)\n    assert (yh.shape[0] == len(harmonics))\n    assert (yh.shape[1:] == '???')\n    assert np.allclose(yh[(:, 0)], [2, 4, 8])\n    assert np.allclose(yh[(:, 1)], [6, 12, 24])\n    assert np.allclose(yh[(:, 2)], [10, 20, 0])", "ground_truth": "data.shape[1:]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_74", "reponame": "librosa", "testpath": "tests/test_display.py", "testname": "test_display.py", "classname": null, "funcname": "test_cmap_robust", "imports": ["import os", "from packaging import version", "import pytest", "import matplotlib", "import matplotlib.pyplot as plt", "import librosa", "import librosa.display", "import numpy as np", "from typing import Any, Dict"], "code": "@pytest.mark.parametrize('data', [np.arange(1, 10.0), (- np.arange(1, 10.0)), np.arange((- 3), 4.0), np.arange(2, dtype=bool)])\ndef test_cmap_robust(data):\n    cmap1 = librosa.display.cmap(data, robust=False)\n    cmap2 = librosa.display.cmap(data, robust=True)\n    assert (type(cmap1) is type(cmap2))\n    if isinstance(cmap1, matplotlib.colors.ListedColormap):\n        assert np.allclose(cmap1.colors, cmap2.colors)\n    elif isinstance(cmap1, matplotlib.colors.LinearSegmentedColormap):\n        assert (cmap1.name == cmap2.name)\n    else:\n        assert (cmap1 == cmap2)", "masked_code": "@pytest.mark.parametrize('data', [np.arange(1, 10.0), (- np.arange(1, 10.0)), np.arange((- 3), 4.0), np.arange(2, dtype=bool)])\ndef test_cmap_robust(data):\n    cmap1 = librosa.display.cmap(data, robust=False)\n    cmap2 = librosa.display.cmap(data, robust=True)\n    assert (type(cmap1) is type(cmap2))\n    if isinstance(cmap1, matplotlib.colors.ListedColormap):\n        assert np.allclose(cmap1.colors, cmap2.colors)\n    elif isinstance(cmap1, matplotlib.colors.LinearSegmentedColormap):\n        assert (cmap1.name == '???')\n    else:\n        assert (cmap1 == cmap2)", "ground_truth": "cmap2.name", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_75", "reponame": "librosa", "testpath": "tests/test_display.py", "testname": "test_display.py", "classname": null, "funcname": "test_same_axes", "imports": ["import os", "from packaging import version", "import pytest", "import matplotlib", "import matplotlib.pyplot as plt", "import librosa", "import librosa.display", "import numpy as np", "from typing import Any, Dict"], "code": "@pytest.mark.parametrize('x_axis,y_axis,xlim,ylim,out', [(None, None, (0.0, 1.0), (0.0, 1.0), False), ('time', 'linear', (0.0, 1.0), (0.0, 1.0), False), ('time', 'time', (0.0, 1.0), (0.0, 2.0), False), ('chroma', 'chroma', (0.0, 1.0), (0.0, 1.0), True), ('s', 'ms', (0.0, 1.0), (0.0, 1.0), True)])\ndef test_same_axes(x_axis, y_axis, xlim, ylim, out):\n    assert (librosa.display.__same_axes(x_axis, y_axis, xlim, ylim) == out)", "masked_code": "@pytest.mark.parametrize('x_axis,y_axis,xlim,ylim,out', [(None, None, (0.0, 1.0), (0.0, 1.0), False), ('time', 'linear', (0.0, 1.0), (0.0, 1.0), False), ('time', 'time', (0.0, 1.0), (0.0, 2.0), False), ('chroma', 'chroma', (0.0, 1.0), (0.0, 1.0), True), ('s', 'ms', (0.0, 1.0), (0.0, 1.0), True)])\ndef test_same_axes(x_axis, y_axis, xlim, ylim, out):\n    assert (librosa.display.__same_axes(x_axis, y_axis, xlim, ylim) == '???')", "ground_truth": "out", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_76", "reponame": "librosa", "testpath": "tests/test_display.py", "testname": "test_display.py", "classname": null, "funcname": "test_auto_aspect", "imports": ["import os", "from packaging import version", "import pytest", "import matplotlib", "import matplotlib.pyplot as plt", "import librosa", "import librosa.display", "import numpy as np", "from typing import Any, Dict"], "code": "def test_auto_aspect():\n    (fig, ax) = plt.subplots(nrows=5)\n    for axi in ax:\n        axi.set(aspect='auto')\n    X = np.zeros((12, 12))\n    librosa.display.specshow(X, x_axis='chroma', y_axis='time', ax=ax[0])\n    assert (ax[0].get_aspect() == 'auto')\n    librosa.display.specshow(X, x_axis='chroma', y_axis='chroma', ax=ax[1])\n    assert (ax[1].get_aspect() == 1.0)\n    librosa.display.specshow(X, x_axis='chroma', y_axis='chroma', auto_aspect=False, ax=ax[2])\n    assert (ax[2].get_aspect() == 'auto')\n    librosa.display.specshow(X[(:2, :)], x_axis='chroma', y_axis='chroma', auto_aspect=True, ax=ax[3])\n    assert (ax[3].get_aspect() == 'auto')\n    librosa.display.specshow(X, x_axis='time', y_axis='ms', ax=ax[4])\n    assert (ax[4].get_aspect() == 1.0)", "masked_code": "def test_auto_aspect():\n    (fig, ax) = plt.subplots(nrows=5)\n    for axi in ax:\n        axi.set(aspect='auto')\n    X = np.zeros((12, 12))\n    librosa.display.specshow(X, x_axis='chroma', y_axis='time', ax=ax[0])\n    assert (ax[0].get_aspect() == '???')\n    librosa.display.specshow(X, x_axis='chroma', y_axis='chroma', ax=ax[1])\n    assert (ax[1].get_aspect() == 1.0)\n    librosa.display.specshow(X, x_axis='chroma', y_axis='chroma', auto_aspect=False, ax=ax[2])\n    assert (ax[2].get_aspect() == 'auto')\n    librosa.display.specshow(X[(:2, :)], x_axis='chroma', y_axis='chroma', auto_aspect=True, ax=ax[3])\n    assert (ax[3].get_aspect() == 'auto')\n    librosa.display.specshow(X, x_axis='time', y_axis='ms', ax=ax[4])\n    assert (ax[4].get_aspect() == 1.0)", "ground_truth": "'auto'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_77", "reponame": "librosa", "testpath": "tests/test_display.py", "testname": "test_display.py", "classname": null, "funcname": "test_auto_aspect", "imports": ["import os", "from packaging import version", "import pytest", "import matplotlib", "import matplotlib.pyplot as plt", "import librosa", "import librosa.display", "import numpy as np", "from typing import Any, Dict"], "code": "def test_auto_aspect():\n    (fig, ax) = plt.subplots(nrows=5)\n    for axi in ax:\n        axi.set(aspect='auto')\n    X = np.zeros((12, 12))\n    librosa.display.specshow(X, x_axis='chroma', y_axis='time', ax=ax[0])\n    assert (ax[0].get_aspect() == 'auto')\n    librosa.display.specshow(X, x_axis='chroma', y_axis='chroma', ax=ax[1])\n    assert (ax[1].get_aspect() == 1.0)\n    librosa.display.specshow(X, x_axis='chroma', y_axis='chroma', auto_aspect=False, ax=ax[2])\n    assert (ax[2].get_aspect() == 'auto')\n    librosa.display.specshow(X[(:2, :)], x_axis='chroma', y_axis='chroma', auto_aspect=True, ax=ax[3])\n    assert (ax[3].get_aspect() == 'auto')\n    librosa.display.specshow(X, x_axis='time', y_axis='ms', ax=ax[4])\n    assert (ax[4].get_aspect() == 1.0)", "masked_code": "def test_auto_aspect():\n    (fig, ax) = plt.subplots(nrows=5)\n    for axi in ax:\n        axi.set(aspect='auto')\n    X = np.zeros((12, 12))\n    librosa.display.specshow(X, x_axis='chroma', y_axis='time', ax=ax[0])\n    assert (ax[0].get_aspect() == 'auto')\n    librosa.display.specshow(X, x_axis='chroma', y_axis='chroma', ax=ax[1])\n    assert (ax[1].get_aspect() == 1.0)\n    librosa.display.specshow(X, x_axis='chroma', y_axis='chroma', auto_aspect=False, ax=ax[2])\n    assert (ax[2].get_aspect() == '???')\n    librosa.display.specshow(X[(:2, :)], x_axis='chroma', y_axis='chroma', auto_aspect=True, ax=ax[3])\n    assert (ax[3].get_aspect() == 'auto')\n    librosa.display.specshow(X, x_axis='time', y_axis='ms', ax=ax[4])\n    assert (ax[4].get_aspect() == 1.0)", "ground_truth": "'auto'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_78", "reponame": "librosa", "testpath": "tests/test_display.py", "testname": "test_display.py", "classname": null, "funcname": "test_auto_aspect", "imports": ["import os", "from packaging import version", "import pytest", "import matplotlib", "import matplotlib.pyplot as plt", "import librosa", "import librosa.display", "import numpy as np", "from typing import Any, Dict"], "code": "def test_auto_aspect():\n    (fig, ax) = plt.subplots(nrows=5)\n    for axi in ax:\n        axi.set(aspect='auto')\n    X = np.zeros((12, 12))\n    librosa.display.specshow(X, x_axis='chroma', y_axis='time', ax=ax[0])\n    assert (ax[0].get_aspect() == 'auto')\n    librosa.display.specshow(X, x_axis='chroma', y_axis='chroma', ax=ax[1])\n    assert (ax[1].get_aspect() == 1.0)\n    librosa.display.specshow(X, x_axis='chroma', y_axis='chroma', auto_aspect=False, ax=ax[2])\n    assert (ax[2].get_aspect() == 'auto')\n    librosa.display.specshow(X[(:2, :)], x_axis='chroma', y_axis='chroma', auto_aspect=True, ax=ax[3])\n    assert (ax[3].get_aspect() == 'auto')\n    librosa.display.specshow(X, x_axis='time', y_axis='ms', ax=ax[4])\n    assert (ax[4].get_aspect() == 1.0)", "masked_code": "def test_auto_aspect():\n    (fig, ax) = plt.subplots(nrows=5)\n    for axi in ax:\n        axi.set(aspect='auto')\n    X = np.zeros((12, 12))\n    librosa.display.specshow(X, x_axis='chroma', y_axis='time', ax=ax[0])\n    assert (ax[0].get_aspect() == 'auto')\n    librosa.display.specshow(X, x_axis='chroma', y_axis='chroma', ax=ax[1])\n    assert (ax[1].get_aspect() == 1.0)\n    librosa.display.specshow(X, x_axis='chroma', y_axis='chroma', auto_aspect=False, ax=ax[2])\n    assert (ax[2].get_aspect() == 'auto')\n    librosa.display.specshow(X[(:2, :)], x_axis='chroma', y_axis='chroma', auto_aspect=True, ax=ax[3])\n    assert (ax[3].get_aspect() == '???')\n    librosa.display.specshow(X, x_axis='time', y_axis='ms', ax=ax[4])\n    assert (ax[4].get_aspect() == 1.0)", "ground_truth": "'auto'", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_79", "reponame": "librosa", "testpath": "tests/test_effects.py", "testname": "test_effects.py", "classname": null, "funcname": "test_preemphasis", "imports": ["import warnings", "import os", "from contextlib import nullcontext as dnr", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('coef', [0.5, 0.99])\n@pytest.mark.parametrize('zi', [None, 0, [0]])\n@pytest.mark.parametrize('return_zf', [False, True])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\ndef test_preemphasis(coef, zi, return_zf: bool, dtype):\n    x = np.arange(10, dtype=dtype)\n    if return_zf:\n        (y, zf) = librosa.effects.preemphasis(x, coef=coef, zi=zi, return_zf=return_zf)\n    else:\n        y = librosa.effects.preemphasis(x, coef=coef, zi=zi, return_zf=return_zf)\n    assert np.allclose(y[1:], (x[1:] - (coef * x[:(- 1)])))\n    assert (x.dtype == y.dtype)", "masked_code": "@pytest.mark.parametrize('coef', [0.5, 0.99])\n@pytest.mark.parametrize('zi', [None, 0, [0]])\n@pytest.mark.parametrize('return_zf', [False, True])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\ndef test_preemphasis(coef, zi, return_zf: bool, dtype):\n    x = np.arange(10, dtype=dtype)\n    if return_zf:\n        (y, zf) = librosa.effects.preemphasis(x, coef=coef, zi=zi, return_zf=return_zf)\n    else:\n        y = librosa.effects.preemphasis(x, coef=coef, zi=zi, return_zf=return_zf)\n    assert np.allclose(y[1:], (x[1:] - (coef * x[:(- 1)])))\n    assert (x.dtype == '???')", "ground_truth": "y.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_80", "reponame": "librosa", "testpath": "tests/test_effects.py", "testname": "test_effects.py", "classname": null, "funcname": "test_preemphasis_continue", "imports": ["import warnings", "import os", "from contextlib import nullcontext as dnr", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('dtype', [np.float32, np.float64])\ndef test_preemphasis_continue(dtype):\n    x = np.arange(64, dtype=dtype)\n    (y1, zf1) = librosa.effects.preemphasis(x[:32], return_zf=True)\n    (y2, zf2) = librosa.effects.preemphasis(x[32:], return_zf=True, zi=zf1)\n    (y_all, zf_all) = librosa.effects.preemphasis(x, return_zf=True)\n    assert np.allclose(y_all, np.concatenate([y1, y2]))\n    assert np.allclose(zf2, zf_all)\n    assert (x.dtype == y_all.dtype)", "masked_code": "@pytest.mark.parametrize('dtype', [np.float32, np.float64])\ndef test_preemphasis_continue(dtype):\n    x = np.arange(64, dtype=dtype)\n    (y1, zf1) = librosa.effects.preemphasis(x[:32], return_zf=True)\n    (y2, zf2) = librosa.effects.preemphasis(x[32:], return_zf=True, zi=zf1)\n    (y_all, zf_all) = librosa.effects.preemphasis(x, return_zf=True)\n    assert np.allclose(y_all, np.concatenate([y1, y2]))\n    assert np.allclose(zf2, zf_all)\n    assert (x.dtype == '???')", "ground_truth": "y_all.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_81", "reponame": "librosa", "testpath": "tests/test_effects.py", "testname": "test_effects.py", "classname": null, "funcname": "test_deemphasis", "imports": ["import warnings", "import os", "from contextlib import nullcontext as dnr", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('coef', [0.5, 0.99])\n@pytest.mark.parametrize('zi', [None, 0, [0]])\n@pytest.mark.parametrize('return_zf', [False, True])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\ndef test_deemphasis(coef, zi, return_zf, dtype):\n    x = np.arange(10, dtype=dtype)\n    y = librosa.effects.preemphasis(x, coef=coef, zi=zi, return_zf=return_zf)\n    if return_zf:\n        (y, zf) = y\n    y_deemph = librosa.effects.deemphasis(y, coef=coef, zi=zi)\n    assert np.allclose(x, y_deemph)\n    assert (x.dtype == y_deemph.dtype)", "masked_code": "@pytest.mark.parametrize('coef', [0.5, 0.99])\n@pytest.mark.parametrize('zi', [None, 0, [0]])\n@pytest.mark.parametrize('return_zf', [False, True])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\ndef test_deemphasis(coef, zi, return_zf, dtype):\n    x = np.arange(10, dtype=dtype)\n    y = librosa.effects.preemphasis(x, coef=coef, zi=zi, return_zf=return_zf)\n    if return_zf:\n        (y, zf) = y\n    y_deemph = librosa.effects.deemphasis(y, coef=coef, zi=zi)\n    assert np.allclose(x, y_deemph)\n    assert (x.dtype == '???')", "ground_truth": "y_deemph.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_82", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_delta", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('slope', np.linspace((- 2), 2, num=6))\n@pytest.mark.parametrize('xin', [np.vstack(([np.arange(100.0)] * 3))])\n@pytest.mark.parametrize('order', [1])\n@pytest.mark.parametrize('width, axis', [(3, 0), (3, 1), (5, 1), (7, 1)])\n@pytest.mark.parametrize('bias', [(- 10), 0, 10])\ndef test_delta(xin, width, slope, order, axis, bias):\n    x = ((slope * xin) + bias)\n    delta = librosa.feature.delta(x, width=width, order=order, axis=axis)\n    assert (x.shape == delta.shape)\n    slice_orig = ([slice(None)] * x.ndim)\n    slice_out = ([slice(None)] * delta.ndim)\n    slice_orig[axis] = slice(((width // 2) + 1), (((- width) // 2) + 1))\n    slice_out[axis] = slice((width // 2), ((- width) // 2))\n    assert np.allclose((x + delta)[tuple(slice_out)], x[tuple(slice_orig)])", "masked_code": "@pytest.mark.parametrize('slope', np.linspace((- 2), 2, num=6))\n@pytest.mark.parametrize('xin', [np.vstack(([np.arange(100.0)] * 3))])\n@pytest.mark.parametrize('order', [1])\n@pytest.mark.parametrize('width, axis', [(3, 0), (3, 1), (5, 1), (7, 1)])\n@pytest.mark.parametrize('bias', [(- 10), 0, 10])\ndef test_delta(xin, width, slope, order, axis, bias):\n    x = ((slope * xin) + bias)\n    delta = librosa.feature.delta(x, width=width, order=order, axis=axis)\n    assert (x.shape == '???')\n    slice_orig = ([slice(None)] * x.ndim)\n    slice_out = ([slice(None)] * delta.ndim)\n    slice_orig[axis] = slice(((width // 2) + 1), (((- width) // 2) + 1))\n    slice_out[axis] = slice((width // 2), ((- width) // 2))\n    assert np.allclose((x + delta)[tuple(slice_out)], x[tuple(slice_orig)])", "ground_truth": "delta.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_83", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_stack_memory", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('data', [np.arange(5.0), np.remainder(np.arange(10000), 24)])\n@pytest.mark.parametrize('delay', [(- 4), (- 2), (- 1), 1, 2, 4])\n@pytest.mark.parametrize('n_steps', [1, 2, 3, 300])\ndef test_stack_memory(data, n_steps, delay):\n    data_stack = librosa.feature.stack_memory(data, n_steps=n_steps, delay=delay)\n    if (data.ndim == 1):\n        data = data.reshape((1, (- 1)))\n    (d, t) = data.shape\n    assert (data_stack.shape[0] == (n_steps * d))\n    assert (data_stack.shape[1] == t)\n    assert np.allclose(data_stack[0], data[0])\n    for i in range(d):\n        for step in range(1, n_steps):\n            if (delay > 0):\n                assert np.allclose(data[(i, :((- step) * delay))], data_stack[(((step * d) + i), (step * delay):)])\n            else:\n                assert np.allclose(data[(i, ((- step) * delay):)], data_stack[(((step * d) + i), :(step * delay))])\n    assert ((np.max(data) + 1e-07) >= np.max(data_stack))\n    assert ((np.min(data) - 1e-07) <= np.min(data_stack))", "masked_code": "@pytest.mark.parametrize('data', [np.arange(5.0), np.remainder(np.arange(10000), 24)])\n@pytest.mark.parametrize('delay', [(- 4), (- 2), (- 1), 1, 2, 4])\n@pytest.mark.parametrize('n_steps', [1, 2, 3, 300])\ndef test_stack_memory(data, n_steps, delay):\n    data_stack = librosa.feature.stack_memory(data, n_steps=n_steps, delay=delay)\n    if (data.ndim == 1):\n        data = data.reshape((1, (- 1)))\n    (d, t) = data.shape\n    assert (data_stack.shape[0] == '???')\n    assert (data_stack.shape[1] == t)\n    assert np.allclose(data_stack[0], data[0])\n    for i in range(d):\n        for step in range(1, n_steps):\n            if (delay > 0):\n                assert np.allclose(data[(i, :((- step) * delay))], data_stack[(((step * d) + i), (step * delay):)])\n            else:\n                assert np.allclose(data[(i, ((- step) * delay):)], data_stack[(((step * d) + i), :(step * delay))])\n    assert ((np.max(data) + 1e-07) >= np.max(data_stack))\n    assert ((np.min(data) - 1e-07) <= np.min(data_stack))", "ground_truth": "(n_steps * d)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_84", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_stack_memory", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('data', [np.arange(5.0), np.remainder(np.arange(10000), 24)])\n@pytest.mark.parametrize('delay', [(- 4), (- 2), (- 1), 1, 2, 4])\n@pytest.mark.parametrize('n_steps', [1, 2, 3, 300])\ndef test_stack_memory(data, n_steps, delay):\n    data_stack = librosa.feature.stack_memory(data, n_steps=n_steps, delay=delay)\n    if (data.ndim == 1):\n        data = data.reshape((1, (- 1)))\n    (d, t) = data.shape\n    assert (data_stack.shape[0] == (n_steps * d))\n    assert (data_stack.shape[1] == t)\n    assert np.allclose(data_stack[0], data[0])\n    for i in range(d):\n        for step in range(1, n_steps):\n            if (delay > 0):\n                assert np.allclose(data[(i, :((- step) * delay))], data_stack[(((step * d) + i), (step * delay):)])\n            else:\n                assert np.allclose(data[(i, ((- step) * delay):)], data_stack[(((step * d) + i), :(step * delay))])\n    assert ((np.max(data) + 1e-07) >= np.max(data_stack))\n    assert ((np.min(data) - 1e-07) <= np.min(data_stack))", "masked_code": "@pytest.mark.parametrize('data', [np.arange(5.0), np.remainder(np.arange(10000), 24)])\n@pytest.mark.parametrize('delay', [(- 4), (- 2), (- 1), 1, 2, 4])\n@pytest.mark.parametrize('n_steps', [1, 2, 3, 300])\ndef test_stack_memory(data, n_steps, delay):\n    data_stack = librosa.feature.stack_memory(data, n_steps=n_steps, delay=delay)\n    if (data.ndim == 1):\n        data = data.reshape((1, (- 1)))\n    (d, t) = data.shape\n    assert (data_stack.shape[0] == (n_steps * d))\n    assert (data_stack.shape[1] == '???')\n    assert np.allclose(data_stack[0], data[0])\n    for i in range(d):\n        for step in range(1, n_steps):\n            if (delay > 0):\n                assert np.allclose(data[(i, :((- step) * delay))], data_stack[(((step * d) + i), (step * delay):)])\n            else:\n                assert np.allclose(data[(i, ((- step) * delay):)], data_stack[(((step * d) + i), :(step * delay))])\n    assert ((np.max(data) + 1e-07) >= np.max(data_stack))\n    assert ((np.min(data) - 1e-07) <= np.min(data_stack))", "ground_truth": "t", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_85", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_spectral_bandwidth_onecol", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('freq', [None, librosa.fft_frequencies(sr=22050, n_fft=1024), (3 * librosa.fft_frequencies(sr=22050, n_fft=1024)), np.random.randn(513, 1)])\ndef test_spectral_bandwidth_onecol(S_ideal, freq):\n    bw = librosa.feature.spectral_bandwidth(S=S_ideal[(:, :1)], freq=freq)\n    assert (bw.shape == (1, 1))", "masked_code": "@pytest.mark.parametrize('freq', [None, librosa.fft_frequencies(sr=22050, n_fft=1024), (3 * librosa.fft_frequencies(sr=22050, n_fft=1024)), np.random.randn(513, 1)])\ndef test_spectral_bandwidth_onecol(S_ideal, freq):\n    bw = librosa.feature.spectral_bandwidth(S=S_ideal[(:, :1)], freq=freq)\n    assert (bw.shape == '???')", "ground_truth": "(1, 1)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_86", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_rms", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('frame_length', [2048, 2049, 4096, 4097])\n@pytest.mark.parametrize('hop_length', [128, 512, 1024])\n@pytest.mark.parametrize('center', [False, True])\n@pytest.mark.parametrize('y2', [np.random.randn(100000)])\ndef test_rms(y_ex, y2, frame_length, hop_length, center):\n    (y1, sr) = y_ex\n    y1 = librosa.util.fix_length(y1, size=(y1.size - (y1.size % frame_length)))\n    y2 = librosa.util.fix_length(y2, size=(y2.size - (y2.size % frame_length)))\n    assert ((y1.size % frame_length) == 0)\n    assert ((y2.size % frame_length) == 0)\n    S1 = librosa.magphase(librosa.stft(y1, n_fft=frame_length, hop_length=hop_length, window=np.ones, center=center))[0]\n    S2 = librosa.magphase(librosa.stft(y2, n_fft=frame_length, hop_length=hop_length, window=np.ones, center=center))[0]\n    rms1 = librosa.feature.rms(S=S1, frame_length=frame_length, hop_length=hop_length)\n    rms2 = librosa.feature.rms(y=y1, frame_length=frame_length, hop_length=hop_length, center=center)\n    rms3 = librosa.feature.rms(S=S2, frame_length=frame_length, hop_length=hop_length)\n    rms4 = librosa.feature.rms(y=y2, frame_length=frame_length, hop_length=hop_length, center=center)\n    assert (rms1.shape == rms2.shape)\n    assert (rms3.shape == rms4.shape)\n    np.testing.assert_allclose(rms1, rms2, atol=0.0005)\n    np.testing.assert_allclose(rms3, rms4, atol=0.0005)", "masked_code": "@pytest.mark.parametrize('frame_length', [2048, 2049, 4096, 4097])\n@pytest.mark.parametrize('hop_length', [128, 512, 1024])\n@pytest.mark.parametrize('center', [False, True])\n@pytest.mark.parametrize('y2', [np.random.randn(100000)])\ndef test_rms(y_ex, y2, frame_length, hop_length, center):\n    (y1, sr) = y_ex\n    y1 = librosa.util.fix_length(y1, size=(y1.size - (y1.size % frame_length)))\n    y2 = librosa.util.fix_length(y2, size=(y2.size - (y2.size % frame_length)))\n    assert ((y1.size % frame_length) == 0)\n    assert ((y2.size % frame_length) == 0)\n    S1 = librosa.magphase(librosa.stft(y1, n_fft=frame_length, hop_length=hop_length, window=np.ones, center=center))[0]\n    S2 = librosa.magphase(librosa.stft(y2, n_fft=frame_length, hop_length=hop_length, window=np.ones, center=center))[0]\n    rms1 = librosa.feature.rms(S=S1, frame_length=frame_length, hop_length=hop_length)\n    rms2 = librosa.feature.rms(y=y1, frame_length=frame_length, hop_length=hop_length, center=center)\n    rms3 = librosa.feature.rms(S=S2, frame_length=frame_length, hop_length=hop_length)\n    rms4 = librosa.feature.rms(y=y2, frame_length=frame_length, hop_length=hop_length, center=center)\n    assert (rms1.shape == '???')\n    assert (rms3.shape == rms4.shape)\n    np.testing.assert_allclose(rms1, rms2, atol=0.0005)\n    np.testing.assert_allclose(rms3, rms4, atol=0.0005)", "ground_truth": "rms2.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_87", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_rms", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('frame_length', [2048, 2049, 4096, 4097])\n@pytest.mark.parametrize('hop_length', [128, 512, 1024])\n@pytest.mark.parametrize('center', [False, True])\n@pytest.mark.parametrize('y2', [np.random.randn(100000)])\ndef test_rms(y_ex, y2, frame_length, hop_length, center):\n    (y1, sr) = y_ex\n    y1 = librosa.util.fix_length(y1, size=(y1.size - (y1.size % frame_length)))\n    y2 = librosa.util.fix_length(y2, size=(y2.size - (y2.size % frame_length)))\n    assert ((y1.size % frame_length) == 0)\n    assert ((y2.size % frame_length) == 0)\n    S1 = librosa.magphase(librosa.stft(y1, n_fft=frame_length, hop_length=hop_length, window=np.ones, center=center))[0]\n    S2 = librosa.magphase(librosa.stft(y2, n_fft=frame_length, hop_length=hop_length, window=np.ones, center=center))[0]\n    rms1 = librosa.feature.rms(S=S1, frame_length=frame_length, hop_length=hop_length)\n    rms2 = librosa.feature.rms(y=y1, frame_length=frame_length, hop_length=hop_length, center=center)\n    rms3 = librosa.feature.rms(S=S2, frame_length=frame_length, hop_length=hop_length)\n    rms4 = librosa.feature.rms(y=y2, frame_length=frame_length, hop_length=hop_length, center=center)\n    assert (rms1.shape == rms2.shape)\n    assert (rms3.shape == rms4.shape)\n    np.testing.assert_allclose(rms1, rms2, atol=0.0005)\n    np.testing.assert_allclose(rms3, rms4, atol=0.0005)", "masked_code": "@pytest.mark.parametrize('frame_length', [2048, 2049, 4096, 4097])\n@pytest.mark.parametrize('hop_length', [128, 512, 1024])\n@pytest.mark.parametrize('center', [False, True])\n@pytest.mark.parametrize('y2', [np.random.randn(100000)])\ndef test_rms(y_ex, y2, frame_length, hop_length, center):\n    (y1, sr) = y_ex\n    y1 = librosa.util.fix_length(y1, size=(y1.size - (y1.size % frame_length)))\n    y2 = librosa.util.fix_length(y2, size=(y2.size - (y2.size % frame_length)))\n    assert ((y1.size % frame_length) == 0)\n    assert ((y2.size % frame_length) == 0)\n    S1 = librosa.magphase(librosa.stft(y1, n_fft=frame_length, hop_length=hop_length, window=np.ones, center=center))[0]\n    S2 = librosa.magphase(librosa.stft(y2, n_fft=frame_length, hop_length=hop_length, window=np.ones, center=center))[0]\n    rms1 = librosa.feature.rms(S=S1, frame_length=frame_length, hop_length=hop_length)\n    rms2 = librosa.feature.rms(y=y1, frame_length=frame_length, hop_length=hop_length, center=center)\n    rms3 = librosa.feature.rms(S=S2, frame_length=frame_length, hop_length=hop_length)\n    rms4 = librosa.feature.rms(y=y2, frame_length=frame_length, hop_length=hop_length, center=center)\n    assert (rms1.shape == rms2.shape)\n    assert (rms3.shape == '???')\n    np.testing.assert_allclose(rms1, rms2, atol=0.0005)\n    np.testing.assert_allclose(rms3, rms4, atol=0.0005)", "ground_truth": "rms4.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_88", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_tonnetz_audio", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "def test_tonnetz_audio(y_ex):\n    (y, sr) = y_ex\n    tonnetz = librosa.feature.tonnetz(y=y, sr=sr)\n    assert (tonnetz.shape[0] == 6)", "masked_code": "def test_tonnetz_audio(y_ex):\n    (y, sr) = y_ex\n    tonnetz = librosa.feature.tonnetz(y=y, sr=sr)\n    assert (tonnetz.shape[0] == '???')", "ground_truth": "6", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_89", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_tonnetz_cqt", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "def test_tonnetz_cqt(y_ex):\n    (y, sr) = y_ex\n    chroma_cqt = librosa.feature.chroma_cqt(y=y, sr=sr, n_chroma=36)\n    tonnetz = librosa.feature.tonnetz(chroma=chroma_cqt, sr=sr)\n    assert (tonnetz.shape[1] == chroma_cqt.shape[1])\n    assert (tonnetz.shape[0] == 6)", "masked_code": "def test_tonnetz_cqt(y_ex):\n    (y, sr) = y_ex\n    chroma_cqt = librosa.feature.chroma_cqt(y=y, sr=sr, n_chroma=36)\n    tonnetz = librosa.feature.tonnetz(chroma=chroma_cqt, sr=sr)\n    assert (tonnetz.shape[1] == '???')\n    assert (tonnetz.shape[0] == 6)", "ground_truth": "chroma_cqt.shape[1]", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_90", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_tonnetz_cqt", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "def test_tonnetz_cqt(y_ex):\n    (y, sr) = y_ex\n    chroma_cqt = librosa.feature.chroma_cqt(y=y, sr=sr, n_chroma=36)\n    tonnetz = librosa.feature.tonnetz(chroma=chroma_cqt, sr=sr)\n    assert (tonnetz.shape[1] == chroma_cqt.shape[1])\n    assert (tonnetz.shape[0] == 6)", "masked_code": "def test_tonnetz_cqt(y_ex):\n    (y, sr) = y_ex\n    chroma_cqt = librosa.feature.chroma_cqt(y=y, sr=sr, n_chroma=36)\n    tonnetz = librosa.feature.tonnetz(chroma=chroma_cqt, sr=sr)\n    assert (tonnetz.shape[1] == chroma_cqt.shape[1])\n    assert (tonnetz.shape[0] == '???')", "ground_truth": "6", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_91", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_tonnetz_msaf", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "def test_tonnetz_msaf():\n    tonnetz_chroma = np.load(os.path.join('tests', 'data', 'feature-tonnetz-chroma.npy'))\n    tonnetz_msaf = np.load(os.path.join('tests', 'data', 'feature-tonnetz-msaf.npy'))\n    tonnetz = librosa.feature.tonnetz(chroma=tonnetz_chroma)\n    assert (tonnetz.shape[1] == tonnetz_chroma.shape[1])\n    assert (tonnetz.shape[0] == 6)\n    assert np.allclose(tonnetz_msaf, tonnetz)", "masked_code": "def test_tonnetz_msaf():\n    tonnetz_chroma = np.load(os.path.join('tests', 'data', 'feature-tonnetz-chroma.npy'))\n    tonnetz_msaf = np.load(os.path.join('tests', 'data', 'feature-tonnetz-msaf.npy'))\n    tonnetz = librosa.feature.tonnetz(chroma=tonnetz_chroma)\n    assert (tonnetz.shape[1] == '???')\n    assert (tonnetz.shape[0] == 6)\n    assert np.allclose(tonnetz_msaf, tonnetz)", "ground_truth": "tonnetz_chroma.shape[1]", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_92", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_tonnetz_msaf", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "def test_tonnetz_msaf():\n    tonnetz_chroma = np.load(os.path.join('tests', 'data', 'feature-tonnetz-chroma.npy'))\n    tonnetz_msaf = np.load(os.path.join('tests', 'data', 'feature-tonnetz-msaf.npy'))\n    tonnetz = librosa.feature.tonnetz(chroma=tonnetz_chroma)\n    assert (tonnetz.shape[1] == tonnetz_chroma.shape[1])\n    assert (tonnetz.shape[0] == 6)\n    assert np.allclose(tonnetz_msaf, tonnetz)", "masked_code": "def test_tonnetz_msaf():\n    tonnetz_chroma = np.load(os.path.join('tests', 'data', 'feature-tonnetz-chroma.npy'))\n    tonnetz_msaf = np.load(os.path.join('tests', 'data', 'feature-tonnetz-msaf.npy'))\n    tonnetz = librosa.feature.tonnetz(chroma=tonnetz_chroma)\n    assert (tonnetz.shape[1] == tonnetz_chroma.shape[1])\n    assert (tonnetz.shape[0] == '???')\n    assert np.allclose(tonnetz_msaf, tonnetz)", "ground_truth": "6", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_93", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_tempogram_odf_peak", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('tempo', [60, 90, 200])\n@pytest.mark.parametrize('win_length', [192, 384])\n@pytest.mark.parametrize('window', ['hann', np.ones])\n@pytest.mark.parametrize('norm', [None, 1, 2, np.inf])\ndef test_tempogram_odf_peak(tempo, win_length, window, norm):\n    sr = 22050\n    hop_length = 512\n    duration = 8\n    odf = np.zeros(((duration * sr) // hop_length))\n    spacing = ((sr * 60.0) // (hop_length * tempo))\n    odf[::int(spacing)] = 1\n    tempogram = librosa.feature.tempogram(onset_envelope=odf, sr=sr, hop_length=hop_length, win_length=win_length, window=window, norm=norm)\n    assert (tempogram.shape[0] == win_length)\n    assert (tempogram.shape[1] == len(odf))\n    idx = np.where(librosa.util.localmax(tempogram.max(axis=1)))[0]\n    assert np.allclose(idx, (spacing * np.arange(1, (1 + len(idx)))))", "masked_code": "@pytest.mark.parametrize('tempo', [60, 90, 200])\n@pytest.mark.parametrize('win_length', [192, 384])\n@pytest.mark.parametrize('window', ['hann', np.ones])\n@pytest.mark.parametrize('norm', [None, 1, 2, np.inf])\ndef test_tempogram_odf_peak(tempo, win_length, window, norm):\n    sr = 22050\n    hop_length = 512\n    duration = 8\n    odf = np.zeros(((duration * sr) // hop_length))\n    spacing = ((sr * 60.0) // (hop_length * tempo))\n    odf[::int(spacing)] = 1\n    tempogram = librosa.feature.tempogram(onset_envelope=odf, sr=sr, hop_length=hop_length, win_length=win_length, window=window, norm=norm)\n    assert (tempogram.shape[0] == '???')\n    assert (tempogram.shape[1] == len(odf))\n    idx = np.where(librosa.util.localmax(tempogram.max(axis=1)))[0]\n    assert np.allclose(idx, (spacing * np.arange(1, (1 + len(idx)))))", "ground_truth": "win_length", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_94", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_tempogram_odf_peak", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('tempo', [60, 90, 200])\n@pytest.mark.parametrize('win_length', [192, 384])\n@pytest.mark.parametrize('window', ['hann', np.ones])\n@pytest.mark.parametrize('norm', [None, 1, 2, np.inf])\ndef test_tempogram_odf_peak(tempo, win_length, window, norm):\n    sr = 22050\n    hop_length = 512\n    duration = 8\n    odf = np.zeros(((duration * sr) // hop_length))\n    spacing = ((sr * 60.0) // (hop_length * tempo))\n    odf[::int(spacing)] = 1\n    tempogram = librosa.feature.tempogram(onset_envelope=odf, sr=sr, hop_length=hop_length, win_length=win_length, window=window, norm=norm)\n    assert (tempogram.shape[0] == win_length)\n    assert (tempogram.shape[1] == len(odf))\n    idx = np.where(librosa.util.localmax(tempogram.max(axis=1)))[0]\n    assert np.allclose(idx, (spacing * np.arange(1, (1 + len(idx)))))", "masked_code": "@pytest.mark.parametrize('tempo', [60, 90, 200])\n@pytest.mark.parametrize('win_length', [192, 384])\n@pytest.mark.parametrize('window', ['hann', np.ones])\n@pytest.mark.parametrize('norm', [None, 1, 2, np.inf])\ndef test_tempogram_odf_peak(tempo, win_length, window, norm):\n    sr = 22050\n    hop_length = 512\n    duration = 8\n    odf = np.zeros(((duration * sr) // hop_length))\n    spacing = ((sr * 60.0) // (hop_length * tempo))\n    odf[::int(spacing)] = 1\n    tempogram = librosa.feature.tempogram(onset_envelope=odf, sr=sr, hop_length=hop_length, win_length=win_length, window=window, norm=norm)\n    assert (tempogram.shape[0] == win_length)\n    assert (tempogram.shape[1] == '???')\n    idx = np.where(librosa.util.localmax(tempogram.max(axis=1)))[0]\n    assert np.allclose(idx, (spacing * np.arange(1, (1 + len(idx)))))", "ground_truth": "len(odf)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_95", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_mfcc", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('S', [librosa.power_to_db((np.random.randn(128, 1) ** 2), ref=np.max)])\n@pytest.mark.parametrize('dct_type', [1, 2, 3])\n@pytest.mark.parametrize('norm', [None, 'ortho'])\n@pytest.mark.parametrize('n_mfcc', [13, 20])\n@pytest.mark.parametrize('lifter', [0, 13])\ndef test_mfcc(S, dct_type, norm, n_mfcc, lifter):\n    E_total = np.sum(S, axis=0)\n    mfcc = librosa.feature.mfcc(S=S, dct_type=dct_type, norm=norm, n_mfcc=n_mfcc, lifter=lifter)\n    assert (mfcc.shape[0] == n_mfcc)\n    assert (mfcc.shape[1] == S.shape[1])\n    if (dct_type == 2):\n        assert (np.var((mfcc[0] / E_total)) <= 1e-29)", "masked_code": "@pytest.mark.parametrize('S', [librosa.power_to_db((np.random.randn(128, 1) ** 2), ref=np.max)])\n@pytest.mark.parametrize('dct_type', [1, 2, 3])\n@pytest.mark.parametrize('norm', [None, 'ortho'])\n@pytest.mark.parametrize('n_mfcc', [13, 20])\n@pytest.mark.parametrize('lifter', [0, 13])\ndef test_mfcc(S, dct_type, norm, n_mfcc, lifter):\n    E_total = np.sum(S, axis=0)\n    mfcc = librosa.feature.mfcc(S=S, dct_type=dct_type, norm=norm, n_mfcc=n_mfcc, lifter=lifter)\n    assert (mfcc.shape[0] == '???')\n    assert (mfcc.shape[1] == S.shape[1])\n    if (dct_type == 2):\n        assert (np.var((mfcc[0] / E_total)) <= 1e-29)", "ground_truth": "n_mfcc", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_96", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_mfcc", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('S', [librosa.power_to_db((np.random.randn(128, 1) ** 2), ref=np.max)])\n@pytest.mark.parametrize('dct_type', [1, 2, 3])\n@pytest.mark.parametrize('norm', [None, 'ortho'])\n@pytest.mark.parametrize('n_mfcc', [13, 20])\n@pytest.mark.parametrize('lifter', [0, 13])\ndef test_mfcc(S, dct_type, norm, n_mfcc, lifter):\n    E_total = np.sum(S, axis=0)\n    mfcc = librosa.feature.mfcc(S=S, dct_type=dct_type, norm=norm, n_mfcc=n_mfcc, lifter=lifter)\n    assert (mfcc.shape[0] == n_mfcc)\n    assert (mfcc.shape[1] == S.shape[1])\n    if (dct_type == 2):\n        assert (np.var((mfcc[0] / E_total)) <= 1e-29)", "masked_code": "@pytest.mark.parametrize('S', [librosa.power_to_db((np.random.randn(128, 1) ** 2), ref=np.max)])\n@pytest.mark.parametrize('dct_type', [1, 2, 3])\n@pytest.mark.parametrize('norm', [None, 'ortho'])\n@pytest.mark.parametrize('n_mfcc', [13, 20])\n@pytest.mark.parametrize('lifter', [0, 13])\ndef test_mfcc(S, dct_type, norm, n_mfcc, lifter):\n    E_total = np.sum(S, axis=0)\n    mfcc = librosa.feature.mfcc(S=S, dct_type=dct_type, norm=norm, n_mfcc=n_mfcc, lifter=lifter)\n    assert (mfcc.shape[0] == n_mfcc)\n    assert (mfcc.shape[1] == '???')\n    if (dct_type == 2):\n        assert (np.var((mfcc[0] / E_total)) <= 1e-29)", "ground_truth": "S.shape[1]", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_97", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_mel_to_stft", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('power', [1, 2])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('n_fft', [1024, 2048])\ndef test_mel_to_stft(power, dtype, n_fft):\n    srand()\n    mel_basis = librosa.filters.mel(sr=22050, n_fft=n_fft, n_mels=128, dtype=dtype)\n    stft_orig = (np.random.randn(((n_fft // 2) + 1), 4) ** power)\n    mels = mel_basis.dot(stft_orig.astype(dtype))\n    stft = librosa.feature.inverse.mel_to_stft(mels, power=power, n_fft=n_fft)\n    assert (stft.dtype == dtype)\n    assert np.all((stft >= 0))\n    assert (stft.shape[0] == (1 + (n_fft // 2)))\n    assert (np.sqrt(np.mean(((mel_basis.dot((stft ** power)) - mels) ** 2))) <= 0.05)", "masked_code": "@pytest.mark.parametrize('power', [1, 2])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('n_fft', [1024, 2048])\ndef test_mel_to_stft(power, dtype, n_fft):\n    srand()\n    mel_basis = librosa.filters.mel(sr=22050, n_fft=n_fft, n_mels=128, dtype=dtype)\n    stft_orig = (np.random.randn(((n_fft // 2) + 1), 4) ** power)\n    mels = mel_basis.dot(stft_orig.astype(dtype))\n    stft = librosa.feature.inverse.mel_to_stft(mels, power=power, n_fft=n_fft)\n    assert (stft.dtype == '???')\n    assert np.all((stft >= 0))\n    assert (stft.shape[0] == (1 + (n_fft // 2)))\n    assert (np.sqrt(np.mean(((mel_basis.dot((stft ** power)) - mels) ** 2))) <= 0.05)", "ground_truth": "dtype", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_98", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_mel_to_stft", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('power', [1, 2])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('n_fft', [1024, 2048])\ndef test_mel_to_stft(power, dtype, n_fft):\n    srand()\n    mel_basis = librosa.filters.mel(sr=22050, n_fft=n_fft, n_mels=128, dtype=dtype)\n    stft_orig = (np.random.randn(((n_fft // 2) + 1), 4) ** power)\n    mels = mel_basis.dot(stft_orig.astype(dtype))\n    stft = librosa.feature.inverse.mel_to_stft(mels, power=power, n_fft=n_fft)\n    assert (stft.dtype == dtype)\n    assert np.all((stft >= 0))\n    assert (stft.shape[0] == (1 + (n_fft // 2)))\n    assert (np.sqrt(np.mean(((mel_basis.dot((stft ** power)) - mels) ** 2))) <= 0.05)", "masked_code": "@pytest.mark.parametrize('power', [1, 2])\n@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('n_fft', [1024, 2048])\ndef test_mel_to_stft(power, dtype, n_fft):\n    srand()\n    mel_basis = librosa.filters.mel(sr=22050, n_fft=n_fft, n_mels=128, dtype=dtype)\n    stft_orig = (np.random.randn(((n_fft // 2) + 1), 4) ** power)\n    mels = mel_basis.dot(stft_orig.astype(dtype))\n    stft = librosa.feature.inverse.mel_to_stft(mels, power=power, n_fft=n_fft)\n    assert (stft.dtype == dtype)\n    assert np.all((stft >= 0))\n    assert (stft.shape[0] == '???')\n    assert (np.sqrt(np.mean(((mel_basis.dot((stft ** power)) - mels) ** 2))) <= 0.05)", "ground_truth": "(1 + (n_fft // 2))", "quality_analysis": {"complexity_score": 13, "left_complexity": 6, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_99", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_mel_to_audio", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "def test_mel_to_audio():\n    y = librosa.tone(440.0, sr=22050, duration=1)\n    M = librosa.feature.melspectrogram(y=y, sr=22050)\n    y_inv = librosa.feature.inverse.mel_to_audio(M, sr=22050, length=len(y))\n    assert (len(y) == len(y_inv))\n    assert librosa.util.valid_audio(y_inv)", "masked_code": "def test_mel_to_audio():\n    y = librosa.tone(440.0, sr=22050, duration=1)\n    M = librosa.feature.melspectrogram(y=y, sr=22050)\n    y_inv = librosa.feature.inverse.mel_to_audio(M, sr=22050, length=len(y))\n    assert (len(y) == '???')\n    assert librosa.util.valid_audio(y_inv)", "ground_truth": "len(y_inv)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_100", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_mfcc_to_mel", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('n_mfcc', [13, 20])\n@pytest.mark.parametrize('n_mels', [64, 128])\n@pytest.mark.parametrize('dct_type', [2, 3])\n@pytest.mark.parametrize('lifter', [(- 1), 0, 1, 2, 3])\n@pytest.mark.parametrize('y', [librosa.tone(440.0, sr=22050, duration=1)])\ndef test_mfcc_to_mel(y, n_mfcc, n_mels, dct_type, lifter):\n    mfcc = librosa.feature.mfcc(y=y, sr=22050, n_mels=n_mels, n_mfcc=n_mfcc, dct_type=dct_type)\n    if (lifter < 0):\n        with pytest.raises(librosa.ParameterError):\n            librosa.feature.inverse.mfcc_to_mel((mfcc * (10 ** 3)), n_mels=n_mels, dct_type=dct_type, lifter=lifter)\n    elif (lifter == 0):\n        melspec = librosa.feature.melspectrogram(y=y, sr=22050, n_mels=n_mels)\n        mel_recover = librosa.feature.inverse.mfcc_to_mel(mfcc, n_mels=n_mels, dct_type=dct_type)\n        assert (melspec.shape == mel_recover.shape)\n        assert np.all((mel_recover >= 0))\n    elif (lifter == 2):\n        with pytest.warns((UserWarning, RuntimeWarning)):\n            librosa.feature.inverse.mfcc_to_mel((mfcc * (10 ** 3)), n_mels=n_mels, dct_type=dct_type, lifter=lifter)\n    else:\n        ones = np.ones(mfcc.shape, dtype=mfcc.dtype)\n        n_mfcc = mfcc.shape[0]\n        idx = np.arange(1, (1 + n_mfcc), dtype=mfcc.dtype)\n        lifter_sine = (1 + ((lifter * 0.5) * np.sin(((np.pi * idx) / lifter))[(:, np.newaxis)]))\n        mel_recover = librosa.feature.inverse.mfcc_to_mel((ones * lifter_sine), n_mels=n_mels, dct_type=dct_type, lifter=lifter)\n        mel_expected = librosa.feature.inverse.mfcc_to_mel(ones, n_mels=n_mels, dct_type=dct_type, lifter=0)\n        np.testing.assert_almost_equal(mel_recover, mel_expected, 3)", "masked_code": "@pytest.mark.parametrize('n_mfcc', [13, 20])\n@pytest.mark.parametrize('n_mels', [64, 128])\n@pytest.mark.parametrize('dct_type', [2, 3])\n@pytest.mark.parametrize('lifter', [(- 1), 0, 1, 2, 3])\n@pytest.mark.parametrize('y', [librosa.tone(440.0, sr=22050, duration=1)])\ndef test_mfcc_to_mel(y, n_mfcc, n_mels, dct_type, lifter):\n    mfcc = librosa.feature.mfcc(y=y, sr=22050, n_mels=n_mels, n_mfcc=n_mfcc, dct_type=dct_type)\n    if (lifter < 0):\n        with pytest.raises(librosa.ParameterError):\n            librosa.feature.inverse.mfcc_to_mel((mfcc * (10 ** 3)), n_mels=n_mels, dct_type=dct_type, lifter=lifter)\n    elif (lifter == 0):\n        melspec = librosa.feature.melspectrogram(y=y, sr=22050, n_mels=n_mels)\n        mel_recover = librosa.feature.inverse.mfcc_to_mel(mfcc, n_mels=n_mels, dct_type=dct_type)\n        assert (melspec.shape == '???')\n        assert np.all((mel_recover >= 0))\n    elif (lifter == 2):\n        with pytest.warns((UserWarning, RuntimeWarning)):\n            librosa.feature.inverse.mfcc_to_mel((mfcc * (10 ** 3)), n_mels=n_mels, dct_type=dct_type, lifter=lifter)\n    else:\n        ones = np.ones(mfcc.shape, dtype=mfcc.dtype)\n        n_mfcc = mfcc.shape[0]\n        idx = np.arange(1, (1 + n_mfcc), dtype=mfcc.dtype)\n        lifter_sine = (1 + ((lifter * 0.5) * np.sin(((np.pi * idx) / lifter))[(:, np.newaxis)]))\n        mel_recover = librosa.feature.inverse.mfcc_to_mel((ones * lifter_sine), n_mels=n_mels, dct_type=dct_type, lifter=lifter)\n        mel_expected = librosa.feature.inverse.mfcc_to_mel(ones, n_mels=n_mels, dct_type=dct_type, lifter=0)\n        np.testing.assert_almost_equal(mel_recover, mel_expected, 3)", "ground_truth": "mel_recover.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_101", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_mfcc_to_audio", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "@pytest.mark.parametrize('n_mfcc', [13, 20])\n@pytest.mark.parametrize('n_mels', [64, 128])\n@pytest.mark.parametrize('dct_type', [2, 3])\n@pytest.mark.parametrize('lifter', [0, 3])\n@pytest.mark.parametrize('y', [librosa.tone(440.0, sr=22050, duration=1)])\ndef test_mfcc_to_audio(y, n_mfcc, n_mels, dct_type, lifter):\n    mfcc = librosa.feature.mfcc(y=y, sr=22050, n_mels=n_mels, n_mfcc=n_mfcc, dct_type=dct_type)\n    y_inv = librosa.feature.inverse.mfcc_to_audio(mfcc, n_mels=n_mels, dct_type=dct_type, lifter=lifter, length=len(y))\n    assert (len(y) == len(y_inv))\n    assert librosa.util.valid_audio(y_inv)", "masked_code": "@pytest.mark.parametrize('n_mfcc', [13, 20])\n@pytest.mark.parametrize('n_mels', [64, 128])\n@pytest.mark.parametrize('dct_type', [2, 3])\n@pytest.mark.parametrize('lifter', [0, 3])\n@pytest.mark.parametrize('y', [librosa.tone(440.0, sr=22050, duration=1)])\ndef test_mfcc_to_audio(y, n_mfcc, n_mels, dct_type, lifter):\n    mfcc = librosa.feature.mfcc(y=y, sr=22050, n_mels=n_mels, n_mfcc=n_mfcc, dct_type=dct_type)\n    y_inv = librosa.feature.inverse.mfcc_to_audio(mfcc, n_mels=n_mels, dct_type=dct_type, lifter=lifter, length=len(y))\n    assert (len(y) == '???')\n    assert librosa.util.valid_audio(y_inv)", "ground_truth": "len(y_inv)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_102", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_chroma_vqt_bpo", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "def test_chroma_vqt_bpo(y_ex):\n    (y, sr) = y_ex\n    chroma = librosa.feature.chroma_vqt(y=y, sr=sr, intervals=[1, 1.25, 1.5], bins_per_octave=12)\n    assert (chroma.shape[0] == 3)\n    chroma2 = librosa.feature.chroma_vqt(y=y, sr=sr, intervals='equal', bins_per_octave=12)\n    assert (chroma2.shape[0] == 12)", "masked_code": "def test_chroma_vqt_bpo(y_ex):\n    (y, sr) = y_ex\n    chroma = librosa.feature.chroma_vqt(y=y, sr=sr, intervals=[1, 1.25, 1.5], bins_per_octave=12)\n    assert (chroma.shape[0] == '???')\n    chroma2 = librosa.feature.chroma_vqt(y=y, sr=sr, intervals='equal', bins_per_octave=12)\n    assert (chroma2.shape[0] == 12)", "ground_truth": "3", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_103", "reponame": "librosa", "testpath": "tests/test_features.py", "testname": "test_features.py", "classname": null, "funcname": "test_chroma_vqt_bpo", "imports": ["import warnings", "import numpy as np", "import pytest", "import librosa", "from test_core import load, srand", "import os"], "code": "def test_chroma_vqt_bpo(y_ex):\n    (y, sr) = y_ex\n    chroma = librosa.feature.chroma_vqt(y=y, sr=sr, intervals=[1, 1.25, 1.5], bins_per_octave=12)\n    assert (chroma.shape[0] == 3)\n    chroma2 = librosa.feature.chroma_vqt(y=y, sr=sr, intervals='equal', bins_per_octave=12)\n    assert (chroma2.shape[0] == 12)", "masked_code": "def test_chroma_vqt_bpo(y_ex):\n    (y, sr) = y_ex\n    chroma = librosa.feature.chroma_vqt(y=y, sr=sr, intervals=[1, 1.25, 1.5], bins_per_octave=12)\n    assert (chroma.shape[0] == 3)\n    chroma2 = librosa.feature.chroma_vqt(y=y, sr=sr, intervals='equal', bins_per_octave=12)\n    assert (chroma2.shape[0] == '???')", "ground_truth": "12", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_104", "reponame": "librosa", "testpath": "tests/test_filters.py", "testname": "test_filters.py", "classname": null, "funcname": "test_melfb", "imports": ["import os", "from contextlib import nullcontext as dnr", "import warnings", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "from typing import Any, ContextManager", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('infile', files(os.path.join('tests', 'data', 'feature-melfb-*.mat')))\n@pytest.mark.filterwarnings('ignore:Empty filters detected')\ndef test_melfb(infile):\n    DATA = load(infile)\n    wts = librosa.filters.mel(sr=DATA['sr'][(0, 0)], n_fft=DATA['nfft'][(0, 0)], n_mels=DATA['nfilts'][(0, 0)], fmin=DATA['fmin'][(0, 0)], fmax=DATA['fmax'][(0, 0)], htk=DATA['htk'][(0, 0)])\n    wts = np.pad(wts, [(0, 0), (0, ((DATA['nfft'][(0, 0)] // 2) - 1))], mode='constant')\n    assert (wts.shape == DATA['wts'].shape)\n    assert np.allclose(wts, DATA['wts'])", "masked_code": "@pytest.mark.parametrize('infile', files(os.path.join('tests', 'data', 'feature-melfb-*.mat')))\n@pytest.mark.filterwarnings('ignore:Empty filters detected')\ndef test_melfb(infile):\n    DATA = load(infile)\n    wts = librosa.filters.mel(sr=DATA['sr'][(0, 0)], n_fft=DATA['nfft'][(0, 0)], n_mels=DATA['nfilts'][(0, 0)], fmin=DATA['fmin'][(0, 0)], fmax=DATA['fmax'][(0, 0)], htk=DATA['htk'][(0, 0)])\n    wts = np.pad(wts, [(0, 0), (0, ((DATA['nfft'][(0, 0)] // 2) - 1))], mode='constant')\n    assert (wts.shape == '???')\n    assert np.allclose(wts, DATA['wts'])", "ground_truth": "DATA['wts'].shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_105", "reponame": "librosa", "testpath": "tests/test_filters.py", "testname": "test_filters.py", "classname": null, "funcname": "test_melfbnorm", "imports": ["import os", "from contextlib import nullcontext as dnr", "import warnings", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "from typing import Any, ContextManager", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('infile', files(os.path.join('tests', 'data', 'feature-melfbnorm-*.mat')))\ndef test_melfbnorm(infile):\n    DATA = load(infile)\n    if (DATA['norm'].shape[(- 1)] == 0):\n        norm = None\n    else:\n        norm = DATA['norm'][(0, 0)]\n    wts = librosa.filters.mel(sr=DATA['sr'][(0, 0)], n_fft=DATA['nfft'][(0, 0)], n_mels=DATA['nfilts'][(0, 0)], fmin=DATA['fmin'][(0, 0)], fmax=DATA['fmax'][(0, 0)], htk=DATA['htk'][(0, 0)], norm=norm)\n    wts = np.pad(wts, [(0, 0), (0, ((DATA['nfft'][(0, 0)] // 2) - 1))], mode='constant')\n    assert (wts.shape == DATA['wts'].shape)\n    assert np.allclose(wts, DATA['wts'])", "masked_code": "@pytest.mark.parametrize('infile', files(os.path.join('tests', 'data', 'feature-melfbnorm-*.mat')))\ndef test_melfbnorm(infile):\n    DATA = load(infile)\n    if (DATA['norm'].shape[(- 1)] == 0):\n        norm = None\n    else:\n        norm = DATA['norm'][(0, 0)]\n    wts = librosa.filters.mel(sr=DATA['sr'][(0, 0)], n_fft=DATA['nfft'][(0, 0)], n_mels=DATA['nfilts'][(0, 0)], fmin=DATA['fmin'][(0, 0)], fmax=DATA['fmax'][(0, 0)], htk=DATA['htk'][(0, 0)], norm=norm)\n    wts = np.pad(wts, [(0, 0), (0, ((DATA['nfft'][(0, 0)] // 2) - 1))], mode='constant')\n    assert (wts.shape == '???')\n    assert np.allclose(wts, DATA['wts'])", "ground_truth": "DATA['wts'].shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_106", "reponame": "librosa", "testpath": "tests/test_filters.py", "testname": "test_filters.py", "classname": null, "funcname": "test_chromafb", "imports": ["import os", "from contextlib import nullcontext as dnr", "import warnings", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "from typing import Any, ContextManager", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('infile', files(os.path.join('tests', 'data', 'feature-chromafb-*.mat')))\ndef test_chromafb(infile):\n    DATA = load(infile)\n    octwidth = DATA['octwidth'][(0, 0)]\n    if (octwidth == 0):\n        octwidth = None\n    A440 = DATA['a440'][(0, 0)]\n    tuning = (DATA['nchroma'][(0, 0)] * (np.log2(A440) - np.log2(440.0)))\n    wts = librosa.filters.chroma(sr=DATA['sr'][(0, 0)], n_fft=DATA['nfft'][(0, 0)], n_chroma=DATA['nchroma'][(0, 0)], tuning=tuning, ctroct=DATA['ctroct'][(0, 0)], octwidth=octwidth, norm=2, base_c=False)\n    wts = np.pad(wts, [(0, 0), (0, ((DATA['nfft'][(0, 0)] // 2) - 1))], mode='constant')\n    assert (wts.shape == DATA['wts'].shape)\n    assert np.allclose(wts, DATA['wts'])", "masked_code": "@pytest.mark.parametrize('infile', files(os.path.join('tests', 'data', 'feature-chromafb-*.mat')))\ndef test_chromafb(infile):\n    DATA = load(infile)\n    octwidth = DATA['octwidth'][(0, 0)]\n    if (octwidth == 0):\n        octwidth = None\n    A440 = DATA['a440'][(0, 0)]\n    tuning = (DATA['nchroma'][(0, 0)] * (np.log2(A440) - np.log2(440.0)))\n    wts = librosa.filters.chroma(sr=DATA['sr'][(0, 0)], n_fft=DATA['nfft'][(0, 0)], n_chroma=DATA['nchroma'][(0, 0)], tuning=tuning, ctroct=DATA['ctroct'][(0, 0)], octwidth=octwidth, norm=2, base_c=False)\n    wts = np.pad(wts, [(0, 0), (0, ((DATA['nfft'][(0, 0)] // 2) - 1))], mode='constant')\n    assert (wts.shape == '???')\n    assert np.allclose(wts, DATA['wts'])", "ground_truth": "DATA['wts'].shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_107", "reponame": "librosa", "testpath": "tests/test_filters.py", "testname": "test_filters.py", "classname": null, "funcname": "test_constant_q", "imports": ["import os", "from contextlib import nullcontext as dnr", "import warnings", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "from typing import Any, ContextManager", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('sr', [11025])\n@pytest.mark.parametrize('fmin', [None, librosa.note_to_hz('C3')])\n@pytest.mark.parametrize('n_bins', [12, 24])\n@pytest.mark.parametrize('bins_per_octave', [12, 24])\n@pytest.mark.parametrize('filter_scale', [1, 2])\n@pytest.mark.parametrize('norm', [1, 2])\n@pytest.mark.parametrize('pad_fft', [False, True])\ndef test_constant_q(sr, fmin, n_bins, bins_per_octave, filter_scale, pad_fft, norm):\n    with pytest.warns(FutureWarning, match='Deprecated'):\n        (F, lengths) = librosa.filters.constant_q(sr=sr, fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave, filter_scale=filter_scale, pad_fft=pad_fft, norm=norm)\n    assert np.all((lengths <= F.shape[1]))\n    assert (len(F) == n_bins)\n    if (not pad_fft):\n        return\n    assert (np.mod(np.log2(F.shape[1]), 1.0) == 0.0)\n    F_fft = np.abs(np.fft.fft(F, axis=1))\n    F_fft = (F_fft / np.max(F_fft, axis=1, keepdims=True))\n    assert (not np.any((F_fft[(:, ((- F_fft.shape[1]) // 2):)] > 0.0001)))", "masked_code": "@pytest.mark.parametrize('sr', [11025])\n@pytest.mark.parametrize('fmin', [None, librosa.note_to_hz('C3')])\n@pytest.mark.parametrize('n_bins', [12, 24])\n@pytest.mark.parametrize('bins_per_octave', [12, 24])\n@pytest.mark.parametrize('filter_scale', [1, 2])\n@pytest.mark.parametrize('norm', [1, 2])\n@pytest.mark.parametrize('pad_fft', [False, True])\ndef test_constant_q(sr, fmin, n_bins, bins_per_octave, filter_scale, pad_fft, norm):\n    with pytest.warns(FutureWarning, match='Deprecated'):\n        (F, lengths) = librosa.filters.constant_q(sr=sr, fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave, filter_scale=filter_scale, pad_fft=pad_fft, norm=norm)\n    assert np.all((lengths <= F.shape[1]))\n    assert (len(F) == '???')\n    if (not pad_fft):\n        return\n    assert (np.mod(np.log2(F.shape[1]), 1.0) == 0.0)\n    F_fft = np.abs(np.fft.fft(F, axis=1))\n    F_fft = (F_fft / np.max(F_fft, axis=1, keepdims=True))\n    assert (not np.any((F_fft[(:, ((- F_fft.shape[1]) // 2):)] > 0.0001)))", "ground_truth": "n_bins", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_108", "reponame": "librosa", "testpath": "tests/test_filters.py", "testname": "test_filters.py", "classname": null, "funcname": "test_wavelet", "imports": ["import os", "from contextlib import nullcontext as dnr", "import warnings", "import glob", "import numpy as np", "import scipy.io", "import scipy.signal", "from typing import Any, ContextManager", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('sr', [11025])\n@pytest.mark.parametrize('fmin', [librosa.note_to_hz('C3')])\n@pytest.mark.parametrize('n_bins', [12, 24])\n@pytest.mark.parametrize('bins_per_octave', [12, 24])\n@pytest.mark.parametrize('filter_scale', [1, 2])\n@pytest.mark.parametrize('norm', [1, 2])\n@pytest.mark.parametrize('pad_fft', [False, True])\n@pytest.mark.parametrize('gamma', [0, 10, None])\ndef test_wavelet(sr, fmin, n_bins, bins_per_octave, filter_scale, pad_fft, norm, gamma):\n    freqs = librosa.cqt_frequencies(fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave)\n    (F, lengths) = librosa.filters.wavelet(freqs=freqs, sr=sr, filter_scale=filter_scale, pad_fft=pad_fft, norm=norm, gamma=gamma)\n    assert np.all((lengths <= F.shape[1]))\n    assert (len(F) == n_bins)\n    if (not pad_fft):\n        return\n    assert (np.mod(np.log2(F.shape[1]), 1.0) == 0.0)\n    F_fft = np.abs(np.fft.fft(F, axis=1))\n    F_fft = (F_fft / np.max(F_fft, axis=1, keepdims=True))\n    assert (np.max(F_fft[(:, ((- F_fft.shape[1]) // 2):)]) < 0.001)", "masked_code": "@pytest.mark.parametrize('sr', [11025])\n@pytest.mark.parametrize('fmin', [librosa.note_to_hz('C3')])\n@pytest.mark.parametrize('n_bins', [12, 24])\n@pytest.mark.parametrize('bins_per_octave', [12, 24])\n@pytest.mark.parametrize('filter_scale', [1, 2])\n@pytest.mark.parametrize('norm', [1, 2])\n@pytest.mark.parametrize('pad_fft', [False, True])\n@pytest.mark.parametrize('gamma', [0, 10, None])\ndef test_wavelet(sr, fmin, n_bins, bins_per_octave, filter_scale, pad_fft, norm, gamma):\n    freqs = librosa.cqt_frequencies(fmin=fmin, n_bins=n_bins, bins_per_octave=bins_per_octave)\n    (F, lengths) = librosa.filters.wavelet(freqs=freqs, sr=sr, filter_scale=filter_scale, pad_fft=pad_fft, norm=norm, gamma=gamma)\n    assert np.all((lengths <= F.shape[1]))\n    assert (len(F) == '???')\n    if (not pad_fft):\n        return\n    assert (np.mod(np.log2(F.shape[1]), 1.0) == 0.0)\n    F_fft = np.abs(np.fft.fft(F, axis=1))\n    F_fft = (F_fft / np.max(F_fft, axis=1, keepdims=True))\n    assert (np.max(F_fft[(:, ((- F_fft.shape[1]) // 2):)]) < 0.001)", "ground_truth": "n_bins", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_109", "reponame": "librosa", "testpath": "tests/test_intervals.py", "testname": "test_intervals.py", "classname": null, "funcname": "test_interval_frequencies", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('n_bins', [6, 12, 24, 30])\n@pytest.mark.parametrize('intervals', ['equal', 'pythagorean', 'ji3', 'ji5', 'ji7', [1, (4 / 3), (3 / 2), (5 / 4)]])\n@pytest.mark.parametrize('bins_per_octave', [6, 12, 15])\ndef test_interval_frequencies(n_bins, intervals, bins_per_octave):\n    freqs = librosa.interval_frequencies(n_bins, fmin=10, intervals=intervals, bins_per_octave=bins_per_octave)\n    assert (len(freqs) == n_bins)\n    assert (min(freqs) == 10)", "masked_code": "@pytest.mark.parametrize('n_bins', [6, 12, 24, 30])\n@pytest.mark.parametrize('intervals', ['equal', 'pythagorean', 'ji3', 'ji5', 'ji7', [1, (4 / 3), (3 / 2), (5 / 4)]])\n@pytest.mark.parametrize('bins_per_octave', [6, 12, 15])\ndef test_interval_frequencies(n_bins, intervals, bins_per_octave):\n    freqs = librosa.interval_frequencies(n_bins, fmin=10, intervals=intervals, bins_per_octave=bins_per_octave)\n    assert (len(freqs) == '???')\n    assert (min(freqs) == 10)", "ground_truth": "n_bins", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_110", "reponame": "librosa", "testpath": "tests/test_intervals.py", "testname": "test_intervals.py", "classname": null, "funcname": "test_interval_frequencies", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('n_bins', [6, 12, 24, 30])\n@pytest.mark.parametrize('intervals', ['equal', 'pythagorean', 'ji3', 'ji5', 'ji7', [1, (4 / 3), (3 / 2), (5 / 4)]])\n@pytest.mark.parametrize('bins_per_octave', [6, 12, 15])\ndef test_interval_frequencies(n_bins, intervals, bins_per_octave):\n    freqs = librosa.interval_frequencies(n_bins, fmin=10, intervals=intervals, bins_per_octave=bins_per_octave)\n    assert (len(freqs) == n_bins)\n    assert (min(freqs) == 10)", "masked_code": "@pytest.mark.parametrize('n_bins', [6, 12, 24, 30])\n@pytest.mark.parametrize('intervals', ['equal', 'pythagorean', 'ji3', 'ji5', 'ji7', [1, (4 / 3), (3 / 2), (5 / 4)]])\n@pytest.mark.parametrize('bins_per_octave', [6, 12, 15])\ndef test_interval_frequencies(n_bins, intervals, bins_per_octave):\n    freqs = librosa.interval_frequencies(n_bins, fmin=10, intervals=intervals, bins_per_octave=bins_per_octave)\n    assert (len(freqs) == n_bins)\n    assert (min(freqs) == '???')", "ground_truth": "10", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_111", "reponame": "librosa", "testpath": "tests/test_intervals.py", "testname": "test_intervals.py", "classname": null, "funcname": "test_pythagorean_factorizations", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('sort', [False, True])\ndef test_pythagorean_factorizations(sort):\n    intervals = librosa.pythagorean_intervals(bins_per_octave=20, sort=sort, return_factors=False)\n    factors = librosa.pythagorean_intervals(bins_per_octave=20, sort=sort, return_factors=True)\n    assert (len(intervals) == len(factors))\n    for (ival, facts) in zip(intervals, factors):\n        value = 0.0\n        for prime in facts:\n            value += (facts[prime] * np.log2(prime))\n        assert np.isclose(ival, np.power(2, value))", "masked_code": "@pytest.mark.parametrize('sort', [False, True])\ndef test_pythagorean_factorizations(sort):\n    intervals = librosa.pythagorean_intervals(bins_per_octave=20, sort=sort, return_factors=False)\n    factors = librosa.pythagorean_intervals(bins_per_octave=20, sort=sort, return_factors=True)\n    assert (len(intervals) == '???')\n    for (ival, facts) in zip(intervals, factors):\n        value = 0.0\n        for prime in facts:\n            value += (facts[prime] * np.log2(prime))\n        assert np.isclose(ival, np.power(2, value))", "ground_truth": "len(factors)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_112", "reponame": "librosa", "testpath": "tests/test_intervals.py", "testname": "test_intervals.py", "classname": null, "funcname": "test_plimit_factorizations", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('sort', [False, True])\n@pytest.mark.parametrize('primes', [[3], [3, 5], [3, 5, 7]])\ndef test_plimit_factorizations(sort, primes):\n    intervals = librosa.plimit_intervals(primes=primes, bins_per_octave=20, sort=sort, return_factors=False)\n    factors = librosa.plimit_intervals(primes=primes, bins_per_octave=20, sort=sort, return_factors=True)\n    assert (len(intervals) == len(factors))\n    for (ival, facts) in zip(intervals, factors):\n        value = 0.0\n        for prime in facts:\n            value += (facts[prime] * np.log2(prime))\n        assert np.isclose(ival, np.power(2, value))", "masked_code": "@pytest.mark.parametrize('sort', [False, True])\n@pytest.mark.parametrize('primes', [[3], [3, 5], [3, 5, 7]])\ndef test_plimit_factorizations(sort, primes):\n    intervals = librosa.plimit_intervals(primes=primes, bins_per_octave=20, sort=sort, return_factors=False)\n    factors = librosa.plimit_intervals(primes=primes, bins_per_octave=20, sort=sort, return_factors=True)\n    assert (len(intervals) == '???')\n    for (ival, facts) in zip(intervals, factors):\n        value = 0.0\n        for prime in facts:\n            value += (facts[prime] * np.log2(prime))\n        assert np.isclose(ival, np.power(2, value))", "ground_truth": "len(factors)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_113", "reponame": "librosa", "testpath": "tests/test_multichannel.py", "testname": "test_multichannel.py", "classname": null, "funcname": "test_sync_multi", "imports": ["import os", "import librosa", "import glob", "import numpy as np", "import scipy.io", "import scipy.stats", "import pytest", "import warnings", "from unittest import mock", "from typing import List, Union", "from contextlib import nullcontext as dnr", "from test_core import srand"], "code": "@pytest.mark.parametrize('aggregate', [None, np.mean, np.sum])\n@pytest.mark.parametrize('ndim,axis', [(1, 0), (1, (- 1)), (2, 0), (2, 1), (2, (- 1)), (3, 0), (3, 2), (3, (- 1)), (4, 0), (4, 3), (4, (- 1))])\ndef test_sync_multi(aggregate, ndim: int, axis: int):\n    data = np.ones(([6] * ndim), dtype=float)\n    slices = [slice(1, 3), slice(3, 4)]\n    dsync = librosa.util.sync(data, slices, aggregate=aggregate, axis=axis)\n    assert (dsync.shape[axis] == len(slices))\n    s_test = list(dsync.shape)\n    del s_test[axis]\n    s_orig = list(data.shape)\n    del s_orig[axis]\n    assert (s_test == s_orig)\n    idx: List[Union[(slice, int)]] = ([slice(None)] * ndim)\n    idx[axis] = 0\n    if (aggregate is np.sum):\n        assert np.allclose(dsync[tuple(idx)], 2)\n    else:\n        assert np.allclose(dsync[tuple(idx)], 1)\n    idx[axis] = 1\n    assert np.allclose(dsync[tuple(idx)], 1)", "masked_code": "@pytest.mark.parametrize('aggregate', [None, np.mean, np.sum])\n@pytest.mark.parametrize('ndim,axis', [(1, 0), (1, (- 1)), (2, 0), (2, 1), (2, (- 1)), (3, 0), (3, 2), (3, (- 1)), (4, 0), (4, 3), (4, (- 1))])\ndef test_sync_multi(aggregate, ndim: int, axis: int):\n    data = np.ones(([6] * ndim), dtype=float)\n    slices = [slice(1, 3), slice(3, 4)]\n    dsync = librosa.util.sync(data, slices, aggregate=aggregate, axis=axis)\n    assert (dsync.shape[axis] == '???')\n    s_test = list(dsync.shape)\n    del s_test[axis]\n    s_orig = list(data.shape)\n    del s_orig[axis]\n    assert (s_test == s_orig)\n    idx: List[Union[(slice, int)]] = ([slice(None)] * ndim)\n    idx[axis] = 0\n    if (aggregate is np.sum):\n        assert np.allclose(dsync[tuple(idx)], 2)\n    else:\n        assert np.allclose(dsync[tuple(idx)], 1)\n    idx[axis] = 1\n    assert np.allclose(dsync[tuple(idx)], 1)", "ground_truth": "len(slices)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_114", "reponame": "librosa", "testpath": "tests/test_multichannel.py", "testname": "test_multichannel.py", "classname": null, "funcname": "test_icqt_multi", "imports": ["import os", "import librosa", "import glob", "import numpy as np", "import scipy.io", "import scipy.stats", "import pytest", "import warnings", "from unittest import mock", "from typing import List, Union", "from contextlib import nullcontext as dnr", "from test_core import srand"], "code": "@pytest.mark.parametrize('scale', [False, True])\n@pytest.mark.parametrize('length', [None, 22050])\ndef test_icqt_multi(y_multi, scale, length):\n    (y, sr) = y_multi\n    C = librosa.cqt(y=y, sr=sr, scale=scale)\n    yboth = librosa.icqt(C, sr=sr, scale=scale, length=length)\n    y0 = librosa.icqt(C[0], sr=sr, scale=scale, length=length)\n    y1 = librosa.icqt(C[1], sr=sr, scale=scale, length=length)\n    if (length is not None):\n        assert (yboth.shape[(- 1)] == length)\n    assert np.allclose(yboth[0], y0, atol=1e-06), np.max(np.abs((yboth[0] - y0)))\n    assert np.allclose(yboth[1], y1, atol=1e-06), np.max(np.abs((yboth[1] - y1)))\n    assert (not np.allclose(yboth[0], yboth[1]))", "masked_code": "@pytest.mark.parametrize('scale', [False, True])\n@pytest.mark.parametrize('length', [None, 22050])\ndef test_icqt_multi(y_multi, scale, length):\n    (y, sr) = y_multi\n    C = librosa.cqt(y=y, sr=sr, scale=scale)\n    yboth = librosa.icqt(C, sr=sr, scale=scale, length=length)\n    y0 = librosa.icqt(C[0], sr=sr, scale=scale, length=length)\n    y1 = librosa.icqt(C[1], sr=sr, scale=scale, length=length)\n    if (length is not None):\n        assert (yboth.shape[(- 1)] == '???')\n    assert np.allclose(yboth[0], y0, atol=1e-06), np.max(np.abs((yboth[0] - y0)))\n    assert np.allclose(yboth[1], y1, atol=1e-06), np.max(np.abs((yboth[1] - y1)))\n    assert (not np.allclose(yboth[0], yboth[1]))", "ground_truth": "length", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_115", "reponame": "librosa", "testpath": "tests/test_multichannel.py", "testname": "test_multichannel.py", "classname": null, "funcname": "test_rms_multi", "imports": ["import os", "import librosa", "import glob", "import numpy as np", "import scipy.io", "import scipy.stats", "import pytest", "import warnings", "from unittest import mock", "from typing import List, Union", "from contextlib import nullcontext as dnr", "from test_core import srand"], "code": "def test_rms_multi(s_multi):\n    (S, sr) = s_multi\n    C0 = librosa.feature.rms(S=S[0])\n    C1 = librosa.feature.rms(S=S[1])\n    Call = librosa.feature.rms(S=S)\n    assert (Call.ndim == 3)\n    assert np.allclose(C0, Call[0])\n    assert np.allclose(C1, Call[1])\n    assert (not np.allclose(Call[0], Call[1]))", "masked_code": "def test_rms_multi(s_multi):\n    (S, sr) = s_multi\n    C0 = librosa.feature.rms(S=S[0])\n    C1 = librosa.feature.rms(S=S[1])\n    Call = librosa.feature.rms(S=S)\n    assert (Call.ndim == '???')\n    assert np.allclose(C0, Call[0])\n    assert np.allclose(C1, Call[1])\n    assert (not np.allclose(Call[0], Call[1]))", "ground_truth": "3", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_116", "reponame": "librosa", "testpath": "tests/test_multichannel.py", "testname": "test_multichannel.py", "classname": null, "funcname": "test_click_multi", "imports": ["import os", "import librosa", "import glob", "import numpy as np", "import scipy.io", "import scipy.stats", "import pytest", "import warnings", "from unittest import mock", "from typing import List, Union", "from contextlib import nullcontext as dnr", "from test_core import srand"], "code": "def test_click_multi():\n    click = np.ones((3, 100))\n    yout = librosa.clicks(times=[0, 1, 2], sr=1000, click=click)\n    assert (yout.shape[0] == click.shape[0])\n    assert np.allclose(yout[(..., :100)], click)\n    assert np.allclose(yout[(..., 1000:1100)], click)\n    assert np.allclose(yout[(..., 2000:2100)], click)", "masked_code": "def test_click_multi():\n    click = np.ones((3, 100))\n    yout = librosa.clicks(times=[0, 1, 2], sr=1000, click=click)\n    assert (yout.shape[0] == '???')\n    assert np.allclose(yout[(..., :100)], click)\n    assert np.allclose(yout[(..., 1000:1100)], click)\n    assert np.allclose(yout[(..., 2000:2100)], click)", "ground_truth": "click.shape[0]", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_117", "reponame": "librosa", "testpath": "tests/test_multichannel.py", "testname": "test_multichannel.py", "classname": null, "funcname": "test_trim_multichannel", "imports": ["import os", "import librosa", "import glob", "import numpy as np", "import scipy.io", "import scipy.stats", "import pytest", "import warnings", "from unittest import mock", "from typing import List, Union", "from contextlib import nullcontext as dnr", "from test_core import srand"], "code": "def test_trim_multichannel(y_multi):\n    (y, sr) = y_multi\n    y = (y * np.array([[1e-06, 1000000.0]]).T)\n    (yt, ival) = librosa.effects.trim(y)\n    (yt0, ival0) = librosa.effects.trim(y[0])\n    (yt1, ival1) = librosa.effects.trim(y[1])\n    assert (ival[0] == max(ival0[0], ival1[0]))\n    assert (ival[1] == min(ival0[1], ival1[1]))", "masked_code": "def test_trim_multichannel(y_multi):\n    (y, sr) = y_multi\n    y = (y * np.array([[1e-06, 1000000.0]]).T)\n    (yt, ival) = librosa.effects.trim(y)\n    (yt0, ival0) = librosa.effects.trim(y[0])\n    (yt1, ival1) = librosa.effects.trim(y[1])\n    assert (ival[0] == '???')\n    assert (ival[1] == min(ival0[1], ival1[1]))", "ground_truth": "max(ival0[0], ival1[0])", "quality_analysis": {"complexity_score": 18, "left_complexity": 5, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_118", "reponame": "librosa", "testpath": "tests/test_multichannel.py", "testname": "test_multichannel.py", "classname": null, "funcname": "test_trim_multichannel", "imports": ["import os", "import librosa", "import glob", "import numpy as np", "import scipy.io", "import scipy.stats", "import pytest", "import warnings", "from unittest import mock", "from typing import List, Union", "from contextlib import nullcontext as dnr", "from test_core import srand"], "code": "def test_trim_multichannel(y_multi):\n    (y, sr) = y_multi\n    y = (y * np.array([[1e-06, 1000000.0]]).T)\n    (yt, ival) = librosa.effects.trim(y)\n    (yt0, ival0) = librosa.effects.trim(y[0])\n    (yt1, ival1) = librosa.effects.trim(y[1])\n    assert (ival[0] == max(ival0[0], ival1[0]))\n    assert (ival[1] == min(ival0[1], ival1[1]))", "masked_code": "def test_trim_multichannel(y_multi):\n    (y, sr) = y_multi\n    y = (y * np.array([[1e-06, 1000000.0]]).T)\n    (yt, ival) = librosa.effects.trim(y)\n    (yt0, ival0) = librosa.effects.trim(y[0])\n    (yt1, ival1) = librosa.effects.trim(y[1])\n    assert (ival[0] == max(ival0[0], ival1[0]))\n    assert (ival[1] == '???')", "ground_truth": "min(ival0[1], ival1[1])", "quality_analysis": {"complexity_score": 18, "left_complexity": 5, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_119", "reponame": "librosa", "testpath": "tests/test_multichannel.py", "testname": "test_multichannel.py", "classname": null, "funcname": "test_resample_multichannel", "imports": ["import os", "import librosa", "import glob", "import numpy as np", "import scipy.io", "import scipy.stats", "import pytest", "import warnings", "from unittest import mock", "from typing import List, Union", "from contextlib import nullcontext as dnr", "from test_core import srand"], "code": "@pytest.mark.parametrize('res_type', ('scipy', 'polyphase', 'sinc_fastest', 'kaiser_fast', 'soxr_qq'))\ndef test_resample_multichannel(y_multi, res_type):\n    (y, sr) = y_multi\n    y_res = librosa.resample(y=y, orig_sr=sr, target_sr=(sr // 2), res_type=res_type)\n    y0_res = librosa.resample(y=y[0], orig_sr=sr, target_sr=(sr // 2), res_type=res_type)\n    y1_res = librosa.resample(y=y[1], orig_sr=sr, target_sr=(sr // 2), res_type=res_type)\n    assert np.allclose(y_res[0], y0_res)\n    assert np.allclose(y_res[1], y1_res)\n    assert (y_res[0].shape == y0_res.shape)", "masked_code": "@pytest.mark.parametrize('res_type', ('scipy', 'polyphase', 'sinc_fastest', 'kaiser_fast', 'soxr_qq'))\ndef test_resample_multichannel(y_multi, res_type):\n    (y, sr) = y_multi\n    y_res = librosa.resample(y=y, orig_sr=sr, target_sr=(sr // 2), res_type=res_type)\n    y0_res = librosa.resample(y=y[0], orig_sr=sr, target_sr=(sr // 2), res_type=res_type)\n    y1_res = librosa.resample(y=y[1], orig_sr=sr, target_sr=(sr // 2), res_type=res_type)\n    assert np.allclose(y_res[0], y0_res)\n    assert np.allclose(y_res[1], y1_res)\n    assert (y_res[0].shape == '???')", "ground_truth": "y0_res.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_120", "reponame": "librosa", "testpath": "tests/test_multichannel.py", "testname": "test_multichannel.py", "classname": null, "funcname": "test_resample_highdim_axis", "imports": ["import os", "import librosa", "import glob", "import numpy as np", "import scipy.io", "import scipy.stats", "import pytest", "import warnings", "from unittest import mock", "from typing import List, Union", "from contextlib import nullcontext as dnr", "from test_core import srand"], "code": "@pytest.mark.parametrize('res_type', ('scipy', 'polyphase', 'sinc_fastest', 'kaiser_fast', 'soxr_qq'))\n@pytest.mark.parametrize('x, axis', [(np.zeros((2, 2, 2, 22050)), (- 1)), (np.zeros((22050, 2, 3)), 0)])\ndef test_resample_highdim_axis(x, axis, res_type):\n    y = librosa.resample(x, orig_sr=22050, target_sr=11025, axis=axis, res_type=res_type)\n    assert (y.shape[axis] == 11025)\n    assert (y.ndim == x.ndim)", "masked_code": "@pytest.mark.parametrize('res_type', ('scipy', 'polyphase', 'sinc_fastest', 'kaiser_fast', 'soxr_qq'))\n@pytest.mark.parametrize('x, axis', [(np.zeros((2, 2, 2, 22050)), (- 1)), (np.zeros((22050, 2, 3)), 0)])\ndef test_resample_highdim_axis(x, axis, res_type):\n    y = librosa.resample(x, orig_sr=22050, target_sr=11025, axis=axis, res_type=res_type)\n    assert (y.shape[axis] == '???')\n    assert (y.ndim == x.ndim)", "ground_truth": "11025", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_121", "reponame": "librosa", "testpath": "tests/test_multichannel.py", "testname": "test_multichannel.py", "classname": null, "funcname": "test_resample_highdim_axis", "imports": ["import os", "import librosa", "import glob", "import numpy as np", "import scipy.io", "import scipy.stats", "import pytest", "import warnings", "from unittest import mock", "from typing import List, Union", "from contextlib import nullcontext as dnr", "from test_core import srand"], "code": "@pytest.mark.parametrize('res_type', ('scipy', 'polyphase', 'sinc_fastest', 'kaiser_fast', 'soxr_qq'))\n@pytest.mark.parametrize('x, axis', [(np.zeros((2, 2, 2, 22050)), (- 1)), (np.zeros((22050, 2, 3)), 0)])\ndef test_resample_highdim_axis(x, axis, res_type):\n    y = librosa.resample(x, orig_sr=22050, target_sr=11025, axis=axis, res_type=res_type)\n    assert (y.shape[axis] == 11025)\n    assert (y.ndim == x.ndim)", "masked_code": "@pytest.mark.parametrize('res_type', ('scipy', 'polyphase', 'sinc_fastest', 'kaiser_fast', 'soxr_qq'))\n@pytest.mark.parametrize('x, axis', [(np.zeros((2, 2, 2, 22050)), (- 1)), (np.zeros((22050, 2, 3)), 0)])\ndef test_resample_highdim_axis(x, axis, res_type):\n    y = librosa.resample(x, orig_sr=22050, target_sr=11025, axis=axis, res_type=res_type)\n    assert (y.shape[axis] == 11025)\n    assert (y.ndim == '???')", "ground_truth": "x.ndim", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_122", "reponame": "librosa", "testpath": "tests/test_notation.py", "testname": "test_notation.py", "classname": null, "funcname": "test_key_to_notes", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('key,ref_notes', [('C:maj', ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']), ('A:min', ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']), ('D:maj', ['Cn', 'C#', 'D', 'D#', 'E', 'Fn', 'F#', 'G', 'G#', 'A', 'A#', 'B']), ('F:min', ['C', 'Db', 'Dn', 'Eb', 'En', 'F', 'Gb', 'G', 'Ab', 'An', 'Bb', 'Bn']), ('Eb:min', ['Cn', 'Db', 'Dn', 'Eb', 'En', 'F', 'Gb', 'Gn', 'Ab', 'An', 'Bb', 'Cb']), ('D#:min', ['Cn', 'C#', 'Dn', 'D#', 'En', 'E#', 'F#', 'Gn', 'G#', 'An', 'A#', 'B']), ('Gb:maj', ['Cn', 'Db', 'Dn', 'Eb', 'En', 'F', 'Gb', 'Gn', 'Ab', 'An', 'Bb', 'Cb']), ('F#:maj', ['Cn', 'C#', 'Dn', 'D#', 'En', 'E#', 'F#', 'Gn', 'G#', 'An', 'A#', 'B']), ('G#:maj', ['B#', 'C#', 'Dn', 'D#', 'En', 'E#', 'F#', 'F##', 'G#', 'An', 'A#', 'Bn']), ('Cb:min', ['Cn', 'Db', 'Ebb', 'Eb', 'Fb', 'Fn', 'Gb', 'Abb', 'Ab', 'Bbb', 'Bb', 'Cb']), ('B#:maj', ['B#', 'C#', 'C##', 'D#', 'D##', 'E#', 'F#', 'F##', 'G#', 'G##', 'A#', 'A##']), ('F##:maj', ['B#', 'C#', 'C##', 'D#', 'D##', 'E#', 'E##', 'F##', 'G#', 'G##', 'A#', 'A##']), ('Fbb:maj', ['Dbb', 'Db', 'Ebb', 'Fbb', 'Fb', 'Gbb', 'Gb', 'Abb', 'Bbbb', 'Bbb', 'Cbb', 'Cb']), ('A###:min', ['A###', 'B##', 'B###', 'C###', 'D##', 'D###', 'E##', 'E###', 'F###', 'G##', 'G###', 'A##']), ('E:ion', ['Cn', 'C#', 'Dn', 'D#', 'E', 'Fn', 'F#', 'Gn', 'G#', 'A', 'A#', 'B']), ('E#:mix', ['B#', 'C#', 'C##', 'D#', 'En', 'E#', 'F#', 'F##', 'G#', 'G##', 'A#', 'Bn']), ('E#:lyd', ['B#', 'C#', 'C##', 'D#', 'D##', 'E#', 'F#', 'F##', 'G#', 'G##', 'A#', 'A##']), ('Gb:dor', ['Cn', 'Db', 'Dn', 'Eb', 'Fb', 'Fn', 'Gb', 'Gn', 'Ab', 'Bbb', 'Bb', 'Cb']), ('Gb:phr', ['Dbb', 'Db', 'Ebb', 'Eb', 'Fb', 'Gbb', 'Gb', 'Abb', 'Ab', 'Bbb', 'Bb', 'Cb']), ('B#:aeol', ['B#', 'C#', 'C##', 'D#', 'En', 'E#', 'F#', 'F##', 'G#', 'An', 'A#', 'Bn']), ('B#:loc', ['B#', 'C#', 'Dn', 'D#', 'En', 'E#', 'F#', 'Gn', 'G#', 'An', 'A#', 'Bn'])])\ndef test_key_to_notes(key, ref_notes):\n    notes = librosa.key_to_notes(key, unicode=False, natural=True)\n    assert (len(notes) == len(ref_notes))\n    for (n, rn) in zip(notes, ref_notes):\n        assert (n == rn)", "masked_code": "@pytest.mark.parametrize('key,ref_notes', [('C:maj', ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']), ('A:min', ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']), ('D:maj', ['Cn', 'C#', 'D', 'D#', 'E', 'Fn', 'F#', 'G', 'G#', 'A', 'A#', 'B']), ('F:min', ['C', 'Db', 'Dn', 'Eb', 'En', 'F', 'Gb', 'G', 'Ab', 'An', 'Bb', 'Bn']), ('Eb:min', ['Cn', 'Db', 'Dn', 'Eb', 'En', 'F', 'Gb', 'Gn', 'Ab', 'An', 'Bb', 'Cb']), ('D#:min', ['Cn', 'C#', 'Dn', 'D#', 'En', 'E#', 'F#', 'Gn', 'G#', 'An', 'A#', 'B']), ('Gb:maj', ['Cn', 'Db', 'Dn', 'Eb', 'En', 'F', 'Gb', 'Gn', 'Ab', 'An', 'Bb', 'Cb']), ('F#:maj', ['Cn', 'C#', 'Dn', 'D#', 'En', 'E#', 'F#', 'Gn', 'G#', 'An', 'A#', 'B']), ('G#:maj', ['B#', 'C#', 'Dn', 'D#', 'En', 'E#', 'F#', 'F##', 'G#', 'An', 'A#', 'Bn']), ('Cb:min', ['Cn', 'Db', 'Ebb', 'Eb', 'Fb', 'Fn', 'Gb', 'Abb', 'Ab', 'Bbb', 'Bb', 'Cb']), ('B#:maj', ['B#', 'C#', 'C##', 'D#', 'D##', 'E#', 'F#', 'F##', 'G#', 'G##', 'A#', 'A##']), ('F##:maj', ['B#', 'C#', 'C##', 'D#', 'D##', 'E#', 'E##', 'F##', 'G#', 'G##', 'A#', 'A##']), ('Fbb:maj', ['Dbb', 'Db', 'Ebb', 'Fbb', 'Fb', 'Gbb', 'Gb', 'Abb', 'Bbbb', 'Bbb', 'Cbb', 'Cb']), ('A###:min', ['A###', 'B##', 'B###', 'C###', 'D##', 'D###', 'E##', 'E###', 'F###', 'G##', 'G###', 'A##']), ('E:ion', ['Cn', 'C#', 'Dn', 'D#', 'E', 'Fn', 'F#', 'Gn', 'G#', 'A', 'A#', 'B']), ('E#:mix', ['B#', 'C#', 'C##', 'D#', 'En', 'E#', 'F#', 'F##', 'G#', 'G##', 'A#', 'Bn']), ('E#:lyd', ['B#', 'C#', 'C##', 'D#', 'D##', 'E#', 'F#', 'F##', 'G#', 'G##', 'A#', 'A##']), ('Gb:dor', ['Cn', 'Db', 'Dn', 'Eb', 'Fb', 'Fn', 'Gb', 'Gn', 'Ab', 'Bbb', 'Bb', 'Cb']), ('Gb:phr', ['Dbb', 'Db', 'Ebb', 'Eb', 'Fb', 'Gbb', 'Gb', 'Abb', 'Ab', 'Bbb', 'Bb', 'Cb']), ('B#:aeol', ['B#', 'C#', 'C##', 'D#', 'En', 'E#', 'F#', 'F##', 'G#', 'An', 'A#', 'Bn']), ('B#:loc', ['B#', 'C#', 'Dn', 'D#', 'En', 'E#', 'F#', 'Gn', 'G#', 'An', 'A#', 'Bn'])])\ndef test_key_to_notes(key, ref_notes):\n    notes = librosa.key_to_notes(key, unicode=False, natural=True)\n    assert (len(notes) == '???')\n    for (n, rn) in zip(notes, ref_notes):\n        assert (n == rn)", "ground_truth": "len(ref_notes)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_123", "reponame": "librosa", "testpath": "tests/test_notation.py", "testname": "test_notation.py", "classname": null, "funcname": "test_key_to_notes_unicode", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('key,ref_notes,natural', [('G#:maj', ['B', 'C', 'D', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B'], False), ('Cb:min', ['C', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B', 'B', 'C'], False), ('G#:maj', ['B', 'C', 'D', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B'], True), ('G#:ion', ['B', 'C', 'D', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B'], True)])\ndef test_key_to_notes_unicode(key, ref_notes, natural):\n    notes = librosa.key_to_notes(key, unicode=True, natural=natural)\n    assert (len(notes) == len(ref_notes))\n    for (n, rn) in zip(notes, ref_notes):\n        assert (n == rn)", "masked_code": "@pytest.mark.parametrize('key,ref_notes,natural', [('G#:maj', ['B', 'C', 'D', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B'], False), ('Cb:min', ['C', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B', 'B', 'C'], False), ('G#:maj', ['B', 'C', 'D', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B'], True), ('G#:ion', ['B', 'C', 'D', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B'], True)])\ndef test_key_to_notes_unicode(key, ref_notes, natural):\n    notes = librosa.key_to_notes(key, unicode=True, natural=natural)\n    assert (len(notes) == '???')\n    for (n, rn) in zip(notes, ref_notes):\n        assert (n == rn)", "ground_truth": "len(ref_notes)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_124", "reponame": "librosa", "testpath": "tests/test_notation.py", "testname": "test_notation.py", "classname": null, "funcname": "test_key_to_notes_no_natural", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('key,ref_notes', [('G#:maj', ['B', 'C', 'D', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B']), ('Cb:min', ['C', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B', 'B', 'C'])])\ndef test_key_to_notes_no_natural(key, ref_notes):\n    notes = librosa.key_to_notes(key, unicode=True, natural=False)\n    assert (len(notes) == len(ref_notes))\n    for (n, rn) in zip(notes, ref_notes):\n        assert (n == rn)", "masked_code": "@pytest.mark.parametrize('key,ref_notes', [('G#:maj', ['B', 'C', 'D', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B']), ('Cb:min', ['C', 'D', 'E', 'E', 'F', 'F', 'G', 'A', 'A', 'B', 'B', 'C'])])\ndef test_key_to_notes_no_natural(key, ref_notes):\n    notes = librosa.key_to_notes(key, unicode=True, natural=False)\n    assert (len(notes) == '???')\n    for (n, rn) in zip(notes, ref_notes):\n        assert (n == rn)", "ground_truth": "len(ref_notes)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_125", "reponame": "librosa", "testpath": "tests/test_notation.py", "testname": "test_notation.py", "classname": null, "funcname": "test_key_to_degrees", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('key,ref_degrees', [('C:maj', [0, 2, 4, 5, 7, 9, 11]), ('C:min', [0, 2, 3, 5, 7, 8, 10]), ('A:min', [9, 11, 0, 2, 4, 5, 7]), ('Gb:maj', [6, 8, 10, 11, 1, 3, 5]), ('A###:maj', [0, 2, 4, 5, 7, 9, 11]), ('C:ion', [0, 2, 4, 5, 7, 9, 11]), ('C:dor', [0, 2, 3, 5, 7, 9, 10]), ('C:phr', [0, 1, 3, 5, 7, 8, 10]), ('D#:lyd', [3, 5, 7, 9, 10, 0, 2]), ('D#:mix', [3, 5, 7, 8, 10, 0, 1]), ('Ebb:aeol', [2, 4, 5, 7, 9, 10, 0]), ('Ebb:loc', [2, 3, 5, 7, 8, 10, 0])])\ndef test_key_to_degrees(key, ref_degrees):\n    degrees = librosa.key_to_degrees(key)\n    assert (len(degrees) == len(ref_degrees))\n    for (d, rd) in zip(degrees, ref_degrees):\n        assert (d == rd)", "masked_code": "@pytest.mark.parametrize('key,ref_degrees', [('C:maj', [0, 2, 4, 5, 7, 9, 11]), ('C:min', [0, 2, 3, 5, 7, 8, 10]), ('A:min', [9, 11, 0, 2, 4, 5, 7]), ('Gb:maj', [6, 8, 10, 11, 1, 3, 5]), ('A###:maj', [0, 2, 4, 5, 7, 9, 11]), ('C:ion', [0, 2, 4, 5, 7, 9, 11]), ('C:dor', [0, 2, 3, 5, 7, 9, 10]), ('C:phr', [0, 1, 3, 5, 7, 8, 10]), ('D#:lyd', [3, 5, 7, 9, 10, 0, 2]), ('D#:mix', [3, 5, 7, 8, 10, 0, 1]), ('Ebb:aeol', [2, 4, 5, 7, 9, 10, 0]), ('Ebb:loc', [2, 3, 5, 7, 8, 10, 0])])\ndef test_key_to_degrees(key, ref_degrees):\n    degrees = librosa.key_to_degrees(key)\n    assert (len(degrees) == '???')\n    for (d, rd) in zip(degrees, ref_degrees):\n        assert (d == rd)", "ground_truth": "len(ref_degrees)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_126", "reponame": "librosa", "testpath": "tests/test_notation.py", "testname": "test_notation.py", "classname": null, "funcname": "test_list_thaat", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "def test_list_thaat():\n    thaat = librosa.list_thaat()\n    assert (len(thaat) == 10)", "masked_code": "def test_list_thaat():\n    thaat = librosa.list_thaat()\n    assert (len(thaat) == '???')", "ground_truth": "10", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_127", "reponame": "librosa", "testpath": "tests/test_notation.py", "testname": "test_notation.py", "classname": null, "funcname": "test_list_mela", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "def test_list_mela():\n    melas = librosa.list_mela()\n    assert (len(melas) == 72)\n    for k in melas:\n        assert (1 <= melas[k] <= 72)", "masked_code": "def test_list_mela():\n    melas = librosa.list_mela()\n    assert (len(melas) == '???')\n    for k in melas:\n        assert (1 <= melas[k] <= 72)", "ground_truth": "72", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_128", "reponame": "librosa", "testpath": "tests/test_notation.py", "testname": "test_notation.py", "classname": null, "funcname": "test_thaat_to_degrees", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('thaat', librosa.list_thaat())\ndef test_thaat_to_degrees(thaat):\n    degrees = librosa.thaat_to_degrees(thaat)\n    assert (len(degrees) == 7)\n    assert (np.all((degrees >= 0)) and np.all((degrees < 12)))", "masked_code": "@pytest.mark.parametrize('thaat', librosa.list_thaat())\ndef test_thaat_to_degrees(thaat):\n    degrees = librosa.thaat_to_degrees(thaat)\n    assert (len(degrees) == '???')\n    assert (np.all((degrees >= 0)) and np.all((degrees < 12)))", "ground_truth": "7", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_129", "reponame": "librosa", "testpath": "tests/test_notation.py", "testname": "test_notation.py", "classname": null, "funcname": "test_mela_to_degrees", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('mela, idx', librosa.list_mela().items())\ndef test_mela_to_degrees(mela, idx):\n    degrees = librosa.mela_to_degrees(mela)\n    assert np.allclose(degrees, librosa.mela_to_degrees(idx))\n    assert (len(degrees) == 7)\n    assert (np.all((degrees >= 0)) and np.all((degrees < 12)))\n    if (idx < 37):\n        assert np.isin(5, degrees)\n    else:\n        assert np.isin(6, degrees)", "masked_code": "@pytest.mark.parametrize('mela, idx', librosa.list_mela().items())\ndef test_mela_to_degrees(mela, idx):\n    degrees = librosa.mela_to_degrees(mela)\n    assert np.allclose(degrees, librosa.mela_to_degrees(idx))\n    assert (len(degrees) == '???')\n    assert (np.all((degrees >= 0)) and np.all((degrees < 12)))\n    if (idx < 37):\n        assert np.isin(5, degrees)\n    else:\n        assert np.isin(6, degrees)", "ground_truth": "7", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_130", "reponame": "librosa", "testpath": "tests/test_notation.py", "testname": "test_notation.py", "classname": null, "funcname": "test_mela_to_svara", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('mela, svara', [(1, ['S', 'R', 'G', 'G', 'G', 'M', 'M', 'P', 'D', 'N', 'N', 'N']), (8, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (15, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (22, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (29, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (36, ['S', 'R', 'R', 'R', 'G', 'M', 'M', 'P', 'D', 'D', 'D', 'N']), (43, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'N', 'N', 'N']), (50, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (57, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (64, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (71, ['S', 'R', 'R', 'R', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N'])])\n@pytest.mark.parametrize('abbr', [False, True])\n@pytest.mark.parametrize('unicode', [False, True])\ndef test_mela_to_svara(mela, svara, abbr, unicode):\n    svara_est = librosa.mela_to_svara(mela, abbr=abbr, unicode=unicode)\n    for (s1, s2) in zip(svara_est, svara):\n        assert (s1[0] == s2[0])\n    if abbr:\n        for s in svara_est:\n            assert (len(s) in (1, 2))\n    else:\n        for s in svara_est:\n            assert (0 < len(s) < 5)\n    if (sys.version >= '3.7'):\n        if (not unicode):\n            for s in svara_est:\n                assert s.isascii()", "masked_code": "@pytest.mark.parametrize('mela, svara', [(1, ['S', 'R', 'G', 'G', 'G', 'M', 'M', 'P', 'D', 'N', 'N', 'N']), (8, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (15, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (22, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (29, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (36, ['S', 'R', 'R', 'R', 'G', 'M', 'M', 'P', 'D', 'D', 'D', 'N']), (43, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'N', 'N', 'N']), (50, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (57, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (64, ['S', 'R', 'R', 'G', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N']), (71, ['S', 'R', 'R', 'R', 'G', 'M', 'M', 'P', 'D', 'D', 'N', 'N'])])\n@pytest.mark.parametrize('abbr', [False, True])\n@pytest.mark.parametrize('unicode', [False, True])\ndef test_mela_to_svara(mela, svara, abbr, unicode):\n    svara_est = librosa.mela_to_svara(mela, abbr=abbr, unicode=unicode)\n    for (s1, s2) in zip(svara_est, svara):\n        assert (s1[0] == '???')\n    if abbr:\n        for s in svara_est:\n            assert (len(s) in (1, 2))\n    else:\n        for s in svara_est:\n            assert (0 < len(s) < 5)\n    if (sys.version >= '3.7'):\n        if (not unicode):\n            for s in svara_est:\n                assert s.isascii()", "ground_truth": "s2[0]", "quality_analysis": {"complexity_score": 10, "left_complexity": 5, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_131", "reponame": "librosa", "testpath": "tests/test_notation.py", "testname": "test_notation.py", "classname": null, "funcname": "test_hz_to_fjs", "imports": ["import os", "import sys", "import warnings", "import numpy as np", "import pytest", "import librosa"], "code": "@pytest.mark.parametrize('hz, fmin, unison, unicode, results', [([55, 66, 77], None, None, True, ['A', 'C', 'D']), ([55, 66, 77], 33, None, True, ['A', 'C', 'E']), ([55, 66, 77], 33, 'Cb', True, ['A', 'C', 'E']), ([55, 66, 77], 33, 'Cb', False, ['Ab^5', 'Cb', 'Ebb^7'])])\ndef test_hz_to_fjs(hz, fmin, unison, unicode, results):\n    fjs = librosa.hz_to_fjs(hz, fmin=fmin, unison=unison, unicode=unicode)\n    assert (list(fjs) == results)", "masked_code": "@pytest.mark.parametrize('hz, fmin, unison, unicode, results', [([55, 66, 77], None, None, True, ['A', 'C', 'D']), ([55, 66, 77], 33, None, True, ['A', 'C', 'E']), ([55, 66, 77], 33, 'Cb', True, ['A', 'C', 'E']), ([55, 66, 77], 33, 'Cb', False, ['Ab^5', 'Cb', 'Ebb^7'])])\ndef test_hz_to_fjs(hz, fmin, unison, unicode, results):\n    fjs = librosa.hz_to_fjs(hz, fmin=fmin, unison=unison, unicode=unicode)\n    assert (list(fjs) == '???')", "ground_truth": "results", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_132", "reponame": "librosa", "testpath": "tests/test_onset.py", "testname": "test_onset.py", "classname": null, "funcname": "test_onset_strength_audio", "imports": ["import pytest", "from contextlib import nullcontext as dnr", "import os", "import warnings", "import numpy as np", "import librosa", "from test_core import srand"], "code": "@pytest.mark.parametrize('feature', [None, librosa.feature.melspectrogram, librosa.feature.chroma_stft])\n@pytest.mark.parametrize('n_fft', [512, 2048])\n@pytest.mark.parametrize('hop_length', [256, 512])\n@pytest.mark.parametrize('lag', [1, 2])\n@pytest.mark.parametrize('max_size', [1, 2])\n@pytest.mark.parametrize('detrend', [False, True])\n@pytest.mark.parametrize('center', [False, True])\n@pytest.mark.parametrize('aggregate', [None, np.mean, np.max])\ndef test_onset_strength_audio(ysr, feature, n_fft, hop_length, lag, max_size, detrend, center, aggregate):\n    (y, sr) = ysr\n    oenv = librosa.onset.onset_strength(y=y, sr=sr, S=None, detrend=detrend, center=center, aggregate=aggregate, feature=feature, n_fft=n_fft, hop_length=hop_length, lag=lag, max_size=max_size)\n    assert (oenv.ndim == 1)\n    S = librosa.feature.melspectrogram(y=y, n_fft=n_fft, hop_length=hop_length)\n    target_shape = S.shape[(- 1)]\n    if (not detrend):\n        assert np.all((oenv >= 0))\n    assert (oenv.shape[(- 1)] == target_shape)", "masked_code": "@pytest.mark.parametrize('feature', [None, librosa.feature.melspectrogram, librosa.feature.chroma_stft])\n@pytest.mark.parametrize('n_fft', [512, 2048])\n@pytest.mark.parametrize('hop_length', [256, 512])\n@pytest.mark.parametrize('lag', [1, 2])\n@pytest.mark.parametrize('max_size', [1, 2])\n@pytest.mark.parametrize('detrend', [False, True])\n@pytest.mark.parametrize('center', [False, True])\n@pytest.mark.parametrize('aggregate', [None, np.mean, np.max])\ndef test_onset_strength_audio(ysr, feature, n_fft, hop_length, lag, max_size, detrend, center, aggregate):\n    (y, sr) = ysr\n    oenv = librosa.onset.onset_strength(y=y, sr=sr, S=None, detrend=detrend, center=center, aggregate=aggregate, feature=feature, n_fft=n_fft, hop_length=hop_length, lag=lag, max_size=max_size)\n    assert (oenv.ndim == 1)\n    S = librosa.feature.melspectrogram(y=y, n_fft=n_fft, hop_length=hop_length)\n    target_shape = S.shape[(- 1)]\n    if (not detrend):\n        assert np.all((oenv >= 0))\n    assert (oenv.shape[(- 1)] == '???')", "ground_truth": "target_shape", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_133", "reponame": "librosa", "testpath": "tests/test_onset.py", "testname": "test_onset.py", "classname": null, "funcname": "test_onset_strength_spectrogram", "imports": ["import pytest", "from contextlib import nullcontext as dnr", "import os", "import warnings", "import numpy as np", "import librosa", "from test_core import srand"], "code": "@pytest.mark.parametrize('feature', [None, librosa.feature.melspectrogram, librosa.feature.chroma_stft])\n@pytest.mark.parametrize('n_fft', [512, 2048])\n@pytest.mark.parametrize('hop_length', [256, 512])\n@pytest.mark.parametrize('detrend', [False, True])\n@pytest.mark.parametrize('center', [False, True])\n@pytest.mark.parametrize('aggregate', [None, np.mean, np.max])\ndef test_onset_strength_spectrogram(melspec_sr, feature, n_fft, hop_length, detrend, center, aggregate):\n    (S, sr) = melspec_sr\n    oenv = librosa.onset.onset_strength(y=None, sr=sr, S=S, detrend=detrend, center=center, aggregate=aggregate, feature=feature, n_fft=n_fft, hop_length=hop_length)\n    assert (oenv.ndim == 1)\n    target_shape = S.shape[(- 1)]\n    if (not detrend):\n        assert np.all((oenv >= 0))\n    assert (oenv.shape[(- 1)] == target_shape)", "masked_code": "@pytest.mark.parametrize('feature', [None, librosa.feature.melspectrogram, librosa.feature.chroma_stft])\n@pytest.mark.parametrize('n_fft', [512, 2048])\n@pytest.mark.parametrize('hop_length', [256, 512])\n@pytest.mark.parametrize('detrend', [False, True])\n@pytest.mark.parametrize('center', [False, True])\n@pytest.mark.parametrize('aggregate', [None, np.mean, np.max])\ndef test_onset_strength_spectrogram(melspec_sr, feature, n_fft, hop_length, detrend, center, aggregate):\n    (S, sr) = melspec_sr\n    oenv = librosa.onset.onset_strength(y=None, sr=sr, S=S, detrend=detrend, center=center, aggregate=aggregate, feature=feature, n_fft=n_fft, hop_length=hop_length)\n    assert (oenv.ndim == 1)\n    target_shape = S.shape[(- 1)]\n    if (not detrend):\n        assert np.all((oenv >= 0))\n    assert (oenv.shape[(- 1)] == '???')", "ground_truth": "target_shape", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_134", "reponame": "librosa", "testpath": "tests/test_onset.py", "testname": "test_onset.py", "classname": null, "funcname": "test_onset_strength_multi_noagg", "imports": ["import pytest", "from contextlib import nullcontext as dnr", "import os", "import warnings", "import numpy as np", "import librosa", "from test_core import srand"], "code": "@pytest.mark.parametrize('lag', [1, 2, 3])\n@pytest.mark.parametrize('aggregate', [np.mean, np.max])\ndef test_onset_strength_multi_noagg(melspec_sr, lag, aggregate):\n    (S, sr) = melspec_sr\n    odf_multi = librosa.onset.onset_strength_multi(S=S, lag=lag, max_size=1, aggregate=False)\n    odf_mean = librosa.onset.onset_strength_multi(S=S, lag=lag, max_size=1, aggregate=aggregate)\n    assert (odf_multi.shape == S.shape)\n    assert np.allclose(odf_mean, aggregate(odf_multi, axis=0))", "masked_code": "@pytest.mark.parametrize('lag', [1, 2, 3])\n@pytest.mark.parametrize('aggregate', [np.mean, np.max])\ndef test_onset_strength_multi_noagg(melspec_sr, lag, aggregate):\n    (S, sr) = melspec_sr\n    odf_multi = librosa.onset.onset_strength_multi(S=S, lag=lag, max_size=1, aggregate=False)\n    odf_mean = librosa.onset.onset_strength_multi(S=S, lag=lag, max_size=1, aggregate=aggregate)\n    assert (odf_multi.shape == '???')\n    assert np.allclose(odf_mean, aggregate(odf_multi, axis=0))", "ground_truth": "S.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_135", "reponame": "librosa", "testpath": "tests/test_onset.py", "testname": "test_onset.py", "classname": null, "funcname": "test_onset_strength_multi", "imports": ["import pytest", "from contextlib import nullcontext as dnr", "import os", "import warnings", "import numpy as np", "import librosa", "from test_core import srand"], "code": "@pytest.mark.parametrize('lag', [1, 2, 3])\ndef test_onset_strength_multi(melspec_sr, lag, channels):\n    (S, sr) = melspec_sr\n    odf_multi = librosa.onset.onset_strength_multi(S=S, lag=lag, max_size=1, channels=channels)\n    assert (len(odf_multi) == (len(channels) - 1))\n    for (i, (s, t)) in enumerate(zip(channels, channels[1:])):\n        odf_single = librosa.onset.onset_strength(S=S[s:t], lag=lag, max_size=1)\n        assert np.allclose(odf_single, odf_multi[i])", "masked_code": "@pytest.mark.parametrize('lag', [1, 2, 3])\ndef test_onset_strength_multi(melspec_sr, lag, channels):\n    (S, sr) = melspec_sr\n    odf_multi = librosa.onset.onset_strength_multi(S=S, lag=lag, max_size=1, channels=channels)\n    assert (len(odf_multi) == '???')\n    for (i, (s, t)) in enumerate(zip(channels, channels[1:])):\n        odf_single = librosa.onset.onset_strength(S=S[s:t], lag=lag, max_size=1)\n        assert np.allclose(odf_single, odf_multi[i])", "ground_truth": "(len(channels) - 1)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_136", "reponame": "librosa", "testpath": "tests/test_onset.py", "testname": "test_onset.py", "classname": null, "funcname": "test_onset_detect_dense_const", "imports": ["import pytest", "from contextlib import nullcontext as dnr", "import os", "import warnings", "import numpy as np", "import librosa", "from test_core import srand"], "code": "def test_onset_detect_dense_const():\n    z = np.zeros(512)\n    onsets = librosa.onset.onset_detect(onset_envelope=z, sparse=False)\n    assert (z.shape == onsets.shape)\n    assert (onsets.dtype is np.dtype(bool))\n    assert (not np.any(onsets))", "masked_code": "def test_onset_detect_dense_const():\n    z = np.zeros(512)\n    onsets = librosa.onset.onset_detect(onset_envelope=z, sparse=False)\n    assert (z.shape == '???')\n    assert (onsets.dtype is np.dtype(bool))\n    assert (not np.any(onsets))", "ground_truth": "onsets.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_137", "reponame": "librosa", "testpath": "tests/test_segment.py", "testname": "test_segment.py", "classname": null, "funcname": "test_cross_similarity", "imports": ["from typing import Union", "import warnings", "import os", "import numpy as np", "import scipy", "from scipy.spatial.distance import cdist, pdist, squareform", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('n', [20, 250])\n@pytest.mark.parametrize('k', [None, 5])\n@pytest.mark.parametrize('metric', ['l2', 'cosine'])\ndef test_cross_similarity(n, k, metric):\n    srand()\n    data_ref = np.random.randn(3, n)\n    data = np.random.randn(3, (n + 7))\n    D = librosa.segment.cross_similarity(data, data_ref, k=k, metric=metric)\n    assert (D.shape == (data_ref.shape[1], data.shape[1]))\n    if (k is not None):\n        real_k = min(k, n)\n        assert (not np.any((D.sum(axis=0) != real_k)))", "masked_code": "@pytest.mark.parametrize('n', [20, 250])\n@pytest.mark.parametrize('k', [None, 5])\n@pytest.mark.parametrize('metric', ['l2', 'cosine'])\ndef test_cross_similarity(n, k, metric):\n    srand()\n    data_ref = np.random.randn(3, n)\n    data = np.random.randn(3, (n + 7))\n    D = librosa.segment.cross_similarity(data, data_ref, k=k, metric=metric)\n    assert (D.shape == '???')\n    if (k is not None):\n        real_k = min(k, n)\n        assert (not np.any((D.sum(axis=0) != real_k)))", "ground_truth": "(data_ref.shape[1], data.shape[1])", "quality_analysis": {"complexity_score": 16, "left_complexity": 2, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_138", "reponame": "librosa", "testpath": "tests/test_segment.py", "testname": "test_segment.py", "classname": null, "funcname": "test_recurrence_to_lag_sparse", "imports": ["from typing import Union", "import warnings", "import os", "import numpy as np", "import scipy", "from scipy.spatial.distance import cdist, pdist, squareform", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('pad', [False, True])\n@pytest.mark.parametrize('axis', [0, 1, (- 1)])\n@pytest.mark.parametrize('rec', [librosa.segment.recurrence_matrix(np.random.randn(3, 100), sparse=True)])\n@pytest.mark.parametrize('fmt', ['csc', 'csr', 'lil', 'bsr', 'dia'])\n@pytest.mark.filterwarnings('ignore:Constructing a DIA matrix')\ndef test_recurrence_to_lag_sparse(pad, axis, rec, fmt):\n    rec_dense = rec.toarray()\n    rec = rec.asformat(fmt)\n    lag_sparse = librosa.segment.recurrence_to_lag(rec, pad=pad, axis=axis)\n    lag_dense = librosa.segment.recurrence_to_lag(rec_dense, pad=pad, axis=axis)\n    assert scipy.sparse.issparse(lag_sparse)\n    assert (rec.format == lag_sparse.format)\n    assert (rec.dtype == lag_sparse.dtype)\n    assert np.allclose(lag_sparse.toarray(), lag_dense)", "masked_code": "@pytest.mark.parametrize('pad', [False, True])\n@pytest.mark.parametrize('axis', [0, 1, (- 1)])\n@pytest.mark.parametrize('rec', [librosa.segment.recurrence_matrix(np.random.randn(3, 100), sparse=True)])\n@pytest.mark.parametrize('fmt', ['csc', 'csr', 'lil', 'bsr', 'dia'])\n@pytest.mark.filterwarnings('ignore:Constructing a DIA matrix')\ndef test_recurrence_to_lag_sparse(pad, axis, rec, fmt):\n    rec_dense = rec.toarray()\n    rec = rec.asformat(fmt)\n    lag_sparse = librosa.segment.recurrence_to_lag(rec, pad=pad, axis=axis)\n    lag_dense = librosa.segment.recurrence_to_lag(rec_dense, pad=pad, axis=axis)\n    assert scipy.sparse.issparse(lag_sparse)\n    assert (rec.format == '???')\n    assert (rec.dtype == lag_sparse.dtype)\n    assert np.allclose(lag_sparse.toarray(), lag_dense)", "ground_truth": "lag_sparse.format", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_139", "reponame": "librosa", "testpath": "tests/test_segment.py", "testname": "test_segment.py", "classname": null, "funcname": "test_recurrence_to_lag_sparse", "imports": ["from typing import Union", "import warnings", "import os", "import numpy as np", "import scipy", "from scipy.spatial.distance import cdist, pdist, squareform", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('pad', [False, True])\n@pytest.mark.parametrize('axis', [0, 1, (- 1)])\n@pytest.mark.parametrize('rec', [librosa.segment.recurrence_matrix(np.random.randn(3, 100), sparse=True)])\n@pytest.mark.parametrize('fmt', ['csc', 'csr', 'lil', 'bsr', 'dia'])\n@pytest.mark.filterwarnings('ignore:Constructing a DIA matrix')\ndef test_recurrence_to_lag_sparse(pad, axis, rec, fmt):\n    rec_dense = rec.toarray()\n    rec = rec.asformat(fmt)\n    lag_sparse = librosa.segment.recurrence_to_lag(rec, pad=pad, axis=axis)\n    lag_dense = librosa.segment.recurrence_to_lag(rec_dense, pad=pad, axis=axis)\n    assert scipy.sparse.issparse(lag_sparse)\n    assert (rec.format == lag_sparse.format)\n    assert (rec.dtype == lag_sparse.dtype)\n    assert np.allclose(lag_sparse.toarray(), lag_dense)", "masked_code": "@pytest.mark.parametrize('pad', [False, True])\n@pytest.mark.parametrize('axis', [0, 1, (- 1)])\n@pytest.mark.parametrize('rec', [librosa.segment.recurrence_matrix(np.random.randn(3, 100), sparse=True)])\n@pytest.mark.parametrize('fmt', ['csc', 'csr', 'lil', 'bsr', 'dia'])\n@pytest.mark.filterwarnings('ignore:Constructing a DIA matrix')\ndef test_recurrence_to_lag_sparse(pad, axis, rec, fmt):\n    rec_dense = rec.toarray()\n    rec = rec.asformat(fmt)\n    lag_sparse = librosa.segment.recurrence_to_lag(rec, pad=pad, axis=axis)\n    lag_dense = librosa.segment.recurrence_to_lag(rec_dense, pad=pad, axis=axis)\n    assert scipy.sparse.issparse(lag_sparse)\n    assert (rec.format == lag_sparse.format)\n    assert (rec.dtype == '???')\n    assert np.allclose(lag_sparse.toarray(), lag_dense)", "ground_truth": "lag_sparse.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_140", "reponame": "librosa", "testpath": "tests/test_segment.py", "testname": "test_segment.py", "classname": null, "funcname": "test_lag_to_recurrence_sparse", "imports": ["from typing import Union", "import warnings", "import os", "import numpy as np", "import scipy", "from scipy.spatial.distance import cdist, pdist, squareform", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('axis', [0, 1, (- 1)])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_lag_to_recurrence_sparse(axis, pad):\n    srand()\n    data = np.random.randn(3, 10)\n    rec = librosa.segment.recurrence_matrix(data, sparse=True)\n    lag = librosa.segment.recurrence_to_lag(rec, pad=pad, axis=axis)\n    lag_dense = lag.toarray()\n    rec_sparse = librosa.segment.lag_to_recurrence(lag, axis=axis)\n    rec_dense = librosa.segment.lag_to_recurrence(lag_dense, axis=axis)\n    assert scipy.sparse.issparse(rec_sparse)\n    assert (rec_sparse.format == lag.format)\n    assert (rec_sparse.dtype == lag.dtype)\n    assert np.allclose(rec_sparse.toarray(), rec_dense)", "masked_code": "@pytest.mark.parametrize('axis', [0, 1, (- 1)])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_lag_to_recurrence_sparse(axis, pad):\n    srand()\n    data = np.random.randn(3, 10)\n    rec = librosa.segment.recurrence_matrix(data, sparse=True)\n    lag = librosa.segment.recurrence_to_lag(rec, pad=pad, axis=axis)\n    lag_dense = lag.toarray()\n    rec_sparse = librosa.segment.lag_to_recurrence(lag, axis=axis)\n    rec_dense = librosa.segment.lag_to_recurrence(lag_dense, axis=axis)\n    assert scipy.sparse.issparse(rec_sparse)\n    assert (rec_sparse.format == '???')\n    assert (rec_sparse.dtype == lag.dtype)\n    assert np.allclose(rec_sparse.toarray(), rec_dense)", "ground_truth": "lag.format", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_141", "reponame": "librosa", "testpath": "tests/test_segment.py", "testname": "test_segment.py", "classname": null, "funcname": "test_lag_to_recurrence_sparse", "imports": ["from typing import Union", "import warnings", "import os", "import numpy as np", "import scipy", "from scipy.spatial.distance import cdist, pdist, squareform", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('axis', [0, 1, (- 1)])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_lag_to_recurrence_sparse(axis, pad):\n    srand()\n    data = np.random.randn(3, 10)\n    rec = librosa.segment.recurrence_matrix(data, sparse=True)\n    lag = librosa.segment.recurrence_to_lag(rec, pad=pad, axis=axis)\n    lag_dense = lag.toarray()\n    rec_sparse = librosa.segment.lag_to_recurrence(lag, axis=axis)\n    rec_dense = librosa.segment.lag_to_recurrence(lag_dense, axis=axis)\n    assert scipy.sparse.issparse(rec_sparse)\n    assert (rec_sparse.format == lag.format)\n    assert (rec_sparse.dtype == lag.dtype)\n    assert np.allclose(rec_sparse.toarray(), rec_dense)", "masked_code": "@pytest.mark.parametrize('axis', [0, 1, (- 1)])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_lag_to_recurrence_sparse(axis, pad):\n    srand()\n    data = np.random.randn(3, 10)\n    rec = librosa.segment.recurrence_matrix(data, sparse=True)\n    lag = librosa.segment.recurrence_to_lag(rec, pad=pad, axis=axis)\n    lag_dense = lag.toarray()\n    rec_sparse = librosa.segment.lag_to_recurrence(lag, axis=axis)\n    rec_dense = librosa.segment.lag_to_recurrence(lag_dense, axis=axis)\n    assert scipy.sparse.issparse(rec_sparse)\n    assert (rec_sparse.format == lag.format)\n    assert (rec_sparse.dtype == '???')\n    assert np.allclose(rec_sparse.toarray(), rec_dense)", "ground_truth": "lag.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_142", "reponame": "librosa", "testpath": "tests/test_segment.py", "testname": "test_segment.py", "classname": null, "funcname": "test_path_enhance", "imports": ["from typing import Union", "import warnings", "import os", "import numpy as np", "import scipy", "from scipy.spatial.distance import cdist, pdist, squareform", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('window', ['rect', 'hann'])\n@pytest.mark.parametrize('n', [5, 9])\n@pytest.mark.parametrize('max_ratio', [1.0, 1.5, 2.0])\n@pytest.mark.parametrize('min_ratio', [None, 1.0])\n@pytest.mark.parametrize('n_filters', [1, 2, 5])\n@pytest.mark.parametrize('zero_mean', [False, True])\n@pytest.mark.parametrize('clip', [False, True])\n@pytest.mark.parametrize('kwargs', [dict(), dict(mode='reflect')])\ndef test_path_enhance(R_input, window, n, max_ratio, min_ratio, n_filters, zero_mean, clip, kwargs):\n    R_smooth = librosa.segment.path_enhance(R_input, window=window, n=n, max_ratio=max_ratio, min_ratio=min_ratio, n_filters=n_filters, zero_mean=zero_mean, clip=clip, **kwargs)\n    assert (R_smooth.shape == R_input.shape)\n    assert np.all(np.isfinite(R_smooth))\n    assert (R_smooth.dtype == R_input.dtype)\n    if clip:\n        assert (np.min(R_smooth) >= 0)", "masked_code": "@pytest.mark.parametrize('window', ['rect', 'hann'])\n@pytest.mark.parametrize('n', [5, 9])\n@pytest.mark.parametrize('max_ratio', [1.0, 1.5, 2.0])\n@pytest.mark.parametrize('min_ratio', [None, 1.0])\n@pytest.mark.parametrize('n_filters', [1, 2, 5])\n@pytest.mark.parametrize('zero_mean', [False, True])\n@pytest.mark.parametrize('clip', [False, True])\n@pytest.mark.parametrize('kwargs', [dict(), dict(mode='reflect')])\ndef test_path_enhance(R_input, window, n, max_ratio, min_ratio, n_filters, zero_mean, clip, kwargs):\n    R_smooth = librosa.segment.path_enhance(R_input, window=window, n=n, max_ratio=max_ratio, min_ratio=min_ratio, n_filters=n_filters, zero_mean=zero_mean, clip=clip, **kwargs)\n    assert (R_smooth.shape == '???')\n    assert np.all(np.isfinite(R_smooth))\n    assert (R_smooth.dtype == R_input.dtype)\n    if clip:\n        assert (np.min(R_smooth) >= 0)", "ground_truth": "R_input.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_143", "reponame": "librosa", "testpath": "tests/test_segment.py", "testname": "test_segment.py", "classname": null, "funcname": "test_path_enhance", "imports": ["from typing import Union", "import warnings", "import os", "import numpy as np", "import scipy", "from scipy.spatial.distance import cdist, pdist, squareform", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('window', ['rect', 'hann'])\n@pytest.mark.parametrize('n', [5, 9])\n@pytest.mark.parametrize('max_ratio', [1.0, 1.5, 2.0])\n@pytest.mark.parametrize('min_ratio', [None, 1.0])\n@pytest.mark.parametrize('n_filters', [1, 2, 5])\n@pytest.mark.parametrize('zero_mean', [False, True])\n@pytest.mark.parametrize('clip', [False, True])\n@pytest.mark.parametrize('kwargs', [dict(), dict(mode='reflect')])\ndef test_path_enhance(R_input, window, n, max_ratio, min_ratio, n_filters, zero_mean, clip, kwargs):\n    R_smooth = librosa.segment.path_enhance(R_input, window=window, n=n, max_ratio=max_ratio, min_ratio=min_ratio, n_filters=n_filters, zero_mean=zero_mean, clip=clip, **kwargs)\n    assert (R_smooth.shape == R_input.shape)\n    assert np.all(np.isfinite(R_smooth))\n    assert (R_smooth.dtype == R_input.dtype)\n    if clip:\n        assert (np.min(R_smooth) >= 0)", "masked_code": "@pytest.mark.parametrize('window', ['rect', 'hann'])\n@pytest.mark.parametrize('n', [5, 9])\n@pytest.mark.parametrize('max_ratio', [1.0, 1.5, 2.0])\n@pytest.mark.parametrize('min_ratio', [None, 1.0])\n@pytest.mark.parametrize('n_filters', [1, 2, 5])\n@pytest.mark.parametrize('zero_mean', [False, True])\n@pytest.mark.parametrize('clip', [False, True])\n@pytest.mark.parametrize('kwargs', [dict(), dict(mode='reflect')])\ndef test_path_enhance(R_input, window, n, max_ratio, min_ratio, n_filters, zero_mean, clip, kwargs):\n    R_smooth = librosa.segment.path_enhance(R_input, window=window, n=n, max_ratio=max_ratio, min_ratio=min_ratio, n_filters=n_filters, zero_mean=zero_mean, clip=clip, **kwargs)\n    assert (R_smooth.shape == R_input.shape)\n    assert np.all(np.isfinite(R_smooth))\n    assert (R_smooth.dtype == '???')\n    if clip:\n        assert (np.min(R_smooth) >= 0)", "ground_truth": "R_input.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_144", "reponame": "librosa", "testpath": "tests/test_sequence.py", "testname": "test_sequence.py", "classname": null, "funcname": "test_trans_uniform", "imports": ["import numpy as np", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('n', range(1, 4))\ndef test_trans_uniform(n):\n    A = librosa.sequence.transition_uniform(n)\n    assert (A.shape == (n, n))\n    assert np.allclose(A, (1.0 / n))", "masked_code": "@pytest.mark.parametrize('n', range(1, 4))\ndef test_trans_uniform(n):\n    A = librosa.sequence.transition_uniform(n)\n    assert (A.shape == '???')\n    assert np.allclose(A, (1.0 / n))", "ground_truth": "(n, n)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_145", "reponame": "librosa", "testpath": "tests/test_sequence.py", "testname": "test_sequence.py", "classname": null, "funcname": "test_trans_loop", "imports": ["import numpy as np", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('n,p', [(2, 0.5), (3, 0.5), (3, [0.8, 0.7, 0.5])])\ndef test_trans_loop(n, p):\n    A = librosa.sequence.transition_loop(n, p)\n    assert (A.shape == (n, n))\n    assert np.allclose(np.diag(A), p)\n    assert np.all((A >= 0))\n    assert np.allclose(A.sum(axis=1), 1)", "masked_code": "@pytest.mark.parametrize('n,p', [(2, 0.5), (3, 0.5), (3, [0.8, 0.7, 0.5])])\ndef test_trans_loop(n, p):\n    A = librosa.sequence.transition_loop(n, p)\n    assert (A.shape == '???')\n    assert np.allclose(np.diag(A), p)\n    assert np.all((A >= 0))\n    assert np.allclose(A.sum(axis=1), 1)", "ground_truth": "(n, n)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_146", "reponame": "librosa", "testpath": "tests/test_sequence.py", "testname": "test_sequence.py", "classname": null, "funcname": "test_trans_cycle", "imports": ["import numpy as np", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('n,p', [(2, 0.5), (3, 0.5), (3, [0.8, 0.7, 0.5])])\ndef test_trans_cycle(n, p):\n    A = librosa.sequence.transition_cycle(n, p)\n    assert (A.shape == (n, n))\n    assert np.allclose(np.diag(A), p)\n    for i in range(n):\n        assert (A[(i, np.mod((i + 1), n))] == (1 - A[(i, i)]))\n    assert np.all((A >= 0))\n    assert np.allclose(A.sum(axis=1), 1)", "masked_code": "@pytest.mark.parametrize('n,p', [(2, 0.5), (3, 0.5), (3, [0.8, 0.7, 0.5])])\ndef test_trans_cycle(n, p):\n    A = librosa.sequence.transition_cycle(n, p)\n    assert (A.shape == '???')\n    assert np.allclose(np.diag(A), p)\n    for i in range(n):\n        assert (A[(i, np.mod((i + 1), n))] == (1 - A[(i, i)]))\n    assert np.all((A >= 0))\n    assert np.allclose(A.sum(axis=1), 1)", "ground_truth": "(n, n)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_147", "reponame": "librosa", "testpath": "tests/test_sequence.py", "testname": "test_sequence.py", "classname": null, "funcname": "test_trans_cycle", "imports": ["import numpy as np", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('n,p', [(2, 0.5), (3, 0.5), (3, [0.8, 0.7, 0.5])])\ndef test_trans_cycle(n, p):\n    A = librosa.sequence.transition_cycle(n, p)\n    assert (A.shape == (n, n))\n    assert np.allclose(np.diag(A), p)\n    for i in range(n):\n        assert (A[(i, np.mod((i + 1), n))] == (1 - A[(i, i)]))\n    assert np.all((A >= 0))\n    assert np.allclose(A.sum(axis=1), 1)", "masked_code": "@pytest.mark.parametrize('n,p', [(2, 0.5), (3, 0.5), (3, [0.8, 0.7, 0.5])])\ndef test_trans_cycle(n, p):\n    A = librosa.sequence.transition_cycle(n, p)\n    assert (A.shape == (n, n))\n    assert np.allclose(np.diag(A), p)\n    for i in range(n):\n        assert (A[(i, np.mod((i + 1), n))] == '???')\n    assert np.all((A >= 0))\n    assert np.allclose(A.sum(axis=1), 1)", "ground_truth": "(1 - A[(i, i)])", "quality_analysis": {"complexity_score": 26, "left_complexity": 15, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_148", "reponame": "librosa", "testpath": "tests/test_sequence.py", "testname": "test_sequence.py", "classname": null, "funcname": "test_rqa_edge", "imports": ["import numpy as np", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('gap_onset', [1, np.inf])\n@pytest.mark.parametrize('gap_extend', [1, np.inf])\n@pytest.mark.parametrize('knight', [False, True])\n@pytest.mark.parametrize('backtrack', [False, True])\ndef test_rqa_edge(gap_onset, gap_extend, knight, backtrack: bool):\n    rec = np.asarray([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 1, 1], [0, 0, 0, 1]])\n    kwargs = dict(gap_onset=gap_onset, gap_extend=gap_extend, knight_moves=knight)\n    if backtrack:\n        out = librosa.sequence.rqa(rec, backtrack=backtrack, **kwargs)\n        (score, path) = out\n        __validate_rqa_results(rec, score, path, gap_onset, gap_extend, backtrack, knight)\n        assert (len(path) == 3)\n    else:\n        out = librosa.sequence.rqa(rec, backtrack=backtrack, **kwargs)\n        assert (out.shape == rec.shape)", "masked_code": "@pytest.mark.parametrize('gap_onset', [1, np.inf])\n@pytest.mark.parametrize('gap_extend', [1, np.inf])\n@pytest.mark.parametrize('knight', [False, True])\n@pytest.mark.parametrize('backtrack', [False, True])\ndef test_rqa_edge(gap_onset, gap_extend, knight, backtrack: bool):\n    rec = np.asarray([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 1, 1], [0, 0, 0, 1]])\n    kwargs = dict(gap_onset=gap_onset, gap_extend=gap_extend, knight_moves=knight)\n    if backtrack:\n        out = librosa.sequence.rqa(rec, backtrack=backtrack, **kwargs)\n        (score, path) = out\n        __validate_rqa_results(rec, score, path, gap_onset, gap_extend, backtrack, knight)\n        assert (len(path) == '???')\n    else:\n        out = librosa.sequence.rqa(rec, backtrack=backtrack, **kwargs)\n        assert (out.shape == rec.shape)", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_149", "reponame": "librosa", "testpath": "tests/test_sequence.py", "testname": "test_sequence.py", "classname": null, "funcname": "test_rqa_edge", "imports": ["import numpy as np", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('gap_onset', [1, np.inf])\n@pytest.mark.parametrize('gap_extend', [1, np.inf])\n@pytest.mark.parametrize('knight', [False, True])\n@pytest.mark.parametrize('backtrack', [False, True])\ndef test_rqa_edge(gap_onset, gap_extend, knight, backtrack: bool):\n    rec = np.asarray([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 1, 1], [0, 0, 0, 1]])\n    kwargs = dict(gap_onset=gap_onset, gap_extend=gap_extend, knight_moves=knight)\n    if backtrack:\n        out = librosa.sequence.rqa(rec, backtrack=backtrack, **kwargs)\n        (score, path) = out\n        __validate_rqa_results(rec, score, path, gap_onset, gap_extend, backtrack, knight)\n        assert (len(path) == 3)\n    else:\n        out = librosa.sequence.rqa(rec, backtrack=backtrack, **kwargs)\n        assert (out.shape == rec.shape)", "masked_code": "@pytest.mark.parametrize('gap_onset', [1, np.inf])\n@pytest.mark.parametrize('gap_extend', [1, np.inf])\n@pytest.mark.parametrize('knight', [False, True])\n@pytest.mark.parametrize('backtrack', [False, True])\ndef test_rqa_edge(gap_onset, gap_extend, knight, backtrack: bool):\n    rec = np.asarray([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 1, 1], [0, 0, 0, 1]])\n    kwargs = dict(gap_onset=gap_onset, gap_extend=gap_extend, knight_moves=knight)\n    if backtrack:\n        out = librosa.sequence.rqa(rec, backtrack=backtrack, **kwargs)\n        (score, path) = out\n        __validate_rqa_results(rec, score, path, gap_onset, gap_extend, backtrack, knight)\n        assert (len(path) == 3)\n    else:\n        out = librosa.sequence.rqa(rec, backtrack=backtrack, **kwargs)\n        assert (out.shape == '???')", "ground_truth": "rec.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_150", "reponame": "librosa", "testpath": "tests/test_sequence.py", "testname": "test_sequence.py", "classname": null, "funcname": "test_rqa_empty", "imports": ["import numpy as np", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('gap_onset', [1, np.inf])\n@pytest.mark.parametrize('gap_extend', [1, np.inf])\n@pytest.mark.parametrize('knight', [False, True])\ndef test_rqa_empty(gap_onset, gap_extend, knight):\n    rec = np.zeros((5, 5))\n    (score, path) = librosa.sequence.rqa(rec, gap_onset=gap_onset, gap_extend=gap_extend, knight_moves=knight, backtrack=True)\n    assert (score.shape == rec.shape)\n    assert np.allclose(score, 0)\n    assert (path.shape == (0, 2))", "masked_code": "@pytest.mark.parametrize('gap_onset', [1, np.inf])\n@pytest.mark.parametrize('gap_extend', [1, np.inf])\n@pytest.mark.parametrize('knight', [False, True])\ndef test_rqa_empty(gap_onset, gap_extend, knight):\n    rec = np.zeros((5, 5))\n    (score, path) = librosa.sequence.rqa(rec, gap_onset=gap_onset, gap_extend=gap_extend, knight_moves=knight, backtrack=True)\n    assert (score.shape == '???')\n    assert np.allclose(score, 0)\n    assert (path.shape == (0, 2))", "ground_truth": "rec.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_151", "reponame": "librosa", "testpath": "tests/test_sequence.py", "testname": "test_sequence.py", "classname": null, "funcname": "test_rqa_empty", "imports": ["import numpy as np", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('gap_onset', [1, np.inf])\n@pytest.mark.parametrize('gap_extend', [1, np.inf])\n@pytest.mark.parametrize('knight', [False, True])\ndef test_rqa_empty(gap_onset, gap_extend, knight):\n    rec = np.zeros((5, 5))\n    (score, path) = librosa.sequence.rqa(rec, gap_onset=gap_onset, gap_extend=gap_extend, knight_moves=knight, backtrack=True)\n    assert (score.shape == rec.shape)\n    assert np.allclose(score, 0)\n    assert (path.shape == (0, 2))", "masked_code": "@pytest.mark.parametrize('gap_onset', [1, np.inf])\n@pytest.mark.parametrize('gap_extend', [1, np.inf])\n@pytest.mark.parametrize('knight', [False, True])\ndef test_rqa_empty(gap_onset, gap_extend, knight):\n    rec = np.zeros((5, 5))\n    (score, path) = librosa.sequence.rqa(rec, gap_onset=gap_onset, gap_extend=gap_extend, knight_moves=knight, backtrack=True)\n    assert (score.shape == rec.shape)\n    assert np.allclose(score, 0)\n    assert (path.shape == '???')", "ground_truth": "(0, 2)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_152", "reponame": "librosa", "testpath": "tests/test_sequence.py", "testname": "test_sequence.py", "classname": null, "funcname": "test_rqa_interior", "imports": ["import numpy as np", "import pytest", "from test_core import srand", "import librosa"], "code": "@pytest.mark.parametrize('gap_onset', [1, np.inf])\n@pytest.mark.parametrize('gap_extend', [1, np.inf])\n@pytest.mark.parametrize('knight', [False, True])\n@pytest.mark.parametrize('backtrack', [False, True])\ndef test_rqa_interior(gap_onset, gap_extend, knight, backtrack: bool):\n    rec = np.asarray([[0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]])\n    kwargs = dict(gap_onset=gap_onset, gap_extend=gap_extend, knight_moves=knight)\n    if backtrack:\n        out = librosa.sequence.rqa(rec, backtrack=backtrack, **kwargs)\n        (score, path) = out\n        __validate_rqa_results(rec, score, path, gap_onset, gap_extend, backtrack, knight)\n        assert (len(path) == 2)\n    else:\n        out = librosa.sequence.rqa(rec, backtrack=backtrack, **kwargs)\n        assert (out.shape == rec.shape)", "masked_code": "@pytest.mark.parametrize('gap_onset', [1, np.inf])\n@pytest.mark.parametrize('gap_extend', [1, np.inf])\n@pytest.mark.parametrize('knight', [False, True])\n@pytest.mark.parametrize('backtrack', [False, True])\ndef test_rqa_interior(gap_onset, gap_extend, knight, backtrack: bool):\n    rec = np.asarray([[0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 0]])\n    kwargs = dict(gap_onset=gap_onset, gap_extend=gap_extend, knight_moves=knight)\n    if backtrack:\n        out = librosa.sequence.rqa(rec, backtrack=backtrack, **kwargs)\n        (score, path) = out\n        __validate_rqa_results(rec, score, path, gap_onset, gap_extend, backtrack, knight)\n        assert (len(path) == 2)\n    else:\n        out = librosa.sequence.rqa(rec, backtrack=backtrack, **kwargs)\n        assert (out.shape == '???')", "ground_truth": "rec.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_153", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_frame_targetaxis", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('in_shape,axis,out_shape', [((20, 20, 20, 20), 0, (6, 10, 20, 20, 20)), ((20, 20, 20, 20), 1, (20, 6, 10, 20, 20)), ((20, 20, 20, 20), 2, (20, 20, 6, 10, 20)), ((20, 20, 20, 20), 3, (20, 20, 20, 6, 10)), ((20, 20, 20, 20), (- 1), (20, 20, 20, 10, 6)), ((20, 20, 20, 20), (- 2), (20, 20, 10, 6, 20)), ((20, 20, 20, 20), (- 3), (20, 10, 6, 20, 20)), ((20, 20, 20, 20), (- 4), (10, 6, 20, 20, 20))])\ndef test_frame_targetaxis(in_shape, axis, out_shape):\n    x = np.empty(in_shape)\n    xf = librosa.util.frame(x, frame_length=10, hop_length=2, axis=axis)\n    assert (xf.shape == out_shape)", "masked_code": "@pytest.mark.parametrize('in_shape,axis,out_shape', [((20, 20, 20, 20), 0, (6, 10, 20, 20, 20)), ((20, 20, 20, 20), 1, (20, 6, 10, 20, 20)), ((20, 20, 20, 20), 2, (20, 20, 6, 10, 20)), ((20, 20, 20, 20), 3, (20, 20, 20, 6, 10)), ((20, 20, 20, 20), (- 1), (20, 20, 20, 10, 6)), ((20, 20, 20, 20), (- 2), (20, 20, 10, 6, 20)), ((20, 20, 20, 20), (- 3), (20, 10, 6, 20, 20)), ((20, 20, 20, 20), (- 4), (10, 6, 20, 20, 20))])\ndef test_frame_targetaxis(in_shape, axis, out_shape):\n    x = np.empty(in_shape)\n    xf = librosa.util.frame(x, frame_length=10, hop_length=2, axis=axis)\n    assert (xf.shape == '???')", "ground_truth": "out_shape", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_154", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_fix_frames", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('frames', [np.arange(20, 100, step=15)])\n@pytest.mark.parametrize('x_min', [0, 20])\n@pytest.mark.parametrize('x_max', [20, 70, 120])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_fix_frames(frames, x_min, x_max, pad):\n    f_fix = librosa.util.fix_frames(frames, x_min=x_min, x_max=x_max, pad=pad)\n    if (x_min is not None):\n        if pad:\n            assert (f_fix[0] == x_min)\n        assert np.all((f_fix >= x_min))\n    if (x_max is not None):\n        if pad:\n            assert (f_fix[(- 1)] == x_max)\n        assert np.all((f_fix <= x_max))", "masked_code": "@pytest.mark.parametrize('frames', [np.arange(20, 100, step=15)])\n@pytest.mark.parametrize('x_min', [0, 20])\n@pytest.mark.parametrize('x_max', [20, 70, 120])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_fix_frames(frames, x_min, x_max, pad):\n    f_fix = librosa.util.fix_frames(frames, x_min=x_min, x_max=x_max, pad=pad)\n    if (x_min is not None):\n        if pad:\n            assert (f_fix[0] == '???')\n        assert np.all((f_fix >= x_min))\n    if (x_max is not None):\n        if pad:\n            assert (f_fix[(- 1)] == x_max)\n        assert np.all((f_fix <= x_max))", "ground_truth": "x_min", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_155", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_fix_frames", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('frames', [np.arange(20, 100, step=15)])\n@pytest.mark.parametrize('x_min', [0, 20])\n@pytest.mark.parametrize('x_max', [20, 70, 120])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_fix_frames(frames, x_min, x_max, pad):\n    f_fix = librosa.util.fix_frames(frames, x_min=x_min, x_max=x_max, pad=pad)\n    if (x_min is not None):\n        if pad:\n            assert (f_fix[0] == x_min)\n        assert np.all((f_fix >= x_min))\n    if (x_max is not None):\n        if pad:\n            assert (f_fix[(- 1)] == x_max)\n        assert np.all((f_fix <= x_max))", "masked_code": "@pytest.mark.parametrize('frames', [np.arange(20, 100, step=15)])\n@pytest.mark.parametrize('x_min', [0, 20])\n@pytest.mark.parametrize('x_max', [20, 70, 120])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_fix_frames(frames, x_min, x_max, pad):\n    f_fix = librosa.util.fix_frames(frames, x_min=x_min, x_max=x_max, pad=pad)\n    if (x_min is not None):\n        if pad:\n            assert (f_fix[0] == x_min)\n        assert np.all((f_fix >= x_min))\n    if (x_max is not None):\n        if pad:\n            assert (f_fix[(- 1)] == '???')\n        assert np.all((f_fix <= x_max))", "ground_truth": "x_max", "quality_analysis": {"complexity_score": 8, "left_complexity": 7, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_156", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_normalize", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('norm', [np.inf, (- np.inf), 0, 0.5, 1.0, 2.0, None])\n@pytest.mark.parametrize('ndims,axis', [(1, 0), (1, (- 1)), (2, 0), (2, 1), (2, (- 1)), (3, 0), (3, 1), (3, 2), (3, (- 1))])\ndef test_normalize(ndims, norm, axis):\n    srand()\n    X = np.asarray(np.random.randn(*([4] * ndims)))\n    X_norm = librosa.util.normalize(X, norm=norm, axis=axis)\n    assert (X_norm.dtype == X.dtype)\n    assert (X_norm.shape == X.shape)\n    if (norm is None):\n        assert np.allclose(X, X_norm)\n        return\n    X_norm = np.abs(X_norm)\n    if (norm == np.inf):\n        values = np.max(X_norm, axis=axis)\n    elif (norm == (- np.inf)):\n        values = np.min(X_norm, axis=axis)\n    elif (norm == 0):\n        values = np.ones(1)\n    else:\n        values = (np.sum((X_norm ** norm), axis=axis) ** (1.0 / norm))\n    assert np.allclose(values, np.ones_like(values))", "masked_code": "@pytest.mark.parametrize('norm', [np.inf, (- np.inf), 0, 0.5, 1.0, 2.0, None])\n@pytest.mark.parametrize('ndims,axis', [(1, 0), (1, (- 1)), (2, 0), (2, 1), (2, (- 1)), (3, 0), (3, 1), (3, 2), (3, (- 1))])\ndef test_normalize(ndims, norm, axis):\n    srand()\n    X = np.asarray(np.random.randn(*([4] * ndims)))\n    X_norm = librosa.util.normalize(X, norm=norm, axis=axis)\n    assert (X_norm.dtype == '???')\n    assert (X_norm.shape == X.shape)\n    if (norm is None):\n        assert np.allclose(X, X_norm)\n        return\n    X_norm = np.abs(X_norm)\n    if (norm == np.inf):\n        values = np.max(X_norm, axis=axis)\n    elif (norm == (- np.inf)):\n        values = np.min(X_norm, axis=axis)\n    elif (norm == 0):\n        values = np.ones(1)\n    else:\n        values = (np.sum((X_norm ** norm), axis=axis) ** (1.0 / norm))\n    assert np.allclose(values, np.ones_like(values))", "ground_truth": "X.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_157", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_normalize", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('norm', [np.inf, (- np.inf), 0, 0.5, 1.0, 2.0, None])\n@pytest.mark.parametrize('ndims,axis', [(1, 0), (1, (- 1)), (2, 0), (2, 1), (2, (- 1)), (3, 0), (3, 1), (3, 2), (3, (- 1))])\ndef test_normalize(ndims, norm, axis):\n    srand()\n    X = np.asarray(np.random.randn(*([4] * ndims)))\n    X_norm = librosa.util.normalize(X, norm=norm, axis=axis)\n    assert (X_norm.dtype == X.dtype)\n    assert (X_norm.shape == X.shape)\n    if (norm is None):\n        assert np.allclose(X, X_norm)\n        return\n    X_norm = np.abs(X_norm)\n    if (norm == np.inf):\n        values = np.max(X_norm, axis=axis)\n    elif (norm == (- np.inf)):\n        values = np.min(X_norm, axis=axis)\n    elif (norm == 0):\n        values = np.ones(1)\n    else:\n        values = (np.sum((X_norm ** norm), axis=axis) ** (1.0 / norm))\n    assert np.allclose(values, np.ones_like(values))", "masked_code": "@pytest.mark.parametrize('norm', [np.inf, (- np.inf), 0, 0.5, 1.0, 2.0, None])\n@pytest.mark.parametrize('ndims,axis', [(1, 0), (1, (- 1)), (2, 0), (2, 1), (2, (- 1)), (3, 0), (3, 1), (3, 2), (3, (- 1))])\ndef test_normalize(ndims, norm, axis):\n    srand()\n    X = np.asarray(np.random.randn(*([4] * ndims)))\n    X_norm = librosa.util.normalize(X, norm=norm, axis=axis)\n    assert (X_norm.dtype == X.dtype)\n    assert (X_norm.shape == '???')\n    if (norm is None):\n        assert np.allclose(X, X_norm)\n        return\n    X_norm = np.abs(X_norm)\n    if (norm == np.inf):\n        values = np.max(X_norm, axis=axis)\n    elif (norm == (- np.inf)):\n        values = np.min(X_norm, axis=axis)\n    elif (norm == 0):\n        values = np.ones(1)\n    else:\n        values = (np.sum((X_norm ** norm), axis=axis) ** (1.0 / norm))\n    assert np.allclose(values, np.ones_like(values))", "ground_truth": "X.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_158", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_sparsify_rows_dtype", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('dtype', [None, np.float32, np.float64])\n@pytest.mark.parametrize('ref_dtype', [np.float32, np.float64])\ndef test_sparsify_rows_dtype(dtype, ref_dtype):\n    x = np.ones(10, dtype=ref_dtype)\n    xs = librosa.util.sparsify_rows(x, dtype=dtype)\n    if (dtype is None):\n        assert (xs.dtype == x.dtype)\n    else:\n        assert (xs.dtype == dtype)", "masked_code": "@pytest.mark.parametrize('dtype', [None, np.float32, np.float64])\n@pytest.mark.parametrize('ref_dtype', [np.float32, np.float64])\ndef test_sparsify_rows_dtype(dtype, ref_dtype):\n    x = np.ones(10, dtype=ref_dtype)\n    xs = librosa.util.sparsify_rows(x, dtype=dtype)\n    if (dtype is None):\n        assert (xs.dtype == '???')\n    else:\n        assert (xs.dtype == dtype)", "ground_truth": "x.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_159", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_sparsify_rows_dtype", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('dtype', [None, np.float32, np.float64])\n@pytest.mark.parametrize('ref_dtype', [np.float32, np.float64])\ndef test_sparsify_rows_dtype(dtype, ref_dtype):\n    x = np.ones(10, dtype=ref_dtype)\n    xs = librosa.util.sparsify_rows(x, dtype=dtype)\n    if (dtype is None):\n        assert (xs.dtype == x.dtype)\n    else:\n        assert (xs.dtype == dtype)", "masked_code": "@pytest.mark.parametrize('dtype', [None, np.float32, np.float64])\n@pytest.mark.parametrize('ref_dtype', [np.float32, np.float64])\ndef test_sparsify_rows_dtype(dtype, ref_dtype):\n    x = np.ones(10, dtype=ref_dtype)\n    xs = librosa.util.sparsify_rows(x, dtype=dtype)\n    if (dtype is None):\n        assert (xs.dtype == x.dtype)\n    else:\n        assert (xs.dtype == '???')", "ground_truth": "dtype", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_160", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_find_files", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('searchdir', [os.path.join(os.path.curdir, 'tests'), os.path.join(os.path.curdir, 'tests', 'data')])\n@pytest.mark.parametrize('ext', [None, 'wav', 'WAV', ['wav'], ['WAV']])\n@pytest.mark.parametrize('recurse', [True])\n@pytest.mark.parametrize('case_sensitive', list(({False} | {(platform.system() != 'Windows')})))\n@pytest.mark.parametrize('limit', [None, 1, 2])\n@pytest.mark.parametrize('offset', [0, 1, (- 1)])\n@pytest.mark.parametrize('output', [[os.path.join(os.path.abspath(os.path.curdir), 'tests', 'data', s) for s in ['test1_22050.mp3', 'test1_22050.wav', 'test1_44100.wav', 'test2_8000.wav']]])\ndef test_find_files(searchdir, ext, recurse, case_sensitive, limit, offset, output):\n    files = librosa.util.find_files(searchdir, ext=ext, recurse=recurse, case_sensitive=case_sensitive, limit=limit, offset=offset)\n    targets = output\n    if (ext is not None):\n        targets = targets[1:]\n    s1 = slice(offset, None)\n    s2 = slice(limit)\n    if (case_sensitive and (ext not in (None, 'wav', ['wav']))):\n        assert (len(files) == 0)\n    else:\n        assert (set(files) == set(targets[s1][s2]))", "masked_code": "@pytest.mark.parametrize('searchdir', [os.path.join(os.path.curdir, 'tests'), os.path.join(os.path.curdir, 'tests', 'data')])\n@pytest.mark.parametrize('ext', [None, 'wav', 'WAV', ['wav'], ['WAV']])\n@pytest.mark.parametrize('recurse', [True])\n@pytest.mark.parametrize('case_sensitive', list(({False} | {(platform.system() != 'Windows')})))\n@pytest.mark.parametrize('limit', [None, 1, 2])\n@pytest.mark.parametrize('offset', [0, 1, (- 1)])\n@pytest.mark.parametrize('output', [[os.path.join(os.path.abspath(os.path.curdir), 'tests', 'data', s) for s in ['test1_22050.mp3', 'test1_22050.wav', 'test1_44100.wav', 'test2_8000.wav']]])\ndef test_find_files(searchdir, ext, recurse, case_sensitive, limit, offset, output):\n    files = librosa.util.find_files(searchdir, ext=ext, recurse=recurse, case_sensitive=case_sensitive, limit=limit, offset=offset)\n    targets = output\n    if (ext is not None):\n        targets = targets[1:]\n    s1 = slice(offset, None)\n    s2 = slice(limit)\n    if (case_sensitive and (ext not in (None, 'wav', ['wav']))):\n        assert (len(files) == 0)\n    else:\n        assert (set(files) == '???')", "ground_truth": "set(targets[s1][s2])", "quality_analysis": {"complexity_score": 16, "left_complexity": 4, "right_complexity": 12, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_161", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_index_to_slice", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('idx', [np.arange(10, 90, 10), np.arange(10, 90, 15)])\n@pytest.mark.parametrize('idx_min', [None, 5, 15])\n@pytest.mark.parametrize('idx_max', [None, 85, 100])\n@pytest.mark.parametrize('step', [None, 2])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_index_to_slice(idx, idx_min, idx_max, step, pad):\n    slices = librosa.util.index_to_slice(idx, idx_min=idx_min, idx_max=idx_max, step=step, pad=pad)\n    if pad:\n        if (idx_min is not None):\n            assert (slices[0].start == idx_min)\n            if (idx.min() != idx_min):\n                slices = slices[1:]\n        if (idx_max is not None):\n            assert (slices[(- 1)].stop == idx_max)\n            if (idx.max() != idx_max):\n                slices = slices[:(- 1)]\n    if (idx_min is not None):\n        idx = idx[(idx >= idx_min)]\n    if (idx_max is not None):\n        idx = idx[(idx <= idx_max)]\n    idx = np.unique(idx)\n    assert (len(slices) == (len(idx) - 1))\n    for (sl, start, stop) in zip(slices, idx, idx[1:]):\n        assert (sl.start == start)\n        assert (sl.stop == stop)\n        assert (sl.step == step)", "masked_code": "@pytest.mark.parametrize('idx', [np.arange(10, 90, 10), np.arange(10, 90, 15)])\n@pytest.mark.parametrize('idx_min', [None, 5, 15])\n@pytest.mark.parametrize('idx_max', [None, 85, 100])\n@pytest.mark.parametrize('step', [None, 2])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_index_to_slice(idx, idx_min, idx_max, step, pad):\n    slices = librosa.util.index_to_slice(idx, idx_min=idx_min, idx_max=idx_max, step=step, pad=pad)\n    if pad:\n        if (idx_min is not None):\n            assert (slices[0].start == idx_min)\n            if (idx.min() != idx_min):\n                slices = slices[1:]\n        if (idx_max is not None):\n            assert (slices[(- 1)].stop == idx_max)\n            if (idx.max() != idx_max):\n                slices = slices[:(- 1)]\n    if (idx_min is not None):\n        idx = idx[(idx >= idx_min)]\n    if (idx_max is not None):\n        idx = idx[(idx <= idx_max)]\n    idx = np.unique(idx)\n    assert (len(slices) == '???')\n    for (sl, start, stop) in zip(slices, idx, idx[1:]):\n        assert (sl.start == start)\n        assert (sl.stop == stop)\n        assert (sl.step == step)", "ground_truth": "(len(idx) - 1)", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_162", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_index_to_slice", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('idx', [np.arange(10, 90, 10), np.arange(10, 90, 15)])\n@pytest.mark.parametrize('idx_min', [None, 5, 15])\n@pytest.mark.parametrize('idx_max', [None, 85, 100])\n@pytest.mark.parametrize('step', [None, 2])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_index_to_slice(idx, idx_min, idx_max, step, pad):\n    slices = librosa.util.index_to_slice(idx, idx_min=idx_min, idx_max=idx_max, step=step, pad=pad)\n    if pad:\n        if (idx_min is not None):\n            assert (slices[0].start == idx_min)\n            if (idx.min() != idx_min):\n                slices = slices[1:]\n        if (idx_max is not None):\n            assert (slices[(- 1)].stop == idx_max)\n            if (idx.max() != idx_max):\n                slices = slices[:(- 1)]\n    if (idx_min is not None):\n        idx = idx[(idx >= idx_min)]\n    if (idx_max is not None):\n        idx = idx[(idx <= idx_max)]\n    idx = np.unique(idx)\n    assert (len(slices) == (len(idx) - 1))\n    for (sl, start, stop) in zip(slices, idx, idx[1:]):\n        assert (sl.start == start)\n        assert (sl.stop == stop)\n        assert (sl.step == step)", "masked_code": "@pytest.mark.parametrize('idx', [np.arange(10, 90, 10), np.arange(10, 90, 15)])\n@pytest.mark.parametrize('idx_min', [None, 5, 15])\n@pytest.mark.parametrize('idx_max', [None, 85, 100])\n@pytest.mark.parametrize('step', [None, 2])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_index_to_slice(idx, idx_min, idx_max, step, pad):\n    slices = librosa.util.index_to_slice(idx, idx_min=idx_min, idx_max=idx_max, step=step, pad=pad)\n    if pad:\n        if (idx_min is not None):\n            assert (slices[0].start == idx_min)\n            if (idx.min() != idx_min):\n                slices = slices[1:]\n        if (idx_max is not None):\n            assert (slices[(- 1)].stop == idx_max)\n            if (idx.max() != idx_max):\n                slices = slices[:(- 1)]\n    if (idx_min is not None):\n        idx = idx[(idx >= idx_min)]\n    if (idx_max is not None):\n        idx = idx[(idx <= idx_max)]\n    idx = np.unique(idx)\n    assert (len(slices) == (len(idx) - 1))\n    for (sl, start, stop) in zip(slices, idx, idx[1:]):\n        assert (sl.start == '???')\n        assert (sl.stop == stop)\n        assert (sl.step == step)", "ground_truth": "start", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_163", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_index_to_slice", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('idx', [np.arange(10, 90, 10), np.arange(10, 90, 15)])\n@pytest.mark.parametrize('idx_min', [None, 5, 15])\n@pytest.mark.parametrize('idx_max', [None, 85, 100])\n@pytest.mark.parametrize('step', [None, 2])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_index_to_slice(idx, idx_min, idx_max, step, pad):\n    slices = librosa.util.index_to_slice(idx, idx_min=idx_min, idx_max=idx_max, step=step, pad=pad)\n    if pad:\n        if (idx_min is not None):\n            assert (slices[0].start == idx_min)\n            if (idx.min() != idx_min):\n                slices = slices[1:]\n        if (idx_max is not None):\n            assert (slices[(- 1)].stop == idx_max)\n            if (idx.max() != idx_max):\n                slices = slices[:(- 1)]\n    if (idx_min is not None):\n        idx = idx[(idx >= idx_min)]\n    if (idx_max is not None):\n        idx = idx[(idx <= idx_max)]\n    idx = np.unique(idx)\n    assert (len(slices) == (len(idx) - 1))\n    for (sl, start, stop) in zip(slices, idx, idx[1:]):\n        assert (sl.start == start)\n        assert (sl.stop == stop)\n        assert (sl.step == step)", "masked_code": "@pytest.mark.parametrize('idx', [np.arange(10, 90, 10), np.arange(10, 90, 15)])\n@pytest.mark.parametrize('idx_min', [None, 5, 15])\n@pytest.mark.parametrize('idx_max', [None, 85, 100])\n@pytest.mark.parametrize('step', [None, 2])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_index_to_slice(idx, idx_min, idx_max, step, pad):\n    slices = librosa.util.index_to_slice(idx, idx_min=idx_min, idx_max=idx_max, step=step, pad=pad)\n    if pad:\n        if (idx_min is not None):\n            assert (slices[0].start == idx_min)\n            if (idx.min() != idx_min):\n                slices = slices[1:]\n        if (idx_max is not None):\n            assert (slices[(- 1)].stop == idx_max)\n            if (idx.max() != idx_max):\n                slices = slices[:(- 1)]\n    if (idx_min is not None):\n        idx = idx[(idx >= idx_min)]\n    if (idx_max is not None):\n        idx = idx[(idx <= idx_max)]\n    idx = np.unique(idx)\n    assert (len(slices) == (len(idx) - 1))\n    for (sl, start, stop) in zip(slices, idx, idx[1:]):\n        assert (sl.start == start)\n        assert (sl.stop == '???')\n        assert (sl.step == step)", "ground_truth": "stop", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_164", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_index_to_slice", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('idx', [np.arange(10, 90, 10), np.arange(10, 90, 15)])\n@pytest.mark.parametrize('idx_min', [None, 5, 15])\n@pytest.mark.parametrize('idx_max', [None, 85, 100])\n@pytest.mark.parametrize('step', [None, 2])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_index_to_slice(idx, idx_min, idx_max, step, pad):\n    slices = librosa.util.index_to_slice(idx, idx_min=idx_min, idx_max=idx_max, step=step, pad=pad)\n    if pad:\n        if (idx_min is not None):\n            assert (slices[0].start == idx_min)\n            if (idx.min() != idx_min):\n                slices = slices[1:]\n        if (idx_max is not None):\n            assert (slices[(- 1)].stop == idx_max)\n            if (idx.max() != idx_max):\n                slices = slices[:(- 1)]\n    if (idx_min is not None):\n        idx = idx[(idx >= idx_min)]\n    if (idx_max is not None):\n        idx = idx[(idx <= idx_max)]\n    idx = np.unique(idx)\n    assert (len(slices) == (len(idx) - 1))\n    for (sl, start, stop) in zip(slices, idx, idx[1:]):\n        assert (sl.start == start)\n        assert (sl.stop == stop)\n        assert (sl.step == step)", "masked_code": "@pytest.mark.parametrize('idx', [np.arange(10, 90, 10), np.arange(10, 90, 15)])\n@pytest.mark.parametrize('idx_min', [None, 5, 15])\n@pytest.mark.parametrize('idx_max', [None, 85, 100])\n@pytest.mark.parametrize('step', [None, 2])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_index_to_slice(idx, idx_min, idx_max, step, pad):\n    slices = librosa.util.index_to_slice(idx, idx_min=idx_min, idx_max=idx_max, step=step, pad=pad)\n    if pad:\n        if (idx_min is not None):\n            assert (slices[0].start == idx_min)\n            if (idx.min() != idx_min):\n                slices = slices[1:]\n        if (idx_max is not None):\n            assert (slices[(- 1)].stop == idx_max)\n            if (idx.max() != idx_max):\n                slices = slices[:(- 1)]\n    if (idx_min is not None):\n        idx = idx[(idx >= idx_min)]\n    if (idx_max is not None):\n        idx = idx[(idx <= idx_max)]\n    idx = np.unique(idx)\n    assert (len(slices) == (len(idx) - 1))\n    for (sl, start, stop) in zip(slices, idx, idx[1:]):\n        assert (sl.start == start)\n        assert (sl.stop == stop)\n        assert (sl.step == '???')", "ground_truth": "step", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_165", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_index_to_slice", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('idx', [np.arange(10, 90, 10), np.arange(10, 90, 15)])\n@pytest.mark.parametrize('idx_min', [None, 5, 15])\n@pytest.mark.parametrize('idx_max', [None, 85, 100])\n@pytest.mark.parametrize('step', [None, 2])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_index_to_slice(idx, idx_min, idx_max, step, pad):\n    slices = librosa.util.index_to_slice(idx, idx_min=idx_min, idx_max=idx_max, step=step, pad=pad)\n    if pad:\n        if (idx_min is not None):\n            assert (slices[0].start == idx_min)\n            if (idx.min() != idx_min):\n                slices = slices[1:]\n        if (idx_max is not None):\n            assert (slices[(- 1)].stop == idx_max)\n            if (idx.max() != idx_max):\n                slices = slices[:(- 1)]\n    if (idx_min is not None):\n        idx = idx[(idx >= idx_min)]\n    if (idx_max is not None):\n        idx = idx[(idx <= idx_max)]\n    idx = np.unique(idx)\n    assert (len(slices) == (len(idx) - 1))\n    for (sl, start, stop) in zip(slices, idx, idx[1:]):\n        assert (sl.start == start)\n        assert (sl.stop == stop)\n        assert (sl.step == step)", "masked_code": "@pytest.mark.parametrize('idx', [np.arange(10, 90, 10), np.arange(10, 90, 15)])\n@pytest.mark.parametrize('idx_min', [None, 5, 15])\n@pytest.mark.parametrize('idx_max', [None, 85, 100])\n@pytest.mark.parametrize('step', [None, 2])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_index_to_slice(idx, idx_min, idx_max, step, pad):\n    slices = librosa.util.index_to_slice(idx, idx_min=idx_min, idx_max=idx_max, step=step, pad=pad)\n    if pad:\n        if (idx_min is not None):\n            assert (slices[0].start == '???')\n            if (idx.min() != idx_min):\n                slices = slices[1:]\n        if (idx_max is not None):\n            assert (slices[(- 1)].stop == idx_max)\n            if (idx.max() != idx_max):\n                slices = slices[:(- 1)]\n    if (idx_min is not None):\n        idx = idx[(idx >= idx_min)]\n    if (idx_max is not None):\n        idx = idx[(idx <= idx_max)]\n    idx = np.unique(idx)\n    assert (len(slices) == (len(idx) - 1))\n    for (sl, start, stop) in zip(slices, idx, idx[1:]):\n        assert (sl.start == start)\n        assert (sl.stop == stop)\n        assert (sl.step == step)", "ground_truth": "idx_min", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_166", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_index_to_slice", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('idx', [np.arange(10, 90, 10), np.arange(10, 90, 15)])\n@pytest.mark.parametrize('idx_min', [None, 5, 15])\n@pytest.mark.parametrize('idx_max', [None, 85, 100])\n@pytest.mark.parametrize('step', [None, 2])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_index_to_slice(idx, idx_min, idx_max, step, pad):\n    slices = librosa.util.index_to_slice(idx, idx_min=idx_min, idx_max=idx_max, step=step, pad=pad)\n    if pad:\n        if (idx_min is not None):\n            assert (slices[0].start == idx_min)\n            if (idx.min() != idx_min):\n                slices = slices[1:]\n        if (idx_max is not None):\n            assert (slices[(- 1)].stop == idx_max)\n            if (idx.max() != idx_max):\n                slices = slices[:(- 1)]\n    if (idx_min is not None):\n        idx = idx[(idx >= idx_min)]\n    if (idx_max is not None):\n        idx = idx[(idx <= idx_max)]\n    idx = np.unique(idx)\n    assert (len(slices) == (len(idx) - 1))\n    for (sl, start, stop) in zip(slices, idx, idx[1:]):\n        assert (sl.start == start)\n        assert (sl.stop == stop)\n        assert (sl.step == step)", "masked_code": "@pytest.mark.parametrize('idx', [np.arange(10, 90, 10), np.arange(10, 90, 15)])\n@pytest.mark.parametrize('idx_min', [None, 5, 15])\n@pytest.mark.parametrize('idx_max', [None, 85, 100])\n@pytest.mark.parametrize('step', [None, 2])\n@pytest.mark.parametrize('pad', [False, True])\ndef test_index_to_slice(idx, idx_min, idx_max, step, pad):\n    slices = librosa.util.index_to_slice(idx, idx_min=idx_min, idx_max=idx_max, step=step, pad=pad)\n    if pad:\n        if (idx_min is not None):\n            assert (slices[0].start == idx_min)\n            if (idx.min() != idx_min):\n                slices = slices[1:]\n        if (idx_max is not None):\n            assert (slices[(- 1)].stop == '???')\n            if (idx.max() != idx_max):\n                slices = slices[:(- 1)]\n    if (idx_min is not None):\n        idx = idx[(idx >= idx_min)]\n    if (idx_max is not None):\n        idx = idx[(idx <= idx_max)]\n    idx = np.unique(idx)\n    assert (len(slices) == (len(idx) - 1))\n    for (sl, start, stop) in zip(slices, idx, idx[1:]):\n        assert (sl.start == start)\n        assert (sl.stop == stop)\n        assert (sl.step == step)", "ground_truth": "idx_max", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_167", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_sync", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('aggregate', [None, np.mean, np.sum])\n@pytest.mark.parametrize('ndim,axis', [(1, 0), (1, (- 1)), (2, 0), (2, 1), (2, (- 1)), (3, 0), (3, 2), (3, (- 1))])\ndef test_sync(aggregate, ndim, axis: int):\n    data = np.ones(([6] * ndim), dtype=float)\n    slices = [slice(1, 3), slice(3, 4)]\n    dsync = librosa.util.sync(data, slices, aggregate=aggregate, axis=axis)\n    assert (dsync.shape[axis] == len(slices))\n    s_test = list(dsync.shape)\n    del s_test[axis]\n    s_orig = list(data.shape)\n    del s_orig[axis]\n    assert (s_test == s_orig)\n    idx: List[Union[(slice, int)]] = ([slice(None)] * ndim)\n    idx[axis] = 0\n    if (aggregate is np.sum):\n        assert np.allclose(dsync[tuple(idx)], 2)\n    else:\n        assert np.allclose(dsync[tuple(idx)], 1)\n    idx[axis] = 1\n    assert np.allclose(dsync[tuple(idx)], 1)", "masked_code": "@pytest.mark.parametrize('aggregate', [None, np.mean, np.sum])\n@pytest.mark.parametrize('ndim,axis', [(1, 0), (1, (- 1)), (2, 0), (2, 1), (2, (- 1)), (3, 0), (3, 2), (3, (- 1))])\ndef test_sync(aggregate, ndim, axis: int):\n    data = np.ones(([6] * ndim), dtype=float)\n    slices = [slice(1, 3), slice(3, 4)]\n    dsync = librosa.util.sync(data, slices, aggregate=aggregate, axis=axis)\n    assert (dsync.shape[axis] == '???')\n    s_test = list(dsync.shape)\n    del s_test[axis]\n    s_orig = list(data.shape)\n    del s_orig[axis]\n    assert (s_test == s_orig)\n    idx: List[Union[(slice, int)]] = ([slice(None)] * ndim)\n    idx[axis] = 0\n    if (aggregate is np.sum):\n        assert np.allclose(dsync[tuple(idx)], 2)\n    else:\n        assert np.allclose(dsync[tuple(idx)], 1)\n    idx[axis] = 1\n    assert np.allclose(dsync[tuple(idx)], 1)", "ground_truth": "len(slices)", "quality_analysis": {"complexity_score": 10, "left_complexity": 6, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_168", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_cyclic_gradient", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('edge_order', [1, 2])\n@pytest.mark.parametrize('axis', [0, 1, (- 1)])\ndef test_cyclic_gradient(psig, edge_order, axis):\n    grad = librosa.util.cyclic_gradient(psig, edge_order=edge_order, axis=axis)\n    assert (grad.shape == psig.shape)\n    assert (grad.dtype == psig.dtype)\n    if (axis == 0):\n        assert np.allclose(grad, 0)\n    else:\n        assert np.allclose(grad, [(- 1.5), 1, 1, 1, (- 1.5)])", "masked_code": "@pytest.mark.parametrize('edge_order', [1, 2])\n@pytest.mark.parametrize('axis', [0, 1, (- 1)])\ndef test_cyclic_gradient(psig, edge_order, axis):\n    grad = librosa.util.cyclic_gradient(psig, edge_order=edge_order, axis=axis)\n    assert (grad.shape == '???')\n    assert (grad.dtype == psig.dtype)\n    if (axis == 0):\n        assert np.allclose(grad, 0)\n    else:\n        assert np.allclose(grad, [(- 1.5), 1, 1, 1, (- 1.5)])", "ground_truth": "psig.shape", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_169", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_cyclic_gradient", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('edge_order', [1, 2])\n@pytest.mark.parametrize('axis', [0, 1, (- 1)])\ndef test_cyclic_gradient(psig, edge_order, axis):\n    grad = librosa.util.cyclic_gradient(psig, edge_order=edge_order, axis=axis)\n    assert (grad.shape == psig.shape)\n    assert (grad.dtype == psig.dtype)\n    if (axis == 0):\n        assert np.allclose(grad, 0)\n    else:\n        assert np.allclose(grad, [(- 1.5), 1, 1, 1, (- 1.5)])", "masked_code": "@pytest.mark.parametrize('edge_order', [1, 2])\n@pytest.mark.parametrize('axis', [0, 1, (- 1)])\ndef test_cyclic_gradient(psig, edge_order, axis):\n    grad = librosa.util.cyclic_gradient(psig, edge_order=edge_order, axis=axis)\n    assert (grad.shape == psig.shape)\n    assert (grad.dtype == '???')\n    if (axis == 0):\n        assert np.allclose(grad, 0)\n    else:\n        assert np.allclose(grad, [(- 1.5), 1, 1, 1, (- 1.5)])", "ground_truth": "psig.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_170", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_shear_sparse", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('fmt', ['csc', 'csr', 'lil', 'dok'])\ndef test_shear_sparse(fmt):\n    E = scipy.sparse.identity(3, format=fmt)\n    E_shear = librosa.util.shear(E, factor=1, axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=1, axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 1, 1], [0, 0, 0], [0, 0, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [1, 0, 0], [1, 0, 0]]))", "masked_code": "@pytest.mark.parametrize('fmt', ['csc', 'csr', 'lil', 'dok'])\ndef test_shear_sparse(fmt):\n    E = scipy.sparse.identity(3, format=fmt)\n    E_shear = librosa.util.shear(E, factor=1, axis=0)\n    assert (E_shear.format == '???')\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=1, axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 1, 1], [0, 0, 0], [0, 0, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [1, 0, 0], [1, 0, 0]]))", "ground_truth": "fmt", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_171", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_shear_sparse", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('fmt', ['csc', 'csr', 'lil', 'dok'])\ndef test_shear_sparse(fmt):\n    E = scipy.sparse.identity(3, format=fmt)\n    E_shear = librosa.util.shear(E, factor=1, axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=1, axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 1, 1], [0, 0, 0], [0, 0, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [1, 0, 0], [1, 0, 0]]))", "masked_code": "@pytest.mark.parametrize('fmt', ['csc', 'csr', 'lil', 'dok'])\ndef test_shear_sparse(fmt):\n    E = scipy.sparse.identity(3, format=fmt)\n    E_shear = librosa.util.shear(E, factor=1, axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=1, axis=1)\n    assert (E_shear.format == '???')\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 1, 1], [0, 0, 0], [0, 0, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [1, 0, 0], [1, 0, 0]]))", "ground_truth": "fmt", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_172", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_shear_sparse", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('fmt', ['csc', 'csr', 'lil', 'dok'])\ndef test_shear_sparse(fmt):\n    E = scipy.sparse.identity(3, format=fmt)\n    E_shear = librosa.util.shear(E, factor=1, axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=1, axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 1, 1], [0, 0, 0], [0, 0, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [1, 0, 0], [1, 0, 0]]))", "masked_code": "@pytest.mark.parametrize('fmt', ['csc', 'csr', 'lil', 'dok'])\ndef test_shear_sparse(fmt):\n    E = scipy.sparse.identity(3, format=fmt)\n    E_shear = librosa.util.shear(E, factor=1, axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=1, axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=1)\n    assert (E_shear.format == '???')\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 1, 1], [0, 0, 0], [0, 0, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [1, 0, 0], [1, 0, 0]]))", "ground_truth": "fmt", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_173", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_shear_sparse", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('fmt', ['csc', 'csr', 'lil', 'dok'])\ndef test_shear_sparse(fmt):\n    E = scipy.sparse.identity(3, format=fmt)\n    E_shear = librosa.util.shear(E, factor=1, axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=1, axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 1, 1], [0, 0, 0], [0, 0, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [1, 0, 0], [1, 0, 0]]))", "masked_code": "@pytest.mark.parametrize('fmt', ['csc', 'csr', 'lil', 'dok'])\ndef test_shear_sparse(fmt):\n    E = scipy.sparse.identity(3, format=fmt)\n    E_shear = librosa.util.shear(E, factor=1, axis=0)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=1, axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [0, 0, 1], [0, 1, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=1)\n    assert (E_shear.format == fmt)\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 1, 1], [0, 0, 0], [0, 0, 0]]))\n    E_shear = librosa.util.shear(E, factor=(- 1), axis=0)\n    assert (E_shear.format == '???')\n    assert np.allclose(E_shear.toarray(), np.asarray([[1, 0, 0], [1, 0, 0], [1, 0, 0]]))", "ground_truth": "fmt", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_174", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_expand_to_1d", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('axes', [0, 1, (- 1), [0], [1], [(- 1)]])\n@pytest.mark.parametrize('ndim', [2, 3, 4])\ndef test_expand_to_1d(axes, ndim):\n    x = np.arange(5)\n    xout = librosa.util.expand_to(x, ndim=ndim, axes=axes)\n    assert (xout.ndim == ndim)\n    assert (xout.size == x.size)\n    assert np.allclose(x, xout.squeeze())\n    if (not hasattr(axes, '__iter__')):\n        axes = [axes]\n    assert np.array_equal(x.shape, xout.squeeze().shape)\n    for (i, ax) in enumerate(axes):\n        assert (xout.shape[ax] == x.shape[i])", "masked_code": "@pytest.mark.parametrize('axes', [0, 1, (- 1), [0], [1], [(- 1)]])\n@pytest.mark.parametrize('ndim', [2, 3, 4])\ndef test_expand_to_1d(axes, ndim):\n    x = np.arange(5)\n    xout = librosa.util.expand_to(x, ndim=ndim, axes=axes)\n    assert (xout.ndim == '???')\n    assert (xout.size == x.size)\n    assert np.allclose(x, xout.squeeze())\n    if (not hasattr(axes, '__iter__')):\n        axes = [axes]\n    assert np.array_equal(x.shape, xout.squeeze().shape)\n    for (i, ax) in enumerate(axes):\n        assert (xout.shape[ax] == x.shape[i])", "ground_truth": "ndim", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_175", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_expand_to_1d", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('axes', [0, 1, (- 1), [0], [1], [(- 1)]])\n@pytest.mark.parametrize('ndim', [2, 3, 4])\ndef test_expand_to_1d(axes, ndim):\n    x = np.arange(5)\n    xout = librosa.util.expand_to(x, ndim=ndim, axes=axes)\n    assert (xout.ndim == ndim)\n    assert (xout.size == x.size)\n    assert np.allclose(x, xout.squeeze())\n    if (not hasattr(axes, '__iter__')):\n        axes = [axes]\n    assert np.array_equal(x.shape, xout.squeeze().shape)\n    for (i, ax) in enumerate(axes):\n        assert (xout.shape[ax] == x.shape[i])", "masked_code": "@pytest.mark.parametrize('axes', [0, 1, (- 1), [0], [1], [(- 1)]])\n@pytest.mark.parametrize('ndim', [2, 3, 4])\ndef test_expand_to_1d(axes, ndim):\n    x = np.arange(5)\n    xout = librosa.util.expand_to(x, ndim=ndim, axes=axes)\n    assert (xout.ndim == ndim)\n    assert (xout.size == '???')\n    assert np.allclose(x, xout.squeeze())\n    if (not hasattr(axes, '__iter__')):\n        axes = [axes]\n    assert np.array_equal(x.shape, xout.squeeze().shape)\n    for (i, ax) in enumerate(axes):\n        assert (xout.shape[ax] == x.shape[i])", "ground_truth": "x.size", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_176", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_expand_to_1d", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('axes', [0, 1, (- 1), [0], [1], [(- 1)]])\n@pytest.mark.parametrize('ndim', [2, 3, 4])\ndef test_expand_to_1d(axes, ndim):\n    x = np.arange(5)\n    xout = librosa.util.expand_to(x, ndim=ndim, axes=axes)\n    assert (xout.ndim == ndim)\n    assert (xout.size == x.size)\n    assert np.allclose(x, xout.squeeze())\n    if (not hasattr(axes, '__iter__')):\n        axes = [axes]\n    assert np.array_equal(x.shape, xout.squeeze().shape)\n    for (i, ax) in enumerate(axes):\n        assert (xout.shape[ax] == x.shape[i])", "masked_code": "@pytest.mark.parametrize('axes', [0, 1, (- 1), [0], [1], [(- 1)]])\n@pytest.mark.parametrize('ndim', [2, 3, 4])\ndef test_expand_to_1d(axes, ndim):\n    x = np.arange(5)\n    xout = librosa.util.expand_to(x, ndim=ndim, axes=axes)\n    assert (xout.ndim == ndim)\n    assert (xout.size == x.size)\n    assert np.allclose(x, xout.squeeze())\n    if (not hasattr(axes, '__iter__')):\n        axes = [axes]\n    assert np.array_equal(x.shape, xout.squeeze().shape)\n    for (i, ax) in enumerate(axes):\n        assert (xout.shape[ax] == '???')", "ground_truth": "x.shape[i]", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_177", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_expand_to_2d", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('axes', [[0, 1], [0, 2], [1, 2]])\n@pytest.mark.parametrize('ndim', [3, 4])\ndef test_expand_to_2d(axes, ndim):\n    x = np.multiply.outer(np.arange(4), np.arange(6))\n    xout = librosa.util.expand_to(x, ndim=ndim, axes=axes)\n    assert (xout.ndim == ndim)\n    assert (xout.size == x.size)\n    assert np.allclose(x, xout.squeeze())\n    assert np.array_equal(x.shape, xout.squeeze().shape)\n    for (i, ax) in enumerate(axes):\n        assert (xout.shape[ax] == x.shape[i])", "masked_code": "@pytest.mark.parametrize('axes', [[0, 1], [0, 2], [1, 2]])\n@pytest.mark.parametrize('ndim', [3, 4])\ndef test_expand_to_2d(axes, ndim):\n    x = np.multiply.outer(np.arange(4), np.arange(6))\n    xout = librosa.util.expand_to(x, ndim=ndim, axes=axes)\n    assert (xout.ndim == '???')\n    assert (xout.size == x.size)\n    assert np.allclose(x, xout.squeeze())\n    assert np.array_equal(x.shape, xout.squeeze().shape)\n    for (i, ax) in enumerate(axes):\n        assert (xout.shape[ax] == x.shape[i])", "ground_truth": "ndim", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_178", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_expand_to_2d", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('axes', [[0, 1], [0, 2], [1, 2]])\n@pytest.mark.parametrize('ndim', [3, 4])\ndef test_expand_to_2d(axes, ndim):\n    x = np.multiply.outer(np.arange(4), np.arange(6))\n    xout = librosa.util.expand_to(x, ndim=ndim, axes=axes)\n    assert (xout.ndim == ndim)\n    assert (xout.size == x.size)\n    assert np.allclose(x, xout.squeeze())\n    assert np.array_equal(x.shape, xout.squeeze().shape)\n    for (i, ax) in enumerate(axes):\n        assert (xout.shape[ax] == x.shape[i])", "masked_code": "@pytest.mark.parametrize('axes', [[0, 1], [0, 2], [1, 2]])\n@pytest.mark.parametrize('ndim', [3, 4])\ndef test_expand_to_2d(axes, ndim):\n    x = np.multiply.outer(np.arange(4), np.arange(6))\n    xout = librosa.util.expand_to(x, ndim=ndim, axes=axes)\n    assert (xout.ndim == ndim)\n    assert (xout.size == '???')\n    assert np.allclose(x, xout.squeeze())\n    assert np.array_equal(x.shape, xout.squeeze().shape)\n    for (i, ax) in enumerate(axes):\n        assert (xout.shape[ax] == x.shape[i])", "ground_truth": "x.size", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_179", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_expand_to_2d", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('axes', [[0, 1], [0, 2], [1, 2]])\n@pytest.mark.parametrize('ndim', [3, 4])\ndef test_expand_to_2d(axes, ndim):\n    x = np.multiply.outer(np.arange(4), np.arange(6))\n    xout = librosa.util.expand_to(x, ndim=ndim, axes=axes)\n    assert (xout.ndim == ndim)\n    assert (xout.size == x.size)\n    assert np.allclose(x, xout.squeeze())\n    assert np.array_equal(x.shape, xout.squeeze().shape)\n    for (i, ax) in enumerate(axes):\n        assert (xout.shape[ax] == x.shape[i])", "masked_code": "@pytest.mark.parametrize('axes', [[0, 1], [0, 2], [1, 2]])\n@pytest.mark.parametrize('ndim', [3, 4])\ndef test_expand_to_2d(axes, ndim):\n    x = np.multiply.outer(np.arange(4), np.arange(6))\n    xout = librosa.util.expand_to(x, ndim=ndim, axes=axes)\n    assert (xout.ndim == ndim)\n    assert (xout.size == x.size)\n    assert np.allclose(x, xout.squeeze())\n    assert np.array_equal(x.shape, xout.squeeze().shape)\n    for (i, ax) in enumerate(axes):\n        assert (xout.shape[ax] == '???')", "ground_truth": "x.shape[i]", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_180", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_abs2_complex", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('x', [(2 - 2j), (3 + 0j), (0.5j ** np.arange(6))])\n@pytest.mark.parametrize('dtype', [np.complex64, np.complex128])\ndef test_abs2_complex(x, dtype):\n    x_cast: Union[(np.complexfloating[(Any, Any)], np.ndarray)] = dtype(x)\n    p = librosa.util.abs2(x_cast)\n    assert np.allclose(p, (np.abs(x_cast) ** 2))\n    assert (p.dtype == librosa.util.dtype_c2r(x_cast.dtype))", "masked_code": "@pytest.mark.parametrize('x', [(2 - 2j), (3 + 0j), (0.5j ** np.arange(6))])\n@pytest.mark.parametrize('dtype', [np.complex64, np.complex128])\ndef test_abs2_complex(x, dtype):\n    x_cast: Union[(np.complexfloating[(Any, Any)], np.ndarray)] = dtype(x)\n    p = librosa.util.abs2(x_cast)\n    assert np.allclose(p, (np.abs(x_cast) ** 2))\n    assert (p.dtype == '???')", "ground_truth": "librosa.util.dtype_c2r(x_cast.dtype)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_181", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_abs2_int_dtype", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "def test_abs2_int_dtype():\n    x = np.arange(5, dtype=np.int16)\n    y = librosa.util.abs2(x, dtype=None)\n    assert (x.dtype == y.dtype)\n    z = librosa.util.abs2(x, dtype=np.float32)\n    assert (z.dtype == np.float32)", "masked_code": "def test_abs2_int_dtype():\n    x = np.arange(5, dtype=np.int16)\n    y = librosa.util.abs2(x, dtype=None)\n    assert (x.dtype == '???')\n    z = librosa.util.abs2(x, dtype=np.float32)\n    assert (z.dtype == np.float32)", "ground_truth": "y.dtype", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_182", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_abs2_int_dtype", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "def test_abs2_int_dtype():\n    x = np.arange(5, dtype=np.int16)\n    y = librosa.util.abs2(x, dtype=None)\n    assert (x.dtype == y.dtype)\n    z = librosa.util.abs2(x, dtype=np.float32)\n    assert (z.dtype == np.float32)", "masked_code": "def test_abs2_int_dtype():\n    x = np.arange(5, dtype=np.int16)\n    y = librosa.util.abs2(x, dtype=None)\n    assert (x.dtype == y.dtype)\n    z = librosa.util.abs2(x, dtype=np.float32)\n    assert (z.dtype == '???')", "ground_truth": "np.float32", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_183", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_abs2_complex_dtype", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "def test_abs2_complex_dtype():\n    x = np.arange(5, dtype=np.complex64)\n    y = librosa.util.abs2(x, dtype=None)\n    assert np.isrealobj(y)\n    assert (y.dtype == np.float32)\n    z = librosa.util.abs2(x, dtype=np.float64)\n    assert (z.dtype == np.float64)", "masked_code": "def test_abs2_complex_dtype():\n    x = np.arange(5, dtype=np.complex64)\n    y = librosa.util.abs2(x, dtype=None)\n    assert np.isrealobj(y)\n    assert (y.dtype == '???')\n    z = librosa.util.abs2(x, dtype=np.float64)\n    assert (z.dtype == np.float64)", "ground_truth": "np.float32", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_184", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_abs2_complex_dtype", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "def test_abs2_complex_dtype():\n    x = np.arange(5, dtype=np.complex64)\n    y = librosa.util.abs2(x, dtype=None)\n    assert np.isrealobj(y)\n    assert (y.dtype == np.float32)\n    z = librosa.util.abs2(x, dtype=np.float64)\n    assert (z.dtype == np.float64)", "masked_code": "def test_abs2_complex_dtype():\n    x = np.arange(5, dtype=np.complex64)\n    y = librosa.util.abs2(x, dtype=None)\n    assert np.isrealobj(y)\n    assert (y.dtype == np.float32)\n    z = librosa.util.abs2(x, dtype=np.float64)\n    assert (z.dtype == '???')", "ground_truth": "np.float64", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "librosa_185", "reponame": "librosa", "testpath": "tests/test_util.py", "testname": "test_util.py", "classname": null, "funcname": "test_phasor", "imports": ["from __future__ import annotations", "import os", "import platform", "import numpy as np", "import scipy.sparse", "import pytest", "import warnings", "import librosa", "from typing import Any, List, Union", "from test_core import srand"], "code": "@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('angles', [(np.pi / 2), [(np.pi / 2), ((- np.pi) / 3)]])\n@pytest.mark.parametrize('mag', [None, 2])\ndef test_phasor(dtype, angles, mag):\n    angles_cast: Union[(np.floating[Any], np.ndarray)] = dtype(angles)\n    z = np.exp((1j * angles_cast))\n    if (mag is not None):\n        mag = dtype(mag)\n        z *= mag\n    z2 = librosa.util.phasor(angles_cast, mag=mag)\n    assert np.allclose(z, z2)\n    assert (z2.dtype == librosa.util.dtype_r2c(dtype))", "masked_code": "@pytest.mark.parametrize('dtype', [np.float32, np.float64])\n@pytest.mark.parametrize('angles', [(np.pi / 2), [(np.pi / 2), ((- np.pi) / 3)]])\n@pytest.mark.parametrize('mag', [None, 2])\ndef test_phasor(dtype, angles, mag):\n    angles_cast: Union[(np.floating[Any], np.ndarray)] = dtype(angles)\n    z = np.exp((1j * angles_cast))\n    if (mag is not None):\n        mag = dtype(mag)\n        z *= mag\n    z2 = librosa.util.phasor(angles_cast, mag=mag)\n    assert np.allclose(z, z2)\n    assert (z2.dtype == '???')", "ground_truth": "librosa.util.dtype_r2c(dtype)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
