{"task_id": "phonopy_0", "reponame": "phonopy", "testpath": "test/test_file_IO.py", "testname": "test_file_IO.py", "classname": null, "funcname": "test_parse_BORN", "imports": ["import pathlib", "import numpy as np", "import pytest", "import phonopy", "from phonopy.file_IO import parse_BORN, read_force_constants_hdf5, write_force_constants_to_hdf5"], "code": "def test_parse_BORN():\n    'Test of parse_BORN.'\n    ph = phonopy.load((cwd / 'phonopy_disp_NaCl.yaml'))\n    nac_params = parse_BORN(ph.primitive, filename=(cwd / 'BORN_NaCl'))\n    z = (np.eye(3) * 1.086875)\n    epsilon = (np.eye(3) * 2.43533967)\n    np.testing.assert_allclose(nac_params['born'], [z, (- z)], atol=1e-05)\n    np.testing.assert_allclose(nac_params['dielectric'], epsilon, atol=1e-05)\n    assert (pytest.approx(14.4) == nac_params['factor'])", "masked_code": "def test_parse_BORN():\n    'Test of parse_BORN.'\n    ph = phonopy.load((cwd / 'phonopy_disp_NaCl.yaml'))\n    nac_params = parse_BORN(ph.primitive, filename=(cwd / 'BORN_NaCl'))\n    z = (np.eye(3) * 1.086875)\n    epsilon = (np.eye(3) * 2.43533967)\n    np.testing.assert_allclose(nac_params['born'], [z, (- z)], atol=1e-05)\n    np.testing.assert_allclose(nac_params['dielectric'], epsilon, atol=1e-05)\n    assert (pytest.approx(14.4) == '???')", "ground_truth": "nac_params['factor']", "quality_analysis": {"complexity_score": 9, "left_complexity": 4, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_1", "reponame": "phonopy", "testpath": "test/test_file_IO.py", "testname": "test_file_IO.py", "classname": null, "funcname": "test_write_force_constants_to_hdf5", "imports": ["import pathlib", "import numpy as np", "import pytest", "import phonopy", "from phonopy.file_IO import parse_BORN, read_force_constants_hdf5, write_force_constants_to_hdf5"], "code": "def test_write_force_constants_to_hdf5():\n    'Test write_force_constants_to_hdf5.'\n    pytest.importorskip('h5py')\n    write_force_constants_to_hdf5(np.zeros(1), physical_unit='eV/angstrom^2')\n    for created_filename in ['force_constants.hdf5']:\n        file_path = pathlib.Path((cwd_called / created_filename))\n        assert file_path.exists()\n        (fc, physical_unit) = read_force_constants_hdf5(file_path, return_physical_unit=True)\n        assert (fc[0] == pytest.approx(0))\n        assert (physical_unit == 'eV/angstrom^2')\n        file_path.unlink()", "masked_code": "def test_write_force_constants_to_hdf5():\n    'Test write_force_constants_to_hdf5.'\n    pytest.importorskip('h5py')\n    write_force_constants_to_hdf5(np.zeros(1), physical_unit='eV/angstrom^2')\n    for created_filename in ['force_constants.hdf5']:\n        file_path = pathlib.Path((cwd_called / created_filename))\n        assert file_path.exists()\n        (fc, physical_unit) = read_force_constants_hdf5(file_path, return_physical_unit=True)\n        assert (fc[0] == '???')\n        assert (physical_unit == 'eV/angstrom^2')\n        file_path.unlink()", "ground_truth": "pytest.approx(0)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_2", "reponame": "phonopy", "testpath": "test/api/test_api_phonopy.py", "testname": "test_api_phonopy.py", "classname": null, "funcname": "test_Phonopy_calculator", "imports": ["import copy", "from pathlib import Path", "import numpy as np", "import pytest", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.pypolymlp import PypolymlpParams", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_Phonopy_calculator():\n    'Test phonopy_load with phonopy_params.yaml.'\n    ph_orig = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), produce_fc=False, log_level=2)\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix)\n    assert (ph.calculator is None)\n    assert (ph.unit_conversion_factor == pytest.approx(15.6333023))\n    with pytest.warns(DeprecationWarning):\n        ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, factor=100)\n        assert (ph.unit_conversion_factor == pytest.approx(100))", "masked_code": "def test_Phonopy_calculator():\n    'Test phonopy_load with phonopy_params.yaml.'\n    ph_orig = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), produce_fc=False, log_level=2)\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix)\n    assert (ph.calculator is None)\n    assert (ph.unit_conversion_factor == '???')\n    with pytest.warns(DeprecationWarning):\n        ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, factor=100)\n        assert (ph.unit_conversion_factor == pytest.approx(100))", "ground_truth": "pytest.approx(15.6333023)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_3", "reponame": "phonopy", "testpath": "test/api/test_api_phonopy.py", "testname": "test_api_phonopy.py", "classname": null, "funcname": "test_Phonopy_calculator", "imports": ["import copy", "from pathlib import Path", "import numpy as np", "import pytest", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.pypolymlp import PypolymlpParams", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_Phonopy_calculator():\n    'Test phonopy_load with phonopy_params.yaml.'\n    ph_orig = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), produce_fc=False, log_level=2)\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix)\n    assert (ph.calculator is None)\n    assert (ph.unit_conversion_factor == pytest.approx(15.6333023))\n    with pytest.warns(DeprecationWarning):\n        ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, factor=100)\n        assert (ph.unit_conversion_factor == pytest.approx(100))", "masked_code": "def test_Phonopy_calculator():\n    'Test phonopy_load with phonopy_params.yaml.'\n    ph_orig = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), produce_fc=False, log_level=2)\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix)\n    assert (ph.calculator is None)\n    assert (ph.unit_conversion_factor == pytest.approx(15.6333023))\n    with pytest.warns(DeprecationWarning):\n        ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, factor=100)\n        assert (ph.unit_conversion_factor == '???')", "ground_truth": "pytest.approx(100)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_4", "reponame": "phonopy", "testpath": "test/api/test_api_phonopy.py", "testname": "test_api_phonopy.py", "classname": null, "funcname": "test_Phonopy_calculator_QE", "imports": ["import copy", "from pathlib import Path", "import numpy as np", "import pytest", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.pypolymlp import PypolymlpParams", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_Phonopy_calculator_QE():\n    'Test phonopy_load with phonopy_params.yaml for QE.'\n    ph_orig = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-QE.yaml.xz'), produce_fc=False, log_level=2)\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, calculator='qe', set_factor_by_calculator=False)\n    assert (ph.calculator == 'qe')\n    assert (ph.unit_conversion_factor == pytest.approx(15.6333023))\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, calculator='qe', set_factor_by_calculator=True)\n    assert (ph.unit_conversion_factor == pytest.approx(108.9707718))", "masked_code": "def test_Phonopy_calculator_QE():\n    'Test phonopy_load with phonopy_params.yaml for QE.'\n    ph_orig = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-QE.yaml.xz'), produce_fc=False, log_level=2)\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, calculator='qe', set_factor_by_calculator=False)\n    assert (ph.calculator == '???')\n    assert (ph.unit_conversion_factor == pytest.approx(15.6333023))\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, calculator='qe', set_factor_by_calculator=True)\n    assert (ph.unit_conversion_factor == pytest.approx(108.9707718))", "ground_truth": "'qe'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_5", "reponame": "phonopy", "testpath": "test/api/test_api_phonopy.py", "testname": "test_api_phonopy.py", "classname": null, "funcname": "test_Phonopy_calculator_QE", "imports": ["import copy", "from pathlib import Path", "import numpy as np", "import pytest", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.pypolymlp import PypolymlpParams", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_Phonopy_calculator_QE():\n    'Test phonopy_load with phonopy_params.yaml for QE.'\n    ph_orig = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-QE.yaml.xz'), produce_fc=False, log_level=2)\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, calculator='qe', set_factor_by_calculator=False)\n    assert (ph.calculator == 'qe')\n    assert (ph.unit_conversion_factor == pytest.approx(15.6333023))\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, calculator='qe', set_factor_by_calculator=True)\n    assert (ph.unit_conversion_factor == pytest.approx(108.9707718))", "masked_code": "def test_Phonopy_calculator_QE():\n    'Test phonopy_load with phonopy_params.yaml for QE.'\n    ph_orig = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-QE.yaml.xz'), produce_fc=False, log_level=2)\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, calculator='qe', set_factor_by_calculator=False)\n    assert (ph.calculator == 'qe')\n    assert (ph.unit_conversion_factor == '???')\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, calculator='qe', set_factor_by_calculator=True)\n    assert (ph.unit_conversion_factor == pytest.approx(108.9707718))", "ground_truth": "pytest.approx(15.6333023)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_6", "reponame": "phonopy", "testpath": "test/api/test_api_phonopy.py", "testname": "test_api_phonopy.py", "classname": null, "funcname": "test_Phonopy_calculator_QE", "imports": ["import copy", "from pathlib import Path", "import numpy as np", "import pytest", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.pypolymlp import PypolymlpParams", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_Phonopy_calculator_QE():\n    'Test phonopy_load with phonopy_params.yaml for QE.'\n    ph_orig = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-QE.yaml.xz'), produce_fc=False, log_level=2)\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, calculator='qe', set_factor_by_calculator=False)\n    assert (ph.calculator == 'qe')\n    assert (ph.unit_conversion_factor == pytest.approx(15.6333023))\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, calculator='qe', set_factor_by_calculator=True)\n    assert (ph.unit_conversion_factor == pytest.approx(108.9707718))", "masked_code": "def test_Phonopy_calculator_QE():\n    'Test phonopy_load with phonopy_params.yaml for QE.'\n    ph_orig = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-QE.yaml.xz'), produce_fc=False, log_level=2)\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, calculator='qe', set_factor_by_calculator=False)\n    assert (ph.calculator == 'qe')\n    assert (ph.unit_conversion_factor == pytest.approx(15.6333023))\n    ph = Phonopy(unitcell=ph_orig.unitcell, supercell_matrix=ph_orig.supercell_matrix, primitive_matrix=ph_orig.primitive_matrix, calculator='qe', set_factor_by_calculator=True)\n    assert (ph.unit_conversion_factor == '???')", "ground_truth": "pytest.approx(108.9707718)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_7", "reponame": "phonopy", "testpath": "test/cui/test_phonopy_cui.py", "testname": "test_phonopy_cui.py", "classname": null, "funcname": "test_unit_conversion_factor", "imports": ["from __future__ import annotations", "import os", "import pathlib", "import tempfile", "from collections.abc import Sequence", "from dataclasses import dataclass, fields", "from typing import Optional, Union", "import numpy as np", "import pytest", "import yaml", "import phonopy", "from phonopy.cui.phonopy_script import main", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import Primitive"], "code": "@pytest.mark.parametrize('load_phonopy_yaml', [False, True])\ndef test_unit_conversion_factor(load_phonopy_yaml: bool):\n    'Test unit_conversion_factor using phonopy/phonopy-load command.'\n    with tempfile.TemporaryDirectory() as temp_dir:\n        original_cwd = pathlib.Path.cwd()\n        os.chdir(temp_dir)\n        try:\n            argparse_control = _get_phonopy_args(filename=((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), band_paths='0 0 0 0 0 1/2', frequency_conversion_factor=100, load_phonopy_yaml=load_phonopy_yaml)\n            with pytest.warns(DeprecationWarning):\n                with pytest.raises(SystemExit) as excinfo:\n                    main(**argparse_control)\n            assert (excinfo.value.code == 0)\n            if load_phonopy_yaml:\n                ref_freq = 47.3113552091\n            else:\n                ref_freq = 29.5294946098\n            with open('band.yaml') as f:\n                band = yaml.safe_load(f)\n                assert (band['phonon'][0]['band'][5]['frequency'] == pytest.approx(ref_freq))\n            for created_filename in ('phonopy.yaml', 'band.yaml'):\n                file_path = pathlib.Path(created_filename)\n                assert file_path.exists()\n                file_path.unlink()\n        finally:\n            os.chdir(original_cwd)", "masked_code": "@pytest.mark.parametrize('load_phonopy_yaml', [False, True])\ndef test_unit_conversion_factor(load_phonopy_yaml: bool):\n    'Test unit_conversion_factor using phonopy/phonopy-load command.'\n    with tempfile.TemporaryDirectory() as temp_dir:\n        original_cwd = pathlib.Path.cwd()\n        os.chdir(temp_dir)\n        try:\n            argparse_control = _get_phonopy_args(filename=((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), band_paths='0 0 0 0 0 1/2', frequency_conversion_factor=100, load_phonopy_yaml=load_phonopy_yaml)\n            with pytest.warns(DeprecationWarning):\n                with pytest.raises(SystemExit) as excinfo:\n                    main(**argparse_control)\n            assert (excinfo.value.code == 0)\n            if load_phonopy_yaml:\n                ref_freq = 47.3113552091\n            else:\n                ref_freq = 29.5294946098\n            with open('band.yaml') as f:\n                band = yaml.safe_load(f)\n                assert (band['phonon'][0]['band'][5]['frequency'] == '???')\n            for created_filename in ('phonopy.yaml', 'band.yaml'):\n                file_path = pathlib.Path(created_filename)\n                assert file_path.exists()\n                file_path.unlink()\n        finally:\n            os.chdir(original_cwd)", "ground_truth": "pytest.approx(ref_freq)", "quality_analysis": {"complexity_score": 25, "left_complexity": 21, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_8", "reponame": "phonopy", "testpath": "test/cui/test_phonopy_cui.py", "testname": "test_phonopy_cui.py", "classname": null, "funcname": "test_unit_conversion_factor_QE", "imports": ["from __future__ import annotations", "import os", "import pathlib", "import tempfile", "from collections.abc import Sequence", "from dataclasses import dataclass, fields", "from typing import Optional, Union", "import numpy as np", "import pytest", "import yaml", "import phonopy", "from phonopy.cui.phonopy_script import main", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import Primitive"], "code": "@pytest.mark.parametrize('load_phonopy_yaml', [False, True])\ndef test_unit_conversion_factor_QE(load_phonopy_yaml: bool):\n    'Test unit_conversion_factor for QE using phonopy/phonopy-load command.'\n    pytest.importorskip('symfc')\n    with tempfile.TemporaryDirectory() as temp_dir:\n        original_cwd = pathlib.Path.cwd()\n        os.chdir(temp_dir)\n        try:\n            argparse_control = _get_phonopy_args(filename=((cwd / '..') / 'phonopy_params_NaCl-QE.yaml.xz'), band_paths='0 0 0 0 0 1/2', load_phonopy_yaml=load_phonopy_yaml)\n            with pytest.raises(SystemExit) as excinfo:\n                main(**argparse_control)\n            assert (excinfo.value.code == 0)\n            if load_phonopy_yaml:\n                ref_freq = 7.3823649712\n            else:\n                ref_freq = 4.5259552147\n            with open('band.yaml') as f:\n                band = yaml.safe_load(f)\n                assert (band['phonon'][0]['band'][5]['frequency'] == pytest.approx(ref_freq))\n            for created_filename in ('phonopy.yaml', 'band.yaml'):\n                file_path = pathlib.Path(created_filename)\n                assert file_path.exists()\n                file_path.unlink()\n        finally:\n            os.chdir(original_cwd)", "masked_code": "@pytest.mark.parametrize('load_phonopy_yaml', [False, True])\ndef test_unit_conversion_factor_QE(load_phonopy_yaml: bool):\n    'Test unit_conversion_factor for QE using phonopy/phonopy-load command.'\n    pytest.importorskip('symfc')\n    with tempfile.TemporaryDirectory() as temp_dir:\n        original_cwd = pathlib.Path.cwd()\n        os.chdir(temp_dir)\n        try:\n            argparse_control = _get_phonopy_args(filename=((cwd / '..') / 'phonopy_params_NaCl-QE.yaml.xz'), band_paths='0 0 0 0 0 1/2', load_phonopy_yaml=load_phonopy_yaml)\n            with pytest.raises(SystemExit) as excinfo:\n                main(**argparse_control)\n            assert (excinfo.value.code == 0)\n            if load_phonopy_yaml:\n                ref_freq = 7.3823649712\n            else:\n                ref_freq = 4.5259552147\n            with open('band.yaml') as f:\n                band = yaml.safe_load(f)\n                assert (band['phonon'][0]['band'][5]['frequency'] == '???')\n            for created_filename in ('phonopy.yaml', 'band.yaml'):\n                file_path = pathlib.Path(created_filename)\n                assert file_path.exists()\n                file_path.unlink()\n        finally:\n            os.chdir(original_cwd)", "ground_truth": "pytest.approx(ref_freq)", "quality_analysis": {"complexity_score": 25, "left_complexity": 21, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_9", "reponame": "phonopy", "testpath": "test/harmonic/test_displacements.py", "testname": "test_displacements.py", "classname": null, "funcname": "test_tio2_random_disp", "imports": ["import itertools", "from typing import Literal, Optional, Union", "import numpy as np", "import pytest", "from phonopy import Phonopy"], "code": "@pytest.mark.parametrize('is_plusminus,distance,number_of_snapshots', itertools.product([False, True], [None, 0.03], [4, 'auto']))\ndef test_tio2_random_disp(ph_tio2: Phonopy, is_plusminus: bool, distance: Optional[float], number_of_snapshots: Union[(int, Literal['auto'])]):\n    'Test random displacements of TiO2.\\n\\n    Currently default displacement distance = 0.01.\\n\\n    '\n    pytest.importorskip('symfc')\n    ph = ph_tio2.copy()\n    ph.generate_displacements(number_of_snapshots=number_of_snapshots, distance=distance, is_plusminus=is_plusminus)\n    d = ph.displacements\n    if (number_of_snapshots == 'auto'):\n        assert (len(d) == (4 * (is_plusminus + 1)))\n    else:\n        assert (len(d) == (4 * (is_plusminus + 1)))\n    if (distance is None):\n        np.testing.assert_allclose(np.linalg.norm(d, axis=2).ravel(), 0.01, atol=1e-08)\n    else:\n        np.testing.assert_allclose(np.linalg.norm(d, axis=2).ravel(), 0.03, atol=1e-08)\n    if is_plusminus:\n        np.testing.assert_allclose(d[:(len(d) // 2)], (- d[(len(d) // 2):]), atol=1e-08)", "masked_code": "@pytest.mark.parametrize('is_plusminus,distance,number_of_snapshots', itertools.product([False, True], [None, 0.03], [4, 'auto']))\ndef test_tio2_random_disp(ph_tio2: Phonopy, is_plusminus: bool, distance: Optional[float], number_of_snapshots: Union[(int, Literal['auto'])]):\n    'Test random displacements of TiO2.\\n\\n    Currently default displacement distance = 0.01.\\n\\n    '\n    pytest.importorskip('symfc')\n    ph = ph_tio2.copy()\n    ph.generate_displacements(number_of_snapshots=number_of_snapshots, distance=distance, is_plusminus=is_plusminus)\n    d = ph.displacements\n    if (number_of_snapshots == 'auto'):\n        assert (len(d) == '???')\n    else:\n        assert (len(d) == (4 * (is_plusminus + 1)))\n    if (distance is None):\n        np.testing.assert_allclose(np.linalg.norm(d, axis=2).ravel(), 0.01, atol=1e-08)\n    else:\n        np.testing.assert_allclose(np.linalg.norm(d, axis=2).ravel(), 0.03, atol=1e-08)\n    if is_plusminus:\n        np.testing.assert_allclose(d[:(len(d) // 2)], (- d[(len(d) // 2):]), atol=1e-08)", "ground_truth": "(4 * (is_plusminus + 1))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_10", "reponame": "phonopy", "testpath": "test/harmonic/test_displacements.py", "testname": "test_displacements.py", "classname": null, "funcname": "test_tio2_random_disp", "imports": ["import itertools", "from typing import Literal, Optional, Union", "import numpy as np", "import pytest", "from phonopy import Phonopy"], "code": "@pytest.mark.parametrize('is_plusminus,distance,number_of_snapshots', itertools.product([False, True], [None, 0.03], [4, 'auto']))\ndef test_tio2_random_disp(ph_tio2: Phonopy, is_plusminus: bool, distance: Optional[float], number_of_snapshots: Union[(int, Literal['auto'])]):\n    'Test random displacements of TiO2.\\n\\n    Currently default displacement distance = 0.01.\\n\\n    '\n    pytest.importorskip('symfc')\n    ph = ph_tio2.copy()\n    ph.generate_displacements(number_of_snapshots=number_of_snapshots, distance=distance, is_plusminus=is_plusminus)\n    d = ph.displacements\n    if (number_of_snapshots == 'auto'):\n        assert (len(d) == (4 * (is_plusminus + 1)))\n    else:\n        assert (len(d) == (4 * (is_plusminus + 1)))\n    if (distance is None):\n        np.testing.assert_allclose(np.linalg.norm(d, axis=2).ravel(), 0.01, atol=1e-08)\n    else:\n        np.testing.assert_allclose(np.linalg.norm(d, axis=2).ravel(), 0.03, atol=1e-08)\n    if is_plusminus:\n        np.testing.assert_allclose(d[:(len(d) // 2)], (- d[(len(d) // 2):]), atol=1e-08)", "masked_code": "@pytest.mark.parametrize('is_plusminus,distance,number_of_snapshots', itertools.product([False, True], [None, 0.03], [4, 'auto']))\ndef test_tio2_random_disp(ph_tio2: Phonopy, is_plusminus: bool, distance: Optional[float], number_of_snapshots: Union[(int, Literal['auto'])]):\n    'Test random displacements of TiO2.\\n\\n    Currently default displacement distance = 0.01.\\n\\n    '\n    pytest.importorskip('symfc')\n    ph = ph_tio2.copy()\n    ph.generate_displacements(number_of_snapshots=number_of_snapshots, distance=distance, is_plusminus=is_plusminus)\n    d = ph.displacements\n    if (number_of_snapshots == 'auto'):\n        assert (len(d) == (4 * (is_plusminus + 1)))\n    else:\n        assert (len(d) == '???')\n    if (distance is None):\n        np.testing.assert_allclose(np.linalg.norm(d, axis=2).ravel(), 0.01, atol=1e-08)\n    else:\n        np.testing.assert_allclose(np.linalg.norm(d, axis=2).ravel(), 0.03, atol=1e-08)\n    if is_plusminus:\n        np.testing.assert_allclose(d[:(len(d) // 2)], (- d[(len(d) // 2):]), atol=1e-08)", "ground_truth": "(4 * (is_plusminus + 1))", "quality_analysis": {"complexity_score": 11, "left_complexity": 4, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_11", "reponame": "phonopy", "testpath": "test/harmonic/test_displacements.py", "testname": "test_displacements.py", "classname": null, "funcname": "test_tio2_random_disp_rd_auto_estimation_factor", "imports": ["import itertools", "from typing import Literal, Optional, Union", "import numpy as np", "import pytest", "from phonopy import Phonopy"], "code": "def test_tio2_random_disp_rd_auto_estimation_factor(ph_tio2: Phonopy):\n    \"Test random displacements of TiO2.\\n\\n    Test for Phonopy.generate_displacements(number_of_snapshots='auto',\\n    number_estimation_factor=NUM)\\n\\n    \"\n    pytest.importorskip('symfc')\n    ph = ph_tio2.copy()\n    ph.generate_displacements(number_of_snapshots='auto')\n    assert (len(ph.displacements) == 4)\n    ph.generate_displacements(number_of_snapshots='auto', number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5)\n    assert (len(ph.displacements) == 8)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5, number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)", "masked_code": "def test_tio2_random_disp_rd_auto_estimation_factor(ph_tio2: Phonopy):\n    \"Test random displacements of TiO2.\\n\\n    Test for Phonopy.generate_displacements(number_of_snapshots='auto',\\n    number_estimation_factor=NUM)\\n\\n    \"\n    pytest.importorskip('symfc')\n    ph = ph_tio2.copy()\n    ph.generate_displacements(number_of_snapshots='auto')\n    assert (len(ph.displacements) == '???')\n    ph.generate_displacements(number_of_snapshots='auto', number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5)\n    assert (len(ph.displacements) == 8)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5, number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)", "ground_truth": "4", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_12", "reponame": "phonopy", "testpath": "test/harmonic/test_displacements.py", "testname": "test_displacements.py", "classname": null, "funcname": "test_tio2_random_disp_rd_auto_estimation_factor", "imports": ["import itertools", "from typing import Literal, Optional, Union", "import numpy as np", "import pytest", "from phonopy import Phonopy"], "code": "def test_tio2_random_disp_rd_auto_estimation_factor(ph_tio2: Phonopy):\n    \"Test random displacements of TiO2.\\n\\n    Test for Phonopy.generate_displacements(number_of_snapshots='auto',\\n    number_estimation_factor=NUM)\\n\\n    \"\n    pytest.importorskip('symfc')\n    ph = ph_tio2.copy()\n    ph.generate_displacements(number_of_snapshots='auto')\n    assert (len(ph.displacements) == 4)\n    ph.generate_displacements(number_of_snapshots='auto', number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5)\n    assert (len(ph.displacements) == 8)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5, number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)", "masked_code": "def test_tio2_random_disp_rd_auto_estimation_factor(ph_tio2: Phonopy):\n    \"Test random displacements of TiO2.\\n\\n    Test for Phonopy.generate_displacements(number_of_snapshots='auto',\\n    number_estimation_factor=NUM)\\n\\n    \"\n    pytest.importorskip('symfc')\n    ph = ph_tio2.copy()\n    ph.generate_displacements(number_of_snapshots='auto')\n    assert (len(ph.displacements) == 4)\n    ph.generate_displacements(number_of_snapshots='auto', number_estimation_factor=10)\n    assert (len(ph.displacements) == '???')\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5)\n    assert (len(ph.displacements) == 8)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5, number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)", "ground_truth": "10", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_13", "reponame": "phonopy", "testpath": "test/harmonic/test_displacements.py", "testname": "test_displacements.py", "classname": null, "funcname": "test_tio2_random_disp_rd_auto_estimation_factor", "imports": ["import itertools", "from typing import Literal, Optional, Union", "import numpy as np", "import pytest", "from phonopy import Phonopy"], "code": "def test_tio2_random_disp_rd_auto_estimation_factor(ph_tio2: Phonopy):\n    \"Test random displacements of TiO2.\\n\\n    Test for Phonopy.generate_displacements(number_of_snapshots='auto',\\n    number_estimation_factor=NUM)\\n\\n    \"\n    pytest.importorskip('symfc')\n    ph = ph_tio2.copy()\n    ph.generate_displacements(number_of_snapshots='auto')\n    assert (len(ph.displacements) == 4)\n    ph.generate_displacements(number_of_snapshots='auto', number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5)\n    assert (len(ph.displacements) == 8)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5, number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)", "masked_code": "def test_tio2_random_disp_rd_auto_estimation_factor(ph_tio2: Phonopy):\n    \"Test random displacements of TiO2.\\n\\n    Test for Phonopy.generate_displacements(number_of_snapshots='auto',\\n    number_estimation_factor=NUM)\\n\\n    \"\n    pytest.importorskip('symfc')\n    ph = ph_tio2.copy()\n    ph.generate_displacements(number_of_snapshots='auto')\n    assert (len(ph.displacements) == 4)\n    ph.generate_displacements(number_of_snapshots='auto', number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5)\n    assert (len(ph.displacements) == '???')\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5, number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)", "ground_truth": "8", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_14", "reponame": "phonopy", "testpath": "test/harmonic/test_displacements.py", "testname": "test_displacements.py", "classname": null, "funcname": "test_tio2_random_disp_rd_auto_estimation_factor", "imports": ["import itertools", "from typing import Literal, Optional, Union", "import numpy as np", "import pytest", "from phonopy import Phonopy"], "code": "def test_tio2_random_disp_rd_auto_estimation_factor(ph_tio2: Phonopy):\n    \"Test random displacements of TiO2.\\n\\n    Test for Phonopy.generate_displacements(number_of_snapshots='auto',\\n    number_estimation_factor=NUM)\\n\\n    \"\n    pytest.importorskip('symfc')\n    ph = ph_tio2.copy()\n    ph.generate_displacements(number_of_snapshots='auto')\n    assert (len(ph.displacements) == 4)\n    ph.generate_displacements(number_of_snapshots='auto', number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5)\n    assert (len(ph.displacements) == 8)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5, number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)", "masked_code": "def test_tio2_random_disp_rd_auto_estimation_factor(ph_tio2: Phonopy):\n    \"Test random displacements of TiO2.\\n\\n    Test for Phonopy.generate_displacements(number_of_snapshots='auto',\\n    number_estimation_factor=NUM)\\n\\n    \"\n    pytest.importorskip('symfc')\n    ph = ph_tio2.copy()\n    ph.generate_displacements(number_of_snapshots='auto')\n    assert (len(ph.displacements) == 4)\n    ph.generate_displacements(number_of_snapshots='auto', number_estimation_factor=10)\n    assert (len(ph.displacements) == 10)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5)\n    assert (len(ph.displacements) == 8)\n    ph.generate_displacements(number_of_snapshots='auto', max_distance=1.5, number_estimation_factor=10)\n    assert (len(ph.displacements) == '???')", "ground_truth": "10", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_15", "reponame": "phonopy", "testpath": "test/harmonic/test_displacements.py", "testname": "test_displacements.py", "classname": null, "funcname": "test_tio2_random_disp_with_random_dist", "imports": ["import itertools", "from typing import Literal, Optional, Union", "import numpy as np", "import pytest", "from phonopy import Phonopy"], "code": "@pytest.mark.parametrize('min_distance', [None, 0.05, 0.2])\ndef test_tio2_random_disp_with_random_dist(ph_tio2: Phonopy, min_distance: Optional[float]):\n    'Test random displacements with random distance of TiO2.'\n    ph = ph_tio2.copy()\n    if ((min_distance is not None) and (min_distance > 0.1)):\n        with pytest.raises(RuntimeError):\n            ph.generate_displacements(number_of_snapshots=1, max_distance=0.1, distance=min_distance)\n    else:\n        n_snapshots = 100\n        ph.generate_displacements(number_of_snapshots=n_snapshots, distance=min_distance, max_distance=0.1)\n        d = ph.displacements\n        assert (len(d) == n_snapshots)\n        dists = np.linalg.norm(d, axis=2).ravel()\n        assert (dists < (0.1 + 1e-08)).all()\n        if (min_distance is not None):\n            assert (dists > (min_distance - 1e-08)).all()", "masked_code": "@pytest.mark.parametrize('min_distance', [None, 0.05, 0.2])\ndef test_tio2_random_disp_with_random_dist(ph_tio2: Phonopy, min_distance: Optional[float]):\n    'Test random displacements with random distance of TiO2.'\n    ph = ph_tio2.copy()\n    if ((min_distance is not None) and (min_distance > 0.1)):\n        with pytest.raises(RuntimeError):\n            ph.generate_displacements(number_of_snapshots=1, max_distance=0.1, distance=min_distance)\n    else:\n        n_snapshots = 100\n        ph.generate_displacements(number_of_snapshots=n_snapshots, distance=min_distance, max_distance=0.1)\n        d = ph.displacements\n        assert (len(d) == '???')\n        dists = np.linalg.norm(d, axis=2).ravel()\n        assert (dists < (0.1 + 1e-08)).all()\n        if (min_distance is not None):\n            assert (dists > (min_distance - 1e-08)).all()", "ground_truth": "n_snapshots", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_16", "reponame": "phonopy", "testpath": "test/harmonic/test_displacements.py", "testname": "test_displacements.py", "classname": null, "funcname": "test_tio2_random_disp_with_random_dist_defualt", "imports": ["import itertools", "from typing import Literal, Optional, Union", "import numpy as np", "import pytest", "from phonopy import Phonopy"], "code": "@pytest.mark.parametrize('max_distance', [None, 0.1])\ndef test_tio2_random_disp_with_random_dist_defualt(ph_tio2: Phonopy, max_distance: Optional[float]):\n    'Test random displacements with random distance of TiO2.\\n\\n    Combination of default distance and max_distance.\\n\\n    '\n    ph = ph_tio2.copy()\n    n_snapshots = 100\n    ph.generate_displacements(number_of_snapshots=n_snapshots, max_distance=max_distance, distance=0.01)\n    d = ph.displacements\n    assert (len(d) == n_snapshots)\n    dists = np.linalg.norm(d, axis=2).ravel()\n    if (max_distance is None):\n        assert (dists < (0.01 + 1e-08)).all()\n    else:\n        assert ((dists < (max_distance + 1e-08)).all() and (dists > (0.01 - 1e-08)).all())", "masked_code": "@pytest.mark.parametrize('max_distance', [None, 0.1])\ndef test_tio2_random_disp_with_random_dist_defualt(ph_tio2: Phonopy, max_distance: Optional[float]):\n    'Test random displacements with random distance of TiO2.\\n\\n    Combination of default distance and max_distance.\\n\\n    '\n    ph = ph_tio2.copy()\n    n_snapshots = 100\n    ph.generate_displacements(number_of_snapshots=n_snapshots, max_distance=max_distance, distance=0.01)\n    d = ph.displacements\n    assert (len(d) == '???')\n    dists = np.linalg.norm(d, axis=2).ravel()\n    if (max_distance is None):\n        assert (dists < (0.01 + 1e-08)).all()\n    else:\n        assert ((dists < (max_distance + 1e-08)).all() and (dists > (0.01 - 1e-08)).all())", "ground_truth": "n_snapshots", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_17", "reponame": "phonopy", "testpath": "test/harmonic/test_displacements.py", "testname": "test_displacements.py", "classname": null, "funcname": "test_tio2_random_disp_with_random_max_distance", "imports": ["import itertools", "from typing import Literal, Optional, Union", "import numpy as np", "import pytest", "from phonopy import Phonopy"], "code": "def test_tio2_random_disp_with_random_max_distance(ph_tio2: Phonopy):\n    'Test random displacements with random distance of TiO2.\\n\\n    Combination of distance and max_distance parameters.\\n\\n    '\n    ph = ph_tio2.copy()\n    n_snapshots = 100\n    ph.generate_displacements(number_of_snapshots=n_snapshots, distance=0.01, max_distance=0.1)\n    d = ph.displacements\n    assert (len(d) == n_snapshots)\n    dists = np.linalg.norm(d, axis=2).ravel()\n    assert (dists < (0.1 + 1e-08)).all()", "masked_code": "def test_tio2_random_disp_with_random_max_distance(ph_tio2: Phonopy):\n    'Test random displacements with random distance of TiO2.\\n\\n    Combination of distance and max_distance parameters.\\n\\n    '\n    ph = ph_tio2.copy()\n    n_snapshots = 100\n    ph.generate_displacements(number_of_snapshots=n_snapshots, distance=0.01, max_distance=0.1)\n    d = ph.displacements\n    assert (len(d) == '???')\n    dists = np.linalg.norm(d, axis=2).ravel()\n    assert (dists < (0.1 + 1e-08)).all()", "ground_truth": "n_snapshots", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_18", "reponame": "phonopy", "testpath": "test/harmonic/test_displacements.py", "testname": "test_displacements.py", "classname": null, "funcname": "test_tio2_random_distances", "imports": ["import itertools", "from typing import Literal, Optional, Union", "import numpy as np", "import pytest", "from phonopy import Phonopy"], "code": "def test_tio2_random_distances(ph_tio2: Phonopy):\n    'Test random distance displacements with random directions of TiO2.'\n    ph = ph_tio2.copy()\n    n_snapshots = 100\n    ph.generate_displacements(number_of_snapshots=n_snapshots, max_distance=0.1, distance=0.01)\n    d = ph.displacements\n    assert (len(d) == n_snapshots)\n    dists = np.linalg.norm(d, axis=2)\n    for dist_supercell in dists:\n        np.testing.assert_allclose(dist_supercell[0], dist_supercell, atol=1e-10)", "masked_code": "def test_tio2_random_distances(ph_tio2: Phonopy):\n    'Test random distance displacements with random directions of TiO2.'\n    ph = ph_tio2.copy()\n    n_snapshots = 100\n    ph.generate_displacements(number_of_snapshots=n_snapshots, max_distance=0.1, distance=0.01)\n    d = ph.displacements\n    assert (len(d) == '???')\n    dists = np.linalg.norm(d, axis=2)\n    for dist_supercell in dists:\n        np.testing.assert_allclose(dist_supercell[0], dist_supercell, atol=1e-10)", "ground_truth": "n_snapshots", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_19", "reponame": "phonopy", "testpath": "test/harmonic/test_dynamical_matrix.py", "testname": "test_dynamical_matrix.py", "classname": null, "funcname": "test_dynmat_gonze_lee_short_range_fc", "imports": ["from __future__ import annotations", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.dynamical_matrix import DynamicalMatrix, DynamicalMatrixGL"], "code": "def test_dynmat_gonze_lee_short_range_fc(ph_nacl: Phonopy):\n    'Test force constants in dynamical matrix with NAC by Gonze and Lee.'\n    ph_nacl.dynamical_matrix.make_Gonze_nac_dataset()\n    assert (ph_nacl.dynamical_matrix._G_cutoff == pytest.approx(1.1584988384375283))\n    assert (ph_nacl.dynamical_matrix._G_list.shape == (307, 3))\n    np.testing.assert_allclose(ph_nacl.dynamical_matrix._dd_q0.view('double').ravel(), [0.5509692730441111, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441109, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441113, 0.0, 0.5509692730441111, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441109, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441113, 0.0], atol=1e-05)\n    fc = ph_nacl.dynamical_matrix.force_constants\n    sr_fc = ph_nacl.dynamical_matrix.short_range_force_constants\n    np.testing.assert_allclose(np.diag(fc[(0, 1)]), [(- 0.3017767), 0.0049673, 0.0049673], atol=1e-05)\n    np.testing.assert_allclose(np.diag(sr_fc[(0, 1)]), [(- 0.13937495), (- 0.04645899), (- 0.04645899)], atol=1e-05)\n    ph_nacl.dynamical_matrix.short_range_force_constants = fc\n    sr_fc = ph_nacl.dynamical_matrix.short_range_force_constants\n    np.testing.assert_allclose(np.diag(sr_fc[(0, 1)]), [(- 0.3017767), 0.0049673, 0.0049673], atol=1e-05)\n    ph_nacl.dynamical_matrix.make_Gonze_nac_dataset()\n    sr_fc = ph_nacl.dynamical_matrix.short_range_force_constants\n    np.testing.assert_allclose(np.diag(sr_fc[(0, 1)]), [(- 0.13937495), (- 0.04645899), (- 0.04645899)], atol=1e-05)", "masked_code": "def test_dynmat_gonze_lee_short_range_fc(ph_nacl: Phonopy):\n    'Test force constants in dynamical matrix with NAC by Gonze and Lee.'\n    ph_nacl.dynamical_matrix.make_Gonze_nac_dataset()\n    assert (ph_nacl.dynamical_matrix._G_cutoff == '???')\n    assert (ph_nacl.dynamical_matrix._G_list.shape == (307, 3))\n    np.testing.assert_allclose(ph_nacl.dynamical_matrix._dd_q0.view('double').ravel(), [0.5509692730441111, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441109, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441113, 0.0, 0.5509692730441111, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441109, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441113, 0.0], atol=1e-05)\n    fc = ph_nacl.dynamical_matrix.force_constants\n    sr_fc = ph_nacl.dynamical_matrix.short_range_force_constants\n    np.testing.assert_allclose(np.diag(fc[(0, 1)]), [(- 0.3017767), 0.0049673, 0.0049673], atol=1e-05)\n    np.testing.assert_allclose(np.diag(sr_fc[(0, 1)]), [(- 0.13937495), (- 0.04645899), (- 0.04645899)], atol=1e-05)\n    ph_nacl.dynamical_matrix.short_range_force_constants = fc\n    sr_fc = ph_nacl.dynamical_matrix.short_range_force_constants\n    np.testing.assert_allclose(np.diag(sr_fc[(0, 1)]), [(- 0.3017767), 0.0049673, 0.0049673], atol=1e-05)\n    ph_nacl.dynamical_matrix.make_Gonze_nac_dataset()\n    sr_fc = ph_nacl.dynamical_matrix.short_range_force_constants\n    np.testing.assert_allclose(np.diag(sr_fc[(0, 1)]), [(- 0.13937495), (- 0.04645899), (- 0.04645899)], atol=1e-05)", "ground_truth": "pytest.approx(1.1584988384375283)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_20", "reponame": "phonopy", "testpath": "test/harmonic/test_dynamical_matrix.py", "testname": "test_dynamical_matrix.py", "classname": null, "funcname": "test_dynmat_gonze_lee_short_range_fc", "imports": ["from __future__ import annotations", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.dynamical_matrix import DynamicalMatrix, DynamicalMatrixGL"], "code": "def test_dynmat_gonze_lee_short_range_fc(ph_nacl: Phonopy):\n    'Test force constants in dynamical matrix with NAC by Gonze and Lee.'\n    ph_nacl.dynamical_matrix.make_Gonze_nac_dataset()\n    assert (ph_nacl.dynamical_matrix._G_cutoff == pytest.approx(1.1584988384375283))\n    assert (ph_nacl.dynamical_matrix._G_list.shape == (307, 3))\n    np.testing.assert_allclose(ph_nacl.dynamical_matrix._dd_q0.view('double').ravel(), [0.5509692730441111, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441109, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441113, 0.0, 0.5509692730441111, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441109, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441113, 0.0], atol=1e-05)\n    fc = ph_nacl.dynamical_matrix.force_constants\n    sr_fc = ph_nacl.dynamical_matrix.short_range_force_constants\n    np.testing.assert_allclose(np.diag(fc[(0, 1)]), [(- 0.3017767), 0.0049673, 0.0049673], atol=1e-05)\n    np.testing.assert_allclose(np.diag(sr_fc[(0, 1)]), [(- 0.13937495), (- 0.04645899), (- 0.04645899)], atol=1e-05)\n    ph_nacl.dynamical_matrix.short_range_force_constants = fc\n    sr_fc = ph_nacl.dynamical_matrix.short_range_force_constants\n    np.testing.assert_allclose(np.diag(sr_fc[(0, 1)]), [(- 0.3017767), 0.0049673, 0.0049673], atol=1e-05)\n    ph_nacl.dynamical_matrix.make_Gonze_nac_dataset()\n    sr_fc = ph_nacl.dynamical_matrix.short_range_force_constants\n    np.testing.assert_allclose(np.diag(sr_fc[(0, 1)]), [(- 0.13937495), (- 0.04645899), (- 0.04645899)], atol=1e-05)", "masked_code": "def test_dynmat_gonze_lee_short_range_fc(ph_nacl: Phonopy):\n    'Test force constants in dynamical matrix with NAC by Gonze and Lee.'\n    ph_nacl.dynamical_matrix.make_Gonze_nac_dataset()\n    assert (ph_nacl.dynamical_matrix._G_cutoff == pytest.approx(1.1584988384375283))\n    assert (ph_nacl.dynamical_matrix._G_list.shape == '???')\n    np.testing.assert_allclose(ph_nacl.dynamical_matrix._dd_q0.view('double').ravel(), [0.5509692730441111, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441109, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441113, 0.0, 0.5509692730441111, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441109, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5509692730441113, 0.0], atol=1e-05)\n    fc = ph_nacl.dynamical_matrix.force_constants\n    sr_fc = ph_nacl.dynamical_matrix.short_range_force_constants\n    np.testing.assert_allclose(np.diag(fc[(0, 1)]), [(- 0.3017767), 0.0049673, 0.0049673], atol=1e-05)\n    np.testing.assert_allclose(np.diag(sr_fc[(0, 1)]), [(- 0.13937495), (- 0.04645899), (- 0.04645899)], atol=1e-05)\n    ph_nacl.dynamical_matrix.short_range_force_constants = fc\n    sr_fc = ph_nacl.dynamical_matrix.short_range_force_constants\n    np.testing.assert_allclose(np.diag(sr_fc[(0, 1)]), [(- 0.3017767), 0.0049673, 0.0049673], atol=1e-05)\n    ph_nacl.dynamical_matrix.make_Gonze_nac_dataset()\n    sr_fc = ph_nacl.dynamical_matrix.short_range_force_constants\n    np.testing.assert_allclose(np.diag(sr_fc[(0, 1)]), [(- 0.13937495), (- 0.04645899), (- 0.04645899)], atol=1e-05)", "ground_truth": "(307, 3)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_21", "reponame": "phonopy", "testpath": "test/harmonic/test_force_constants.py", "testname": "test_force_constants.py", "classname": null, "funcname": "test_fc_cutoff_radius", "imports": ["import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.force_constants import cutoff_force_constants, rearrange_force_constants_array", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive, isclose"], "code": "@pytest.mark.parametrize('is_compact', [False, True])\ndef test_fc_cutoff_radius(ph_nacl: Phonopy, ph_nacl_compact_fcsym: Phonopy, is_compact):\n    'Test of cutoff radius of force constants calculation by NaCl.'\n    if is_compact:\n        ph = ph_nacl_compact_fcsym\n    else:\n        ph = ph_nacl\n    fc_orig = ph.force_constants.copy()\n    ph.set_force_constants_zero_with_radius(4.0)\n    changed = (np.abs((fc_orig - ph.force_constants)) > 1e-08)\n    ph.force_constants = fc_orig\n    if is_compact:\n        assert (np.sum(changed) == 534)\n    else:\n        assert (np.sum(changed) == 17088)", "masked_code": "@pytest.mark.parametrize('is_compact', [False, True])\ndef test_fc_cutoff_radius(ph_nacl: Phonopy, ph_nacl_compact_fcsym: Phonopy, is_compact):\n    'Test of cutoff radius of force constants calculation by NaCl.'\n    if is_compact:\n        ph = ph_nacl_compact_fcsym\n    else:\n        ph = ph_nacl\n    fc_orig = ph.force_constants.copy()\n    ph.set_force_constants_zero_with_radius(4.0)\n    changed = (np.abs((fc_orig - ph.force_constants)) > 1e-08)\n    ph.force_constants = fc_orig\n    if is_compact:\n        assert (np.sum(changed) == '???')\n    else:\n        assert (np.sum(changed) == 17088)", "ground_truth": "534", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_22", "reponame": "phonopy", "testpath": "test/harmonic/test_force_constants.py", "testname": "test_force_constants.py", "classname": null, "funcname": "test_fc_cutoff_radius", "imports": ["import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.force_constants import cutoff_force_constants, rearrange_force_constants_array", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive, isclose"], "code": "@pytest.mark.parametrize('is_compact', [False, True])\ndef test_fc_cutoff_radius(ph_nacl: Phonopy, ph_nacl_compact_fcsym: Phonopy, is_compact):\n    'Test of cutoff radius of force constants calculation by NaCl.'\n    if is_compact:\n        ph = ph_nacl_compact_fcsym\n    else:\n        ph = ph_nacl\n    fc_orig = ph.force_constants.copy()\n    ph.set_force_constants_zero_with_radius(4.0)\n    changed = (np.abs((fc_orig - ph.force_constants)) > 1e-08)\n    ph.force_constants = fc_orig\n    if is_compact:\n        assert (np.sum(changed) == 534)\n    else:\n        assert (np.sum(changed) == 17088)", "masked_code": "@pytest.mark.parametrize('is_compact', [False, True])\ndef test_fc_cutoff_radius(ph_nacl: Phonopy, ph_nacl_compact_fcsym: Phonopy, is_compact):\n    'Test of cutoff radius of force constants calculation by NaCl.'\n    if is_compact:\n        ph = ph_nacl_compact_fcsym\n    else:\n        ph = ph_nacl\n    fc_orig = ph.force_constants.copy()\n    ph.set_force_constants_zero_with_radius(4.0)\n    changed = (np.abs((fc_orig - ph.force_constants)) > 1e-08)\n    ph.force_constants = fc_orig\n    if is_compact:\n        assert (np.sum(changed) == 534)\n    else:\n        assert (np.sum(changed) == '???')", "ground_truth": "17088", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_23", "reponame": "phonopy", "testpath": "test/harmonic/test_force_constants.py", "testname": "test_force_constants.py", "classname": null, "funcname": "test_fc_cutoff_radius_svecs", "imports": ["import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.force_constants import cutoff_force_constants, rearrange_force_constants_array", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive, isclose"], "code": "@pytest.mark.parametrize('is_compact,store_dense_svecs', [(False, False), (False, True), (True, False), (True, True)])\ndef test_fc_cutoff_radius_svecs(ph_nacl: Phonopy, ph_nacl_compact_fcsym: Phonopy, is_compact, store_dense_svecs):\n    'Test of cutoff radius with dense-svecs format by NaCl.'\n    if is_compact:\n        ph = ph_nacl_compact_fcsym\n    else:\n        ph = ph_nacl\n    fc = ph.force_constants.copy()\n    primitive_matrix = np.dot(np.linalg.inv(ph.supercell_matrix), ph.primitive_matrix)\n    primitive = get_primitive(ph.supercell, primitive_matrix, store_dense_svecs=store_dense_svecs)\n    cutoff_force_constants(fc, ph.supercell, primitive, 4.0)\n    changed = (np.abs((ph.force_constants - fc)) > 1e-08)\n    if is_compact:\n        assert (np.sum(changed) == 534)\n    else:\n        assert (np.sum(changed) == 17088)", "masked_code": "@pytest.mark.parametrize('is_compact,store_dense_svecs', [(False, False), (False, True), (True, False), (True, True)])\ndef test_fc_cutoff_radius_svecs(ph_nacl: Phonopy, ph_nacl_compact_fcsym: Phonopy, is_compact, store_dense_svecs):\n    'Test of cutoff radius with dense-svecs format by NaCl.'\n    if is_compact:\n        ph = ph_nacl_compact_fcsym\n    else:\n        ph = ph_nacl\n    fc = ph.force_constants.copy()\n    primitive_matrix = np.dot(np.linalg.inv(ph.supercell_matrix), ph.primitive_matrix)\n    primitive = get_primitive(ph.supercell, primitive_matrix, store_dense_svecs=store_dense_svecs)\n    cutoff_force_constants(fc, ph.supercell, primitive, 4.0)\n    changed = (np.abs((ph.force_constants - fc)) > 1e-08)\n    if is_compact:\n        assert (np.sum(changed) == '???')\n    else:\n        assert (np.sum(changed) == 17088)", "ground_truth": "534", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_24", "reponame": "phonopy", "testpath": "test/harmonic/test_force_constants.py", "testname": "test_force_constants.py", "classname": null, "funcname": "test_fc_cutoff_radius_svecs", "imports": ["import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.force_constants import cutoff_force_constants, rearrange_force_constants_array", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive, isclose"], "code": "@pytest.mark.parametrize('is_compact,store_dense_svecs', [(False, False), (False, True), (True, False), (True, True)])\ndef test_fc_cutoff_radius_svecs(ph_nacl: Phonopy, ph_nacl_compact_fcsym: Phonopy, is_compact, store_dense_svecs):\n    'Test of cutoff radius with dense-svecs format by NaCl.'\n    if is_compact:\n        ph = ph_nacl_compact_fcsym\n    else:\n        ph = ph_nacl\n    fc = ph.force_constants.copy()\n    primitive_matrix = np.dot(np.linalg.inv(ph.supercell_matrix), ph.primitive_matrix)\n    primitive = get_primitive(ph.supercell, primitive_matrix, store_dense_svecs=store_dense_svecs)\n    cutoff_force_constants(fc, ph.supercell, primitive, 4.0)\n    changed = (np.abs((ph.force_constants - fc)) > 1e-08)\n    if is_compact:\n        assert (np.sum(changed) == 534)\n    else:\n        assert (np.sum(changed) == 17088)", "masked_code": "@pytest.mark.parametrize('is_compact,store_dense_svecs', [(False, False), (False, True), (True, False), (True, True)])\ndef test_fc_cutoff_radius_svecs(ph_nacl: Phonopy, ph_nacl_compact_fcsym: Phonopy, is_compact, store_dense_svecs):\n    'Test of cutoff radius with dense-svecs format by NaCl.'\n    if is_compact:\n        ph = ph_nacl_compact_fcsym\n    else:\n        ph = ph_nacl\n    fc = ph.force_constants.copy()\n    primitive_matrix = np.dot(np.linalg.inv(ph.supercell_matrix), ph.primitive_matrix)\n    primitive = get_primitive(ph.supercell, primitive_matrix, store_dense_svecs=store_dense_svecs)\n    cutoff_force_constants(fc, ph.supercell, primitive, 4.0)\n    changed = (np.abs((ph.force_constants - fc)) > 1e-08)\n    if is_compact:\n        assert (np.sum(changed) == 534)\n    else:\n        assert (np.sum(changed) == '???')", "ground_truth": "17088", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_25", "reponame": "phonopy", "testpath": "test/harmonic/test_force_constants.py", "testname": "test_force_constants.py", "classname": null, "funcname": "test_rearrange_force_constants_array", "imports": ["import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.force_constants import cutoff_force_constants, rearrange_force_constants_array", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive, isclose"], "code": "def test_rearrange_force_constants_array(nacl_unitcell_order1: PhonopyAtoms, nacl_unitcell_order2: PhonopyAtoms, ph_nacl: Phonopy):\n    'Test of rearrange_force_constants_array.'\n    ph1 = ph_nacl\n    assert isclose(nacl_unitcell_order1, ph1.unitcell)\n    fc = ph1.force_constants\n    assert (fc.shape[0] == fc.shape[1])\n    ph2 = Phonopy(nacl_unitcell_order2, supercell_matrix=[2, 2, 2], primitive_matrix='F')\n    (re_fc, indices) = rearrange_force_constants_array(fc, ph1.supercell, ph2.supercell)\n    ph1.run_qpoints([[0.5, 0.5, 0.5]])\n    freq1 = ph1.get_qpoints_dict()['frequencies']\n    ph2.force_constants = re_fc\n    ph2.run_qpoints([[0.5, 0.5, 0.5]])\n    freq2 = ph2.get_qpoints_dict()['frequencies']\n    np.testing.assert_allclose(fc[(indices[3], indices[3])], re_fc[(3, 3)])\n    np.testing.assert_allclose(freq1, freq2)", "masked_code": "def test_rearrange_force_constants_array(nacl_unitcell_order1: PhonopyAtoms, nacl_unitcell_order2: PhonopyAtoms, ph_nacl: Phonopy):\n    'Test of rearrange_force_constants_array.'\n    ph1 = ph_nacl\n    assert isclose(nacl_unitcell_order1, ph1.unitcell)\n    fc = ph1.force_constants\n    assert (fc.shape[0] == '???')\n    ph2 = Phonopy(nacl_unitcell_order2, supercell_matrix=[2, 2, 2], primitive_matrix='F')\n    (re_fc, indices) = rearrange_force_constants_array(fc, ph1.supercell, ph2.supercell)\n    ph1.run_qpoints([[0.5, 0.5, 0.5]])\n    freq1 = ph1.get_qpoints_dict()['frequencies']\n    ph2.force_constants = re_fc\n    ph2.run_qpoints([[0.5, 0.5, 0.5]])\n    freq2 = ph2.get_qpoints_dict()['frequencies']\n    np.testing.assert_allclose(fc[(indices[3], indices[3])], re_fc[(3, 3)])\n    np.testing.assert_allclose(freq1, freq2)", "ground_truth": "fc.shape[1]", "quality_analysis": {"complexity_score": 12, "left_complexity": 6, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_26", "reponame": "phonopy", "testpath": "test/interface/test_abacus.py", "testname": "test_abacus.py", "classname": null, "funcname": "test_read_abacus_nomag", "imports": ["import os", "import numpy as np", "from phonopy.interface.abacus import read_abacus, read_abacus_output", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure import cells"], "code": "def test_read_abacus_nomag():\n    'Test of read_ABACUS.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abinit-pwscf.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')", "masked_code": "def test_read_abacus_nomag():\n    'Test of read_ABACUS.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abinit-pwscf.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == '???')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')", "ground_truth": "'Na_ONCV_PBE-1.0.upf'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_27", "reponame": "phonopy", "testpath": "test/interface/test_abacus.py", "testname": "test_abacus.py", "classname": null, "funcname": "test_read_abacus_nomag", "imports": ["import os", "import numpy as np", "from phonopy.interface.abacus import read_abacus, read_abacus_output", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure import cells"], "code": "def test_read_abacus_nomag():\n    'Test of read_ABACUS.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abinit-pwscf.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')", "masked_code": "def test_read_abacus_nomag():\n    'Test of read_ABACUS.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abinit-pwscf.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == '???')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')", "ground_truth": "'Cl_ONCV_PBE-1.0.upf'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_28", "reponame": "phonopy", "testpath": "test/interface/test_abacus.py", "testname": "test_abacus.py", "classname": null, "funcname": "test_read_abacus_nomag", "imports": ["import os", "import numpy as np", "from phonopy.interface.abacus import read_abacus, read_abacus_output", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure import cells"], "code": "def test_read_abacus_nomag():\n    'Test of read_ABACUS.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abinit-pwscf.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')", "masked_code": "def test_read_abacus_nomag():\n    'Test of read_ABACUS.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abinit-pwscf.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == '???')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')", "ground_truth": "'Na_gga_9au_100Ry_4s2p1d.orb'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_29", "reponame": "phonopy", "testpath": "test/interface/test_abacus.py", "testname": "test_abacus.py", "classname": null, "funcname": "test_read_abacus_nomag", "imports": ["import os", "import numpy as np", "from phonopy.interface.abacus import read_abacus, read_abacus_output", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure import cells"], "code": "def test_read_abacus_nomag():\n    'Test of read_ABACUS.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abinit-pwscf.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')", "masked_code": "def test_read_abacus_nomag():\n    'Test of read_ABACUS.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abinit-pwscf.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == '???')", "ground_truth": "'Cl_gga_8au_100Ry_2s2p1d.orb'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_30", "reponame": "phonopy", "testpath": "test/interface/test_abacus.py", "testname": "test_abacus.py", "classname": null, "funcname": "test_read_abacus_mag", "imports": ["import os", "import numpy as np", "from phonopy.interface.abacus import read_abacus, read_abacus_output", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure import cells"], "code": "def test_read_abacus_mag():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - np.array((([1] * 4) + ([2] * 4))))\n    assert (np.abs(diff_mag) < 1e-05).all()", "masked_code": "def test_read_abacus_mag():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == '???')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - np.array((([1] * 4) + ([2] * 4))))\n    assert (np.abs(diff_mag) < 1e-05).all()", "ground_truth": "'Na_ONCV_PBE-1.0.upf'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_31", "reponame": "phonopy", "testpath": "test/interface/test_abacus.py", "testname": "test_abacus.py", "classname": null, "funcname": "test_read_abacus_mag", "imports": ["import os", "import numpy as np", "from phonopy.interface.abacus import read_abacus, read_abacus_output", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure import cells"], "code": "def test_read_abacus_mag():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - np.array((([1] * 4) + ([2] * 4))))\n    assert (np.abs(diff_mag) < 1e-05).all()", "masked_code": "def test_read_abacus_mag():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == '???')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - np.array((([1] * 4) + ([2] * 4))))\n    assert (np.abs(diff_mag) < 1e-05).all()", "ground_truth": "'Cl_ONCV_PBE-1.0.upf'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_32", "reponame": "phonopy", "testpath": "test/interface/test_abacus.py", "testname": "test_abacus.py", "classname": null, "funcname": "test_read_abacus_mag", "imports": ["import os", "import numpy as np", "from phonopy.interface.abacus import read_abacus, read_abacus_output", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure import cells"], "code": "def test_read_abacus_mag():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - np.array((([1] * 4) + ([2] * 4))))\n    assert (np.abs(diff_mag) < 1e-05).all()", "masked_code": "def test_read_abacus_mag():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == '???')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - np.array((([1] * 4) + ([2] * 4))))\n    assert (np.abs(diff_mag) < 1e-05).all()", "ground_truth": "'Na_gga_9au_100Ry_4s2p1d.orb'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_33", "reponame": "phonopy", "testpath": "test/interface/test_abacus.py", "testname": "test_abacus.py", "classname": null, "funcname": "test_read_abacus_mag", "imports": ["import os", "import numpy as np", "from phonopy.interface.abacus import read_abacus, read_abacus_output", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure import cells"], "code": "def test_read_abacus_mag():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - np.array((([1] * 4) + ([2] * 4))))\n    assert (np.abs(diff_mag) < 1e-05).all()", "masked_code": "def test_read_abacus_mag():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == '???')\n    diff_mag = (cell_ref.magnetic_moments - np.array((([1] * 4) + ([2] * 4))))\n    assert (np.abs(diff_mag) < 1e-05).all()", "ground_truth": "'Cl_gga_8au_100Ry_2s2p1d.orb'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_34", "reponame": "phonopy", "testpath": "test/interface/test_abacus.py", "testname": "test_abacus.py", "classname": null, "funcname": "test_read_abacus_mag_noncolin", "imports": ["import os", "import numpy as np", "from phonopy.interface.abacus import read_abacus, read_abacus_output", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure import cells"], "code": "def test_read_abacus_mag_noncolin():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - cell.magnetic_moments)\n    assert (np.abs(diff_mag) < 1e-05).all()", "masked_code": "def test_read_abacus_mag_noncolin():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == '???')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - cell.magnetic_moments)\n    assert (np.abs(diff_mag) < 1e-05).all()", "ground_truth": "'Na_ONCV_PBE-1.0.upf'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_35", "reponame": "phonopy", "testpath": "test/interface/test_abacus.py", "testname": "test_abacus.py", "classname": null, "funcname": "test_read_abacus_mag_noncolin", "imports": ["import os", "import numpy as np", "from phonopy.interface.abacus import read_abacus, read_abacus_output", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure import cells"], "code": "def test_read_abacus_mag_noncolin():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - cell.magnetic_moments)\n    assert (np.abs(diff_mag) < 1e-05).all()", "masked_code": "def test_read_abacus_mag_noncolin():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == '???')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - cell.magnetic_moments)\n    assert (np.abs(diff_mag) < 1e-05).all()", "ground_truth": "'Cl_ONCV_PBE-1.0.upf'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_36", "reponame": "phonopy", "testpath": "test/interface/test_abacus.py", "testname": "test_abacus.py", "classname": null, "funcname": "test_read_abacus_mag_noncolin", "imports": ["import os", "import numpy as np", "from phonopy.interface.abacus import read_abacus, read_abacus_output", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure import cells"], "code": "def test_read_abacus_mag_noncolin():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - cell.magnetic_moments)\n    assert (np.abs(diff_mag) < 1e-05).all()", "masked_code": "def test_read_abacus_mag_noncolin():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == '???')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - cell.magnetic_moments)\n    assert (np.abs(diff_mag) < 1e-05).all()", "ground_truth": "'Na_gga_9au_100Ry_4s2p1d.orb'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_37", "reponame": "phonopy", "testpath": "test/interface/test_abacus.py", "testname": "test_abacus.py", "classname": null, "funcname": "test_read_abacus_mag_noncolin", "imports": ["import os", "import numpy as np", "from phonopy.interface.abacus import read_abacus, read_abacus_output", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure import cells"], "code": "def test_read_abacus_mag_noncolin():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == 'Cl_gga_8au_100Ry_2s2p1d.orb')\n    diff_mag = (cell_ref.magnetic_moments - cell.magnetic_moments)\n    assert (np.abs(diff_mag) < 1e-05).all()", "masked_code": "def test_read_abacus_mag_noncolin():\n    'Test of read_ABACUS with magnetic moments.'\n    (cell, pps, orbitals, abfs) = read_abacus(os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.stru'))\n    filename = os.path.join(data_dir, 'NaCl-abacus-mag-noncolin.yaml')\n    cell_ref = read_cell_yaml(filename)\n    assert cells.isclose(cell, cell_ref)\n    diff_pos = (cell.scaled_positions - cell_ref.scaled_positions)\n    diff_pos -= np.rint(diff_pos)\n    assert (np.abs(diff_pos) < 1e-05).all()\n    for (s, s_r) in zip(cell.symbols, cell_ref.symbols):\n        assert (s == s_r)\n    assert (pps['Na'] == 'Na_ONCV_PBE-1.0.upf')\n    assert (pps['Cl'] == 'Cl_ONCV_PBE-1.0.upf')\n    assert (orbitals['Na'] == 'Na_gga_9au_100Ry_4s2p1d.orb')\n    assert (orbitals['Cl'] == '???')\n    diff_mag = (cell_ref.magnetic_moments - cell.magnetic_moments)\n    assert (np.abs(diff_mag) < 1e-05).all()", "ground_truth": "'Cl_gga_8au_100Ry_2s2p1d.orb'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_38", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_write_phonopy_yaml", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_write_phonopy_yaml(ph_nacl_nofcsym: Phonopy, helper_methods):\n    'Test PhonopyYaml.set_phonon_info, __str__, yaml_data, parse.'\n    phonon = ph_nacl_nofcsym\n    phpy_yaml = PhonopyYaml(calculator='vasp')\n    phpy_yaml.set_phonon_info(phonon)\n    phpy_yaml_test = PhonopyYaml()\n    phpy_yaml_test._data = load_phonopy_yaml(yaml.safe_load(io.StringIO(str(phpy_yaml))), calculator=phpy_yaml.calculator)\n    helper_methods.compare_cells_with_order(phpy_yaml.primitive, phpy_yaml_test.primitive)\n    helper_methods.compare_cells_with_order(phpy_yaml.unitcell, phpy_yaml_test.unitcell)\n    helper_methods.compare_cells_with_order(phpy_yaml.supercell, phpy_yaml_test.supercell)\n    assert (phpy_yaml.version == phpy_yaml_test.version)\n    np.testing.assert_allclose(phpy_yaml.supercell_matrix, phpy_yaml_test.supercell_matrix, atol=1e-08)\n    np.testing.assert_allclose(phpy_yaml.primitive_matrix, phpy_yaml_test.primitive_matrix, atol=1e-08)", "masked_code": "def test_write_phonopy_yaml(ph_nacl_nofcsym: Phonopy, helper_methods):\n    'Test PhonopyYaml.set_phonon_info, __str__, yaml_data, parse.'\n    phonon = ph_nacl_nofcsym\n    phpy_yaml = PhonopyYaml(calculator='vasp')\n    phpy_yaml.set_phonon_info(phonon)\n    phpy_yaml_test = PhonopyYaml()\n    phpy_yaml_test._data = load_phonopy_yaml(yaml.safe_load(io.StringIO(str(phpy_yaml))), calculator=phpy_yaml.calculator)\n    helper_methods.compare_cells_with_order(phpy_yaml.primitive, phpy_yaml_test.primitive)\n    helper_methods.compare_cells_with_order(phpy_yaml.unitcell, phpy_yaml_test.unitcell)\n    helper_methods.compare_cells_with_order(phpy_yaml.supercell, phpy_yaml_test.supercell)\n    assert (phpy_yaml.version == '???')\n    np.testing.assert_allclose(phpy_yaml.supercell_matrix, phpy_yaml_test.supercell_matrix, atol=1e-08)\n    np.testing.assert_allclose(phpy_yaml.primitive_matrix, phpy_yaml_test.primitive_matrix, atol=1e-08)", "ground_truth": "phpy_yaml_test.version", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_39", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_load_nac_yaml", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_load_nac_yaml():\n    'Test to read NAC params using PhonopyYamlLoader.'\n    pyl = PhonopyYamlLoader(yaml.safe_load(open((cwd / 'nac.yaml')))).parse()\n    assert pyl.data.nac_params\n    for key in ('dielectric', 'born', 'factor', 'method'):\n        assert (key in pyl.data.nac_params)\n    assert (pyl.data.nac_params['dielectric'].shape == (3, 3))\n    assert (pyl.data.nac_params['born'].shape == (2, 3, 3))\n    assert isinstance(pyl.data.nac_params['factor'], float)\n    assert isinstance(pyl.data.nac_params['method'], str)", "masked_code": "def test_load_nac_yaml():\n    'Test to read NAC params using PhonopyYamlLoader.'\n    pyl = PhonopyYamlLoader(yaml.safe_load(open((cwd / 'nac.yaml')))).parse()\n    assert pyl.data.nac_params\n    for key in ('dielectric', 'born', 'factor', 'method'):\n        assert (key in pyl.data.nac_params)\n    assert (pyl.data.nac_params['dielectric'].shape == '???')\n    assert (pyl.data.nac_params['born'].shape == (2, 3, 3))\n    assert isinstance(pyl.data.nac_params['factor'], float)\n    assert isinstance(pyl.data.nac_params['method'], str)", "ground_truth": "(3, 3)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_40", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_load_nac_yaml", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_load_nac_yaml():\n    'Test to read NAC params using PhonopyYamlLoader.'\n    pyl = PhonopyYamlLoader(yaml.safe_load(open((cwd / 'nac.yaml')))).parse()\n    assert pyl.data.nac_params\n    for key in ('dielectric', 'born', 'factor', 'method'):\n        assert (key in pyl.data.nac_params)\n    assert (pyl.data.nac_params['dielectric'].shape == (3, 3))\n    assert (pyl.data.nac_params['born'].shape == (2, 3, 3))\n    assert isinstance(pyl.data.nac_params['factor'], float)\n    assert isinstance(pyl.data.nac_params['method'], str)", "masked_code": "def test_load_nac_yaml():\n    'Test to read NAC params using PhonopyYamlLoader.'\n    pyl = PhonopyYamlLoader(yaml.safe_load(open((cwd / 'nac.yaml')))).parse()\n    assert pyl.data.nac_params\n    for key in ('dielectric', 'born', 'factor', 'method'):\n        assert (key in pyl.data.nac_params)\n    assert (pyl.data.nac_params['dielectric'].shape == (3, 3))\n    assert (pyl.data.nac_params['born'].shape == '???')\n    assert isinstance(pyl.data.nac_params['factor'], float)\n    assert isinstance(pyl.data.nac_params['method'], str)", "ground_truth": "(2, 3, 3)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_41", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == '???')\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "(['Na'] * 4)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_42", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == '???')\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "(['Cl'] * 3)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_43", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == '???')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "'Cl1'", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_44", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == '???')\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "(['Na'] * 4)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_45", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == '???')\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "(['Cl'] * 3)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_46", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == '???')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "'Cl1'", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_47", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == '???')\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "(['Na'] * 32)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_48", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == '???')\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "(['Cl'] * 24)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_49", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == '???')\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "(['Cl1'] * 8)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_50", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == '???')\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "(['Na'] * 4)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_51", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == '???')\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "(['Cl'] * 3)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_52", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == '???')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "'Cl1'", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_53", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == '???')\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "(['Na'] * 4)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_54", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == '???')\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "(['Cl'] * 3)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_55", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == '???')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "'Cl1'", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_56", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == '???')\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "(['Na'] * 32)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_57", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == '???')\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "ground_truth": "(['Cl'] * 24)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_58", "reponame": "phonopy", "testpath": "test/interface/test_phonopy_yaml.py", "testname": "test_phonopy_yaml.py", "classname": null, "funcname": "test_phonopy_yaml_extended_symbol", "imports": ["import io", "from pathlib import Path", "import numpy as np", "import yaml", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import PhonopyYaml, PhonopyYamlLoader, load_phonopy_yaml, read_cell_yaml, read_phonopy_yaml", "from phonopy.interface.vasp import read_vasp", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_primitive", "from phonopy.structure.dataset import get_displacements_and_forces"], "code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == (['Cl1'] * 8))", "masked_code": "def test_phonopy_yaml_extended_symbol(nacl_unitcell_order1: PhonopyAtoms):\n    'Test of PhonopyYaml with extended symbol.'\n    unitcell = nacl_unitcell_order1\n    symbols = unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    cell = PhonopyAtoms(cell=unitcell.cell, symbols=symbols, scaled_positions=unitcell.scaled_positions, masses=unitcell.masses)\n    ph = Phonopy(cell, supercell_matrix=[2, 2, 2])\n    assert (ph.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph.supercell.symbols[(- 8):] == (['Cl1'] * 8))\n    ph_load = phonopy.load(io.StringIO(str(PhonopyYaml().set_phonon_info(ph))))\n    assert (ph_load.primitive.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.primitive.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.primitive.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.unitcell.symbols[:4] == (['Na'] * 4))\n    assert (ph_load.unitcell.symbols[4:7] == (['Cl'] * 3))\n    assert (ph_load.unitcell.symbols[(- 1)] == 'Cl1')\n    assert (ph_load.supercell.symbols[:32] == (['Na'] * 32))\n    assert (ph_load.supercell.symbols[(- 32):(- 8)] == (['Cl'] * 24))\n    assert (ph_load.supercell.symbols[(- 8):] == '???')", "ground_truth": "(['Cl1'] * 8)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_59", "reponame": "phonopy", "testpath": "test/interface/test_pwscf.py", "testname": "test_pwscf.py", "classname": null, "funcname": "test_read_pwscf_NaCl_Xn", "imports": ["import pathlib", "import numpy as np", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.interface.qe import read_pwscf", "from phonopy.structure.symmetry import Symmetry"], "code": "def test_read_pwscf_NaCl_Xn():\n    'Test of read_pwscf.'\n    (cell, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf-Xn.in'))\n    print(cell)\n    symnums = pp_filenames.keys()\n    assert (set(symnums) == {'Na', 'Cl', 'Cl1'})\n    np.testing.assert_allclose(cell.masses, [22.98976928, 22.98976928, 22.98976928, 22.98976928, 35.453, 35.453, 70.0, 70.0])\n    assert (['Na', 'Na', 'Na', 'Na', 'Cl', 'Cl', 'Cl1', 'Cl1'] == cell.symbols)\n    (cell_ref, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf.in'))\n    symops = Symmetry(cell).symmetry_operations\n    symops_ref = Symmetry(cell_ref).symmetry_operations\n    np.testing.assert_allclose(symops['translations'], symops_ref['translations'])\n    np.testing.assert_array_equal(symops['rotations'], symops_ref['rotations'])", "masked_code": "def test_read_pwscf_NaCl_Xn():\n    'Test of read_pwscf.'\n    (cell, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf-Xn.in'))\n    print(cell)\n    symnums = pp_filenames.keys()\n    assert (set(symnums) == '???')\n    np.testing.assert_allclose(cell.masses, [22.98976928, 22.98976928, 22.98976928, 22.98976928, 35.453, 35.453, 70.0, 70.0])\n    assert (['Na', 'Na', 'Na', 'Na', 'Cl', 'Cl', 'Cl1', 'Cl1'] == cell.symbols)\n    (cell_ref, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf.in'))\n    symops = Symmetry(cell).symmetry_operations\n    symops_ref = Symmetry(cell_ref).symmetry_operations\n    np.testing.assert_allclose(symops['translations'], symops_ref['translations'])\n    np.testing.assert_array_equal(symops['rotations'], symops_ref['rotations'])", "ground_truth": "{'Na', 'Cl', 'Cl1'}", "quality_analysis": {"complexity_score": 4, "left_complexity": 4, "right_complexity": 0, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_60", "reponame": "phonopy", "testpath": "test/interface/test_pwscf.py", "testname": "test_pwscf.py", "classname": null, "funcname": "test_read_pwscf_NaCl_Xn", "imports": ["import pathlib", "import numpy as np", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.interface.qe import read_pwscf", "from phonopy.structure.symmetry import Symmetry"], "code": "def test_read_pwscf_NaCl_Xn():\n    'Test of read_pwscf.'\n    (cell, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf-Xn.in'))\n    print(cell)\n    symnums = pp_filenames.keys()\n    assert (set(symnums) == {'Na', 'Cl', 'Cl1'})\n    np.testing.assert_allclose(cell.masses, [22.98976928, 22.98976928, 22.98976928, 22.98976928, 35.453, 35.453, 70.0, 70.0])\n    assert (['Na', 'Na', 'Na', 'Na', 'Cl', 'Cl', 'Cl1', 'Cl1'] == cell.symbols)\n    (cell_ref, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf.in'))\n    symops = Symmetry(cell).symmetry_operations\n    symops_ref = Symmetry(cell_ref).symmetry_operations\n    np.testing.assert_allclose(symops['translations'], symops_ref['translations'])\n    np.testing.assert_array_equal(symops['rotations'], symops_ref['rotations'])", "masked_code": "def test_read_pwscf_NaCl_Xn():\n    'Test of read_pwscf.'\n    (cell, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf-Xn.in'))\n    print(cell)\n    symnums = pp_filenames.keys()\n    assert (set(symnums) == {'Na', 'Cl', 'Cl1'})\n    np.testing.assert_allclose(cell.masses, [22.98976928, 22.98976928, 22.98976928, 22.98976928, 35.453, 35.453, 70.0, 70.0])\n    assert (['Na', 'Na', 'Na', 'Na', 'Cl', 'Cl', 'Cl1', 'Cl1'] == '???')\n    (cell_ref, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf.in'))\n    symops = Symmetry(cell).symmetry_operations\n    symops_ref = Symmetry(cell_ref).symmetry_operations\n    np.testing.assert_allclose(symops['translations'], symops_ref['translations'])\n    np.testing.assert_array_equal(symops['rotations'], symops_ref['rotations'])", "ground_truth": "cell.symbols", "quality_analysis": {"complexity_score": 12, "left_complexity": 10, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_61", "reponame": "phonopy", "testpath": "test/interface/test_qlm.py", "testname": "test_qlm.py", "classname": null, "funcname": "test_cell2struct_and_read_qlm", "imports": ["import os", "import tempfile", "import numpy as np", "from phonopy.interface.qlm import parse_set_of_forces, read_qlm"], "code": "def test_cell2struct_and_read_qlm():\n    'Test read_qlm and get_qlm_structure.'\n    sitex_ref = ('% site-data vn=3.0 xpos fast io=15 nbas=8' + ' alat=10.7531113565 plat= 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0\\n#                            pos\\n Na        0.0000000000   0.0000000000   0.0000000000\\n Na        0.0000000000   0.5000000000   0.5000000000\\n Na2       0.5000000000   0.0000000000   0.5000000000\\n Na3       0.5000000000   0.5000000000   0.0000000000\\n Cl        0.5000000000   0.5000000000   0.5000000000\\n Clu       0.5000000000   0.0000000000   0.0000000000\\n Cl        0.0000000000   0.5000000000   0.0000000000\\n Cld       0.0000000000   0.0000000000   0.5000000000\\n')\n    try:\n        fl1 = tempfile.NamedTemporaryFile(delete=False)\n        fl1.write(sitex_ref.encode())\n        fl1.close()\n        (cell1, (inst1,)) = read_qlm(fl1.name)\n        fl2 = tempfile.NamedTemporaryFile(delete=False)\n        fl2.write(inst1.to_site_str(cell1).encode())\n        fl2.close()\n        (cell2, _) = read_qlm(fl2.name)\n        np.testing.assert_allclose(cell1.cell, cell2.cell, atol=1e-07)\n        np.testing.assert_allclose(cell1.scaled_positions, cell2.scaled_positions, atol=1e-07)\n        assert (cell1.symbols == cell2.symbols)\n    finally:\n        os.unlink(fl1.name)\n        os.unlink(fl2.name)", "masked_code": "def test_cell2struct_and_read_qlm():\n    'Test read_qlm and get_qlm_structure.'\n    sitex_ref = ('% site-data vn=3.0 xpos fast io=15 nbas=8' + ' alat=10.7531113565 plat= 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0\\n#                            pos\\n Na        0.0000000000   0.0000000000   0.0000000000\\n Na        0.0000000000   0.5000000000   0.5000000000\\n Na2       0.5000000000   0.0000000000   0.5000000000\\n Na3       0.5000000000   0.5000000000   0.0000000000\\n Cl        0.5000000000   0.5000000000   0.5000000000\\n Clu       0.5000000000   0.0000000000   0.0000000000\\n Cl        0.0000000000   0.5000000000   0.0000000000\\n Cld       0.0000000000   0.0000000000   0.5000000000\\n')\n    try:\n        fl1 = tempfile.NamedTemporaryFile(delete=False)\n        fl1.write(sitex_ref.encode())\n        fl1.close()\n        (cell1, (inst1,)) = read_qlm(fl1.name)\n        fl2 = tempfile.NamedTemporaryFile(delete=False)\n        fl2.write(inst1.to_site_str(cell1).encode())\n        fl2.close()\n        (cell2, _) = read_qlm(fl2.name)\n        np.testing.assert_allclose(cell1.cell, cell2.cell, atol=1e-07)\n        np.testing.assert_allclose(cell1.scaled_positions, cell2.scaled_positions, atol=1e-07)\n        assert (cell1.symbols == '???')\n    finally:\n        os.unlink(fl1.name)\n        os.unlink(fl2.name)", "ground_truth": "cell2.symbols", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_62", "reponame": "phonopy", "testpath": "test/interface/test_symfc.py", "testname": "test_symfc.py", "classname": null, "funcname": "test_symfc_cutoff", "imports": ["from __future__ import annotations", "from typing import Optional", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.force_constants import compact_fc_to_full_fc, full_fc_to_compact_fc", "from phonopy.interface.symfc import SymfcFCSolver, symmetrize_by_projector"], "code": "@pytest.mark.parametrize('cutoff', [None, {3: 5.0}])\ndef test_symfc_cutoff(ph_nacl: Phonopy, cutoff: Optional[dict]):\n    'Test symfc interface with cutoff distance.'\n    ph = ph_nacl\n    symfc_solver = SymfcFCSolver(ph.supercell, symmetry=ph.symmetry, options={'cutoff': cutoff}, log_level=1)\n    symfc_solver.compute_basis_set(orders=[2, 3])\n    basis_set_fc3 = symfc_solver.basis_set[3]\n    if (cutoff is None):\n        assert (basis_set_fc3.basis_set.shape == (786, 758))\n    else:\n        assert (basis_set_fc3.basis_set.shape == (80, 67))\n        nonzero_elems = symfc_solver.get_nonzero_atomic_indices_fc3()\n        assert (nonzero_elems is not None)\n        assert (nonzero_elems.size == (len(ph.supercell) ** 3))\n        assert (nonzero_elems.sum() == 21952)", "masked_code": "@pytest.mark.parametrize('cutoff', [None, {3: 5.0}])\ndef test_symfc_cutoff(ph_nacl: Phonopy, cutoff: Optional[dict]):\n    'Test symfc interface with cutoff distance.'\n    ph = ph_nacl\n    symfc_solver = SymfcFCSolver(ph.supercell, symmetry=ph.symmetry, options={'cutoff': cutoff}, log_level=1)\n    symfc_solver.compute_basis_set(orders=[2, 3])\n    basis_set_fc3 = symfc_solver.basis_set[3]\n    if (cutoff is None):\n        assert (basis_set_fc3.basis_set.shape == '???')\n    else:\n        assert (basis_set_fc3.basis_set.shape == (80, 67))\n        nonzero_elems = symfc_solver.get_nonzero_atomic_indices_fc3()\n        assert (nonzero_elems is not None)\n        assert (nonzero_elems.size == (len(ph.supercell) ** 3))\n        assert (nonzero_elems.sum() == 21952)", "ground_truth": "(786, 758)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_63", "reponame": "phonopy", "testpath": "test/interface/test_symfc.py", "testname": "test_symfc.py", "classname": null, "funcname": "test_symfc_cutoff", "imports": ["from __future__ import annotations", "from typing import Optional", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.force_constants import compact_fc_to_full_fc, full_fc_to_compact_fc", "from phonopy.interface.symfc import SymfcFCSolver, symmetrize_by_projector"], "code": "@pytest.mark.parametrize('cutoff', [None, {3: 5.0}])\ndef test_symfc_cutoff(ph_nacl: Phonopy, cutoff: Optional[dict]):\n    'Test symfc interface with cutoff distance.'\n    ph = ph_nacl\n    symfc_solver = SymfcFCSolver(ph.supercell, symmetry=ph.symmetry, options={'cutoff': cutoff}, log_level=1)\n    symfc_solver.compute_basis_set(orders=[2, 3])\n    basis_set_fc3 = symfc_solver.basis_set[3]\n    if (cutoff is None):\n        assert (basis_set_fc3.basis_set.shape == (786, 758))\n    else:\n        assert (basis_set_fc3.basis_set.shape == (80, 67))\n        nonzero_elems = symfc_solver.get_nonzero_atomic_indices_fc3()\n        assert (nonzero_elems is not None)\n        assert (nonzero_elems.size == (len(ph.supercell) ** 3))\n        assert (nonzero_elems.sum() == 21952)", "masked_code": "@pytest.mark.parametrize('cutoff', [None, {3: 5.0}])\ndef test_symfc_cutoff(ph_nacl: Phonopy, cutoff: Optional[dict]):\n    'Test symfc interface with cutoff distance.'\n    ph = ph_nacl\n    symfc_solver = SymfcFCSolver(ph.supercell, symmetry=ph.symmetry, options={'cutoff': cutoff}, log_level=1)\n    symfc_solver.compute_basis_set(orders=[2, 3])\n    basis_set_fc3 = symfc_solver.basis_set[3]\n    if (cutoff is None):\n        assert (basis_set_fc3.basis_set.shape == (786, 758))\n    else:\n        assert (basis_set_fc3.basis_set.shape == '???')\n        nonzero_elems = symfc_solver.get_nonzero_atomic_indices_fc3()\n        assert (nonzero_elems is not None)\n        assert (nonzero_elems.size == (len(ph.supercell) ** 3))\n        assert (nonzero_elems.sum() == 21952)", "ground_truth": "(80, 67)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_64", "reponame": "phonopy", "testpath": "test/interface/test_symfc.py", "testname": "test_symfc.py", "classname": null, "funcname": "test_symfc_cutoff", "imports": ["from __future__ import annotations", "from typing import Optional", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.force_constants import compact_fc_to_full_fc, full_fc_to_compact_fc", "from phonopy.interface.symfc import SymfcFCSolver, symmetrize_by_projector"], "code": "@pytest.mark.parametrize('cutoff', [None, {3: 5.0}])\ndef test_symfc_cutoff(ph_nacl: Phonopy, cutoff: Optional[dict]):\n    'Test symfc interface with cutoff distance.'\n    ph = ph_nacl\n    symfc_solver = SymfcFCSolver(ph.supercell, symmetry=ph.symmetry, options={'cutoff': cutoff}, log_level=1)\n    symfc_solver.compute_basis_set(orders=[2, 3])\n    basis_set_fc3 = symfc_solver.basis_set[3]\n    if (cutoff is None):\n        assert (basis_set_fc3.basis_set.shape == (786, 758))\n    else:\n        assert (basis_set_fc3.basis_set.shape == (80, 67))\n        nonzero_elems = symfc_solver.get_nonzero_atomic_indices_fc3()\n        assert (nonzero_elems is not None)\n        assert (nonzero_elems.size == (len(ph.supercell) ** 3))\n        assert (nonzero_elems.sum() == 21952)", "masked_code": "@pytest.mark.parametrize('cutoff', [None, {3: 5.0}])\ndef test_symfc_cutoff(ph_nacl: Phonopy, cutoff: Optional[dict]):\n    'Test symfc interface with cutoff distance.'\n    ph = ph_nacl\n    symfc_solver = SymfcFCSolver(ph.supercell, symmetry=ph.symmetry, options={'cutoff': cutoff}, log_level=1)\n    symfc_solver.compute_basis_set(orders=[2, 3])\n    basis_set_fc3 = symfc_solver.basis_set[3]\n    if (cutoff is None):\n        assert (basis_set_fc3.basis_set.shape == (786, 758))\n    else:\n        assert (basis_set_fc3.basis_set.shape == (80, 67))\n        nonzero_elems = symfc_solver.get_nonzero_atomic_indices_fc3()\n        assert (nonzero_elems is not None)\n        assert (nonzero_elems.size == '???')\n        assert (nonzero_elems.sum() == 21952)", "ground_truth": "(len(ph.supercell) ** 3)", "quality_analysis": {"complexity_score": 10, "left_complexity": 2, "right_complexity": 8, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_65", "reponame": "phonopy", "testpath": "test/interface/test_symfc.py", "testname": "test_symfc.py", "classname": null, "funcname": "test_symfc_cutoff", "imports": ["from __future__ import annotations", "from typing import Optional", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.force_constants import compact_fc_to_full_fc, full_fc_to_compact_fc", "from phonopy.interface.symfc import SymfcFCSolver, symmetrize_by_projector"], "code": "@pytest.mark.parametrize('cutoff', [None, {3: 5.0}])\ndef test_symfc_cutoff(ph_nacl: Phonopy, cutoff: Optional[dict]):\n    'Test symfc interface with cutoff distance.'\n    ph = ph_nacl\n    symfc_solver = SymfcFCSolver(ph.supercell, symmetry=ph.symmetry, options={'cutoff': cutoff}, log_level=1)\n    symfc_solver.compute_basis_set(orders=[2, 3])\n    basis_set_fc3 = symfc_solver.basis_set[3]\n    if (cutoff is None):\n        assert (basis_set_fc3.basis_set.shape == (786, 758))\n    else:\n        assert (basis_set_fc3.basis_set.shape == (80, 67))\n        nonzero_elems = symfc_solver.get_nonzero_atomic_indices_fc3()\n        assert (nonzero_elems is not None)\n        assert (nonzero_elems.size == (len(ph.supercell) ** 3))\n        assert (nonzero_elems.sum() == 21952)", "masked_code": "@pytest.mark.parametrize('cutoff', [None, {3: 5.0}])\ndef test_symfc_cutoff(ph_nacl: Phonopy, cutoff: Optional[dict]):\n    'Test symfc interface with cutoff distance.'\n    ph = ph_nacl\n    symfc_solver = SymfcFCSolver(ph.supercell, symmetry=ph.symmetry, options={'cutoff': cutoff}, log_level=1)\n    symfc_solver.compute_basis_set(orders=[2, 3])\n    basis_set_fc3 = symfc_solver.basis_set[3]\n    if (cutoff is None):\n        assert (basis_set_fc3.basis_set.shape == (786, 758))\n    else:\n        assert (basis_set_fc3.basis_set.shape == (80, 67))\n        nonzero_elems = symfc_solver.get_nonzero_atomic_indices_fc3()\n        assert (nonzero_elems is not None)\n        assert (nonzero_elems.size == (len(ph.supercell) ** 3))\n        assert (nonzero_elems.sum() == '???')", "ground_truth": "21952", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_66", "reponame": "phonopy", "testpath": "test/interface/test_symfc.py", "testname": "test_symfc.py", "classname": null, "funcname": "test_symmetrize_by_projector", "imports": ["from __future__ import annotations", "from typing import Optional", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.force_constants import compact_fc_to_full_fc, full_fc_to_compact_fc", "from phonopy.interface.symfc import SymfcFCSolver, symmetrize_by_projector"], "code": "def test_symmetrize_by_projector(ph_zr3n4_nofcsym: Phonopy, ph_zr3n4_nofcsym_compact_fc: Phonopy):\n    'Test symmetrization by projector.'\n    for (i, ph) in enumerate((ph_zr3n4_nofcsym, ph_zr3n4_nofcsym_compact_fc)):\n        fc_sym = symmetrize_by_projector(ph.supercell, ph.force_constants, 2, primitive=ph.primitive, log_level=2)\n        diff = (ph.force_constants - fc_sym)\n        assert (diff.max() == pytest.approx(0.001016, rel=1e-05))\n        if (i == 1):\n            fc_sym = compact_fc_to_full_fc(ph.primitive, fc_sym)\n        for (i, j, k) in list(np.ndindex((len(ph.supercell), 3, 3))):\n            assert (fc_sym[(:, i, j, k)].sum() == pytest.approx(0))\n            assert (fc_sym[(i, :, j, k)].sum() == pytest.approx(0))", "masked_code": "def test_symmetrize_by_projector(ph_zr3n4_nofcsym: Phonopy, ph_zr3n4_nofcsym_compact_fc: Phonopy):\n    'Test symmetrization by projector.'\n    for (i, ph) in enumerate((ph_zr3n4_nofcsym, ph_zr3n4_nofcsym_compact_fc)):\n        fc_sym = symmetrize_by_projector(ph.supercell, ph.force_constants, 2, primitive=ph.primitive, log_level=2)\n        diff = (ph.force_constants - fc_sym)\n        assert (diff.max() == '???')\n        if (i == 1):\n            fc_sym = compact_fc_to_full_fc(ph.primitive, fc_sym)\n        for (i, j, k) in list(np.ndindex((len(ph.supercell), 3, 3))):\n            assert (fc_sym[(:, i, j, k)].sum() == pytest.approx(0))\n            assert (fc_sym[(i, :, j, k)].sum() == pytest.approx(0))", "ground_truth": "pytest.approx(0.001016, rel=1e-05)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_67", "reponame": "phonopy", "testpath": "test/interface/test_symfc.py", "testname": "test_symfc.py", "classname": null, "funcname": "test_symmetrize_by_projector", "imports": ["from __future__ import annotations", "from typing import Optional", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.force_constants import compact_fc_to_full_fc, full_fc_to_compact_fc", "from phonopy.interface.symfc import SymfcFCSolver, symmetrize_by_projector"], "code": "def test_symmetrize_by_projector(ph_zr3n4_nofcsym: Phonopy, ph_zr3n4_nofcsym_compact_fc: Phonopy):\n    'Test symmetrization by projector.'\n    for (i, ph) in enumerate((ph_zr3n4_nofcsym, ph_zr3n4_nofcsym_compact_fc)):\n        fc_sym = symmetrize_by_projector(ph.supercell, ph.force_constants, 2, primitive=ph.primitive, log_level=2)\n        diff = (ph.force_constants - fc_sym)\n        assert (diff.max() == pytest.approx(0.001016, rel=1e-05))\n        if (i == 1):\n            fc_sym = compact_fc_to_full_fc(ph.primitive, fc_sym)\n        for (i, j, k) in list(np.ndindex((len(ph.supercell), 3, 3))):\n            assert (fc_sym[(:, i, j, k)].sum() == pytest.approx(0))\n            assert (fc_sym[(i, :, j, k)].sum() == pytest.approx(0))", "masked_code": "def test_symmetrize_by_projector(ph_zr3n4_nofcsym: Phonopy, ph_zr3n4_nofcsym_compact_fc: Phonopy):\n    'Test symmetrization by projector.'\n    for (i, ph) in enumerate((ph_zr3n4_nofcsym, ph_zr3n4_nofcsym_compact_fc)):\n        fc_sym = symmetrize_by_projector(ph.supercell, ph.force_constants, 2, primitive=ph.primitive, log_level=2)\n        diff = (ph.force_constants - fc_sym)\n        assert (diff.max() == pytest.approx(0.001016, rel=1e-05))\n        if (i == 1):\n            fc_sym = compact_fc_to_full_fc(ph.primitive, fc_sym)\n        for (i, j, k) in list(np.ndindex((len(ph.supercell), 3, 3))):\n            assert (fc_sym[(:, i, j, k)].sum() == '???')\n            assert (fc_sym[(i, :, j, k)].sum() == pytest.approx(0))", "ground_truth": "pytest.approx(0)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_68", "reponame": "phonopy", "testpath": "test/interface/test_symfc.py", "testname": "test_symfc.py", "classname": null, "funcname": "test_symmetrize_by_projector", "imports": ["from __future__ import annotations", "from typing import Optional", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.force_constants import compact_fc_to_full_fc, full_fc_to_compact_fc", "from phonopy.interface.symfc import SymfcFCSolver, symmetrize_by_projector"], "code": "def test_symmetrize_by_projector(ph_zr3n4_nofcsym: Phonopy, ph_zr3n4_nofcsym_compact_fc: Phonopy):\n    'Test symmetrization by projector.'\n    for (i, ph) in enumerate((ph_zr3n4_nofcsym, ph_zr3n4_nofcsym_compact_fc)):\n        fc_sym = symmetrize_by_projector(ph.supercell, ph.force_constants, 2, primitive=ph.primitive, log_level=2)\n        diff = (ph.force_constants - fc_sym)\n        assert (diff.max() == pytest.approx(0.001016, rel=1e-05))\n        if (i == 1):\n            fc_sym = compact_fc_to_full_fc(ph.primitive, fc_sym)\n        for (i, j, k) in list(np.ndindex((len(ph.supercell), 3, 3))):\n            assert (fc_sym[(:, i, j, k)].sum() == pytest.approx(0))\n            assert (fc_sym[(i, :, j, k)].sum() == pytest.approx(0))", "masked_code": "def test_symmetrize_by_projector(ph_zr3n4_nofcsym: Phonopy, ph_zr3n4_nofcsym_compact_fc: Phonopy):\n    'Test symmetrization by projector.'\n    for (i, ph) in enumerate((ph_zr3n4_nofcsym, ph_zr3n4_nofcsym_compact_fc)):\n        fc_sym = symmetrize_by_projector(ph.supercell, ph.force_constants, 2, primitive=ph.primitive, log_level=2)\n        diff = (ph.force_constants - fc_sym)\n        assert (diff.max() == pytest.approx(0.001016, rel=1e-05))\n        if (i == 1):\n            fc_sym = compact_fc_to_full_fc(ph.primitive, fc_sym)\n        for (i, j, k) in list(np.ndindex((len(ph.supercell), 3, 3))):\n            assert (fc_sym[(:, i, j, k)].sum() == pytest.approx(0))\n            assert (fc_sym[(i, :, j, k)].sum() == '???')", "ground_truth": "pytest.approx(0)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_69", "reponame": "phonopy", "testpath": "test/interface/test_symfc.py", "testname": "test_symfc.py", "classname": null, "funcname": "test_symmetrize_by_projector_with_inconsistent_p2s", "imports": ["from __future__ import annotations", "from typing import Optional", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.harmonic.force_constants import compact_fc_to_full_fc, full_fc_to_compact_fc", "from phonopy.interface.symfc import SymfcFCSolver, symmetrize_by_projector"], "code": "def test_symmetrize_by_projector_with_inconsistent_p2s(ph_tio2_nofcsym: Phonopy):\n    \"Test symmetrization by projector with special shape of compact fc.\\n\\n    This is not an ideal situation, but user might encounter it when a\\n    non-primitive cell is used as the phonopy's primitive cell.\\n\\n    \"\n    ph = ph_tio2_nofcsym\n    ph_copy = Phonopy(unitcell=ph.unitcell, supercell_matrix=ph.supercell_matrix)\n    fc = full_fc_to_compact_fc(ph_copy.primitive, ph.force_constants)\n    with pytest.warns(UserWarning, match='p2s_map of primitive cell does not match with p2s_map of symfc.'):\n        fc_sym = symmetrize_by_projector(ph_copy.supercell, fc, 2, primitive=ph_copy.primitive, log_level=2)\n    assert ((fc - fc_sym).max() == pytest.approx(0.001054, rel=1e-05))", "masked_code": "def test_symmetrize_by_projector_with_inconsistent_p2s(ph_tio2_nofcsym: Phonopy):\n    \"Test symmetrization by projector with special shape of compact fc.\\n\\n    This is not an ideal situation, but user might encounter it when a\\n    non-primitive cell is used as the phonopy's primitive cell.\\n\\n    \"\n    ph = ph_tio2_nofcsym\n    ph_copy = Phonopy(unitcell=ph.unitcell, supercell_matrix=ph.supercell_matrix)\n    fc = full_fc_to_compact_fc(ph_copy.primitive, ph.force_constants)\n    with pytest.warns(UserWarning, match='p2s_map of primitive cell does not match with p2s_map of symfc.'):\n        fc_sym = symmetrize_by_projector(ph_copy.supercell, fc, 2, primitive=ph_copy.primitive, log_level=2)\n    assert ((fc - fc_sym).max() == '???')", "ground_truth": "pytest.approx(0.001054, rel=1e-05)", "quality_analysis": {"complexity_score": 7, "left_complexity": 3, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_70", "reponame": "phonopy", "testpath": "test/interface/test_vasp.py", "testname": "test_vasp.py", "classname": null, "funcname": "test_get_vasp_structure_lines", "imports": ["import tarfile", "import tempfile", "from io import StringIO", "from pathlib import Path", "import numpy as np", "import pytest", "from phonopy.file_IO import parse_FORCE_SETS", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.interface.vasp import Vasprun, VasprunxmlExpat, get_vasp_structure_lines, parse_set_of_forces, read_vasp, read_vasp_from_strings, read_XDATCAR, write_XDATCAR"], "code": "@pytest.mark.parametrize('first_line_str, is_vasp4', [(None, True), (None, False), ('my_comment', True), ('my_comment', False)])\ndef test_get_vasp_structure_lines(helper_methods, is_vasp4, first_line_str):\n    'Test get_vasp_structure_lines (almost write_vasp).'\n    filename = (cwd / 'NaCl-vasp.yaml')\n    cell_ref = read_cell_yaml(filename)\n    lines = get_vasp_structure_lines(cell_ref, direct=True, is_vasp4=is_vasp4, first_line_str=first_line_str)\n    cell = read_vasp_from_strings('\\n'.join(lines))\n    helper_methods.compare_cells_with_order(cell, cell_ref)\n    if is_vasp4:\n        assert (lines[0] == 'Na Cl')\n    elif first_line_str:\n        assert (lines[0] == first_line_str)", "masked_code": "@pytest.mark.parametrize('first_line_str, is_vasp4', [(None, True), (None, False), ('my_comment', True), ('my_comment', False)])\ndef test_get_vasp_structure_lines(helper_methods, is_vasp4, first_line_str):\n    'Test get_vasp_structure_lines (almost write_vasp).'\n    filename = (cwd / 'NaCl-vasp.yaml')\n    cell_ref = read_cell_yaml(filename)\n    lines = get_vasp_structure_lines(cell_ref, direct=True, is_vasp4=is_vasp4, first_line_str=first_line_str)\n    cell = read_vasp_from_strings('\\n'.join(lines))\n    helper_methods.compare_cells_with_order(cell, cell_ref)\n    if is_vasp4:\n        assert (lines[0] == '???')\n    elif first_line_str:\n        assert (lines[0] == first_line_str)", "ground_truth": "'Na Cl'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_71", "reponame": "phonopy", "testpath": "test/interface/test_vasp.py", "testname": "test_vasp.py", "classname": null, "funcname": "test_get_vasp_structure_lines", "imports": ["import tarfile", "import tempfile", "from io import StringIO", "from pathlib import Path", "import numpy as np", "import pytest", "from phonopy.file_IO import parse_FORCE_SETS", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.interface.vasp import Vasprun, VasprunxmlExpat, get_vasp_structure_lines, parse_set_of_forces, read_vasp, read_vasp_from_strings, read_XDATCAR, write_XDATCAR"], "code": "@pytest.mark.parametrize('first_line_str, is_vasp4', [(None, True), (None, False), ('my_comment', True), ('my_comment', False)])\ndef test_get_vasp_structure_lines(helper_methods, is_vasp4, first_line_str):\n    'Test get_vasp_structure_lines (almost write_vasp).'\n    filename = (cwd / 'NaCl-vasp.yaml')\n    cell_ref = read_cell_yaml(filename)\n    lines = get_vasp_structure_lines(cell_ref, direct=True, is_vasp4=is_vasp4, first_line_str=first_line_str)\n    cell = read_vasp_from_strings('\\n'.join(lines))\n    helper_methods.compare_cells_with_order(cell, cell_ref)\n    if is_vasp4:\n        assert (lines[0] == 'Na Cl')\n    elif first_line_str:\n        assert (lines[0] == first_line_str)", "masked_code": "@pytest.mark.parametrize('first_line_str, is_vasp4', [(None, True), (None, False), ('my_comment', True), ('my_comment', False)])\ndef test_get_vasp_structure_lines(helper_methods, is_vasp4, first_line_str):\n    'Test get_vasp_structure_lines (almost write_vasp).'\n    filename = (cwd / 'NaCl-vasp.yaml')\n    cell_ref = read_cell_yaml(filename)\n    lines = get_vasp_structure_lines(cell_ref, direct=True, is_vasp4=is_vasp4, first_line_str=first_line_str)\n    cell = read_vasp_from_strings('\\n'.join(lines))\n    helper_methods.compare_cells_with_order(cell, cell_ref)\n    if is_vasp4:\n        assert (lines[0] == 'Na Cl')\n    elif first_line_str:\n        assert (lines[0] == '???')", "ground_truth": "first_line_str", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_72", "reponame": "phonopy", "testpath": "test/interface/test_vasp.py", "testname": "test_vasp.py", "classname": null, "funcname": "test_VasprunxmlExpat", "imports": ["import tarfile", "import tempfile", "from io import StringIO", "from pathlib import Path", "import numpy as np", "import pytest", "from phonopy.file_IO import parse_FORCE_SETS", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.interface.vasp import Vasprun, VasprunxmlExpat, get_vasp_structure_lines, parse_set_of_forces, read_vasp, read_vasp_from_strings, read_XDATCAR, write_XDATCAR"], "code": "def test_VasprunxmlExpat():\n    'Test VasprunxmlExpat.'\n    filename_vasprun = (cwd / 'vasprun.xml.tar.bz2')\n    _tar = tarfile.open(filename_vasprun)\n    for member in _tar.getmembers():\n        vasprun = VasprunxmlExpat(_tar.extractfile(member))\n        vasprun.parse()\n        np.testing.assert_equal(vasprun.fft_grid, [64, 64, 64])\n        np.testing.assert_equal(vasprun.fft_fine_grid, [128, 128, 128])\n        assert (vasprun.efermi is None)\n        assert (vasprun.symbols == ((['Na'] * 32) + (['Cl'] * 32)))\n        np.testing.assert_almost_equal(vasprun.NELECT, 448)\n        np.testing.assert_almost_equal(vasprun.volume, 1473.99433936)\n        break", "masked_code": "def test_VasprunxmlExpat():\n    'Test VasprunxmlExpat.'\n    filename_vasprun = (cwd / 'vasprun.xml.tar.bz2')\n    _tar = tarfile.open(filename_vasprun)\n    for member in _tar.getmembers():\n        vasprun = VasprunxmlExpat(_tar.extractfile(member))\n        vasprun.parse()\n        np.testing.assert_equal(vasprun.fft_grid, [64, 64, 64])\n        np.testing.assert_equal(vasprun.fft_fine_grid, [128, 128, 128])\n        assert (vasprun.efermi is None)\n        assert (vasprun.symbols == '???')\n        np.testing.assert_almost_equal(vasprun.NELECT, 448)\n        np.testing.assert_almost_equal(vasprun.volume, 1473.99433936)\n        break", "ground_truth": "((['Na'] * 32) + (['Cl'] * 32))", "quality_analysis": {"complexity_score": 16, "left_complexity": 2, "right_complexity": 14, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_73", "reponame": "phonopy", "testpath": "test/phonon/test_band_structure.py", "testname": "test_band_structure.py", "classname": null, "funcname": "test_band_structure", "imports": ["from __future__ import annotations", "import pathlib", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.phonon.band_structure import get_band_qpoints"], "code": "def test_band_structure(ph_nacl: Phonopy):\n    'Test band structure calculation by NaCl.'\n    ph_nacl.run_band_structure(_get_band_qpoints(), with_group_velocities=False, is_band_connection=False)\n    freqs = ph_nacl.get_band_structure_dict()['frequencies']\n    assert (len(freqs) == 3)\n    assert (freqs[0].shape == (11, 6))\n    np.testing.assert_allclose(freqs[0][0], [0, 0, 0, 4.61643516, 4.61643516, 7.39632718], atol=0.001)", "masked_code": "def test_band_structure(ph_nacl: Phonopy):\n    'Test band structure calculation by NaCl.'\n    ph_nacl.run_band_structure(_get_band_qpoints(), with_group_velocities=False, is_band_connection=False)\n    freqs = ph_nacl.get_band_structure_dict()['frequencies']\n    assert (len(freqs) == '???')\n    assert (freqs[0].shape == (11, 6))\n    np.testing.assert_allclose(freqs[0][0], [0, 0, 0, 4.61643516, 4.61643516, 7.39632718], atol=0.001)", "ground_truth": "3", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_74", "reponame": "phonopy", "testpath": "test/phonon/test_band_structure.py", "testname": "test_band_structure.py", "classname": null, "funcname": "test_band_structure", "imports": ["from __future__ import annotations", "import pathlib", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.phonon.band_structure import get_band_qpoints"], "code": "def test_band_structure(ph_nacl: Phonopy):\n    'Test band structure calculation by NaCl.'\n    ph_nacl.run_band_structure(_get_band_qpoints(), with_group_velocities=False, is_band_connection=False)\n    freqs = ph_nacl.get_band_structure_dict()['frequencies']\n    assert (len(freqs) == 3)\n    assert (freqs[0].shape == (11, 6))\n    np.testing.assert_allclose(freqs[0][0], [0, 0, 0, 4.61643516, 4.61643516, 7.39632718], atol=0.001)", "masked_code": "def test_band_structure(ph_nacl: Phonopy):\n    'Test band structure calculation by NaCl.'\n    ph_nacl.run_band_structure(_get_band_qpoints(), with_group_velocities=False, is_band_connection=False)\n    freqs = ph_nacl.get_band_structure_dict()['frequencies']\n    assert (len(freqs) == 3)\n    assert (freqs[0].shape == '???')\n    np.testing.assert_allclose(freqs[0][0], [0, 0, 0, 4.61643516, 4.61643516, 7.39632718], atol=0.001)", "ground_truth": "(11, 6)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_75", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt03_P2", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt03_P2():\n    'Test of pt03_P2.'\n    data = _load_data(chars_P2)\n    phonon = _get_phonon('P2', [3, 2, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'C2']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt03_P2():\n    'Test of pt03_P2.'\n    data = _load_data(chars_P2)\n    phonon = _get_phonon('P2', [3, 2, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'C2'])", "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_76", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt04_Pc", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt04_Pc():\n    'Test of pt04_Pc.'\n    data = _load_data(chars_Pc)\n    phonon = _get_phonon('Pc', [2, 2, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0.5, 0]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'sgh']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt04_Pc():\n    'Test of pt04_Pc.'\n    data = _load_data(chars_Pc)\n    phonon = _get_phonon('Pc', [2, 2, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0.5, 0]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'sgh'])", "quality_analysis": {"complexity_score": 12, "left_complexity": 5, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_77", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt06_P222_1", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt06_P222_1():\n    'Test of pt06_P222_1.'\n    data = _load_data(chars_P222_1)\n    phonon = _get_phonon('P222_1', [2, 2, 1], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5], [0.5, 0.5, 0], [0.5, 0, 0.5], [0, 0.5, 0.5], [0.5, 0.5, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'C2', 'C2x', 'C2y']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt06_P222_1():\n    'Test of pt06_P222_1.'\n    data = _load_data(chars_P222_1)\n    phonon = _get_phonon('P222_1', [2, 2, 1], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5], [0.5, 0.5, 0], [0.5, 0, 0.5], [0, 0.5, 0.5], [0.5, 0.5, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'C2', 'C2x', 'C2y'])", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_78", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt07_Amm2", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt07_Amm2():\n    'Test of pt07_Amm2.'\n    data = _load_data(chars_Amm2)\n    phonon = _get_phonon('Amm2', [3, 2, 2], [[1, 0, 0], [0, 0.5, (- 0.5)], [0, 0.5, 0.5]])\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, (- 0.5)], [0.5, 0, (- 0.5)], [0.5, 0, 0], [0, 0.25, (- 0.25)], [0.5, 0.25, (- 0.25)]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'C2', 'sgvyz', 'sgvxz']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt07_Amm2():\n    'Test of pt07_Amm2.'\n    data = _load_data(chars_Amm2)\n    phonon = _get_phonon('Amm2', [3, 2, 2], [[1, 0, 0], [0, 0.5, (- 0.5)], [0, 0.5, 0.5]])\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, (- 0.5)], [0.5, 0, (- 0.5)], [0.5, 0, 0], [0, 0.25, (- 0.25)], [0.5, 0.25, (- 0.25)]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'C2', 'sgvyz', 'sgvxz'])", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_79", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt09_P4_1", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt09_P4_1():\n    'Test of pt09_P4_1.'\n    data = _load_data(chars_P4_1)\n    phonon = _get_phonon('P4_1', [2, 2, 1], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'C4', 'C2', 'C4']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt09_P4_1():\n    'Test of pt09_P4_1.'\n    data = _load_data(chars_P4_1)\n    phonon = _get_phonon('P4_1', [2, 2, 1], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'C4', 'C2', 'C4'])", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_80", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt10_Pbar4", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt10_Pbar4():\n    'Test of pt10_Pbar4.'\n    data = _load_data(chars_Pbar4)\n    phonon = _get_phonon('P-4', [1, 1, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [0.5, 0.5, 0], [0.5, 0.5, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'S4', 'C2', 'S4']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt10_Pbar4():\n    'Test of pt10_Pbar4.'\n    data = _load_data(chars_Pbar4)\n    phonon = _get_phonon('P-4', [1, 1, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [0.5, 0.5, 0], [0.5, 0.5, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'S4', 'C2', 'S4'])", "quality_analysis": {"complexity_score": 14, "left_complexity": 5, "right_complexity": 9, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_81", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt11_I4_1a", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt11_I4_1a():\n    'Test of pt11_I4_1a.'\n    data = _load_data(chars_I4_1a)\n    phonon = _get_phonon('I4_1a', [2, 2, 1], (np.array([[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]]) * 0.5))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0.5, (- 0.5)], [0, 0, 0.5], [0.25, 0.25, 0.25], [0, 0.5, 0]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'C4', 'C2', 'C4', 'i', 'S4', 'sgh', 'S4']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt11_I4_1a():\n    'Test of pt11_I4_1a.'\n    data = _load_data(chars_I4_1a)\n    phonon = _get_phonon('I4_1a', [2, 2, 1], (np.array([[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]]) * 0.5))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0.5, (- 0.5)], [0, 0, 0.5], [0.25, 0.25, 0.25], [0, 0.5, 0]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'C4', 'C2', 'C4', 'i', 'S4', 'sgh', 'S4'])", "quality_analysis": {"complexity_score": 18, "left_complexity": 5, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_82", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt13_P4mm", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt13_P4mm():\n    'Test of pt13_P4mm.'\n    data = _load_data(chars_P4mm)\n    phonon = _get_phonon('P4mm', [3, 3, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [0.5, 0.5, 0.5], [0, 0.5, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'C4', 'C2', 'C4', 'sgv', 'sgd', 'sgv', 'sgd']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt13_P4mm():\n    'Test of pt13_P4mm.'\n    data = _load_data(chars_P4mm)\n    phonon = _get_phonon('P4mm', [3, 3, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [0.5, 0.5, 0.5], [0, 0.5, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'C4', 'C2', 'C4', 'sgv', 'sgd', 'sgv', 'sgd'])", "quality_analysis": {"complexity_score": 18, "left_complexity": 5, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_83", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt14_Pbar42_1m", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt14_Pbar42_1m():\n    'Test of pt14_Pbar42_1m.'\n    data = _load_data(chars_Pbar42_1m)\n    phonon = _get_phonon('P-42_1m', [2, 2, 3], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0.5, 0.5], [0, 0, 0.5], [0.5, 0.5, 0], [0, 0.5, 0], [0, 0.5, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'S4', 'C2z', 'S4', \"C2'\", 'sgd', \"C2'\", 'sgd']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt14_Pbar42_1m():\n    'Test of pt14_Pbar42_1m.'\n    data = _load_data(chars_Pbar42_1m)\n    phonon = _get_phonon('P-42_1m', [2, 2, 3], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0.5, 0.5], [0, 0, 0.5], [0.5, 0.5, 0], [0, 0.5, 0], [0, 0.5, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'S4', 'C2z', 'S4', \"C2'\", 'sgd', \"C2'\", 'sgd'])", "quality_analysis": {"complexity_score": 18, "left_complexity": 5, "right_complexity": 13, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_84", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt19_P3m1", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt19_P3m1():\n    'Test of pt19_P3m1.'\n    data = _load_data(chars_P3m1)\n    phonon = _get_phonon('P3m1', [4, 4, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), (1 / 2)]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'C3', 'C3', 'sgv', 'sgv', 'sgv']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt19_P3m1():\n    'Test of pt19_P3m1.'\n    data = _load_data(chars_P3m1)\n    phonon = _get_phonon('P3m1', [4, 4, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), (1 / 2)]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'C3', 'C3', 'sgv', 'sgv', 'sgv'])", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_85", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt19_P31m", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt19_P31m():\n    'Test of pt19_P31m.'\n    data = _load_data(chars_P31m)\n    phonon = _get_phonon('P31m', [1, 1, 3], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), (1 / 2)]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'C3', 'C3', 'sgv', 'sgv', 'sgv']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt19_P31m():\n    'Test of pt19_P31m.'\n    data = _load_data(chars_P31m)\n    phonon = _get_phonon('P31m', [1, 1, 3], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), (1 / 2)]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'C3', 'C3', 'sgv', 'sgv', 'sgv'])", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_86", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt20_Pbar3m1", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt20_Pbar3m1():\n    'Test of pt20_Pbar3m1.'\n    data = _load_data(chars_Pbar3m1)\n    phonon = _get_phonon('P-3m1', [3, 3, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), 0], [(1.0 / 3), (1.0 / 3), 0.5], [0.5, 0, 0], [0.5, 0, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'i', 'C3', 'S6', 'C3', 'S6', \"C2'\", 'sgd', \"C2'\", 'sgd', \"C2'\", 'sgd']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt20_Pbar3m1():\n    'Test of pt20_Pbar3m1.'\n    data = _load_data(chars_Pbar3m1)\n    phonon = _get_phonon('P-3m1', [3, 3, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), 0], [(1.0 / 3), (1.0 / 3), 0.5], [0.5, 0, 0], [0.5, 0, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'i', 'C3', 'S6', 'C3', 'S6', \"C2'\", 'sgd', \"C2'\", 'sgd', \"C2'\", 'sgd'])", "quality_analysis": {"complexity_score": 22, "left_complexity": 5, "right_complexity": 17, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_87", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt21_P6", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt21_P6():\n    'Test of pt21_P6.'\n    data = _load_data(chars_P6)\n    phonon = _get_phonon('P6', [2, 2, 1], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'C6', 'C3', 'C2', 'C3', 'C6']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt21_P6():\n    'Test of pt21_P6.'\n    data = _load_data(chars_P6)\n    phonon = _get_phonon('P6', [2, 2, 1], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'C6', 'C3', 'C2', 'C3', 'C6'])", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_88", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt22_Pbar6", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt22_Pbar6():\n    'Test of pt22_Pbar6.'\n    data = _load_data(chars_Pbar6)\n    phonon = _get_phonon('P-6', [1, 1, 3], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(2.0 / 3), ((- 1.0) / 3), 0], [(2.0 / 3), ((- 1.0) / 3), 0.5], [(1.0 / 3), (1.0 / 3), 0], [(1.0 / 3), (1.0 / 3), 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'S3', 'C3', 'sgh', 'C3', 'S3']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt22_Pbar6():\n    'Test of pt22_Pbar6.'\n    data = _load_data(chars_Pbar6)\n    phonon = _get_phonon('P-6', [1, 1, 3], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(2.0 / 3), ((- 1.0) / 3), 0], [(2.0 / 3), ((- 1.0) / 3), 0.5], [(1.0 / 3), (1.0 / 3), 0], [(1.0 / 3), (1.0 / 3), 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'S3', 'C3', 'sgh', 'C3', 'S3'])", "quality_analysis": {"complexity_score": 16, "left_complexity": 5, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_89", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt24_P6_222", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt24_P6_222():\n    'Test of pt24_P6_222.'\n    data = _load_data(chars_P6_222)\n    phonon = _get_phonon('P6_222', [2, 2, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), 0], [(1.0 / 3), (1.0 / 3), 0.5], [0.5, 0, 0], [0.5, 0, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'C6', 'C3', 'C2', 'C3', 'C6', \"C2''\", \"C2'\", \"C2''\", \"C2'\", \"C2''\", \"C2'\"]))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt24_P6_222():\n    'Test of pt24_P6_222.'\n    data = _load_data(chars_P6_222)\n    phonon = _get_phonon('P6_222', [2, 2, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), 0], [(1.0 / 3), (1.0 / 3), 0.5], [0.5, 0, 0], [0.5, 0, 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'C6', 'C3', 'C2', 'C3', 'C6', \"C2''\", \"C2'\", \"C2''\", \"C2'\", \"C2''\", \"C2'\"])", "quality_analysis": {"complexity_score": 22, "left_complexity": 5, "right_complexity": 17, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_90", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt26_Pbar6m2", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt26_Pbar6m2():\n    'Test of pt26_Pbar6m2.'\n    data = _load_data(chars_Pbar6m2)\n    phonon = _get_phonon('P-6m2', [2, 2, 3], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), 0], [(1.0 / 3), (1.0 / 3), 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'S3', 'C3', 'sgh', 'C3', 'S3', \"C'2\", 'sgv', \"C'2\", 'sgv', \"C'2\", 'sgv']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt26_Pbar6m2():\n    'Test of pt26_Pbar6m2.'\n    data = _load_data(chars_Pbar6m2)\n    phonon = _get_phonon('P-6m2', [2, 2, 3], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), 0], [(1.0 / 3), (1.0 / 3), 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'S3', 'C3', 'sgh', 'C3', 'S3', \"C'2\", 'sgv', \"C'2\", 'sgv', \"C'2\", 'sgv'])", "quality_analysis": {"complexity_score": 22, "left_complexity": 5, "right_complexity": 17, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_91", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt26_Pbar62m", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt26_Pbar62m():\n    'Test of pt26_Pbar62m.'\n    data = _load_data(chars_Pbar62m)\n    phonon = _get_phonon('P-62m', [1, 1, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0], degeneracy_tolerance=0.0001)\n    chars = phonon.irreps.characters\n    _show_chars(chars)\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), 0], [(1.0 / 3), (1.0 / 3), 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'S3', 'C3', 'sgh', 'C3', 'S3', \"C'2\", 'sgv', \"C'2\", 'sgv', \"C'2\", 'sgv']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt26_Pbar62m():\n    'Test of pt26_Pbar62m.'\n    data = _load_data(chars_Pbar62m)\n    phonon = _get_phonon('P-62m', [1, 1, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0], degeneracy_tolerance=0.0001)\n    chars = phonon.irreps.characters\n    _show_chars(chars)\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0, 0, 0.5], [(1.0 / 3), (1.0 / 3), 0], [(1.0 / 3), (1.0 / 3), 0.5]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'S3', 'C3', 'sgh', 'C3', 'S3', \"C'2\", 'sgv', \"C'2\", 'sgv', \"C'2\", 'sgv'])", "quality_analysis": {"complexity_score": 22, "left_complexity": 5, "right_complexity": 17, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_92", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt28_P2_13", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt28_P2_13():\n    'Test of pt28_P2_13.'\n    data = _load_data(chars_P2_13)\n    phonon = _get_phonon('P2_13', [2, 2, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0.5, 0.5], [0.5, 0.5, 0], [0, 0.5, 0]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'C2', 'C2', 'C2', 'C3', 'C3', 'C3', 'C3', 'C3', 'C3', 'C3', 'C3']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt28_P2_13():\n    'Test of pt28_P2_13.'\n    data = _load_data(chars_P2_13)\n    phonon = _get_phonon('P2_13', [2, 2, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0.5, 0.5], [0.5, 0.5, 0], [0, 0.5, 0]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'C2', 'C2', 'C2', 'C3', 'C3', 'C3', 'C3', 'C3', 'C3', 'C3', 'C3'])", "quality_analysis": {"complexity_score": 22, "left_complexity": 5, "right_complexity": 17, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_93", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt29_Pabar3", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt29_Pabar3():\n    'Test of pt29_Pabar3.'\n    data = _load_data(chars_Pabar3)\n    phonon = _get_phonon('Pa-3', [2, 2, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0.5, 0.5], [0.5, 0.5, 0], [0, 0.5, 0]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'i', 'C2', 'sgh', 'C2', 'sgh', 'C2', 'sgh', 'C3', 'S6', 'C3', 'S6', 'C3', 'S6', 'C3', 'S6', 'C3', 'S6', 'C3', 'S6', 'C3', 'S6', 'C3', 'S6']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt29_Pabar3():\n    'Test of pt29_Pabar3.'\n    data = _load_data(chars_Pabar3)\n    phonon = _get_phonon('Pa-3', [2, 2, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0.5, 0.5], [0.5, 0.5, 0], [0, 0.5, 0]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'i', 'C2', 'sgh', 'C2', 'sgh', 'C2', 'sgh', 'C3', 'S6', 'C3', 'S6', 'C3', 'S6', 'C3', 'S6', 'C3', 'S6', 'C3', 'S6', 'C3', 'S6', 'C3', 'S6'])", "quality_analysis": {"complexity_score": 34, "left_complexity": 5, "right_complexity": 29, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_94", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt30_P4_332", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt30_P4_332():\n    'Test of pt30_P4_332.'\n    data = _load_data(chars_P4_332)\n    phonon = _get_phonon('P4_332', [1, 1, 1], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0.5, 0.5], [0.5, 0.5, 0], [0, 0.5, 0]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'C4', 'C2', 'C4', 'C2', \"C2'\", 'C2', \"C2'\", 'C3', \"C2'\", 'C3', 'C4', 'C3', \"C2'\", 'C3', 'C4', 'C3', 'C4', 'C3', \"C2'\", 'C3', \"C2'\", 'C3', 'C4']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt30_P4_332():\n    'Test of pt30_P4_332.'\n    data = _load_data(chars_P4_332)\n    phonon = _get_phonon('P4_332', [1, 1, 1], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0.5, 0.5], [0.5, 0.5, 0], [0, 0.5, 0]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'C4', 'C2', 'C4', 'C2', \"C2'\", 'C2', \"C2'\", 'C3', \"C2'\", 'C3', 'C4', 'C3', \"C2'\", 'C3', 'C4', 'C3', 'C4', 'C3', \"C2'\", 'C3', \"C2'\", 'C3', 'C4'])", "quality_analysis": {"complexity_score": 34, "left_complexity": 5, "right_complexity": 29, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_95", "reponame": "phonopy", "testpath": "test/phonon/test_irreps.py", "testname": "test_irreps.py", "classname": null, "funcname": "test_pt31_Pbar43m", "imports": ["from __future__ import annotations", "import os", "from io import StringIO", "import numpy as np", "import phonopy", "from phonopy import Phonopy", "from phonopy.interface.vasp import read_vasp"], "code": "def test_pt31_Pbar43m():\n    'Test of pt31_Pbar43m.'\n    data = _load_data(chars_Pbar43m)\n    phonon = _get_phonon('P-43m', [2, 2, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0.5, 0.5], [0.5, 0.5, 0], [0, 0.5, 0]]\n    assert (set(phonon.irreps.rotation_symbols) == set(['E', 'S4', 'C2', 'S4', 'C2', 'sgd', 'C2', 'sgd', 'C3', 'sgd', 'C3', 'S4', 'C3', 'sgd', 'C3', 'S4', 'C3', 'S4', 'C3', 'sgd', 'C3', 'sgd', 'C3', 'S4']))\n    _check_char_sum(phonon, qpoints)", "masked_code": "def test_pt31_Pbar43m():\n    'Test of pt31_Pbar43m.'\n    data = _load_data(chars_Pbar43m)\n    phonon = _get_phonon('P-43m', [2, 2, 2], np.eye(3))\n    phonon.set_irreps([0, 0, 0])\n    chars = phonon.irreps.characters\n    np.testing.assert_allclose(chars, data, atol=1e-05)\n    qpoints = [[0.5, 0.5, 0.5], [0.5, 0.5, 0], [0, 0.5, 0]]\n    assert (set(phonon.irreps.rotation_symbols) == '???')\n    _check_char_sum(phonon, qpoints)", "ground_truth": "set(['E', 'S4', 'C2', 'S4', 'C2', 'sgd', 'C2', 'sgd', 'C3', 'sgd', 'C3', 'S4', 'C3', 'sgd', 'C3', 'S4', 'C3', 'S4', 'C3', 'sgd', 'C3', 'sgd', 'C3', 'S4'])", "quality_analysis": {"complexity_score": 34, "left_complexity": 5, "right_complexity": 29, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_96", "reponame": "phonopy", "testpath": "test/phonon/test_random_displacements.py", "testname": "test_random_displacements.py", "classname": null, "funcname": "test_random_displacements_all_atoms_TiPN3_max_distance", "imports": ["import os", "from copy import deepcopy", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.phonon.random_displacements import RandomDisplacements"], "code": "def test_random_displacements_all_atoms_TiPN3_max_distance(ph_tipn3):\n    'Test max_distance.'\n    rd = _get_random_displacements_all_atoms_TiPN3(ph_tipn3)\n    n_gt_max = (np.linalg.norm(rd.u.reshape((- 1), 3), axis=1) > 0.2).sum()\n    assert (n_gt_max == 5)\n    rd = _get_random_displacements_all_atoms_TiPN3(ph_tipn3, max_distance=0.2)\n    distances = np.linalg.norm(rd.u.reshape((- 1), 3), axis=1)\n    distances_gt_max = np.extract((distances > (0.2 - 1e-05)), distances)\n    assert (len(distances_gt_max) == 5)\n    np.testing.assert_almost_equal(distances_gt_max, 0.2)", "masked_code": "def test_random_displacements_all_atoms_TiPN3_max_distance(ph_tipn3):\n    'Test max_distance.'\n    rd = _get_random_displacements_all_atoms_TiPN3(ph_tipn3)\n    n_gt_max = (np.linalg.norm(rd.u.reshape((- 1), 3), axis=1) > 0.2).sum()\n    assert (n_gt_max == 5)\n    rd = _get_random_displacements_all_atoms_TiPN3(ph_tipn3, max_distance=0.2)\n    distances = np.linalg.norm(rd.u.reshape((- 1), 3), axis=1)\n    distances_gt_max = np.extract((distances > (0.2 - 1e-05)), distances)\n    assert (len(distances_gt_max) == '???')\n    np.testing.assert_almost_equal(distances_gt_max, 0.2)", "ground_truth": "5", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_97", "reponame": "phonopy", "testpath": "test/phonon/test_random_displacements.py", "testname": "test_random_displacements.py", "classname": null, "funcname": "test_tio2_random_disp_plusminus", "imports": ["import os", "from copy import deepcopy", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.phonon.random_displacements import RandomDisplacements"], "code": "@pytest.mark.parametrize('is_plusminus', [True, False])\ndef test_tio2_random_disp_plusminus(ph_tio2: Phonopy, is_plusminus: bool):\n    'Test random plus-minus displacements of TiO2.\\n\\n    Note\\n    ----\\n    Displacements of last 4 supercells are minus of those of first 4 supercells.\\n\\n    '\n    dataset = deepcopy(ph_tio2.dataset)\n    disp_ref = [[0, 0.01, 0.0, 0.0], [0, 0.0, 0.01, 0.0], [0, 0.0, 0.0, 0.01], [0, 0.0, 0.0, (- 0.01)], [72, 0.01, 0.0, 0.0], [72, 0.0, 0.0, 0.01]]\n    np.testing.assert_allclose(ph_tio2.displacements, disp_ref, atol=1e-08)\n    ph_tio2.generate_displacements(number_of_snapshots=4, distance=0.03, is_plusminus=is_plusminus, temperature=300)\n    d = ph_tio2.displacements\n    if is_plusminus:\n        assert (len(d) == 8)\n        np.testing.assert_allclose(d[:4], (- d[4:]), atol=1e-08)\n    else:\n        assert (len(d) == 4)\n    ph_tio2.dataset = dataset", "masked_code": "@pytest.mark.parametrize('is_plusminus', [True, False])\ndef test_tio2_random_disp_plusminus(ph_tio2: Phonopy, is_plusminus: bool):\n    'Test random plus-minus displacements of TiO2.\\n\\n    Note\\n    ----\\n    Displacements of last 4 supercells are minus of those of first 4 supercells.\\n\\n    '\n    dataset = deepcopy(ph_tio2.dataset)\n    disp_ref = [[0, 0.01, 0.0, 0.0], [0, 0.0, 0.01, 0.0], [0, 0.0, 0.0, 0.01], [0, 0.0, 0.0, (- 0.01)], [72, 0.01, 0.0, 0.0], [72, 0.0, 0.0, 0.01]]\n    np.testing.assert_allclose(ph_tio2.displacements, disp_ref, atol=1e-08)\n    ph_tio2.generate_displacements(number_of_snapshots=4, distance=0.03, is_plusminus=is_plusminus, temperature=300)\n    d = ph_tio2.displacements\n    if is_plusminus:\n        assert (len(d) == '???')\n        np.testing.assert_allclose(d[:4], (- d[4:]), atol=1e-08)\n    else:\n        assert (len(d) == 4)\n    ph_tio2.dataset = dataset", "ground_truth": "8", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_98", "reponame": "phonopy", "testpath": "test/phonon/test_random_displacements.py", "testname": "test_random_displacements.py", "classname": null, "funcname": "test_tio2_random_disp_plusminus", "imports": ["import os", "from copy import deepcopy", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.phonon.random_displacements import RandomDisplacements"], "code": "@pytest.mark.parametrize('is_plusminus', [True, False])\ndef test_tio2_random_disp_plusminus(ph_tio2: Phonopy, is_plusminus: bool):\n    'Test random plus-minus displacements of TiO2.\\n\\n    Note\\n    ----\\n    Displacements of last 4 supercells are minus of those of first 4 supercells.\\n\\n    '\n    dataset = deepcopy(ph_tio2.dataset)\n    disp_ref = [[0, 0.01, 0.0, 0.0], [0, 0.0, 0.01, 0.0], [0, 0.0, 0.0, 0.01], [0, 0.0, 0.0, (- 0.01)], [72, 0.01, 0.0, 0.0], [72, 0.0, 0.0, 0.01]]\n    np.testing.assert_allclose(ph_tio2.displacements, disp_ref, atol=1e-08)\n    ph_tio2.generate_displacements(number_of_snapshots=4, distance=0.03, is_plusminus=is_plusminus, temperature=300)\n    d = ph_tio2.displacements\n    if is_plusminus:\n        assert (len(d) == 8)\n        np.testing.assert_allclose(d[:4], (- d[4:]), atol=1e-08)\n    else:\n        assert (len(d) == 4)\n    ph_tio2.dataset = dataset", "masked_code": "@pytest.mark.parametrize('is_plusminus', [True, False])\ndef test_tio2_random_disp_plusminus(ph_tio2: Phonopy, is_plusminus: bool):\n    'Test random plus-minus displacements of TiO2.\\n\\n    Note\\n    ----\\n    Displacements of last 4 supercells are minus of those of first 4 supercells.\\n\\n    '\n    dataset = deepcopy(ph_tio2.dataset)\n    disp_ref = [[0, 0.01, 0.0, 0.0], [0, 0.0, 0.01, 0.0], [0, 0.0, 0.0, 0.01], [0, 0.0, 0.0, (- 0.01)], [72, 0.01, 0.0, 0.0], [72, 0.0, 0.0, 0.01]]\n    np.testing.assert_allclose(ph_tio2.displacements, disp_ref, atol=1e-08)\n    ph_tio2.generate_displacements(number_of_snapshots=4, distance=0.03, is_plusminus=is_plusminus, temperature=300)\n    d = ph_tio2.displacements\n    if is_plusminus:\n        assert (len(d) == 8)\n        np.testing.assert_allclose(d[:4], (- d[4:]), atol=1e-08)\n    else:\n        assert (len(d) == '???')\n    ph_tio2.dataset = dataset", "ground_truth": "4", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_99", "reponame": "phonopy", "testpath": "test/phonopy_load/test_phonopy_load.py", "testname": "test_phonopy_load.py", "classname": null, "funcname": "test_unit_conversion_factor", "imports": ["from pathlib import Path", "import pytest", "import phonopy"], "code": "def test_unit_conversion_factor():\n    'Test phonopy_load with phonopy_params.yaml.'\n    ph = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), produce_fc=False, log_level=2)\n    assert (ph.calculator is None)\n    assert (ph.unit_conversion_factor == pytest.approx(15.6333023))\n    with pytest.warns(DeprecationWarning):\n        ph = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), factor=100, produce_fc=False, log_level=2)\n        assert (ph.unit_conversion_factor == pytest.approx(100))", "masked_code": "def test_unit_conversion_factor():\n    'Test phonopy_load with phonopy_params.yaml.'\n    ph = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), produce_fc=False, log_level=2)\n    assert (ph.calculator is None)\n    assert (ph.unit_conversion_factor == '???')\n    with pytest.warns(DeprecationWarning):\n        ph = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), factor=100, produce_fc=False, log_level=2)\n        assert (ph.unit_conversion_factor == pytest.approx(100))", "ground_truth": "pytest.approx(15.6333023)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_100", "reponame": "phonopy", "testpath": "test/phonopy_load/test_phonopy_load.py", "testname": "test_phonopy_load.py", "classname": null, "funcname": "test_unit_conversion_factor", "imports": ["from pathlib import Path", "import pytest", "import phonopy"], "code": "def test_unit_conversion_factor():\n    'Test phonopy_load with phonopy_params.yaml.'\n    ph = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), produce_fc=False, log_level=2)\n    assert (ph.calculator is None)\n    assert (ph.unit_conversion_factor == pytest.approx(15.6333023))\n    with pytest.warns(DeprecationWarning):\n        ph = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), factor=100, produce_fc=False, log_level=2)\n        assert (ph.unit_conversion_factor == pytest.approx(100))", "masked_code": "def test_unit_conversion_factor():\n    'Test phonopy_load with phonopy_params.yaml.'\n    ph = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), produce_fc=False, log_level=2)\n    assert (ph.calculator is None)\n    assert (ph.unit_conversion_factor == pytest.approx(15.6333023))\n    with pytest.warns(DeprecationWarning):\n        ph = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-fd.yaml.xz'), factor=100, produce_fc=False, log_level=2)\n        assert (ph.unit_conversion_factor == '???')", "ground_truth": "pytest.approx(100)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_101", "reponame": "phonopy", "testpath": "test/phonopy_load/test_phonopy_load.py", "testname": "test_phonopy_load.py", "classname": null, "funcname": "test_unit_conversion_factor_QE", "imports": ["from pathlib import Path", "import pytest", "import phonopy"], "code": "def test_unit_conversion_factor_QE():\n    'Test phonopy_load with QE phonopy_params.yaml.'\n    ph = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-QE.yaml.xz'), produce_fc=False, log_level=2)\n    assert (ph.calculator == 'qe')\n    assert (ph.unit_conversion_factor == pytest.approx(108.9707718))", "masked_code": "def test_unit_conversion_factor_QE():\n    'Test phonopy_load with QE phonopy_params.yaml.'\n    ph = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-QE.yaml.xz'), produce_fc=False, log_level=2)\n    assert (ph.calculator == '???')\n    assert (ph.unit_conversion_factor == pytest.approx(108.9707718))", "ground_truth": "'qe'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_102", "reponame": "phonopy", "testpath": "test/phonopy_load/test_phonopy_load.py", "testname": "test_phonopy_load.py", "classname": null, "funcname": "test_unit_conversion_factor_QE", "imports": ["from pathlib import Path", "import pytest", "import phonopy"], "code": "def test_unit_conversion_factor_QE():\n    'Test phonopy_load with QE phonopy_params.yaml.'\n    ph = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-QE.yaml.xz'), produce_fc=False, log_level=2)\n    assert (ph.calculator == 'qe')\n    assert (ph.unit_conversion_factor == pytest.approx(108.9707718))", "masked_code": "def test_unit_conversion_factor_QE():\n    'Test phonopy_load with QE phonopy_params.yaml.'\n    ph = phonopy.load(((cwd / '..') / 'phonopy_params_NaCl-QE.yaml.xz'), produce_fc=False, log_level=2)\n    assert (ph.calculator == 'qe')\n    assert (ph.unit_conversion_factor == '???')", "ground_truth": "pytest.approx(108.9707718)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_103", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_PhonopyAtoms_with_Xn_symbol", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_PhonopyAtoms_with_Xn_symbol(ph_nacl: Phonopy):\n    'Test of PhonopyAtoms with Xn symbol.'\n    symbols = ph_nacl.unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    masses = ph_nacl.unitcell.masses\n    masses[(- 1)] = 70.0\n    numbers = ph_nacl.unitcell.numbers\n    numbers[(- 1)] = (numbers[(- 1)] + PhonopyAtoms._MOD_DIVISOR)\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (symbols == cell.symbols)\n    np.testing.assert_allclose(cell.masses, ph_nacl.unitcell.masses)\n    np.testing.assert_equal(cell.numbers_with_shifts, numbers)\n    np.testing.assert_equal(cell.numbers, ph_nacl.unitcell.numbers)\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols, masses=masses)\n    assert (symbols == cell.symbols)\n    np.testing.assert_allclose(cell.masses, masses)\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, numbers=numbers)\n    assert (str(e.value) == 'Atomic numbers cannot be larger than 118.')\n    symbols[(- 1)] = 'Cl_1'\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (str(e.value) == 'Invalid symbol: Cl_1.')\n    symbols[(- 1)] = 'Cl_0'\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (str(e.value) == 'Invalid symbol: Cl_0.')", "masked_code": "def test_PhonopyAtoms_with_Xn_symbol(ph_nacl: Phonopy):\n    'Test of PhonopyAtoms with Xn symbol.'\n    symbols = ph_nacl.unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    masses = ph_nacl.unitcell.masses\n    masses[(- 1)] = 70.0\n    numbers = ph_nacl.unitcell.numbers\n    numbers[(- 1)] = (numbers[(- 1)] + PhonopyAtoms._MOD_DIVISOR)\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (symbols == cell.symbols)\n    np.testing.assert_allclose(cell.masses, ph_nacl.unitcell.masses)\n    np.testing.assert_equal(cell.numbers_with_shifts, numbers)\n    np.testing.assert_equal(cell.numbers, ph_nacl.unitcell.numbers)\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols, masses=masses)\n    assert (symbols == cell.symbols)\n    np.testing.assert_allclose(cell.masses, masses)\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, numbers=numbers)\n    assert (str(e.value) == '???')\n    symbols[(- 1)] = 'Cl_1'\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (str(e.value) == 'Invalid symbol: Cl_1.')\n    symbols[(- 1)] = 'Cl_0'\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (str(e.value) == 'Invalid symbol: Cl_0.')", "ground_truth": "'Atomic numbers cannot be larger than 118.'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_104", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_PhonopyAtoms_with_Xn_symbol", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_PhonopyAtoms_with_Xn_symbol(ph_nacl: Phonopy):\n    'Test of PhonopyAtoms with Xn symbol.'\n    symbols = ph_nacl.unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    masses = ph_nacl.unitcell.masses\n    masses[(- 1)] = 70.0\n    numbers = ph_nacl.unitcell.numbers\n    numbers[(- 1)] = (numbers[(- 1)] + PhonopyAtoms._MOD_DIVISOR)\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (symbols == cell.symbols)\n    np.testing.assert_allclose(cell.masses, ph_nacl.unitcell.masses)\n    np.testing.assert_equal(cell.numbers_with_shifts, numbers)\n    np.testing.assert_equal(cell.numbers, ph_nacl.unitcell.numbers)\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols, masses=masses)\n    assert (symbols == cell.symbols)\n    np.testing.assert_allclose(cell.masses, masses)\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, numbers=numbers)\n    assert (str(e.value) == 'Atomic numbers cannot be larger than 118.')\n    symbols[(- 1)] = 'Cl_1'\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (str(e.value) == 'Invalid symbol: Cl_1.')\n    symbols[(- 1)] = 'Cl_0'\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (str(e.value) == 'Invalid symbol: Cl_0.')", "masked_code": "def test_PhonopyAtoms_with_Xn_symbol(ph_nacl: Phonopy):\n    'Test of PhonopyAtoms with Xn symbol.'\n    symbols = ph_nacl.unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    masses = ph_nacl.unitcell.masses\n    masses[(- 1)] = 70.0\n    numbers = ph_nacl.unitcell.numbers\n    numbers[(- 1)] = (numbers[(- 1)] + PhonopyAtoms._MOD_DIVISOR)\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (symbols == cell.symbols)\n    np.testing.assert_allclose(cell.masses, ph_nacl.unitcell.masses)\n    np.testing.assert_equal(cell.numbers_with_shifts, numbers)\n    np.testing.assert_equal(cell.numbers, ph_nacl.unitcell.numbers)\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols, masses=masses)\n    assert (symbols == cell.symbols)\n    np.testing.assert_allclose(cell.masses, masses)\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, numbers=numbers)\n    assert (str(e.value) == 'Atomic numbers cannot be larger than 118.')\n    symbols[(- 1)] = 'Cl_1'\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (str(e.value) == '???')\n    symbols[(- 1)] = 'Cl_0'\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (str(e.value) == 'Invalid symbol: Cl_0.')", "ground_truth": "'Invalid symbol: Cl_1.'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_105", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_PhonopyAtoms_with_Xn_symbol", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_PhonopyAtoms_with_Xn_symbol(ph_nacl: Phonopy):\n    'Test of PhonopyAtoms with Xn symbol.'\n    symbols = ph_nacl.unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    masses = ph_nacl.unitcell.masses\n    masses[(- 1)] = 70.0\n    numbers = ph_nacl.unitcell.numbers\n    numbers[(- 1)] = (numbers[(- 1)] + PhonopyAtoms._MOD_DIVISOR)\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (symbols == cell.symbols)\n    np.testing.assert_allclose(cell.masses, ph_nacl.unitcell.masses)\n    np.testing.assert_equal(cell.numbers_with_shifts, numbers)\n    np.testing.assert_equal(cell.numbers, ph_nacl.unitcell.numbers)\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols, masses=masses)\n    assert (symbols == cell.symbols)\n    np.testing.assert_allclose(cell.masses, masses)\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, numbers=numbers)\n    assert (str(e.value) == 'Atomic numbers cannot be larger than 118.')\n    symbols[(- 1)] = 'Cl_1'\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (str(e.value) == 'Invalid symbol: Cl_1.')\n    symbols[(- 1)] = 'Cl_0'\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (str(e.value) == 'Invalid symbol: Cl_0.')", "masked_code": "def test_PhonopyAtoms_with_Xn_symbol(ph_nacl: Phonopy):\n    'Test of PhonopyAtoms with Xn symbol.'\n    symbols = ph_nacl.unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    masses = ph_nacl.unitcell.masses\n    masses[(- 1)] = 70.0\n    numbers = ph_nacl.unitcell.numbers\n    numbers[(- 1)] = (numbers[(- 1)] + PhonopyAtoms._MOD_DIVISOR)\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (symbols == cell.symbols)\n    np.testing.assert_allclose(cell.masses, ph_nacl.unitcell.masses)\n    np.testing.assert_equal(cell.numbers_with_shifts, numbers)\n    np.testing.assert_equal(cell.numbers, ph_nacl.unitcell.numbers)\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols, masses=masses)\n    assert (symbols == cell.symbols)\n    np.testing.assert_allclose(cell.masses, masses)\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, numbers=numbers)\n    assert (str(e.value) == 'Atomic numbers cannot be larger than 118.')\n    symbols[(- 1)] = 'Cl_1'\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (str(e.value) == 'Invalid symbol: Cl_1.')\n    symbols[(- 1)] = 'Cl_0'\n    with pytest.raises(RuntimeError) as e:\n        _ = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols)\n    assert (str(e.value) == '???')", "ground_truth": "'Invalid symbol: Cl_0.'", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_106", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_formula():\n    'Test of PhonopyAtoms formula property.'\n    assert (cell_SiO2.formula == 'O4Si2')\n    assert (cell_AcO2.formula == 'Ac2O4')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0.5, 0.5]], symbols=['Fe', 'Fe1'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0]], symbols=['Fe11', 'Fe2'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')", "masked_code": "def test_formula():\n    'Test of PhonopyAtoms formula property.'\n    assert (cell_SiO2.formula == '???')\n    assert (cell_AcO2.formula == 'Ac2O4')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0.5, 0.5]], symbols=['Fe', 'Fe1'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0]], symbols=['Fe11', 'Fe2'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')", "ground_truth": "'O4Si2'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_107", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_formula():\n    'Test of PhonopyAtoms formula property.'\n    assert (cell_SiO2.formula == 'O4Si2')\n    assert (cell_AcO2.formula == 'Ac2O4')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0.5, 0.5]], symbols=['Fe', 'Fe1'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0]], symbols=['Fe11', 'Fe2'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')", "masked_code": "def test_formula():\n    'Test of PhonopyAtoms formula property.'\n    assert (cell_SiO2.formula == 'O4Si2')\n    assert (cell_AcO2.formula == '???')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0.5, 0.5]], symbols=['Fe', 'Fe1'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0]], symbols=['Fe11', 'Fe2'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')", "ground_truth": "'Ac2O4'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_108", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_formula():\n    'Test of PhonopyAtoms formula property.'\n    assert (cell_SiO2.formula == 'O4Si2')\n    assert (cell_AcO2.formula == 'Ac2O4')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0.5, 0.5]], symbols=['Fe', 'Fe1'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0]], symbols=['Fe11', 'Fe2'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')", "masked_code": "def test_formula():\n    'Test of PhonopyAtoms formula property.'\n    assert (cell_SiO2.formula == 'O4Si2')\n    assert (cell_AcO2.formula == 'Ac2O4')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0.5, 0.5]], symbols=['Fe', 'Fe1'], masses=[55.845, 55.845])\n    assert (cell.formula == '???')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0]], symbols=['Fe11', 'Fe2'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')", "ground_truth": "'Fe2'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_109", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_formula():\n    'Test of PhonopyAtoms formula property.'\n    assert (cell_SiO2.formula == 'O4Si2')\n    assert (cell_AcO2.formula == 'Ac2O4')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0.5, 0.5]], symbols=['Fe', 'Fe1'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0]], symbols=['Fe11', 'Fe2'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')", "masked_code": "def test_formula():\n    'Test of PhonopyAtoms formula property.'\n    assert (cell_SiO2.formula == 'O4Si2')\n    assert (cell_AcO2.formula == 'Ac2O4')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0.5, 0.5]], symbols=['Fe', 'Fe1'], masses=[55.845, 55.845])\n    assert (cell.formula == 'Fe2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0]], symbols=['Fe11', 'Fe2'], masses=[55.845, 55.845])\n    assert (cell.formula == '???')", "ground_truth": "'Fe2'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_110", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_formula_complex", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_formula_complex():\n    'Test formula property with more complex structures.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]], symbols=['Fe', 'O', 'O', 'Ti'])\n    assert (cell.formula == 'FeO2Ti')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O'], masses=[55.845, 55.845, 15.999])\n    assert (cell.formula == 'Fe2O')", "masked_code": "def test_formula_complex():\n    'Test formula property with more complex structures.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]], symbols=['Fe', 'O', 'O', 'Ti'])\n    assert (cell.formula == '???')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O'], masses=[55.845, 55.845, 15.999])\n    assert (cell.formula == 'Fe2O')", "ground_truth": "'FeO2Ti'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_111", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_formula_complex", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_formula_complex():\n    'Test formula property with more complex structures.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]], symbols=['Fe', 'O', 'O', 'Ti'])\n    assert (cell.formula == 'FeO2Ti')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O'], masses=[55.845, 55.845, 15.999])\n    assert (cell.formula == 'Fe2O')", "masked_code": "def test_formula_complex():\n    'Test formula property with more complex structures.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0, 0, 0.5]], symbols=['Fe', 'O', 'O', 'Ti'])\n    assert (cell.formula == 'FeO2Ti')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O'], masses=[55.845, 55.845, 15.999])\n    assert (cell.formula == '???')", "ground_truth": "'Fe2O'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_112", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_reduced_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "masked_code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == '???')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "ground_truth": "'Fe2O2'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_113", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_reduced_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "masked_code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == '???')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "ground_truth": "'FeO'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_114", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_reduced_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "masked_code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == '???')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "ground_truth": "'FeO2'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_115", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_reduced_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "masked_code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == '???')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "ground_truth": "'FeO2'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_116", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_reduced_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "masked_code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == '???')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "ground_truth": "'Fe2O2'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_117", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_reduced_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "masked_code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == '???')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "ground_truth": "'FeO'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_118", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_reduced_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "masked_code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == '???')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "ground_truth": "'Fe6O6'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_119", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_reduced_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "masked_code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == '???')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "ground_truth": "'FeO'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_120", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_reduced_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "masked_code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == '???')\n    assert (cell.reduced_formula == 'Fe2O3')", "ground_truth": "'Fe2O3'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_121", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_reduced_formula", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == 'Fe2O3')", "masked_code": "def test_reduced_formula():\n    'Test reduced_formula property.'\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe', 'Fe', 'O', 'O'])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0]], symbols=['Fe', 'O', 'O'])\n    assert (cell.formula == 'FeO2')\n    assert (cell.reduced_formula == 'FeO2')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0], [0.5, 0, 0], [0, 0.5, 0], [0.5, 0.5, 0]], symbols=['Fe1', 'Fe2', 'O1', 'O2'], masses=[55.845, 55.845, 15.999, 15.999])\n    assert (cell.formula == 'Fe2O2')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[[0, 0, 0]], symbols=['H'])\n    assert (cell.formula == 'H')\n    assert (cell.reduced_formula == 'H')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=[], symbols=[])\n    assert (cell.reduced_formula == '')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 12), symbols=((['Fe'] * 6) + (['O'] * 6)))\n    assert (cell.formula == 'Fe6O6')\n    assert (cell.reduced_formula == 'FeO')\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * 5), symbols=((['Fe'] * 2) + (['O'] * 3)))\n    assert (cell.formula == 'Fe2O3')\n    assert (cell.reduced_formula == '???')", "ground_truth": "'Fe2O3'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_122", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_formulas", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "@pytest.mark.parametrize('symbols,expected_formula,expected_normalized', [(['Fe', 'Fe', 'O', 'O'], 'Fe2O2', 'Fe0.5O0.5'), (['Fe', 'O', 'O'], 'FeO2', 'Fe0.333O0.667'), (['Fe', 'Fe', 'O', 'O', 'O'], 'Fe2O3', 'Fe0.4O0.6'), (['H'], 'H', 'H1.0'), ([], '', ''), (((['Fe'] * 6) + (['O'] * 6)), 'Fe6O6', 'Fe0.5O0.5'), (['Fe1', 'Fe2', 'O'], 'Fe2O', 'Fe0.667O0.333')])\ndef test_formulas(symbols, expected_formula, expected_normalized):\n    'Test all formula properties.'\n    masses = None\n    if any(((s.rstrip('0123456789') != s) for s in symbols)):\n        masses = []\n        for s in symbols:\n            base = s.rstrip('0123456789')\n            if (base == 'Fe'):\n                masses.append(55.845)\n            elif (base == 'O'):\n                masses.append(15.999)\n            elif (base == 'H'):\n                masses.append(1.008)\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * len(symbols)), symbols=symbols, masses=masses)\n    assert (cell.formula == expected_formula)\n    assert (cell.normalized_formula == expected_normalized)", "masked_code": "@pytest.mark.parametrize('symbols,expected_formula,expected_normalized', [(['Fe', 'Fe', 'O', 'O'], 'Fe2O2', 'Fe0.5O0.5'), (['Fe', 'O', 'O'], 'FeO2', 'Fe0.333O0.667'), (['Fe', 'Fe', 'O', 'O', 'O'], 'Fe2O3', 'Fe0.4O0.6'), (['H'], 'H', 'H1.0'), ([], '', ''), (((['Fe'] * 6) + (['O'] * 6)), 'Fe6O6', 'Fe0.5O0.5'), (['Fe1', 'Fe2', 'O'], 'Fe2O', 'Fe0.667O0.333')])\ndef test_formulas(symbols, expected_formula, expected_normalized):\n    'Test all formula properties.'\n    masses = None\n    if any(((s.rstrip('0123456789') != s) for s in symbols)):\n        masses = []\n        for s in symbols:\n            base = s.rstrip('0123456789')\n            if (base == 'Fe'):\n                masses.append(55.845)\n            elif (base == 'O'):\n                masses.append(15.999)\n            elif (base == 'H'):\n                masses.append(1.008)\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * len(symbols)), symbols=symbols, masses=masses)\n    assert (cell.formula == '???')\n    assert (cell.normalized_formula == expected_normalized)", "ground_truth": "expected_formula", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_123", "reponame": "phonopy", "testpath": "test/structure/test_atoms.py", "testname": "test_atoms.py", "classname": null, "funcname": "test_formulas", "imports": ["from collections.abc import Callable", "from io import StringIO", "import numpy as np", "import pytest", "import yaml", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms, parse_cell_dict"], "code": "@pytest.mark.parametrize('symbols,expected_formula,expected_normalized', [(['Fe', 'Fe', 'O', 'O'], 'Fe2O2', 'Fe0.5O0.5'), (['Fe', 'O', 'O'], 'FeO2', 'Fe0.333O0.667'), (['Fe', 'Fe', 'O', 'O', 'O'], 'Fe2O3', 'Fe0.4O0.6'), (['H'], 'H', 'H1.0'), ([], '', ''), (((['Fe'] * 6) + (['O'] * 6)), 'Fe6O6', 'Fe0.5O0.5'), (['Fe1', 'Fe2', 'O'], 'Fe2O', 'Fe0.667O0.333')])\ndef test_formulas(symbols, expected_formula, expected_normalized):\n    'Test all formula properties.'\n    masses = None\n    if any(((s.rstrip('0123456789') != s) for s in symbols)):\n        masses = []\n        for s in symbols:\n            base = s.rstrip('0123456789')\n            if (base == 'Fe'):\n                masses.append(55.845)\n            elif (base == 'O'):\n                masses.append(15.999)\n            elif (base == 'H'):\n                masses.append(1.008)\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * len(symbols)), symbols=symbols, masses=masses)\n    assert (cell.formula == expected_formula)\n    assert (cell.normalized_formula == expected_normalized)", "masked_code": "@pytest.mark.parametrize('symbols,expected_formula,expected_normalized', [(['Fe', 'Fe', 'O', 'O'], 'Fe2O2', 'Fe0.5O0.5'), (['Fe', 'O', 'O'], 'FeO2', 'Fe0.333O0.667'), (['Fe', 'Fe', 'O', 'O', 'O'], 'Fe2O3', 'Fe0.4O0.6'), (['H'], 'H', 'H1.0'), ([], '', ''), (((['Fe'] * 6) + (['O'] * 6)), 'Fe6O6', 'Fe0.5O0.5'), (['Fe1', 'Fe2', 'O'], 'Fe2O', 'Fe0.667O0.333')])\ndef test_formulas(symbols, expected_formula, expected_normalized):\n    'Test all formula properties.'\n    masses = None\n    if any(((s.rstrip('0123456789') != s) for s in symbols)):\n        masses = []\n        for s in symbols:\n            base = s.rstrip('0123456789')\n            if (base == 'Fe'):\n                masses.append(55.845)\n            elif (base == 'O'):\n                masses.append(15.999)\n            elif (base == 'H'):\n                masses.append(1.008)\n    cell = PhonopyAtoms(cell=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], scaled_positions=([[0, 0, 0]] * len(symbols)), symbols=symbols, masses=masses)\n    assert (cell.formula == expected_formula)\n    assert (cell.normalized_formula == '???')", "ground_truth": "expected_normalized", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_124", "reponame": "phonopy", "testpath": "test/structure/test_cells.py", "testname": "test_cells.py", "classname": null, "funcname": "test_get_primitive_convcell_nacl_svecs", "imports": ["import os", "from collections.abc import Callable", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import Primitive, ShortestPairs, TrimmedCell, compute_all_sg_permutations, compute_permutation_for_rotation, convert_to_phonopy_primitive, dense_to_sparse_svecs, get_angles, get_cell_matrix_from_lattice, get_cell_parameters, get_primitive, get_primitive_matrix, get_supercell, isclose, sparse_to_dense_svecs"], "code": "@pytest.mark.parametrize('store_dense_svecs', [True, False])\ndef test_get_primitive_convcell_nacl_svecs(nacl_unitcell_order1: PhonopyAtoms, store_dense_svecs):\n    'Test shortest vectors by NaCl.'\n    pcell = get_primitive(nacl_unitcell_order1, primitive_matrix=primitive_matrix_nacl, store_dense_svecs=store_dense_svecs)\n    (svecs, multi) = pcell.get_smallest_vectors()\n    if store_dense_svecs:\n        assert (svecs.shape == (54, 3))\n        assert (multi.shape == (8, 2, 2))\n        assert (np.sum(multi[(:, :, 0)]) == 54)\n        assert (np.sum(multi[((- 1):, (- 1), :)]) == 54)\n    else:\n        assert (svecs.shape == (8, 2, 27, 3))\n        assert (multi.shape == (8, 2))", "masked_code": "@pytest.mark.parametrize('store_dense_svecs', [True, False])\ndef test_get_primitive_convcell_nacl_svecs(nacl_unitcell_order1: PhonopyAtoms, store_dense_svecs):\n    'Test shortest vectors by NaCl.'\n    pcell = get_primitive(nacl_unitcell_order1, primitive_matrix=primitive_matrix_nacl, store_dense_svecs=store_dense_svecs)\n    (svecs, multi) = pcell.get_smallest_vectors()\n    if store_dense_svecs:\n        assert (svecs.shape == '???')\n        assert (multi.shape == (8, 2, 2))\n        assert (np.sum(multi[(:, :, 0)]) == 54)\n        assert (np.sum(multi[((- 1):, (- 1), :)]) == 54)\n    else:\n        assert (svecs.shape == (8, 2, 27, 3))\n        assert (multi.shape == (8, 2))", "ground_truth": "(54, 3)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_125", "reponame": "phonopy", "testpath": "test/structure/test_cells.py", "testname": "test_cells.py", "classname": null, "funcname": "test_get_primitive_convcell_nacl_svecs", "imports": ["import os", "from collections.abc import Callable", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import Primitive, ShortestPairs, TrimmedCell, compute_all_sg_permutations, compute_permutation_for_rotation, convert_to_phonopy_primitive, dense_to_sparse_svecs, get_angles, get_cell_matrix_from_lattice, get_cell_parameters, get_primitive, get_primitive_matrix, get_supercell, isclose, sparse_to_dense_svecs"], "code": "@pytest.mark.parametrize('store_dense_svecs', [True, False])\ndef test_get_primitive_convcell_nacl_svecs(nacl_unitcell_order1: PhonopyAtoms, store_dense_svecs):\n    'Test shortest vectors by NaCl.'\n    pcell = get_primitive(nacl_unitcell_order1, primitive_matrix=primitive_matrix_nacl, store_dense_svecs=store_dense_svecs)\n    (svecs, multi) = pcell.get_smallest_vectors()\n    if store_dense_svecs:\n        assert (svecs.shape == (54, 3))\n        assert (multi.shape == (8, 2, 2))\n        assert (np.sum(multi[(:, :, 0)]) == 54)\n        assert (np.sum(multi[((- 1):, (- 1), :)]) == 54)\n    else:\n        assert (svecs.shape == (8, 2, 27, 3))\n        assert (multi.shape == (8, 2))", "masked_code": "@pytest.mark.parametrize('store_dense_svecs', [True, False])\ndef test_get_primitive_convcell_nacl_svecs(nacl_unitcell_order1: PhonopyAtoms, store_dense_svecs):\n    'Test shortest vectors by NaCl.'\n    pcell = get_primitive(nacl_unitcell_order1, primitive_matrix=primitive_matrix_nacl, store_dense_svecs=store_dense_svecs)\n    (svecs, multi) = pcell.get_smallest_vectors()\n    if store_dense_svecs:\n        assert (svecs.shape == (54, 3))\n        assert (multi.shape == '???')\n        assert (np.sum(multi[(:, :, 0)]) == 54)\n        assert (np.sum(multi[((- 1):, (- 1), :)]) == 54)\n    else:\n        assert (svecs.shape == (8, 2, 27, 3))\n        assert (multi.shape == (8, 2))", "ground_truth": "(8, 2, 2)", "quality_analysis": {"complexity_score": 7, "left_complexity": 2, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_126", "reponame": "phonopy", "testpath": "test/structure/test_cells.py", "testname": "test_cells.py", "classname": null, "funcname": "test_get_primitive_convcell_nacl_svecs", "imports": ["import os", "from collections.abc import Callable", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import Primitive, ShortestPairs, TrimmedCell, compute_all_sg_permutations, compute_permutation_for_rotation, convert_to_phonopy_primitive, dense_to_sparse_svecs, get_angles, get_cell_matrix_from_lattice, get_cell_parameters, get_primitive, get_primitive_matrix, get_supercell, isclose, sparse_to_dense_svecs"], "code": "@pytest.mark.parametrize('store_dense_svecs', [True, False])\ndef test_get_primitive_convcell_nacl_svecs(nacl_unitcell_order1: PhonopyAtoms, store_dense_svecs):\n    'Test shortest vectors by NaCl.'\n    pcell = get_primitive(nacl_unitcell_order1, primitive_matrix=primitive_matrix_nacl, store_dense_svecs=store_dense_svecs)\n    (svecs, multi) = pcell.get_smallest_vectors()\n    if store_dense_svecs:\n        assert (svecs.shape == (54, 3))\n        assert (multi.shape == (8, 2, 2))\n        assert (np.sum(multi[(:, :, 0)]) == 54)\n        assert (np.sum(multi[((- 1):, (- 1), :)]) == 54)\n    else:\n        assert (svecs.shape == (8, 2, 27, 3))\n        assert (multi.shape == (8, 2))", "masked_code": "@pytest.mark.parametrize('store_dense_svecs', [True, False])\ndef test_get_primitive_convcell_nacl_svecs(nacl_unitcell_order1: PhonopyAtoms, store_dense_svecs):\n    'Test shortest vectors by NaCl.'\n    pcell = get_primitive(nacl_unitcell_order1, primitive_matrix=primitive_matrix_nacl, store_dense_svecs=store_dense_svecs)\n    (svecs, multi) = pcell.get_smallest_vectors()\n    if store_dense_svecs:\n        assert (svecs.shape == (54, 3))\n        assert (multi.shape == (8, 2, 2))\n        assert (np.sum(multi[(:, :, 0)]) == '???')\n        assert (np.sum(multi[((- 1):, (- 1), :)]) == 54)\n    else:\n        assert (svecs.shape == (8, 2, 27, 3))\n        assert (multi.shape == (8, 2))", "ground_truth": "54", "quality_analysis": {"complexity_score": 11, "left_complexity": 10, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_127", "reponame": "phonopy", "testpath": "test/structure/test_cells.py", "testname": "test_cells.py", "classname": null, "funcname": "test_get_primitive_convcell_nacl_svecs", "imports": ["import os", "from collections.abc import Callable", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import Primitive, ShortestPairs, TrimmedCell, compute_all_sg_permutations, compute_permutation_for_rotation, convert_to_phonopy_primitive, dense_to_sparse_svecs, get_angles, get_cell_matrix_from_lattice, get_cell_parameters, get_primitive, get_primitive_matrix, get_supercell, isclose, sparse_to_dense_svecs"], "code": "@pytest.mark.parametrize('store_dense_svecs', [True, False])\ndef test_get_primitive_convcell_nacl_svecs(nacl_unitcell_order1: PhonopyAtoms, store_dense_svecs):\n    'Test shortest vectors by NaCl.'\n    pcell = get_primitive(nacl_unitcell_order1, primitive_matrix=primitive_matrix_nacl, store_dense_svecs=store_dense_svecs)\n    (svecs, multi) = pcell.get_smallest_vectors()\n    if store_dense_svecs:\n        assert (svecs.shape == (54, 3))\n        assert (multi.shape == (8, 2, 2))\n        assert (np.sum(multi[(:, :, 0)]) == 54)\n        assert (np.sum(multi[((- 1):, (- 1), :)]) == 54)\n    else:\n        assert (svecs.shape == (8, 2, 27, 3))\n        assert (multi.shape == (8, 2))", "masked_code": "@pytest.mark.parametrize('store_dense_svecs', [True, False])\ndef test_get_primitive_convcell_nacl_svecs(nacl_unitcell_order1: PhonopyAtoms, store_dense_svecs):\n    'Test shortest vectors by NaCl.'\n    pcell = get_primitive(nacl_unitcell_order1, primitive_matrix=primitive_matrix_nacl, store_dense_svecs=store_dense_svecs)\n    (svecs, multi) = pcell.get_smallest_vectors()\n    if store_dense_svecs:\n        assert (svecs.shape == (54, 3))\n        assert (multi.shape == (8, 2, 2))\n        assert (np.sum(multi[(:, :, 0)]) == 54)\n        assert (np.sum(multi[((- 1):, (- 1), :)]) == '???')\n    else:\n        assert (svecs.shape == (8, 2, 27, 3))\n        assert (multi.shape == (8, 2))", "ground_truth": "54", "quality_analysis": {"complexity_score": 13, "left_complexity": 12, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_128", "reponame": "phonopy", "testpath": "test/structure/test_cells.py", "testname": "test_cells.py", "classname": null, "funcname": "test_get_primitive_convcell_nacl_svecs", "imports": ["import os", "from collections.abc import Callable", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import Primitive, ShortestPairs, TrimmedCell, compute_all_sg_permutations, compute_permutation_for_rotation, convert_to_phonopy_primitive, dense_to_sparse_svecs, get_angles, get_cell_matrix_from_lattice, get_cell_parameters, get_primitive, get_primitive_matrix, get_supercell, isclose, sparse_to_dense_svecs"], "code": "@pytest.mark.parametrize('store_dense_svecs', [True, False])\ndef test_get_primitive_convcell_nacl_svecs(nacl_unitcell_order1: PhonopyAtoms, store_dense_svecs):\n    'Test shortest vectors by NaCl.'\n    pcell = get_primitive(nacl_unitcell_order1, primitive_matrix=primitive_matrix_nacl, store_dense_svecs=store_dense_svecs)\n    (svecs, multi) = pcell.get_smallest_vectors()\n    if store_dense_svecs:\n        assert (svecs.shape == (54, 3))\n        assert (multi.shape == (8, 2, 2))\n        assert (np.sum(multi[(:, :, 0)]) == 54)\n        assert (np.sum(multi[((- 1):, (- 1), :)]) == 54)\n    else:\n        assert (svecs.shape == (8, 2, 27, 3))\n        assert (multi.shape == (8, 2))", "masked_code": "@pytest.mark.parametrize('store_dense_svecs', [True, False])\ndef test_get_primitive_convcell_nacl_svecs(nacl_unitcell_order1: PhonopyAtoms, store_dense_svecs):\n    'Test shortest vectors by NaCl.'\n    pcell = get_primitive(nacl_unitcell_order1, primitive_matrix=primitive_matrix_nacl, store_dense_svecs=store_dense_svecs)\n    (svecs, multi) = pcell.get_smallest_vectors()\n    if store_dense_svecs:\n        assert (svecs.shape == (54, 3))\n        assert (multi.shape == (8, 2, 2))\n        assert (np.sum(multi[(:, :, 0)]) == 54)\n        assert (np.sum(multi[((- 1):, (- 1), :)]) == 54)\n    else:\n        assert (svecs.shape == '???')\n        assert (multi.shape == (8, 2))", "ground_truth": "(8, 2, 27, 3)", "quality_analysis": {"complexity_score": 8, "left_complexity": 2, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_129", "reponame": "phonopy", "testpath": "test/structure/test_cells.py", "testname": "test_cells.py", "classname": null, "funcname": "test_get_primitive_convcell_nacl_svecs", "imports": ["import os", "from collections.abc import Callable", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import Primitive, ShortestPairs, TrimmedCell, compute_all_sg_permutations, compute_permutation_for_rotation, convert_to_phonopy_primitive, dense_to_sparse_svecs, get_angles, get_cell_matrix_from_lattice, get_cell_parameters, get_primitive, get_primitive_matrix, get_supercell, isclose, sparse_to_dense_svecs"], "code": "@pytest.mark.parametrize('store_dense_svecs', [True, False])\ndef test_get_primitive_convcell_nacl_svecs(nacl_unitcell_order1: PhonopyAtoms, store_dense_svecs):\n    'Test shortest vectors by NaCl.'\n    pcell = get_primitive(nacl_unitcell_order1, primitive_matrix=primitive_matrix_nacl, store_dense_svecs=store_dense_svecs)\n    (svecs, multi) = pcell.get_smallest_vectors()\n    if store_dense_svecs:\n        assert (svecs.shape == (54, 3))\n        assert (multi.shape == (8, 2, 2))\n        assert (np.sum(multi[(:, :, 0)]) == 54)\n        assert (np.sum(multi[((- 1):, (- 1), :)]) == 54)\n    else:\n        assert (svecs.shape == (8, 2, 27, 3))\n        assert (multi.shape == (8, 2))", "masked_code": "@pytest.mark.parametrize('store_dense_svecs', [True, False])\ndef test_get_primitive_convcell_nacl_svecs(nacl_unitcell_order1: PhonopyAtoms, store_dense_svecs):\n    'Test shortest vectors by NaCl.'\n    pcell = get_primitive(nacl_unitcell_order1, primitive_matrix=primitive_matrix_nacl, store_dense_svecs=store_dense_svecs)\n    (svecs, multi) = pcell.get_smallest_vectors()\n    if store_dense_svecs:\n        assert (svecs.shape == (54, 3))\n        assert (multi.shape == (8, 2, 2))\n        assert (np.sum(multi[(:, :, 0)]) == 54)\n        assert (np.sum(multi[((- 1):, (- 1), :)]) == 54)\n    else:\n        assert (svecs.shape == (8, 2, 27, 3))\n        assert (multi.shape == '???')", "ground_truth": "(8, 2)", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_130", "reponame": "phonopy", "testpath": "test/structure/test_cells.py", "testname": "test_cells.py", "classname": null, "funcname": "test_ShortestPairs_dense_nacl", "imports": ["import os", "from collections.abc import Callable", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import Primitive, ShortestPairs, TrimmedCell, compute_all_sg_permutations, compute_permutation_for_rotation, convert_to_phonopy_primitive, dense_to_sparse_svecs, get_angles, get_cell_matrix_from_lattice, get_cell_parameters, get_primitive, get_primitive_matrix, get_supercell, isclose, sparse_to_dense_svecs"], "code": "def test_ShortestPairs_dense_nacl(ph_nacl: Phonopy, helper_methods: Callable):\n    'Test ShortestPairs (dense) by NaCl.'\n    scell = ph_nacl.supercell\n    pcell = ph_nacl.primitive\n    pos = scell.scaled_positions\n    spairs = ShortestPairs(scell.cell, pos, pos[pcell.p2s_map], store_dense_svecs=True)\n    svecs = spairs.shortest_vectors\n    multi = spairs.multiplicities\n    assert (multi[((- 1), (- 1), :)].sum() == multi[(:, :, 0)].sum())\n    np.testing.assert_array_equal(multi[(:, :, 0)].ravel(), multi_nacl_ref)\n    np.testing.assert_allclose(svecs_nacl_ref10, svecs[multi[(1, 0, 1)]:multi[(1, 0, :)].sum()], atol=1e-08)\n    np.testing.assert_allclose(svecs_nacl_ref30, svecs[multi[(3, 0, 1)]:multi[(3, 0, :)].sum()], atol=1e-08)\n    pos_from_svecs = (svecs[(multi[(:, 0, 1)], :)] + pos[0])\n    helper_methods.compare_positions_with_order(pos_from_svecs, pos, scell.cell)", "masked_code": "def test_ShortestPairs_dense_nacl(ph_nacl: Phonopy, helper_methods: Callable):\n    'Test ShortestPairs (dense) by NaCl.'\n    scell = ph_nacl.supercell\n    pcell = ph_nacl.primitive\n    pos = scell.scaled_positions\n    spairs = ShortestPairs(scell.cell, pos, pos[pcell.p2s_map], store_dense_svecs=True)\n    svecs = spairs.shortest_vectors\n    multi = spairs.multiplicities\n    assert (multi[((- 1), (- 1), :)].sum() == '???')\n    np.testing.assert_array_equal(multi[(:, :, 0)].ravel(), multi_nacl_ref)\n    np.testing.assert_allclose(svecs_nacl_ref10, svecs[multi[(1, 0, 1)]:multi[(1, 0, :)].sum()], atol=1e-08)\n    np.testing.assert_allclose(svecs_nacl_ref30, svecs[multi[(3, 0, 1)]:multi[(3, 0, :)].sum()], atol=1e-08)\n    pos_from_svecs = (svecs[(multi[(:, 0, 1)], :)] + pos[0])\n    helper_methods.compare_positions_with_order(pos_from_svecs, pos, scell.cell)", "ground_truth": "multi[(:, :, 0)].sum()", "quality_analysis": {"complexity_score": 6, "left_complexity": 3, "right_complexity": 3, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_131", "reponame": "phonopy", "testpath": "test/structure/test_cells.py", "testname": "test_cells.py", "classname": null, "funcname": "test_get_supercell_with_Xn_symbol", "imports": ["import os", "from collections.abc import Callable", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import Primitive, ShortestPairs, TrimmedCell, compute_all_sg_permutations, compute_permutation_for_rotation, convert_to_phonopy_primitive, dense_to_sparse_svecs, get_angles, get_cell_matrix_from_lattice, get_cell_parameters, get_primitive, get_primitive_matrix, get_supercell, isclose, sparse_to_dense_svecs"], "code": "def test_get_supercell_with_Xn_symbol(ph_nacl: Phonopy):\n    'Test of get_supercell with Xn symbol.'\n    symbols = ph_nacl.unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    masses = ph_nacl.unitcell.masses\n    masses[(- 1)] = 70.0\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols, masses=masses)\n    scell = get_supercell(cell, np.diag([2, 2, 2]))\n    assert (scell.symbols[(- 8):] == (['Cl1'] * 8))\n    np.testing.assert_allclose(scell.masses[(- 8):], ([70.0] * 8))", "masked_code": "def test_get_supercell_with_Xn_symbol(ph_nacl: Phonopy):\n    'Test of get_supercell with Xn symbol.'\n    symbols = ph_nacl.unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    masses = ph_nacl.unitcell.masses\n    masses[(- 1)] = 70.0\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols, masses=masses)\n    scell = get_supercell(cell, np.diag([2, 2, 2]))\n    assert (scell.symbols[(- 8):] == '???')\n    np.testing.assert_allclose(scell.masses[(- 8):], ([70.0] * 8))", "ground_truth": "(['Cl1'] * 8)", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_132", "reponame": "phonopy", "testpath": "test/structure/test_cells.py", "testname": "test_cells.py", "classname": null, "funcname": "test_get_primitive_with_Xn_symbol", "imports": ["import os", "from collections.abc import Callable", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import Primitive, ShortestPairs, TrimmedCell, compute_all_sg_permutations, compute_permutation_for_rotation, convert_to_phonopy_primitive, dense_to_sparse_svecs, get_angles, get_cell_matrix_from_lattice, get_cell_parameters, get_primitive, get_primitive_matrix, get_supercell, isclose, sparse_to_dense_svecs"], "code": "def test_get_primitive_with_Xn_symbol(ph_nacl: Phonopy):\n    'Test of get_primitive with Xn symbol.\\n\\n    Symbols with index breaks symmetry to make primitive cell.\\n\\n    Can not make primitive cell like:\\n    [\"Na\", \"Na\", \"Na\", \"Na\", \"Cl\", \"Cl\", \"Cl\", \"Cl1\"] -> [\"Na\", \"Cl\"]\\n\\n    '\n    symbols = ph_nacl.unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    masses = ph_nacl.unitcell.masses\n    masses[(- 1)] = 70.0\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols, masses=masses)\n    with pytest.raises(RuntimeError) as e:\n        get_primitive(cell, primitive_matrix='F')\n    assert (str(e.value).split('\\n')[0] == 'Atom symbol mapping failure.')", "masked_code": "def test_get_primitive_with_Xn_symbol(ph_nacl: Phonopy):\n    'Test of get_primitive with Xn symbol.\\n\\n    Symbols with index breaks symmetry to make primitive cell.\\n\\n    Can not make primitive cell like:\\n    [\"Na\", \"Na\", \"Na\", \"Na\", \"Cl\", \"Cl\", \"Cl\", \"Cl1\"] -> [\"Na\", \"Cl\"]\\n\\n    '\n    symbols = ph_nacl.unitcell.symbols\n    symbols[(- 1)] = 'Cl1'\n    masses = ph_nacl.unitcell.masses\n    masses[(- 1)] = 70.0\n    cell = PhonopyAtoms(cell=ph_nacl.unitcell.cell, scaled_positions=ph_nacl.unitcell.scaled_positions, symbols=symbols, masses=masses)\n    with pytest.raises(RuntimeError) as e:\n        get_primitive(cell, primitive_matrix='F')\n    assert (str(e.value).split('\\n')[0] == '???')", "ground_truth": "'Atom symbol mapping failure.'", "quality_analysis": {"complexity_score": 9, "left_complexity": 8, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_133", "reponame": "phonopy", "testpath": "test/structure/test_grid_points.py", "testname": "test_grid_points.py", "classname": null, "funcname": "test_GridPoints", "imports": ["import os", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.grid_points import GeneralizedRegularGridPoints, GridPoints, length2mesh"], "code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == np.dtype('int64'))\n    assert (gp.weights.dtype == np.dtype('int64'))\n    assert (gp.grid_mapping_table.dtype == np.dtype('int64'))\n    assert (gp.grid_address.dtype == np.dtype('intc'))\n    assert (gp.mesh_numbers.dtype == np.dtype('intc'))\n    assert (gp.reciprocal_lattice.dtype == np.dtype('double'))\n    assert (gp.qpoints.dtype == np.dtype('double'))\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "masked_code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == '???')\n    assert (gp.weights.dtype == np.dtype('int64'))\n    assert (gp.grid_mapping_table.dtype == np.dtype('int64'))\n    assert (gp.grid_address.dtype == np.dtype('intc'))\n    assert (gp.mesh_numbers.dtype == np.dtype('intc'))\n    assert (gp.reciprocal_lattice.dtype == np.dtype('double'))\n    assert (gp.qpoints.dtype == np.dtype('double'))\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "ground_truth": "np.dtype('int64')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_134", "reponame": "phonopy", "testpath": "test/structure/test_grid_points.py", "testname": "test_grid_points.py", "classname": null, "funcname": "test_GridPoints", "imports": ["import os", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.grid_points import GeneralizedRegularGridPoints, GridPoints, length2mesh"], "code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == np.dtype('int64'))\n    assert (gp.weights.dtype == np.dtype('int64'))\n    assert (gp.grid_mapping_table.dtype == np.dtype('int64'))\n    assert (gp.grid_address.dtype == np.dtype('intc'))\n    assert (gp.mesh_numbers.dtype == np.dtype('intc'))\n    assert (gp.reciprocal_lattice.dtype == np.dtype('double'))\n    assert (gp.qpoints.dtype == np.dtype('double'))\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "masked_code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == np.dtype('int64'))\n    assert (gp.weights.dtype == '???')\n    assert (gp.grid_mapping_table.dtype == np.dtype('int64'))\n    assert (gp.grid_address.dtype == np.dtype('intc'))\n    assert (gp.mesh_numbers.dtype == np.dtype('intc'))\n    assert (gp.reciprocal_lattice.dtype == np.dtype('double'))\n    assert (gp.qpoints.dtype == np.dtype('double'))\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "ground_truth": "np.dtype('int64')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_135", "reponame": "phonopy", "testpath": "test/structure/test_grid_points.py", "testname": "test_grid_points.py", "classname": null, "funcname": "test_GridPoints", "imports": ["import os", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.grid_points import GeneralizedRegularGridPoints, GridPoints, length2mesh"], "code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == np.dtype('int64'))\n    assert (gp.weights.dtype == np.dtype('int64'))\n    assert (gp.grid_mapping_table.dtype == np.dtype('int64'))\n    assert (gp.grid_address.dtype == np.dtype('intc'))\n    assert (gp.mesh_numbers.dtype == np.dtype('intc'))\n    assert (gp.reciprocal_lattice.dtype == np.dtype('double'))\n    assert (gp.qpoints.dtype == np.dtype('double'))\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "masked_code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == np.dtype('int64'))\n    assert (gp.weights.dtype == np.dtype('int64'))\n    assert (gp.grid_mapping_table.dtype == '???')\n    assert (gp.grid_address.dtype == np.dtype('intc'))\n    assert (gp.mesh_numbers.dtype == np.dtype('intc'))\n    assert (gp.reciprocal_lattice.dtype == np.dtype('double'))\n    assert (gp.qpoints.dtype == np.dtype('double'))\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "ground_truth": "np.dtype('int64')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_136", "reponame": "phonopy", "testpath": "test/structure/test_grid_points.py", "testname": "test_grid_points.py", "classname": null, "funcname": "test_GridPoints", "imports": ["import os", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.grid_points import GeneralizedRegularGridPoints, GridPoints, length2mesh"], "code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == np.dtype('int64'))\n    assert (gp.weights.dtype == np.dtype('int64'))\n    assert (gp.grid_mapping_table.dtype == np.dtype('int64'))\n    assert (gp.grid_address.dtype == np.dtype('intc'))\n    assert (gp.mesh_numbers.dtype == np.dtype('intc'))\n    assert (gp.reciprocal_lattice.dtype == np.dtype('double'))\n    assert (gp.qpoints.dtype == np.dtype('double'))\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "masked_code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == np.dtype('int64'))\n    assert (gp.weights.dtype == np.dtype('int64'))\n    assert (gp.grid_mapping_table.dtype == np.dtype('int64'))\n    assert (gp.grid_address.dtype == '???')\n    assert (gp.mesh_numbers.dtype == np.dtype('intc'))\n    assert (gp.reciprocal_lattice.dtype == np.dtype('double'))\n    assert (gp.qpoints.dtype == np.dtype('double'))\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "ground_truth": "np.dtype('intc')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_137", "reponame": "phonopy", "testpath": "test/structure/test_grid_points.py", "testname": "test_grid_points.py", "classname": null, "funcname": "test_GridPoints", "imports": ["import os", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.grid_points import GeneralizedRegularGridPoints, GridPoints, length2mesh"], "code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == np.dtype('int64'))\n    assert (gp.weights.dtype == np.dtype('int64'))\n    assert (gp.grid_mapping_table.dtype == np.dtype('int64'))\n    assert (gp.grid_address.dtype == np.dtype('intc'))\n    assert (gp.mesh_numbers.dtype == np.dtype('intc'))\n    assert (gp.reciprocal_lattice.dtype == np.dtype('double'))\n    assert (gp.qpoints.dtype == np.dtype('double'))\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "masked_code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == np.dtype('int64'))\n    assert (gp.weights.dtype == np.dtype('int64'))\n    assert (gp.grid_mapping_table.dtype == np.dtype('int64'))\n    assert (gp.grid_address.dtype == np.dtype('intc'))\n    assert (gp.mesh_numbers.dtype == '???')\n    assert (gp.reciprocal_lattice.dtype == np.dtype('double'))\n    assert (gp.qpoints.dtype == np.dtype('double'))\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "ground_truth": "np.dtype('intc')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_138", "reponame": "phonopy", "testpath": "test/structure/test_grid_points.py", "testname": "test_grid_points.py", "classname": null, "funcname": "test_GridPoints", "imports": ["import os", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.grid_points import GeneralizedRegularGridPoints, GridPoints, length2mesh"], "code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == np.dtype('int64'))\n    assert (gp.weights.dtype == np.dtype('int64'))\n    assert (gp.grid_mapping_table.dtype == np.dtype('int64'))\n    assert (gp.grid_address.dtype == np.dtype('intc'))\n    assert (gp.mesh_numbers.dtype == np.dtype('intc'))\n    assert (gp.reciprocal_lattice.dtype == np.dtype('double'))\n    assert (gp.qpoints.dtype == np.dtype('double'))\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "masked_code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == np.dtype('int64'))\n    assert (gp.weights.dtype == np.dtype('int64'))\n    assert (gp.grid_mapping_table.dtype == np.dtype('int64'))\n    assert (gp.grid_address.dtype == np.dtype('intc'))\n    assert (gp.mesh_numbers.dtype == np.dtype('intc'))\n    assert (gp.reciprocal_lattice.dtype == '???')\n    assert (gp.qpoints.dtype == np.dtype('double'))\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "ground_truth": "np.dtype('double')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_139", "reponame": "phonopy", "testpath": "test/structure/test_grid_points.py", "testname": "test_grid_points.py", "classname": null, "funcname": "test_GridPoints", "imports": ["import os", "import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.grid_points import GeneralizedRegularGridPoints, GridPoints, length2mesh"], "code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == np.dtype('int64'))\n    assert (gp.weights.dtype == np.dtype('int64'))\n    assert (gp.grid_mapping_table.dtype == np.dtype('int64'))\n    assert (gp.grid_address.dtype == np.dtype('intc'))\n    assert (gp.mesh_numbers.dtype == np.dtype('intc'))\n    assert (gp.reciprocal_lattice.dtype == np.dtype('double'))\n    assert (gp.qpoints.dtype == np.dtype('double'))\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "masked_code": "def test_GridPoints():\n    'Test of GridPoints.'\n    gp = GridPoints([2, 3, 4], [[(- 1), 1, 1], [1, (- 1), 1], [1, 1, (- 1)]])\n    assert (gp.ir_grid_points.dtype == np.dtype('int64'))\n    assert (gp.weights.dtype == np.dtype('int64'))\n    assert (gp.grid_mapping_table.dtype == np.dtype('int64'))\n    assert (gp.grid_address.dtype == np.dtype('intc'))\n    assert (gp.mesh_numbers.dtype == np.dtype('intc'))\n    assert (gp.reciprocal_lattice.dtype == np.dtype('double'))\n    assert (gp.qpoints.dtype == '???')\n    np.testing.assert_array_equal(gp.grid_address, ga234)", "ground_truth": "np.dtype('double')", "quality_analysis": {"complexity_score": 6, "left_complexity": 2, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_140", "reponame": "phonopy", "testpath": "test/structure/test_symmetry.py", "testname": "test_symmetry.py", "classname": null, "funcname": "test_Symmetry_pointgroup", "imports": ["import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_supercell", "from phonopy.structure.symmetry import Symmetry, _get_mapping_between_cells, collect_unique_rotations, symmetrize_borns_and_epsilon"], "code": "def test_Symmetry_pointgroup(ph_tio2: Phonopy):\n    'Test for point group symbol.'\n    assert (ph_tio2.symmetry.pointgroup_symbol == '4/mmm')", "masked_code": "def test_Symmetry_pointgroup(ph_tio2: Phonopy):\n    'Test for point group symbol.'\n    assert (ph_tio2.symmetry.pointgroup_symbol == '???')", "ground_truth": "'4/mmm'", "quality_analysis": {"complexity_score": 3, "left_complexity": 2, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_141", "reponame": "phonopy", "testpath": "test/structure/test_symmetry.py", "testname": "test_symmetry.py", "classname": null, "funcname": "test_collect_unique_rotations", "imports": ["import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_supercell", "from phonopy.structure.symmetry import Symmetry, _get_mapping_between_cells, collect_unique_rotations, symmetrize_borns_and_epsilon"], "code": "def test_collect_unique_rotations(ph_nacl: Phonopy):\n    'Test collect_unique_rotations function.'\n    rotations = ph_nacl.symmetry.symmetry_operations['rotations']\n    ptg = collect_unique_rotations(rotations)\n    assert (len(rotations) == 1536)\n    assert (len(ptg) == 48)\n    assert (len(ptg) == len(ph_nacl.symmetry.pointgroup_operations))", "masked_code": "def test_collect_unique_rotations(ph_nacl: Phonopy):\n    'Test collect_unique_rotations function.'\n    rotations = ph_nacl.symmetry.symmetry_operations['rotations']\n    ptg = collect_unique_rotations(rotations)\n    assert (len(rotations) == '???')\n    assert (len(ptg) == 48)\n    assert (len(ptg) == len(ph_nacl.symmetry.pointgroup_operations))", "ground_truth": "1536", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_142", "reponame": "phonopy", "testpath": "test/structure/test_symmetry.py", "testname": "test_symmetry.py", "classname": null, "funcname": "test_collect_unique_rotations", "imports": ["import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_supercell", "from phonopy.structure.symmetry import Symmetry, _get_mapping_between_cells, collect_unique_rotations, symmetrize_borns_and_epsilon"], "code": "def test_collect_unique_rotations(ph_nacl: Phonopy):\n    'Test collect_unique_rotations function.'\n    rotations = ph_nacl.symmetry.symmetry_operations['rotations']\n    ptg = collect_unique_rotations(rotations)\n    assert (len(rotations) == 1536)\n    assert (len(ptg) == 48)\n    assert (len(ptg) == len(ph_nacl.symmetry.pointgroup_operations))", "masked_code": "def test_collect_unique_rotations(ph_nacl: Phonopy):\n    'Test collect_unique_rotations function.'\n    rotations = ph_nacl.symmetry.symmetry_operations['rotations']\n    ptg = collect_unique_rotations(rotations)\n    assert (len(rotations) == 1536)\n    assert (len(ptg) == '???')\n    assert (len(ptg) == len(ph_nacl.symmetry.pointgroup_operations))", "ground_truth": "48", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_143", "reponame": "phonopy", "testpath": "test/structure/test_symmetry.py", "testname": "test_symmetry.py", "classname": null, "funcname": "test_collect_unique_rotations", "imports": ["import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_supercell", "from phonopy.structure.symmetry import Symmetry, _get_mapping_between_cells, collect_unique_rotations, symmetrize_borns_and_epsilon"], "code": "def test_collect_unique_rotations(ph_nacl: Phonopy):\n    'Test collect_unique_rotations function.'\n    rotations = ph_nacl.symmetry.symmetry_operations['rotations']\n    ptg = collect_unique_rotations(rotations)\n    assert (len(rotations) == 1536)\n    assert (len(ptg) == 48)\n    assert (len(ptg) == len(ph_nacl.symmetry.pointgroup_operations))", "masked_code": "def test_collect_unique_rotations(ph_nacl: Phonopy):\n    'Test collect_unique_rotations function.'\n    rotations = ph_nacl.symmetry.symmetry_operations['rotations']\n    ptg = collect_unique_rotations(rotations)\n    assert (len(rotations) == 1536)\n    assert (len(ptg) == 48)\n    assert (len(ptg) == '???')", "ground_truth": "len(ph_nacl.symmetry.pointgroup_operations)", "quality_analysis": {"complexity_score": 9, "left_complexity": 4, "right_complexity": 5, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_144", "reponame": "phonopy", "testpath": "test/structure/test_symmetry.py", "testname": "test_symmetry.py", "classname": null, "funcname": "test_reciprocal_operations", "imports": ["import numpy as np", "import pytest", "from phonopy import Phonopy", "from phonopy.structure.atoms import PhonopyAtoms", "from phonopy.structure.cells import get_supercell", "from phonopy.structure.symmetry import Symmetry, _get_mapping_between_cells, collect_unique_rotations, symmetrize_borns_and_epsilon"], "code": "def test_reciprocal_operations(ph_zr3n4: Phonopy):\n    'Test reciprocal operations.\\n\\n    Zr3N4 is a non-centrosymmetric crystal.\\n\\n    '\n    ptg = ph_zr3n4.symmetry.pointgroup_operations\n    rops = ph_zr3n4.symmetry.reciprocal_operations\n    matches = []\n    for r in ptg:\n        for (i, rec_r) in enumerate(rops):\n            if (r == rec_r).all():\n                matches.append(i)\n                break\n    assert (len(np.unique(matches)) == len(ptg))\n    found_inv = False\n    for rec_r in rops:\n        if (rec_r == (- np.eye(3, dtype=int))).all():\n            found_inv = True\n            break\n    assert found_inv", "masked_code": "def test_reciprocal_operations(ph_zr3n4: Phonopy):\n    'Test reciprocal operations.\\n\\n    Zr3N4 is a non-centrosymmetric crystal.\\n\\n    '\n    ptg = ph_zr3n4.symmetry.pointgroup_operations\n    rops = ph_zr3n4.symmetry.reciprocal_operations\n    matches = []\n    for r in ptg:\n        for (i, rec_r) in enumerate(rops):\n            if (r == rec_r).all():\n                matches.append(i)\n                break\n    assert (len(np.unique(matches)) == '???')\n    found_inv = False\n    for rec_r in rops:\n        if (rec_r == (- np.eye(3, dtype=int))).all():\n            found_inv = True\n            break\n    assert found_inv", "ground_truth": "len(ptg)", "quality_analysis": {"complexity_score": 11, "left_complexity": 7, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
