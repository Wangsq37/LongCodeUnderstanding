{"task_id": "phonopy_0", "reponame": "phonopy", "testpath": "test_file_IO.py", "testname": "test_file_IO.py", "classname": null, "funcname": "test_write_force_constants_to_hdf5", "imports": ["import pathlib", "import numpy as np", "import pytest", "import phonopy", "from phonopy.file_IO import parse_BORN, read_force_constants_hdf5, write_force_constants_to_hdf5"], "code": "def test_write_force_constants_to_hdf5():\n    'Test write_force_constants_to_hdf5 with augmented input.'\n    pytest.importorskip('h5py')\n    force_constants_aug = np.array([(- 1000000000000.0), 1e-12, 0, 3.14])\n    phys_unit_aug = 'J/m^2'\n    write_force_constants_to_hdf5(force_constants_aug, physical_unit=phys_unit_aug)\n    for created_filename in ['force_constants.hdf5']:\n        file_path = pathlib.Path((cwd_called / created_filename))\n        assert file_path.exists()\n        (fc, physical_unit) = read_force_constants_hdf5(file_path, return_physical_unit=True)\n        assert (fc[0] == pytest.approx((- 1000000000000.0)))\n        assert (fc[1] == pytest.approx(1e-12))\n        assert (fc[2] == pytest.approx(0))\n        assert (fc[3] == pytest.approx(3.14))\n        assert (physical_unit == 'J/m^2')\n        file_path.unlink()", "masked_code": "def test_write_force_constants_to_hdf5():\n    'Test write_force_constants_to_hdf5 with augmented input.'\n    pytest.importorskip('h5py')\n    force_constants_aug = np.array([(- 1000000000000.0), 1e-12, 0, 3.14])\n    phys_unit_aug = 'J/m^2'\n    write_force_constants_to_hdf5(force_constants_aug, physical_unit=phys_unit_aug)\n    for created_filename in ['force_constants.hdf5']:\n        file_path = pathlib.Path((cwd_called / created_filename))\n        assert file_path.exists()\n        (fc, physical_unit) = read_force_constants_hdf5(file_path, return_physical_unit=True)\n        assert (fc[0] == '???')\n        assert (fc[1] == pytest.approx(1e-12))\n        assert (fc[2] == pytest.approx(0))\n        assert (fc[3] == pytest.approx(3.14))\n        assert (physical_unit == 'J/m^2')\n        file_path.unlink()", "ground_truth": "pytest.approx((- 1000000000000.0))", "quality_analysis": {"complexity_score": 11, "left_complexity": 5, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_1", "reponame": "phonopy", "testpath": "test_file_IO.py", "testname": "test_file_IO.py", "classname": null, "funcname": "test_write_force_constants_to_hdf5", "imports": ["import pathlib", "import numpy as np", "import pytest", "import phonopy", "from phonopy.file_IO import parse_BORN, read_force_constants_hdf5, write_force_constants_to_hdf5"], "code": "def test_write_force_constants_to_hdf5():\n    'Test write_force_constants_to_hdf5 with augmented input.'\n    pytest.importorskip('h5py')\n    force_constants_aug = np.array([(- 1000000000000.0), 1e-12, 0, 3.14])\n    phys_unit_aug = 'J/m^2'\n    write_force_constants_to_hdf5(force_constants_aug, physical_unit=phys_unit_aug)\n    for created_filename in ['force_constants.hdf5']:\n        file_path = pathlib.Path((cwd_called / created_filename))\n        assert file_path.exists()\n        (fc, physical_unit) = read_force_constants_hdf5(file_path, return_physical_unit=True)\n        assert (fc[0] == pytest.approx((- 1000000000000.0)))\n        assert (fc[1] == pytest.approx(1e-12))\n        assert (fc[2] == pytest.approx(0))\n        assert (fc[3] == pytest.approx(3.14))\n        assert (physical_unit == 'J/m^2')\n        file_path.unlink()", "masked_code": "def test_write_force_constants_to_hdf5():\n    'Test write_force_constants_to_hdf5 with augmented input.'\n    pytest.importorskip('h5py')\n    force_constants_aug = np.array([(- 1000000000000.0), 1e-12, 0, 3.14])\n    phys_unit_aug = 'J/m^2'\n    write_force_constants_to_hdf5(force_constants_aug, physical_unit=phys_unit_aug)\n    for created_filename in ['force_constants.hdf5']:\n        file_path = pathlib.Path((cwd_called / created_filename))\n        assert file_path.exists()\n        (fc, physical_unit) = read_force_constants_hdf5(file_path, return_physical_unit=True)\n        assert (fc[0] == pytest.approx((- 1000000000000.0)))\n        assert (fc[1] == '???')\n        assert (fc[2] == pytest.approx(0))\n        assert (fc[3] == pytest.approx(3.14))\n        assert (physical_unit == 'J/m^2')\n        file_path.unlink()", "ground_truth": "pytest.approx(1e-12)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_2", "reponame": "phonopy", "testpath": "test_file_IO.py", "testname": "test_file_IO.py", "classname": null, "funcname": "test_write_force_constants_to_hdf5", "imports": ["import pathlib", "import numpy as np", "import pytest", "import phonopy", "from phonopy.file_IO import parse_BORN, read_force_constants_hdf5, write_force_constants_to_hdf5"], "code": "def test_write_force_constants_to_hdf5():\n    'Test write_force_constants_to_hdf5 with augmented input.'\n    pytest.importorskip('h5py')\n    force_constants_aug = np.array([(- 1000000000000.0), 1e-12, 0, 3.14])\n    phys_unit_aug = 'J/m^2'\n    write_force_constants_to_hdf5(force_constants_aug, physical_unit=phys_unit_aug)\n    for created_filename in ['force_constants.hdf5']:\n        file_path = pathlib.Path((cwd_called / created_filename))\n        assert file_path.exists()\n        (fc, physical_unit) = read_force_constants_hdf5(file_path, return_physical_unit=True)\n        assert (fc[0] == pytest.approx((- 1000000000000.0)))\n        assert (fc[1] == pytest.approx(1e-12))\n        assert (fc[2] == pytest.approx(0))\n        assert (fc[3] == pytest.approx(3.14))\n        assert (physical_unit == 'J/m^2')\n        file_path.unlink()", "masked_code": "def test_write_force_constants_to_hdf5():\n    'Test write_force_constants_to_hdf5 with augmented input.'\n    pytest.importorskip('h5py')\n    force_constants_aug = np.array([(- 1000000000000.0), 1e-12, 0, 3.14])\n    phys_unit_aug = 'J/m^2'\n    write_force_constants_to_hdf5(force_constants_aug, physical_unit=phys_unit_aug)\n    for created_filename in ['force_constants.hdf5']:\n        file_path = pathlib.Path((cwd_called / created_filename))\n        assert file_path.exists()\n        (fc, physical_unit) = read_force_constants_hdf5(file_path, return_physical_unit=True)\n        assert (fc[0] == pytest.approx((- 1000000000000.0)))\n        assert (fc[1] == pytest.approx(1e-12))\n        assert (fc[2] == '???')\n        assert (fc[3] == pytest.approx(3.14))\n        assert (physical_unit == 'J/m^2')\n        file_path.unlink()", "ground_truth": "pytest.approx(0)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_3", "reponame": "phonopy", "testpath": "test_file_IO.py", "testname": "test_file_IO.py", "classname": null, "funcname": "test_write_force_constants_to_hdf5", "imports": ["import pathlib", "import numpy as np", "import pytest", "import phonopy", "from phonopy.file_IO import parse_BORN, read_force_constants_hdf5, write_force_constants_to_hdf5"], "code": "def test_write_force_constants_to_hdf5():\n    'Test write_force_constants_to_hdf5 with augmented input.'\n    pytest.importorskip('h5py')\n    force_constants_aug = np.array([(- 1000000000000.0), 1e-12, 0, 3.14])\n    phys_unit_aug = 'J/m^2'\n    write_force_constants_to_hdf5(force_constants_aug, physical_unit=phys_unit_aug)\n    for created_filename in ['force_constants.hdf5']:\n        file_path = pathlib.Path((cwd_called / created_filename))\n        assert file_path.exists()\n        (fc, physical_unit) = read_force_constants_hdf5(file_path, return_physical_unit=True)\n        assert (fc[0] == pytest.approx((- 1000000000000.0)))\n        assert (fc[1] == pytest.approx(1e-12))\n        assert (fc[2] == pytest.approx(0))\n        assert (fc[3] == pytest.approx(3.14))\n        assert (physical_unit == 'J/m^2')\n        file_path.unlink()", "masked_code": "def test_write_force_constants_to_hdf5():\n    'Test write_force_constants_to_hdf5 with augmented input.'\n    pytest.importorskip('h5py')\n    force_constants_aug = np.array([(- 1000000000000.0), 1e-12, 0, 3.14])\n    phys_unit_aug = 'J/m^2'\n    write_force_constants_to_hdf5(force_constants_aug, physical_unit=phys_unit_aug)\n    for created_filename in ['force_constants.hdf5']:\n        file_path = pathlib.Path((cwd_called / created_filename))\n        assert file_path.exists()\n        (fc, physical_unit) = read_force_constants_hdf5(file_path, return_physical_unit=True)\n        assert (fc[0] == pytest.approx((- 1000000000000.0)))\n        assert (fc[1] == pytest.approx(1e-12))\n        assert (fc[2] == pytest.approx(0))\n        assert (fc[3] == '???')\n        assert (physical_unit == 'J/m^2')\n        file_path.unlink()", "ground_truth": "pytest.approx(3.14)", "quality_analysis": {"complexity_score": 9, "left_complexity": 5, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_4", "reponame": "phonopy", "testpath": "test_pwscf.py", "testname": "test_pwscf.py", "classname": null, "funcname": "test_read_pwscf_NaCl_Xn", "imports": ["import pathlib", "import numpy as np", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.interface.qe import read_pwscf", "from phonopy.structure.symmetry import Symmetry"], "code": "def test_read_pwscf_NaCl_Xn():\n    'Augmented test of read_pwscf with comprehensive inputs.'\n    (cell, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf-Xn.in'))\n    print(cell)\n    symnums = pp_filenames.keys()\n    augmented_keys = {'Na', 'Cl', 'Cl1'}\n    assert (set(symnums) == augmented_keys)\n    np.testing.assert_allclose(cell.masses, [22.989769, 22.989769, 22.989769, 22.989769, 35.453, 35.453, 70.0, 70.0])\n    assert (['Na', 'Na', 'Na', 'Na', 'Cl', 'Cl', 'Cl1', 'Cl1'] == cell.symbols)\n    (cell_ref, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf.in'))\n    symops = Symmetry(cell).symmetry_operations\n    symops_ref = Symmetry(cell_ref).symmetry_operations\n    np.testing.assert_allclose(symops['translations'], symops_ref['translations'])\n    np.testing.assert_array_equal(symops['rotations'], symops_ref['rotations'])", "masked_code": "def test_read_pwscf_NaCl_Xn():\n    'Augmented test of read_pwscf with comprehensive inputs.'\n    (cell, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf-Xn.in'))\n    print(cell)\n    symnums = pp_filenames.keys()\n    augmented_keys = {'Na', 'Cl', 'Cl1'}\n    assert (set(symnums) == '???')\n    np.testing.assert_allclose(cell.masses, [22.989769, 22.989769, 22.989769, 22.989769, 35.453, 35.453, 70.0, 70.0])\n    assert (['Na', 'Na', 'Na', 'Na', 'Cl', 'Cl', 'Cl1', 'Cl1'] == cell.symbols)\n    (cell_ref, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf.in'))\n    symops = Symmetry(cell).symmetry_operations\n    symops_ref = Symmetry(cell_ref).symmetry_operations\n    np.testing.assert_allclose(symops['translations'], symops_ref['translations'])\n    np.testing.assert_array_equal(symops['rotations'], symops_ref['rotations'])", "ground_truth": "augmented_keys", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_5", "reponame": "phonopy", "testpath": "test_pwscf.py", "testname": "test_pwscf.py", "classname": null, "funcname": "test_read_pwscf_NaCl_Xn", "imports": ["import pathlib", "import numpy as np", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.interface.qe import read_pwscf", "from phonopy.structure.symmetry import Symmetry"], "code": "def test_read_pwscf_NaCl_Xn():\n    'Augmented test of read_pwscf with comprehensive inputs.'\n    (cell, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf-Xn.in'))\n    print(cell)\n    symnums = pp_filenames.keys()\n    augmented_keys = {'Na', 'Cl', 'Cl1'}\n    assert (set(symnums) == augmented_keys)\n    np.testing.assert_allclose(cell.masses, [22.989769, 22.989769, 22.989769, 22.989769, 35.453, 35.453, 70.0, 70.0])\n    assert (['Na', 'Na', 'Na', 'Na', 'Cl', 'Cl', 'Cl1', 'Cl1'] == cell.symbols)\n    (cell_ref, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf.in'))\n    symops = Symmetry(cell).symmetry_operations\n    symops_ref = Symmetry(cell_ref).symmetry_operations\n    np.testing.assert_allclose(symops['translations'], symops_ref['translations'])\n    np.testing.assert_array_equal(symops['rotations'], symops_ref['rotations'])", "masked_code": "def test_read_pwscf_NaCl_Xn():\n    'Augmented test of read_pwscf with comprehensive inputs.'\n    (cell, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf-Xn.in'))\n    print(cell)\n    symnums = pp_filenames.keys()\n    augmented_keys = {'Na', 'Cl', 'Cl1'}\n    assert (set(symnums) == augmented_keys)\n    np.testing.assert_allclose(cell.masses, [22.989769, 22.989769, 22.989769, 22.989769, 35.453, 35.453, 70.0, 70.0])\n    assert (['Na', 'Na', 'Na', 'Na', 'Cl', 'Cl', 'Cl1', 'Cl1'] == '???')\n    (cell_ref, pp_filenames) = read_pwscf((cwd / 'NaCl-pwscf.in'))\n    symops = Symmetry(cell).symmetry_operations\n    symops_ref = Symmetry(cell_ref).symmetry_operations\n    np.testing.assert_allclose(symops['translations'], symops_ref['translations'])\n    np.testing.assert_array_equal(symops['rotations'], symops_ref['rotations'])", "ground_truth": "cell.symbols", "quality_analysis": {"complexity_score": 12, "left_complexity": 10, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_6", "reponame": "phonopy", "testpath": "test_qlm.py", "testname": "test_qlm.py", "classname": null, "funcname": "test_cell2struct_and_read_qlm", "imports": ["import os", "import tempfile", "import numpy as np", "from phonopy.interface.qlm import parse_set_of_forces, read_qlm"], "code": "def test_cell2struct_and_read_qlm():\n    'Test read_qlm and get_qlm_structure.'\n    sitex_ref = ('% site-data vn=5.0 xpos fast io=20 nbas=10' + ' alat=24.56789 plat= 1.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 3.0\\n#                            pos\\n Li        0.0000000000   0.0000000000   0.0000000000\\n Li        0.0000000000   1.0000000000   2.0000000000\\n F         1.0000000000   2.0000000000   0.0000000000\\n Xe       -0.5000000000   1.5000000000   2.5000000000\\n Na        2.5000000000   0.0000000000   0.5000000000\\n Clu      -1.0000000000   2.0000000000   1.5000000000\\n Br        0.0000000000   0.0000000000  -1.0000000000\\n Sr        1.2345678900   2.3456789000   1.1111111111\\n P         0.0000000000   0.0000000000   0.0000000000\\n H        -2.0000000000   0.0000000000   3.0000000000\\n')\n    try:\n        fl1 = tempfile.NamedTemporaryFile(delete=False)\n        fl1.write(sitex_ref.encode())\n        fl1.close()\n        (cell1, (inst1,)) = read_qlm(fl1.name)\n        fl2 = tempfile.NamedTemporaryFile(delete=False)\n        fl2.write(inst1.to_site_str(cell1).encode())\n        fl2.close()\n        (cell2, _) = read_qlm(fl2.name)\n        np.testing.assert_allclose(cell1.cell, cell2.cell, atol=1e-07)\n        np.testing.assert_allclose(cell1.scaled_positions, cell2.scaled_positions, atol=1e-07)\n        assert (cell1.symbols == cell2.symbols)\n    finally:\n        os.unlink(fl1.name)\n        os.unlink(fl2.name)", "masked_code": "def test_cell2struct_and_read_qlm():\n    'Test read_qlm and get_qlm_structure.'\n    sitex_ref = ('% site-data vn=5.0 xpos fast io=20 nbas=10' + ' alat=24.56789 plat= 1.0 0.0 0.0 0.0 2.0 0.0 0.0 0.0 3.0\\n#                            pos\\n Li        0.0000000000   0.0000000000   0.0000000000\\n Li        0.0000000000   1.0000000000   2.0000000000\\n F         1.0000000000   2.0000000000   0.0000000000\\n Xe       -0.5000000000   1.5000000000   2.5000000000\\n Na        2.5000000000   0.0000000000   0.5000000000\\n Clu      -1.0000000000   2.0000000000   1.5000000000\\n Br        0.0000000000   0.0000000000  -1.0000000000\\n Sr        1.2345678900   2.3456789000   1.1111111111\\n P         0.0000000000   0.0000000000   0.0000000000\\n H        -2.0000000000   0.0000000000   3.0000000000\\n')\n    try:\n        fl1 = tempfile.NamedTemporaryFile(delete=False)\n        fl1.write(sitex_ref.encode())\n        fl1.close()\n        (cell1, (inst1,)) = read_qlm(fl1.name)\n        fl2 = tempfile.NamedTemporaryFile(delete=False)\n        fl2.write(inst1.to_site_str(cell1).encode())\n        fl2.close()\n        (cell2, _) = read_qlm(fl2.name)\n        np.testing.assert_allclose(cell1.cell, cell2.cell, atol=1e-07)\n        np.testing.assert_allclose(cell1.scaled_positions, cell2.scaled_positions, atol=1e-07)\n        assert (cell1.symbols == '???')\n    finally:\n        os.unlink(fl1.name)\n        os.unlink(fl2.name)", "ground_truth": "cell2.symbols", "quality_analysis": {"complexity_score": 4, "left_complexity": 2, "right_complexity": 2, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "phonopy_7", "reponame": "phonopy", "testpath": "test_vasp.py", "testname": "test_vasp.py", "classname": null, "funcname": "test_get_vasp_structure_lines", "imports": ["import tarfile", "import tempfile", "from io import StringIO", "from pathlib import Path", "import numpy as np", "import pytest", "from phonopy.file_IO import parse_FORCE_SETS", "from phonopy.interface.phonopy_yaml import read_cell_yaml", "from phonopy.interface.vasp import Vasprun, VasprunxmlExpat, get_vasp_structure_lines, parse_set_of_forces, read_vasp, read_vasp_from_strings, read_XDATCAR, write_XDATCAR"], "code": "@pytest.mark.parametrize('first_line_str, is_vasp4', [(None, True), (None, False), ('my_comment', True), ('my_comment', False), ('SingleSymbol', True), ('EdgeCase', False), ('', True), ('', False), ('EdgeCaseSymbols', True), ('Na Cl Br', False)])\ndef test_get_vasp_structure_lines(helper_methods, is_vasp4, first_line_str):\n    'Test get_vasp_structure_lines (almost write_vasp).'\n    poscar_yaml_augmented = 'lattice:\\n- [ 10.0, 0.0, 0.0 ]\\n- [ 0.0, 10.0, 0.0 ]\\n- [ 0.0, 0.0, 20.0 ]\\npoints:\\n- symbol: Na # 1\\n  coordinates: [ 0.0, 0.0, 0.0 ]\\n  mass: 22.989769\\n- symbol: Cl # 2\\n  coordinates: [ 0.5, 0.0, 0.0 ]\\n  mass: 35.453000\\n- symbol: Br # 3\\n  coordinates: [ 0.5, 0.5, 0.0 ]\\n  mass: 79.904\\n- symbol: Na # 4\\n  coordinates: [ 0.0, 0.5, 0.0 ]\\n  mass: 22.989769\\n- symbol: Cl # 5\\n  coordinates: [ 0.0, 0.0, 0.5 ]\\n  mass: 35.453000\\n- symbol: Br # 6\\n  coordinates: [ 0.5, 0.0, 0.5 ]\\n  mass: 79.904\\n- symbol: Na # 7\\n  coordinates: [ 0.5, 0.5, 0.5 ]\\n  mass: 22.989769\\n- symbol: Cl # 8\\n  coordinates: [ 0.0, 0.5, 0.5 ]\\n  mass: 35.453000\\n'\n    cell_ref = read_cell_yaml(StringIO(poscar_yaml_augmented))\n    lines = get_vasp_structure_lines(cell_ref, direct=True, is_vasp4=is_vasp4, first_line_str=first_line_str)\n    cell = read_vasp_from_strings('\\n'.join(lines))\n    helper_methods.compare_cells(cell, cell_ref)\n    if is_vasp4:\n        assert ((lines[0] == 'Na Cl Br') or (lines[0] == 'Na Cl') or (lines[0] == 'Na Cl Br'))\n    elif first_line_str:\n        assert (lines[0] == first_line_str)", "masked_code": "@pytest.mark.parametrize('first_line_str, is_vasp4', [(None, True), (None, False), ('my_comment', True), ('my_comment', False), ('SingleSymbol', True), ('EdgeCase', False), ('', True), ('', False), ('EdgeCaseSymbols', True), ('Na Cl Br', False)])\ndef test_get_vasp_structure_lines(helper_methods, is_vasp4, first_line_str):\n    'Test get_vasp_structure_lines (almost write_vasp).'\n    poscar_yaml_augmented = 'lattice:\\n- [ 10.0, 0.0, 0.0 ]\\n- [ 0.0, 10.0, 0.0 ]\\n- [ 0.0, 0.0, 20.0 ]\\npoints:\\n- symbol: Na # 1\\n  coordinates: [ 0.0, 0.0, 0.0 ]\\n  mass: 22.989769\\n- symbol: Cl # 2\\n  coordinates: [ 0.5, 0.0, 0.0 ]\\n  mass: 35.453000\\n- symbol: Br # 3\\n  coordinates: [ 0.5, 0.5, 0.0 ]\\n  mass: 79.904\\n- symbol: Na # 4\\n  coordinates: [ 0.0, 0.5, 0.0 ]\\n  mass: 22.989769\\n- symbol: Cl # 5\\n  coordinates: [ 0.0, 0.0, 0.5 ]\\n  mass: 35.453000\\n- symbol: Br # 6\\n  coordinates: [ 0.5, 0.0, 0.5 ]\\n  mass: 79.904\\n- symbol: Na # 7\\n  coordinates: [ 0.5, 0.5, 0.5 ]\\n  mass: 22.989769\\n- symbol: Cl # 8\\n  coordinates: [ 0.0, 0.5, 0.5 ]\\n  mass: 35.453000\\n'\n    cell_ref = read_cell_yaml(StringIO(poscar_yaml_augmented))\n    lines = get_vasp_structure_lines(cell_ref, direct=True, is_vasp4=is_vasp4, first_line_str=first_line_str)\n    cell = read_vasp_from_strings('\\n'.join(lines))\n    helper_methods.compare_cells(cell, cell_ref)\n    if is_vasp4:\n        assert ((lines[0] == 'Na Cl Br') or (lines[0] == 'Na Cl') or (lines[0] == 'Na Cl Br'))\n    elif first_line_str:\n        assert (lines[0] == '???')", "ground_truth": "first_line_str", "quality_analysis": {"complexity_score": 6, "left_complexity": 5, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
