{"task_id": "fluids_0", "reponame": "fluids", "testpath": "test_numerics_special.py", "testname": "test_numerics_special.py", "classname": null, "funcname": "test_py_factorial", "imports": ["from math import exp, hypot, isinf, isnan, log", "from fluids.numerics import assert_close, comb", "from fluids.numerics.special import py_cacos, py_catanh, py_hypot, trunc_exp, trunc_log"], "code": "def test_py_factorial():\n    import math\n    from fluids.numerics.special import py_factorial\n    try:\n        py_factorial((- 3))\n        assert False, 'Expected ValueError for negative input to factorial'\n    except ValueError:\n        pass\n    assert (py_factorial(0) == 1)\n    assert (py_factorial(20) == math.factorial(20))\n    try:\n        py_factorial(7.0)\n        assert False, 'Expected TypeError for float input to factorial'\n    except TypeError:\n        pass\n    try:\n        py_factorial(15.0)\n        assert False, 'Expected TypeError for float input to factorial'\n    except TypeError:\n        pass\n    try:\n        py_factorial(7.5)\n        assert False, 'Expected TypeError for non-integral float input to factorial'\n    except TypeError:\n        pass\n    assert (py_factorial(30) == math.factorial(30))\n    for i in range(35):\n        assert (py_factorial(i) == math.factorial(i))", "masked_code": "def test_py_factorial():\n    import math\n    from fluids.numerics.special import py_factorial\n    try:\n        py_factorial((- 3))\n        assert False, 'Expected ValueError for negative input to factorial'\n    except ValueError:\n        pass\n    assert (py_factorial(0) == 1)\n    assert (py_factorial(20) == '???')\n    try:\n        py_factorial(7.0)\n        assert False, 'Expected TypeError for float input to factorial'\n    except TypeError:\n        pass\n    try:\n        py_factorial(15.0)\n        assert False, 'Expected TypeError for float input to factorial'\n    except TypeError:\n        pass\n    try:\n        py_factorial(7.5)\n        assert False, 'Expected TypeError for non-integral float input to factorial'\n    except TypeError:\n        pass\n    assert (py_factorial(30) == math.factorial(30))\n    for i in range(35):\n        assert (py_factorial(i) == math.factorial(i))", "ground_truth": "math.factorial(20)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_1", "reponame": "fluids", "testpath": "test_numerics_special.py", "testname": "test_numerics_special.py", "classname": null, "funcname": "test_py_factorial", "imports": ["from math import exp, hypot, isinf, isnan, log", "from fluids.numerics import assert_close, comb", "from fluids.numerics.special import py_cacos, py_catanh, py_hypot, trunc_exp, trunc_log"], "code": "def test_py_factorial():\n    import math\n    from fluids.numerics.special import py_factorial\n    try:\n        py_factorial((- 3))\n        assert False, 'Expected ValueError for negative input to factorial'\n    except ValueError:\n        pass\n    assert (py_factorial(0) == 1)\n    assert (py_factorial(20) == math.factorial(20))\n    try:\n        py_factorial(7.0)\n        assert False, 'Expected TypeError for float input to factorial'\n    except TypeError:\n        pass\n    try:\n        py_factorial(15.0)\n        assert False, 'Expected TypeError for float input to factorial'\n    except TypeError:\n        pass\n    try:\n        py_factorial(7.5)\n        assert False, 'Expected TypeError for non-integral float input to factorial'\n    except TypeError:\n        pass\n    assert (py_factorial(30) == math.factorial(30))\n    for i in range(35):\n        assert (py_factorial(i) == math.factorial(i))", "masked_code": "def test_py_factorial():\n    import math\n    from fluids.numerics.special import py_factorial\n    try:\n        py_factorial((- 3))\n        assert False, 'Expected ValueError for negative input to factorial'\n    except ValueError:\n        pass\n    assert (py_factorial(0) == 1)\n    assert (py_factorial(20) == math.factorial(20))\n    try:\n        py_factorial(7.0)\n        assert False, 'Expected TypeError for float input to factorial'\n    except TypeError:\n        pass\n    try:\n        py_factorial(15.0)\n        assert False, 'Expected TypeError for float input to factorial'\n    except TypeError:\n        pass\n    try:\n        py_factorial(7.5)\n        assert False, 'Expected TypeError for non-integral float input to factorial'\n    except TypeError:\n        pass\n    assert (py_factorial(30) == '???')\n    for i in range(35):\n        assert (py_factorial(i) == math.factorial(i))", "ground_truth": "math.factorial(30)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_2", "reponame": "fluids", "testpath": "test_numerics_special.py", "testname": "test_numerics_special.py", "classname": null, "funcname": "test_py_factorial", "imports": ["from math import exp, hypot, isinf, isnan, log", "from fluids.numerics import assert_close, comb", "from fluids.numerics.special import py_cacos, py_catanh, py_hypot, trunc_exp, trunc_log"], "code": "def test_py_factorial():\n    import math\n    from fluids.numerics.special import py_factorial\n    try:\n        py_factorial((- 3))\n        assert False, 'Expected ValueError for negative input to factorial'\n    except ValueError:\n        pass\n    assert (py_factorial(0) == 1)\n    assert (py_factorial(20) == math.factorial(20))\n    try:\n        py_factorial(7.0)\n        assert False, 'Expected TypeError for float input to factorial'\n    except TypeError:\n        pass\n    try:\n        py_factorial(15.0)\n        assert False, 'Expected TypeError for float input to factorial'\n    except TypeError:\n        pass\n    try:\n        py_factorial(7.5)\n        assert False, 'Expected TypeError for non-integral float input to factorial'\n    except TypeError:\n        pass\n    assert (py_factorial(30) == math.factorial(30))\n    for i in range(35):\n        assert (py_factorial(i) == math.factorial(i))", "masked_code": "def test_py_factorial():\n    import math\n    from fluids.numerics.special import py_factorial\n    try:\n        py_factorial((- 3))\n        assert False, 'Expected ValueError for negative input to factorial'\n    except ValueError:\n        pass\n    assert (py_factorial(0) == 1)\n    assert (py_factorial(20) == math.factorial(20))\n    try:\n        py_factorial(7.0)\n        assert False, 'Expected TypeError for float input to factorial'\n    except TypeError:\n        pass\n    try:\n        py_factorial(15.0)\n        assert False, 'Expected TypeError for float input to factorial'\n    except TypeError:\n        pass\n    try:\n        py_factorial(7.5)\n        assert False, 'Expected TypeError for non-integral float input to factorial'\n    except TypeError:\n        pass\n    assert (py_factorial(30) == math.factorial(30))\n    for i in range(35):\n        assert (py_factorial(i) == '???')", "ground_truth": "math.factorial(i)", "quality_analysis": {"complexity_score": 8, "left_complexity": 4, "right_complexity": 4, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_3", "reponame": "fluids", "testpath": "test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    plug_types = electrical_plug_types\n    assert (sum((1 for c in plug_types if (c.lower() in 'aeiou'))) == 3)\n    v1 = list(voltages_1_phase_residential)\n    v1[0] = 0\n    v1[(- 1)] = 9999\n    assert (sum(v1) == ((((sum(voltages_1_phase_residential) - voltages_1_phase_residential[0]) + 0) - voltages_1_phase_residential[(- 1)]) + 9999))\n    assert (len(v1) == 8)\n    v3 = list(voltages_3_phase)\n    v3[1] = (- 415)\n    v3[2] = 440.5\n    assert (sum(v3) == ((((sum(voltages_3_phase) - voltages_3_phase[1]) + (- 415)) - voltages_3_phase[2]) + 440.5))\n    assert (len(v3) == 13)\n    freqs = (list(residential_power_frequencies) + [0])\n    assert (set(freqs) == (set(residential_power_frequencies) | {0}))\n    volt_count = sum([1 for i in residential_power.values() if (i.voltage == 110)])\n    assert (volt_count >= 0)\n    freq_count_extreme = sum([1 for i in residential_power.values() if ((i.freq < 0) or (i.freq > 1000))])\n    assert (freq_count_extreme == 0)\n    with pytest.raises(KeyError):\n        residential_power['zz']\n    odd_len = [k for (k, v) in industrial_power.items() if (isinstance(v.voltage, tuple) and ((len(v.voltage) % 2) == 1))]\n    assert isinstance(odd_len, list)\n    high_freqs = [i.freq for i in industrial_power.values() if (i.freq > 1000)]\n    assert (len(high_freqs) == 0)\n    with pytest.raises(KeyError):\n        industrial_power['CA']", "masked_code": "def test_power_sources():\n    plug_types = electrical_plug_types\n    assert (sum((1 for c in plug_types if (c.lower() in 'aeiou'))) == '???')\n    v1 = list(voltages_1_phase_residential)\n    v1[0] = 0\n    v1[(- 1)] = 9999\n    assert (sum(v1) == ((((sum(voltages_1_phase_residential) - voltages_1_phase_residential[0]) + 0) - voltages_1_phase_residential[(- 1)]) + 9999))\n    assert (len(v1) == 8)\n    v3 = list(voltages_3_phase)\n    v3[1] = (- 415)\n    v3[2] = 440.5\n    assert (sum(v3) == ((((sum(voltages_3_phase) - voltages_3_phase[1]) + (- 415)) - voltages_3_phase[2]) + 440.5))\n    assert (len(v3) == 13)\n    freqs = (list(residential_power_frequencies) + [0])\n    assert (set(freqs) == (set(residential_power_frequencies) | {0}))\n    volt_count = sum([1 for i in residential_power.values() if (i.voltage == 110)])\n    assert (volt_count >= 0)\n    freq_count_extreme = sum([1 for i in residential_power.values() if ((i.freq < 0) or (i.freq > 1000))])\n    assert (freq_count_extreme == 0)\n    with pytest.raises(KeyError):\n        residential_power['zz']\n    odd_len = [k for (k, v) in industrial_power.items() if (isinstance(v.voltage, tuple) and ((len(v.voltage) % 2) == 1))]\n    assert isinstance(odd_len, list)\n    high_freqs = [i.freq for i in industrial_power.values() if (i.freq > 1000)]\n    assert (len(high_freqs) == 0)\n    with pytest.raises(KeyError):\n        industrial_power['CA']", "ground_truth": "3", "quality_analysis": {"complexity_score": 4, "left_complexity": 3, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_4", "reponame": "fluids", "testpath": "test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    plug_types = electrical_plug_types\n    assert (sum((1 for c in plug_types if (c.lower() in 'aeiou'))) == 3)\n    v1 = list(voltages_1_phase_residential)\n    v1[0] = 0\n    v1[(- 1)] = 9999\n    assert (sum(v1) == ((((sum(voltages_1_phase_residential) - voltages_1_phase_residential[0]) + 0) - voltages_1_phase_residential[(- 1)]) + 9999))\n    assert (len(v1) == 8)\n    v3 = list(voltages_3_phase)\n    v3[1] = (- 415)\n    v3[2] = 440.5\n    assert (sum(v3) == ((((sum(voltages_3_phase) - voltages_3_phase[1]) + (- 415)) - voltages_3_phase[2]) + 440.5))\n    assert (len(v3) == 13)\n    freqs = (list(residential_power_frequencies) + [0])\n    assert (set(freqs) == (set(residential_power_frequencies) | {0}))\n    volt_count = sum([1 for i in residential_power.values() if (i.voltage == 110)])\n    assert (volt_count >= 0)\n    freq_count_extreme = sum([1 for i in residential_power.values() if ((i.freq < 0) or (i.freq > 1000))])\n    assert (freq_count_extreme == 0)\n    with pytest.raises(KeyError):\n        residential_power['zz']\n    odd_len = [k for (k, v) in industrial_power.items() if (isinstance(v.voltage, tuple) and ((len(v.voltage) % 2) == 1))]\n    assert isinstance(odd_len, list)\n    high_freqs = [i.freq for i in industrial_power.values() if (i.freq > 1000)]\n    assert (len(high_freqs) == 0)\n    with pytest.raises(KeyError):\n        industrial_power['CA']", "masked_code": "def test_power_sources():\n    plug_types = electrical_plug_types\n    assert (sum((1 for c in plug_types if (c.lower() in 'aeiou'))) == 3)\n    v1 = list(voltages_1_phase_residential)\n    v1[0] = 0\n    v1[(- 1)] = 9999\n    assert (sum(v1) == '???')\n    assert (len(v1) == 8)\n    v3 = list(voltages_3_phase)\n    v3[1] = (- 415)\n    v3[2] = 440.5\n    assert (sum(v3) == ((((sum(voltages_3_phase) - voltages_3_phase[1]) + (- 415)) - voltages_3_phase[2]) + 440.5))\n    assert (len(v3) == 13)\n    freqs = (list(residential_power_frequencies) + [0])\n    assert (set(freqs) == (set(residential_power_frequencies) | {0}))\n    volt_count = sum([1 for i in residential_power.values() if (i.voltage == 110)])\n    assert (volt_count >= 0)\n    freq_count_extreme = sum([1 for i in residential_power.values() if ((i.freq < 0) or (i.freq > 1000))])\n    assert (freq_count_extreme == 0)\n    with pytest.raises(KeyError):\n        residential_power['zz']\n    odd_len = [k for (k, v) in industrial_power.items() if (isinstance(v.voltage, tuple) and ((len(v.voltage) % 2) == 1))]\n    assert isinstance(odd_len, list)\n    high_freqs = [i.freq for i in industrial_power.values() if (i.freq > 1000)]\n    assert (len(high_freqs) == 0)\n    with pytest.raises(KeyError):\n        industrial_power['CA']", "ground_truth": "((((sum(voltages_1_phase_residential) - voltages_1_phase_residential[0]) + 0) - voltages_1_phase_residential[(- 1)]) + 9999)", "quality_analysis": {"complexity_score": 30, "left_complexity": 4, "right_complexity": 26, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_5", "reponame": "fluids", "testpath": "test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    plug_types = electrical_plug_types\n    assert (sum((1 for c in plug_types if (c.lower() in 'aeiou'))) == 3)\n    v1 = list(voltages_1_phase_residential)\n    v1[0] = 0\n    v1[(- 1)] = 9999\n    assert (sum(v1) == ((((sum(voltages_1_phase_residential) - voltages_1_phase_residential[0]) + 0) - voltages_1_phase_residential[(- 1)]) + 9999))\n    assert (len(v1) == 8)\n    v3 = list(voltages_3_phase)\n    v3[1] = (- 415)\n    v3[2] = 440.5\n    assert (sum(v3) == ((((sum(voltages_3_phase) - voltages_3_phase[1]) + (- 415)) - voltages_3_phase[2]) + 440.5))\n    assert (len(v3) == 13)\n    freqs = (list(residential_power_frequencies) + [0])\n    assert (set(freqs) == (set(residential_power_frequencies) | {0}))\n    volt_count = sum([1 for i in residential_power.values() if (i.voltage == 110)])\n    assert (volt_count >= 0)\n    freq_count_extreme = sum([1 for i in residential_power.values() if ((i.freq < 0) or (i.freq > 1000))])\n    assert (freq_count_extreme == 0)\n    with pytest.raises(KeyError):\n        residential_power['zz']\n    odd_len = [k for (k, v) in industrial_power.items() if (isinstance(v.voltage, tuple) and ((len(v.voltage) % 2) == 1))]\n    assert isinstance(odd_len, list)\n    high_freqs = [i.freq for i in industrial_power.values() if (i.freq > 1000)]\n    assert (len(high_freqs) == 0)\n    with pytest.raises(KeyError):\n        industrial_power['CA']", "masked_code": "def test_power_sources():\n    plug_types = electrical_plug_types\n    assert (sum((1 for c in plug_types if (c.lower() in 'aeiou'))) == 3)\n    v1 = list(voltages_1_phase_residential)\n    v1[0] = 0\n    v1[(- 1)] = 9999\n    assert (sum(v1) == ((((sum(voltages_1_phase_residential) - voltages_1_phase_residential[0]) + 0) - voltages_1_phase_residential[(- 1)]) + 9999))\n    assert (len(v1) == '???')\n    v3 = list(voltages_3_phase)\n    v3[1] = (- 415)\n    v3[2] = 440.5\n    assert (sum(v3) == ((((sum(voltages_3_phase) - voltages_3_phase[1]) + (- 415)) - voltages_3_phase[2]) + 440.5))\n    assert (len(v3) == 13)\n    freqs = (list(residential_power_frequencies) + [0])\n    assert (set(freqs) == (set(residential_power_frequencies) | {0}))\n    volt_count = sum([1 for i in residential_power.values() if (i.voltage == 110)])\n    assert (volt_count >= 0)\n    freq_count_extreme = sum([1 for i in residential_power.values() if ((i.freq < 0) or (i.freq > 1000))])\n    assert (freq_count_extreme == 0)\n    with pytest.raises(KeyError):\n        residential_power['zz']\n    odd_len = [k for (k, v) in industrial_power.items() if (isinstance(v.voltage, tuple) and ((len(v.voltage) % 2) == 1))]\n    assert isinstance(odd_len, list)\n    high_freqs = [i.freq for i in industrial_power.values() if (i.freq > 1000)]\n    assert (len(high_freqs) == 0)\n    with pytest.raises(KeyError):\n        industrial_power['CA']", "ground_truth": "8", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_6", "reponame": "fluids", "testpath": "test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    plug_types = electrical_plug_types\n    assert (sum((1 for c in plug_types if (c.lower() in 'aeiou'))) == 3)\n    v1 = list(voltages_1_phase_residential)\n    v1[0] = 0\n    v1[(- 1)] = 9999\n    assert (sum(v1) == ((((sum(voltages_1_phase_residential) - voltages_1_phase_residential[0]) + 0) - voltages_1_phase_residential[(- 1)]) + 9999))\n    assert (len(v1) == 8)\n    v3 = list(voltages_3_phase)\n    v3[1] = (- 415)\n    v3[2] = 440.5\n    assert (sum(v3) == ((((sum(voltages_3_phase) - voltages_3_phase[1]) + (- 415)) - voltages_3_phase[2]) + 440.5))\n    assert (len(v3) == 13)\n    freqs = (list(residential_power_frequencies) + [0])\n    assert (set(freqs) == (set(residential_power_frequencies) | {0}))\n    volt_count = sum([1 for i in residential_power.values() if (i.voltage == 110)])\n    assert (volt_count >= 0)\n    freq_count_extreme = sum([1 for i in residential_power.values() if ((i.freq < 0) or (i.freq > 1000))])\n    assert (freq_count_extreme == 0)\n    with pytest.raises(KeyError):\n        residential_power['zz']\n    odd_len = [k for (k, v) in industrial_power.items() if (isinstance(v.voltage, tuple) and ((len(v.voltage) % 2) == 1))]\n    assert isinstance(odd_len, list)\n    high_freqs = [i.freq for i in industrial_power.values() if (i.freq > 1000)]\n    assert (len(high_freqs) == 0)\n    with pytest.raises(KeyError):\n        industrial_power['CA']", "masked_code": "def test_power_sources():\n    plug_types = electrical_plug_types\n    assert (sum((1 for c in plug_types if (c.lower() in 'aeiou'))) == 3)\n    v1 = list(voltages_1_phase_residential)\n    v1[0] = 0\n    v1[(- 1)] = 9999\n    assert (sum(v1) == ((((sum(voltages_1_phase_residential) - voltages_1_phase_residential[0]) + 0) - voltages_1_phase_residential[(- 1)]) + 9999))\n    assert (len(v1) == 8)\n    v3 = list(voltages_3_phase)\n    v3[1] = (- 415)\n    v3[2] = 440.5\n    assert (sum(v3) == '???')\n    assert (len(v3) == 13)\n    freqs = (list(residential_power_frequencies) + [0])\n    assert (set(freqs) == (set(residential_power_frequencies) | {0}))\n    volt_count = sum([1 for i in residential_power.values() if (i.voltage == 110)])\n    assert (volt_count >= 0)\n    freq_count_extreme = sum([1 for i in residential_power.values() if ((i.freq < 0) or (i.freq > 1000))])\n    assert (freq_count_extreme == 0)\n    with pytest.raises(KeyError):\n        residential_power['zz']\n    odd_len = [k for (k, v) in industrial_power.items() if (isinstance(v.voltage, tuple) and ((len(v.voltage) % 2) == 1))]\n    assert isinstance(odd_len, list)\n    high_freqs = [i.freq for i in industrial_power.values() if (i.freq > 1000)]\n    assert (len(high_freqs) == 0)\n    with pytest.raises(KeyError):\n        industrial_power['CA']", "ground_truth": "((((sum(voltages_3_phase) - voltages_3_phase[1]) + (- 415)) - voltages_3_phase[2]) + 440.5)", "quality_analysis": {"complexity_score": 30, "left_complexity": 4, "right_complexity": 26, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_7", "reponame": "fluids", "testpath": "test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    plug_types = electrical_plug_types\n    assert (sum((1 for c in plug_types if (c.lower() in 'aeiou'))) == 3)\n    v1 = list(voltages_1_phase_residential)\n    v1[0] = 0\n    v1[(- 1)] = 9999\n    assert (sum(v1) == ((((sum(voltages_1_phase_residential) - voltages_1_phase_residential[0]) + 0) - voltages_1_phase_residential[(- 1)]) + 9999))\n    assert (len(v1) == 8)\n    v3 = list(voltages_3_phase)\n    v3[1] = (- 415)\n    v3[2] = 440.5\n    assert (sum(v3) == ((((sum(voltages_3_phase) - voltages_3_phase[1]) + (- 415)) - voltages_3_phase[2]) + 440.5))\n    assert (len(v3) == 13)\n    freqs = (list(residential_power_frequencies) + [0])\n    assert (set(freqs) == (set(residential_power_frequencies) | {0}))\n    volt_count = sum([1 for i in residential_power.values() if (i.voltage == 110)])\n    assert (volt_count >= 0)\n    freq_count_extreme = sum([1 for i in residential_power.values() if ((i.freq < 0) or (i.freq > 1000))])\n    assert (freq_count_extreme == 0)\n    with pytest.raises(KeyError):\n        residential_power['zz']\n    odd_len = [k for (k, v) in industrial_power.items() if (isinstance(v.voltage, tuple) and ((len(v.voltage) % 2) == 1))]\n    assert isinstance(odd_len, list)\n    high_freqs = [i.freq for i in industrial_power.values() if (i.freq > 1000)]\n    assert (len(high_freqs) == 0)\n    with pytest.raises(KeyError):\n        industrial_power['CA']", "masked_code": "def test_power_sources():\n    plug_types = electrical_plug_types\n    assert (sum((1 for c in plug_types if (c.lower() in 'aeiou'))) == 3)\n    v1 = list(voltages_1_phase_residential)\n    v1[0] = 0\n    v1[(- 1)] = 9999\n    assert (sum(v1) == ((((sum(voltages_1_phase_residential) - voltages_1_phase_residential[0]) + 0) - voltages_1_phase_residential[(- 1)]) + 9999))\n    assert (len(v1) == 8)\n    v3 = list(voltages_3_phase)\n    v3[1] = (- 415)\n    v3[2] = 440.5\n    assert (sum(v3) == ((((sum(voltages_3_phase) - voltages_3_phase[1]) + (- 415)) - voltages_3_phase[2]) + 440.5))\n    assert (len(v3) == '???')\n    freqs = (list(residential_power_frequencies) + [0])\n    assert (set(freqs) == (set(residential_power_frequencies) | {0}))\n    volt_count = sum([1 for i in residential_power.values() if (i.voltage == 110)])\n    assert (volt_count >= 0)\n    freq_count_extreme = sum([1 for i in residential_power.values() if ((i.freq < 0) or (i.freq > 1000))])\n    assert (freq_count_extreme == 0)\n    with pytest.raises(KeyError):\n        residential_power['zz']\n    odd_len = [k for (k, v) in industrial_power.items() if (isinstance(v.voltage, tuple) and ((len(v.voltage) % 2) == 1))]\n    assert isinstance(odd_len, list)\n    high_freqs = [i.freq for i in industrial_power.values() if (i.freq > 1000)]\n    assert (len(high_freqs) == 0)\n    with pytest.raises(KeyError):\n        industrial_power['CA']", "ground_truth": "13", "quality_analysis": {"complexity_score": 5, "left_complexity": 4, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_8", "reponame": "fluids", "testpath": "test_pump.py", "testname": "test_pump.py", "classname": null, "funcname": "test_power_sources", "imports": ["import pytest", "from fluids.constants import hp", "from fluids.numerics import assert_close, assert_close1d", "from fluids.pump import Corripio_motor_efficiency, Corripio_pump_efficiency, CountryPower, CSA_motor_efficiency, VFD_efficiency, current_ideal, electrical_plug_types, industrial_power, motor_efficiency_underloaded, motor_round_size, nema_high_P, nema_min_P, nema_sizes, nema_sizes_hp, residential_power, residential_power_frequencies, specific_diameter, specific_speed, speed_synchronous, voltages_1_phase_residential, voltages_3_phase"], "code": "def test_power_sources():\n    plug_types = electrical_plug_types\n    assert (sum((1 for c in plug_types if (c.lower() in 'aeiou'))) == 3)\n    v1 = list(voltages_1_phase_residential)\n    v1[0] = 0\n    v1[(- 1)] = 9999\n    assert (sum(v1) == ((((sum(voltages_1_phase_residential) - voltages_1_phase_residential[0]) + 0) - voltages_1_phase_residential[(- 1)]) + 9999))\n    assert (len(v1) == 8)\n    v3 = list(voltages_3_phase)\n    v3[1] = (- 415)\n    v3[2] = 440.5\n    assert (sum(v3) == ((((sum(voltages_3_phase) - voltages_3_phase[1]) + (- 415)) - voltages_3_phase[2]) + 440.5))\n    assert (len(v3) == 13)\n    freqs = (list(residential_power_frequencies) + [0])\n    assert (set(freqs) == (set(residential_power_frequencies) | {0}))\n    volt_count = sum([1 for i in residential_power.values() if (i.voltage == 110)])\n    assert (volt_count >= 0)\n    freq_count_extreme = sum([1 for i in residential_power.values() if ((i.freq < 0) or (i.freq > 1000))])\n    assert (freq_count_extreme == 0)\n    with pytest.raises(KeyError):\n        residential_power['zz']\n    odd_len = [k for (k, v) in industrial_power.items() if (isinstance(v.voltage, tuple) and ((len(v.voltage) % 2) == 1))]\n    assert isinstance(odd_len, list)\n    high_freqs = [i.freq for i in industrial_power.values() if (i.freq > 1000)]\n    assert (len(high_freqs) == 0)\n    with pytest.raises(KeyError):\n        industrial_power['CA']", "masked_code": "def test_power_sources():\n    plug_types = electrical_plug_types\n    assert (sum((1 for c in plug_types if (c.lower() in 'aeiou'))) == 3)\n    v1 = list(voltages_1_phase_residential)\n    v1[0] = 0\n    v1[(- 1)] = 9999\n    assert (sum(v1) == ((((sum(voltages_1_phase_residential) - voltages_1_phase_residential[0]) + 0) - voltages_1_phase_residential[(- 1)]) + 9999))\n    assert (len(v1) == 8)\n    v3 = list(voltages_3_phase)\n    v3[1] = (- 415)\n    v3[2] = 440.5\n    assert (sum(v3) == ((((sum(voltages_3_phase) - voltages_3_phase[1]) + (- 415)) - voltages_3_phase[2]) + 440.5))\n    assert (len(v3) == 13)\n    freqs = (list(residential_power_frequencies) + [0])\n    assert (set(freqs) == '???')\n    volt_count = sum([1 for i in residential_power.values() if (i.voltage == 110)])\n    assert (volt_count >= 0)\n    freq_count_extreme = sum([1 for i in residential_power.values() if ((i.freq < 0) or (i.freq > 1000))])\n    assert (freq_count_extreme == 0)\n    with pytest.raises(KeyError):\n        residential_power['zz']\n    odd_len = [k for (k, v) in industrial_power.items() if (isinstance(v.voltage, tuple) and ((len(v.voltage) % 2) == 1))]\n    assert isinstance(odd_len, list)\n    high_freqs = [i.freq for i in industrial_power.values() if (i.freq > 1000)]\n    assert (len(high_freqs) == 0)\n    with pytest.raises(KeyError):\n        industrial_power['CA']", "ground_truth": "(set(residential_power_frequencies) | {0})", "quality_analysis": {"complexity_score": 10, "left_complexity": 4, "right_complexity": 6, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_9", "reponame": "fluids", "testpath": "test_two_phase_voidage.py", "testname": "test_two_phase_voidage.py", "classname": null, "funcname": "test_liquid_gas_voidage", "imports": ["import pytest", "from fluids.numerics import assert_close, assert_close1d, linspace", "from fluids.two_phase_voidage import Armand, Baroczy, Beattie_Whalley, Chisholm_Armand, Chisholm_voidage, Cicchitti, Dix, Domanski_Didion, Duckler, Fauske, Fourar_Bories, Graham, Gregory_Scott, Guzhov, Harms, Huq_Loth, Kawahara, Kopte_Newell_Chato, Lin_Kwok, Lockhart_Martinelli_Xtt, McAdams, Nicklin_Wilkes_Davidson, Nishino_Yamazaki, Rouhani_1, Rouhani_2, Smith, Steiner, Sun_Duffey_Peng, Tandon_Varma_Gupta, Thom, Turner_Wallis, Woldesemayat_Ghajar, Xu_Fang_voidage, Yashar, Zivi, density_two_phase, gas_liquid_viscosity, gas_liquid_viscosity_methods, homogeneous, liquid_gas_voidage, liquid_gas_voidage_methods, two_phase_voidage_experimental"], "code": "def test_liquid_gas_voidage():\n    voidage = liquid_gas_voidage(m=250.0, x=0.001, rhol=1200.0, rhog=40.0, mul=0.0035, mug=7.8e-06, sigma=0.0152, D=2.5)\n    assert_close(voidage, 0.02915451895043604)\n    kwargs = dict(m=250.0, x=0.001, rhol=1200.0, rhog=40.0, mul=0.0035, mug=7.8e-06, sigma=0.0152, D=2.5, P=1000000.0, Pc=100000000.0)\n    for m in liquid_gas_voidage_methods(**kwargs):\n        liquid_gas_voidage(Method=m, **kwargs)\n    with pytest.raises(Exception):\n        liquid_gas_voidage(Method='BADMETHOD', **kwargs)\n    assert (len(liquid_gas_voidage_methods(**kwargs)) == 29)", "masked_code": "def test_liquid_gas_voidage():\n    voidage = liquid_gas_voidage(m=250.0, x=0.001, rhol=1200.0, rhog=40.0, mul=0.0035, mug=7.8e-06, sigma=0.0152, D=2.5)\n    assert_close(voidage, 0.02915451895043604)\n    kwargs = dict(m=250.0, x=0.001, rhol=1200.0, rhog=40.0, mul=0.0035, mug=7.8e-06, sigma=0.0152, D=2.5, P=1000000.0, Pc=100000000.0)\n    for m in liquid_gas_voidage_methods(**kwargs):\n        liquid_gas_voidage(Method=m, **kwargs)\n    with pytest.raises(Exception):\n        liquid_gas_voidage(Method='BADMETHOD', **kwargs)\n    assert (len(liquid_gas_voidage_methods(**kwargs)) == '???')", "ground_truth": "29", "quality_analysis": {"complexity_score": 7, "left_complexity": 6, "right_complexity": 1, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_10", "reponame": "fluids", "testpath": "test_two_phase_voidage.py", "testname": "test_two_phase_voidage.py", "classname": null, "funcname": "test_gas_liquid_viscosity", "imports": ["import pytest", "from fluids.numerics import assert_close, assert_close1d, linspace", "from fluids.two_phase_voidage import Armand, Baroczy, Beattie_Whalley, Chisholm_Armand, Chisholm_voidage, Cicchitti, Dix, Domanski_Didion, Duckler, Fauske, Fourar_Bories, Graham, Gregory_Scott, Guzhov, Harms, Huq_Loth, Kawahara, Kopte_Newell_Chato, Lin_Kwok, Lockhart_Martinelli_Xtt, McAdams, Nicklin_Wilkes_Davidson, Nishino_Yamazaki, Rouhani_1, Rouhani_2, Smith, Steiner, Sun_Duffey_Peng, Tandon_Varma_Gupta, Thom, Turner_Wallis, Woldesemayat_Ghajar, Xu_Fang_voidage, Yashar, Zivi, density_two_phase, gas_liquid_viscosity, gas_liquid_viscosity_methods, homogeneous, liquid_gas_voidage, liquid_gas_voidage_methods, two_phase_voidage_experimental"], "code": "def test_gas_liquid_viscosity():\n    mu = gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06)\n    assert_close(4.848475e-06, mu)\n    mu = gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06, rhol=350.0, rhog=0.3, Method='Duckler')\n    assert_close(mu, 4.999090909090909e-06)\n    simple_methods = gas_liquid_viscosity_methods()\n    assert (list(sorted(simple_methods)) == list(sorted(['McAdams', 'Cicchitti', 'Lin Kwok'])))\n    all_methods = gas_liquid_viscosity_methods(rhol=350.0, rhog=0.3)\n    all_methods_expect = ['Beattie Whalley', 'Fourar Bories', 'Duckler', 'McAdams', 'Cicchitti', 'Lin Kwok']\n    assert (list(sorted(all_methods)) == list(sorted(all_methods_expect)))\n    for m in all_methods_expect:\n        gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06, rhol=350.0, rhog=0.3, Method=m)\n    with pytest.raises(Exception):\n        gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06, Method='NOTAMETHOD')", "masked_code": "def test_gas_liquid_viscosity():\n    mu = gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06)\n    assert_close(4.848475e-06, mu)\n    mu = gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06, rhol=350.0, rhog=0.3, Method='Duckler')\n    assert_close(mu, 4.999090909090909e-06)\n    simple_methods = gas_liquid_viscosity_methods()\n    assert (list(sorted(simple_methods)) == '???')\n    all_methods = gas_liquid_viscosity_methods(rhol=350.0, rhog=0.3)\n    all_methods_expect = ['Beattie Whalley', 'Fourar Bories', 'Duckler', 'McAdams', 'Cicchitti', 'Lin Kwok']\n    assert (list(sorted(all_methods)) == list(sorted(all_methods_expect)))\n    for m in all_methods_expect:\n        gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06, rhol=350.0, rhog=0.3, Method=m)\n    with pytest.raises(Exception):\n        gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06, Method='NOTAMETHOD')", "ground_truth": "list(sorted(['McAdams', 'Cicchitti', 'Lin Kwok']))", "quality_analysis": {"complexity_score": 18, "left_complexity": 7, "right_complexity": 11, "is_quality": true, "reason": "High quality assertion"}}
{"task_id": "fluids_11", "reponame": "fluids", "testpath": "test_two_phase_voidage.py", "testname": "test_two_phase_voidage.py", "classname": null, "funcname": "test_gas_liquid_viscosity", "imports": ["import pytest", "from fluids.numerics import assert_close, assert_close1d, linspace", "from fluids.two_phase_voidage import Armand, Baroczy, Beattie_Whalley, Chisholm_Armand, Chisholm_voidage, Cicchitti, Dix, Domanski_Didion, Duckler, Fauske, Fourar_Bories, Graham, Gregory_Scott, Guzhov, Harms, Huq_Loth, Kawahara, Kopte_Newell_Chato, Lin_Kwok, Lockhart_Martinelli_Xtt, McAdams, Nicklin_Wilkes_Davidson, Nishino_Yamazaki, Rouhani_1, Rouhani_2, Smith, Steiner, Sun_Duffey_Peng, Tandon_Varma_Gupta, Thom, Turner_Wallis, Woldesemayat_Ghajar, Xu_Fang_voidage, Yashar, Zivi, density_two_phase, gas_liquid_viscosity, gas_liquid_viscosity_methods, homogeneous, liquid_gas_voidage, liquid_gas_voidage_methods, two_phase_voidage_experimental"], "code": "def test_gas_liquid_viscosity():\n    mu = gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06)\n    assert_close(4.848475e-06, mu)\n    mu = gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06, rhol=350.0, rhog=0.3, Method='Duckler')\n    assert_close(mu, 4.999090909090909e-06)\n    simple_methods = gas_liquid_viscosity_methods()\n    assert (list(sorted(simple_methods)) == list(sorted(['McAdams', 'Cicchitti', 'Lin Kwok'])))\n    all_methods = gas_liquid_viscosity_methods(rhol=350.0, rhog=0.3)\n    all_methods_expect = ['Beattie Whalley', 'Fourar Bories', 'Duckler', 'McAdams', 'Cicchitti', 'Lin Kwok']\n    assert (list(sorted(all_methods)) == list(sorted(all_methods_expect)))\n    for m in all_methods_expect:\n        gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06, rhol=350.0, rhog=0.3, Method=m)\n    with pytest.raises(Exception):\n        gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06, Method='NOTAMETHOD')", "masked_code": "def test_gas_liquid_viscosity():\n    mu = gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06)\n    assert_close(4.848475e-06, mu)\n    mu = gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06, rhol=350.0, rhog=0.3, Method='Duckler')\n    assert_close(mu, 4.999090909090909e-06)\n    simple_methods = gas_liquid_viscosity_methods()\n    assert (list(sorted(simple_methods)) == list(sorted(['McAdams', 'Cicchitti', 'Lin Kwok'])))\n    all_methods = gas_liquid_viscosity_methods(rhol=350.0, rhog=0.3)\n    all_methods_expect = ['Beattie Whalley', 'Fourar Bories', 'Duckler', 'McAdams', 'Cicchitti', 'Lin Kwok']\n    assert (list(sorted(all_methods)) == '???')\n    for m in all_methods_expect:\n        gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06, rhol=350.0, rhog=0.3, Method=m)\n    with pytest.raises(Exception):\n        gas_liquid_viscosity(x=0.99, mul=0.023, mug=4.8e-06, Method='NOTAMETHOD')", "ground_truth": "list(sorted(all_methods_expect))", "quality_analysis": {"complexity_score": 14, "left_complexity": 7, "right_complexity": 7, "is_quality": true, "reason": "High quality assertion"}}
